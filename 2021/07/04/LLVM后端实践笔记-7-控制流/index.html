

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="P2Tree">
  <meta name="keywords" content="">
  
    <meta name="description" content="这一章会介绍与控制流有关的功能实现，比如 if、else、while 和 for 等，还会介绍如何将控制流的 IR 表示转换为机器指令；之后会引入几个后端优化，处理一些跳转需求引入的问题，同时来说明如何编写后端优化的 pass。在条件指令小节中，会介绍 LLVM IR 中的特殊指令 select 和 select_cc，以及如何处理这种指令，从而来支持更细节的控制流支持实现。 7.1 控制流语句7">
<meta property="og:type" content="article">
<meta property="og:title" content="LLVM 后端实践笔记 7：控制流">
<meta property="og:url" content="http://p2tree.github.io/2021/07/04/LLVM%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-7-%E6%8E%A7%E5%88%B6%E6%B5%81/index.html">
<meta property="og:site_name" content="P2Tree Home">
<meta property="og:description" content="这一章会介绍与控制流有关的功能实现，比如 if、else、while 和 for 等，还会介绍如何将控制流的 IR 表示转换为机器指令；之后会引入几个后端优化，处理一些跳转需求引入的问题，同时来说明如何编写后端优化的 pass。在条件指令小节中，会介绍 LLVM IR 中的特殊指令 select 和 select_cc，以及如何处理这种指令，从而来支持更细节的控制流支持实现。 7.1 控制流语句7">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jsd.cdn.zzko.cn/gh/p2tree/web-asset/20210704/index_small.png">
<meta property="article:published_time" content="2021-07-04T14:09:23.000Z">
<meta property="article:modified_time" content="2024-08-03T05:03:48.286Z">
<meta property="article:author" content="P2Tree">
<meta property="article:tag" content="LLVM">
<meta property="article:tag" content="编译器">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jsd.cdn.zzko.cn/gh/p2tree/web-asset/20210704/index_small.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>LLVM 后端实践笔记 7：控制流 - P2Tree Home</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"p2tree.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="P2Tree Home" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>P2Tree Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://jsd.cdn.zzko.cn/gh/p2tree/web-asset/20210704/index.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LLVM 后端实践笔记 7：控制流"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-07-04 22:09" pubdate>
          July 4, 2021 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LLVM 后端实践笔记 7：控制流</h1>
            
            
              <div class="markdown-body">
                
                <p>这一章会介绍与控制流有关的功能实现，比如 if、else、while 和 for 等，还会介绍如何将控制流的 IR 表示转换为机器指令；之后会引入几个后端优化，处理一些跳转需求引入的问题，同时来说明如何编写后端优化的 pass。在条件指令小节中，会介绍 LLVM IR 中的特殊指令 select 和 select_cc，以及如何处理这种指令，从而来支持更细节的控制流支持实现。</p>
<h2 id="7-1-控制流语句"><a href="#7-1-控制流语句" class="headerlink" title="7.1 控制流语句"></a>7.1 控制流语句</h2><h3 id="7-1-1-简要说明"><a href="#7-1-1-简要说明" class="headerlink" title="7.1.1 简要说明"></a>7.1.1 简要说明</h3><p>从机器层面上来看，所有的跳转只分为无条件跳转和有条件跳转，从跳转方式上来分，又分为直接跳转（绝对地址）和间接跳转（相对偏移），所以我们只需要将 LLVM IR 的跳转 node 成功下降到机器跳转指令，并维护好跳转的范围、跳转的重定位信息即可。</p>
<p>Cpu032I 型机器支持 J 类型的跳转指令，比如无条件跳转 JMP，有条件跳转 JEQ、JNE、JLT、JGT、JLE、JGE，这部分指令是需要通过检查 condition code （SW 寄存器）来决定跳转条件的；Cpu032II 型机器除了支持 J 类型跳转指令之外，还支持 B 类型的跳转指令，比如 BEQ 和 BNE，这两个是通过直接比较操作数值关系来决定跳转条件的。相比较，后者的跳转依赖的资源少，指令效率更高。</p>
<p>SelectionDAG 中的 node，无条件跳转是 <code>ISD::br</code>，有条件跳转是 <code>ISD::brcond</code>，我们需要在 tablegen 中通过指定指令选择 pattern 来对这些 node 做映射。</p>
<p>另外，J 类型指令依赖的 condition code 是通过比较指令（比如 CMP）的结果来设置的，我们在之前的章节已经完成了比较指令，LLVM IR 的 <code>setcc</code> node 通常会被翻译为 <code>addiu reg1, zero, const + cmp reg1, reg2</code> 指令。</p>
<h3 id="7-1-2-文件修改"><a href="#7-1-2-文件修改" class="headerlink" title="7.1.2 文件修改"></a>7.1.2 文件修改</h3><h4 id="1-Cpu0ISelLowering-cpp"><a href="#1-Cpu0ISelLowering-cpp" class="headerlink" title="(1) Cpu0ISelLowering.cpp"></a>(1) Cpu0ISelLowering.cpp</h4><p>设置本章需要的几个 node 为 custom 的 lowering 类型，即我们会通过自定义的 lowering 操作来处理它们，这包括 <code>BlockAddress</code>，<code>JumpTable</code> 和 <code>BRCOND</code>。这分别对应 <code>lowerBlockAddress()</code>，<code>lowerJumpTable()</code> 和 <code>lowerBRCOND()</code> 函数，具体实现可参见代码，其中 <code>getAddrLocal()</code> 和 <code>getAddrNonPIC()</code> 是我们前边章节已经实现的自定义 node 生成函数。<code>BRCOND</code> 是条件跳转节点（包括 condition 的 op 和 condition 为 true 时 跳转的 block 的地址），<code>BlockAddress</code> 字面可知是 BasicBlock 的起始地址类型的节点，<code>JumpTable</code> 是跳转表类型的节点。后两者是叶子节点类型。</p>
<p>另外，设置 <code>SETCC</code> 在 i1 类型时做 Promote。增加了几行代码来说明额外的一些 ISD 的 node 需要做 Expand，有关于 Expand 我们在之前的章节介绍过，就是采用 LLVM 内部提供的一些展开方式来展开这些我们不支持的操作。这些操作包括：<code>BR_JT</code>，<code>BR_CC</code>，<code>CTPOP</code>，<code>CTTZ</code>，<code>CTTZ_ZERO_UNDEF</code>，<code>CTLZ_ZERO_UNDEF</code>。其中 <code>BR_JT</code> 操作的其中一个 op 是 <code>JumpTable</code> 类型的节点（保存 <code>JumpTable</code> 中的一个 index）。<code>BR_CC</code> 操作和 <code>SELECT_CC</code> 操作类似，区别是它保存有两个 op，通过比较相对大小来选择不同的分支。</p>
<h4 id="2-Cpu0InstrInfo-td"><a href="#2-Cpu0InstrInfo-td" class="headerlink" title="(2) Cpu0InstrInfo.td"></a>(2) Cpu0InstrInfo.td</h4><p>增加两个和跳转有关的操作数类型：<code>brtarget16</code> 和 <code>brtarget24</code>，前者是 16 位偏移的编码，将用于 <code>BEQ</code>、<code>BNE</code> 一类的指令，这一类指令是属于 Cpu032II 型号中特有；后者是 24 位偏移的编码，将用于 <code>JEQ</code>、<code>JNE</code> 一类的指令。两个操作数均指定了编码函数和解码函数的名称。还定义了 <code>jmptarget</code> 操作数类型，用来作为无条件跳转 <code>JMP</code> 的操作数。</p>
<p>之后便是定义这几条跳转指令，包括它们的匹配 pattern 和编码。</p>
<p>无条件跳转 <code>JMP</code> 的匹配 pattern 直接指明到了 <code>[(br bb::$addr)]</code>，很好理解。</p>
<p>然后我们做一些优化来定义 比较+跳转指令选择 Pattern，也就是将 <code>brcond + seteq/setueq/setne/setune/setlt/setult/setgt/setugt/setle/setule/setge/setuge</code> 系列模式转换为机器指令的比较+跳转指令组合。对于 J 系列的跳转指令，实际上会转换为 <code>Jxx + CMP</code> 模式，而对于 B 系列的跳转指令，则直接转换成指令本身。</p>
<p>比如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">def : Pat&lt;(brcond (i32 (setne RC:$lhs, RC:$rhs)), bb:$dst), (JNEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)&gt;;<br>def : Pat&lt;(brcond (i32 (setne RC:$lhs, RC:$rhs)), bb:$dst), (BNEOp RC:$lhs, RC:$rhs, bb:$dst)&gt;;<br></code></pre></td></tr></table></figure>

<p>需要留意的一个是，我们无法从 C 语言生成 <code>setueq</code> 和 <code>setune</code> 指令，所以实际上并不会对其做选择（不过考虑到不要过分依赖前端，还是实现了）。</p>
<h4 id="3-Cpu0MCInstLower-cpp"><a href="#3-Cpu0MCInstLower-cpp" class="headerlink" title="(3) Cpu0MCInstLower.cpp"></a>(3) Cpu0MCInstLower.cpp</h4><p>因为跳转的地址既可以是跳转表偏移，也可以是一个 label，所以需要在 <code>MachineOperand</code> 这里对相关的类型做 lowering。在 <code>LowerSymbolOperand()</code> 函数中增加对 <code>MO_MachineBasicBlock</code>、<code>MO_BlockAddress</code> 和 <code>MO_JumpTableIndex</code> 类型的 lowering。</p>
<h4 id="4-Cpu0MCCodeEmitter-h-cpp"><a href="#4-Cpu0MCCodeEmitter-h-cpp" class="headerlink" title="(4) Cpu0MCCodeEmitter.h&#x2F;cpp"></a>(4) Cpu0MCCodeEmitter.h&#x2F;cpp</h4><p>实现地址操作数的编码实现函数，包括 <code>getBranch16TargetOpValue()</code>，<code>getBranch24TargetOpValue()</code> 和 <code>getJumpTargetOpValue()</code> 函数，对 <code>JMP</code> 指令同时还是表达式类型的跳转位置的情况，选择正确的 fixups，fixups 类型在 Cpu0FixupKinds.h 文件中定义。</p>
<h4 id="5-Cpu0AsmPrinter-h-cpp"><a href="#5-Cpu0AsmPrinter-h-cpp" class="headerlink" title="(5) Cpu0AsmPrinter.h&#x2F;cpp"></a>(5) Cpu0AsmPrinter.h&#x2F;cpp</h4><p>定义一个名为 <code>isLongBranchPseudo()</code> 的函数，用来判断指令是否是长跳转的伪指令。</p>
<p>同时在 <code>EmitInstruction()</code> 函数中增加当属于长跳转伪指令时，不发射该指令。</p>
<h4 id="6-MCTargetDesc-Cpu0FixupKinds-h"><a href="#6-MCTargetDesc-Cpu0FixupKinds-h" class="headerlink" title="(6) MCTargetDesc&#x2F;Cpu0FixupKinds.h"></a>(6) MCTargetDesc&#x2F;Cpu0FixupKinds.h</h4><p>添加重定位类型 <code>fixup_Cpu0_PC16</code> 和 <code>fixup_Cpu0_PC24</code>。</p>
<h4 id="7-MCTargetDesc-Cpu0ELFObjectWriter-cpp"><a href="#7-MCTargetDesc-Cpu0ELFObjectWriter-cpp" class="headerlink" title="(7) MCTargetDesc&#x2F;Cpu0ELFObjectWriter.cpp"></a>(7) MCTargetDesc&#x2F;Cpu0ELFObjectWriter.cpp</h4><p>添加重定位类型的一些设置，在 <code>getRelocType()</code> 函数中增加内容。</p>
<h4 id="8-MCTargetDesc-Cpu0AsmBackend-cpp"><a href="#8-MCTargetDesc-Cpu0AsmBackend-cpp" class="headerlink" title="(8) MCTargetDesc&#x2F;Cpu0AsmBackend.cpp"></a>(8) MCTargetDesc&#x2F;Cpu0AsmBackend.cpp</h4><p>这里有个小的要点需要留意。Cpu0 的架构和其他 RISC 机器一样，采用五级流水线结构，跳转指令会在 decode 阶段实现跳转动作（也就是将 PC 修改为跳转后的位置），但跳转指令在 fetch 阶段时，PC 会自动先移动到下一条指令位置，fetch 阶段在 decode 阶段之前，所以实际上，在 decode 阶段执行前，PC 已经自动 +4 （一个指令长度），所以实际上跳转指令中的偏移，并不是从跳转指令到目标位置的差，而应该是跳转指令的下一条指令到目标位置的差。</p>
<p>比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ca65">jne $BB0_2<br>jmp $BB0_1         # jne 指令 decode 之前，PC 指向这里<br>$BB0_1:<br>ld $4, 36($fp)<br>addiu $4, $4, 1<br>st $4, 36($fp)<br>jmp $BB0_2<br>$BB0_2:<br>ld $4, 32($fp)     # jne 指令 decode 之后，假设 PC 指向这里<br></code></pre></td></tr></table></figure>

<p>jne 指令中的偏移，应该是 jmp 指令到 最后一条 ld 指令之间的距离，也就是 20 （而不是 24）。</p>
<p>为了实现这样的修正，我们在 <code>adjustFixupValue()</code> 函数中，针对重定位类型 <code>fixup_Cpu0_PC16</code> 和 <code>fixup_Cpu0_PC24</code>，指定其 Value 应该在自身的基础上减 4。</p>
<h3 id="7-1-3-检验成果"><a href="#7-1-3-检验成果" class="headerlink" title="7.1.3 检验成果"></a>7.1.3 检验成果</h3><p>编译提供的测试用例 ch7_1_controlflow.c， 使用 Cpu032I 生成的汇编如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">...<br>cmp $sw, $3, $2<br>jne $sw, $BB0_2<br>jmp $BB0_1<br>$BB0_1:<br>ld $4, 4($sp)<br>addiu $4, $4, 1<br>st $4, 4($sp)<br>jmp $BB0_2<br>$BB0_2:<br>ld $2, 4($sp)<br>...<br></code></pre></td></tr></table></figure>

<p>可见 Cpu032I 处理器使用 sw 寄存器和 J 系列跳转指令完成控制流操作。</p>
<p>使用 Cpu032II 生成的汇编如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">...<br>bne $2, $zero, $BB0_2<br>jmp $BB0_1<br>$BB0_1:<br>ld $4, 4($sp)<br>addiu $4, $4, 1<br>st $4, 4($sp)<br>jmp $BB0_2<br>$BB0_2:<br>ld $2, 4($sp)<br></code></pre></td></tr></table></figure>

<p>Cpu032II 处理器使用 B 系列跳转指令完成控制流操作，指令数更少。</p>
<p>通过 Cpu032I 直接生成二进制代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=obj ch7_1_controlflow.ll -o ch7_1_controlflow.o<br>hexdump ch7_1_controlflow.o<br></code></pre></td></tr></table></figure>

<p>通过 hexdump 可以将二进制代码输出到终端。从其中找到 <code>31 00 00 14 36 00 00 00</code> 这段编码，<code>31</code> 是 jne 指令，<code>36</code> 是 jmp 指令，<code>14</code> 是 偏移的编码，可见这里偏移是 20，说明我们 Cpu0AsmBackend.cpp 中的设计生效了。</p>
<h2 id="7-2-消除无用的-JMP-指令"><a href="#7-2-消除无用的-JMP-指令" class="headerlink" title="7.2 消除无用的 JMP 指令"></a>7.2 消除无用的 JMP 指令</h2><p>LLVM 的大多数优化操作都是在中端完成，也就是在 LLVM IR 下完成。除了中端优化以外，其实还有一些依赖于后端特性的优化在后端完成。比如说，Mips 机器中的填充延迟槽优化，就是针对 RISC 下的 pipeline 优化。如果你的后端是一个带有延迟槽的 pipeline RISC 机器，那么也可以使用 Mips 的这一套优化。</p>
<p>这一小节，我们实现一个简单的后端优化，叫做消除无用的 JMP 指令。这个算法简单且高效，可以作为一个优化的教程来学习，通过学习，也可以了解如何新增一个优化 pass，以及如何在真实的工程中编写复杂的优化算法。</p>
<h3 id="7-2-1-简要说明"><a href="#7-2-1-简要说明" class="headerlink" title="7.2.1 简要说明"></a>7.2.1 简要说明</h3><p>对于如下汇编指令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">    jmp    $BB_0<br>$BB_0:<br>    ... other instructions<br></code></pre></td></tr></table></figure>

<p>在 jmp 指令的下一条指令，就是 jmp 指令需要跳转的 BasicBlock 块，因为 jmp 指令是无条件跳转，所以这里的控制流必然会做顺序执行，进而可以明确这里的 jmp 指令是多余的，即使删掉这条 jmp 指令，程序流也一样可以执行正确。</p>
<p>所以，我们的目的就是识别这种模式，并删除对应的 jmp 指令。</p>
<h3 id="7-2-2-文件修改"><a href="#7-2-2-文件修改" class="headerlink" title="7.2.2 文件修改"></a>7.2.2 文件修改</h3><h4 id="1-CMakeLists-txt"><a href="#1-CMakeLists-txt" class="headerlink" title="(1) CMakeLists.txt"></a>(1) CMakeLists.txt</h4><p>添加新文件 Cpu0DelUselessJMP.cpp。</p>
<h4 id="2-Cpu0-h"><a href="#2-Cpu0-h" class="headerlink" title="(2) Cpu0.h"></a>(2) Cpu0.h</h4><p>声明这个 pass 的工厂函数。</p>
<h4 id="3-Cpu0TargetMachine-cpp"><a href="#3-Cpu0TargetMachine-cpp" class="headerlink" title="(3) Cpu0TargetMachine.cpp"></a>(3) Cpu0TargetMachine.cpp</h4><p>覆盖 <code>addPreEmitPass()</code> 函数，在其中添加我们的 pass。调用这个函数表示我们的 pass 会在代码发射之前被执行。</p>
<h3 id="7-2-3-文件新增"><a href="#7-2-3-文件新增" class="headerlink" title="7.2.3 文件新增"></a>7.2.3 文件新增</h3><h4 id="1-Cpu0DelUselessJMP-cpp"><a href="#1-Cpu0DelUselessJMP-cpp" class="headerlink" title="(1) Cpu0DelUselessJMP.cpp"></a>(1) Cpu0DelUselessJMP.cpp</h4><p>这是我们实现该优化 pass 的具体代码。有几个具体要留意的点：</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_TYPE <span class="hljs-string">&quot;del-jmp&quot;</span></span><br><br>...<br><span class="hljs-built_in">LLVM_DEBUG</span>(<span class="hljs-built_in">dbgs</span>() &lt;&lt; <span class="hljs-string">&quot;debug info&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这里是为我们的优化 pass 添加一个调试宏，这样我们可以通过在执行编译命令时，指定该调试宏来打印出我们想要的调试信息。注意需要以 debug 模式来编译编译器，并且在执行编译命令时，指定参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llc -debug-only=del-jmp<br></code></pre></td></tr></table></figure>

<p>或直接打开所有调试信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llc -debug<br></code></pre></td></tr></table></figure>

<p>其次，代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">STATISTIC</span>(NumDelJmp, <span class="hljs-string">&quot;Number of useless jmp deleted&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>表示我们定义了一个全局变量 <code>NumDelJmp</code>，可以允许我们在执行编译命令时，当执行完毕时，打印出这个变量的值。这个变量的作用是统计这个优化 pass 一共消除了多少的无用 jmp 指令，变量的累加是在实现该 pass 的逻辑中手动设计进去的。</p>
<p>在执行编译命令时，指定参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llc -stats<br></code></pre></td></tr></table></figure>

<p>就可以打印出所有的统计变量的值。</p>
<p>其次，代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> cl::opt&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">EnableDelJmp</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  ...</span></span><br><span class="hljs-params"><span class="hljs-function">  ...</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这部分代码是向 LLVM 注册了一个编译参数，参数名称是这里第一个元素，还指定了参数的默认值，描述信息等。我们使用参数名为：<code>enable-cpu0-del-useless-jmp</code>，默认是打开的。这就是说，如果我们指定了这个参数，并且令其值为 false，则会关闭这个优化 pass。</p>
<p>具体的实现代码中，继承了 MachineFunctionPass 类，并在 <code>runOnMachineFunction</code> 中重写了逻辑，这个函数会在每次进入一个新的 Function 时被执行。在内部逻辑中调用了 <code>runOnMachineBasicBlock</code> 函数，同理，这个函数在每进入一个新的 BasicBlock 时被执行。</p>
<p>我们的基本思路是，在每个函数中遍历每一个基本块，直接取其最后一条指令，判断是否为 jmp 指令，如果是，再判断这条指令指向的基本块是否是下一个基本块。如果都满足，则调用 <code>MBB.erase(I)</code> 删除 <code>I</code> 指向的指令（jmp 指令）并且累加 <code>NumDelJmp</code> 变量。</p>
<h3 id="7-2-4-检验成果"><a href="#7-2-4-检验成果" class="headerlink" title="7.2.4 检验成果"></a>7.2.4 检验成果</h3><p>执行我提供的测试用例：ch7_2_deluselessjmp.cpp</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">build/bin/llc -march=cpu0 -relocation-model=static -filetype=asm -stats ch7_2_deluselessjmp.ll -o -<br></code></pre></td></tr></table></figure>

<p>查看输出汇编，会发现已经没有 jmp 指令，输出 statistics 信息中 <code>8 del-jmp</code> 告诉我们删除了 8 条无用的 jmp 指令。可以关闭这个优化再查看汇编（添加 <code>-enable-cpu0-del-useless-jmp=false</code>），两次结果做对比。</p>
<h2 id="7-3-填充跳转延迟槽"><a href="#7-3-填充跳转延迟槽" class="headerlink" title="7.3 填充跳转延迟槽"></a>7.3 填充跳转延迟槽</h2><p>这是个功能性的 pass。很多 RISC 机器采用多级流水线设计，有些 phase 会产生延迟，为了保证软件运行正确，可能会需要软件（编译器）在需要延迟的指令做处理。Cpu0 就符合这种情况，对于所有的跳转指令，需要有一个 cycle 的延迟，编译器需要负责对这些跳转指令做延迟插入指令。为了让实现简单，我们目前的实现只是将一条 nop 指令填充到跳转指令之后。有关于将其他有用的指令插入到跳转之后，可以参考 Mips 的实现（更加有意义，不单单是一条无用的等待），比如 MipsDelaySlotFiller.cpp 文件。</p>
<h3 id="7-3-1-简要说明"><a href="#7-3-1-简要说明" class="headerlink" title="7.3.1 简要说明"></a>7.3.1 简要说明</h3><p>对于如下汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">    jne    $sw, $BB_0<br>    nop    // 这里是插入的指令<br>$BB_1:<br>    ... other instructions<br></code></pre></td></tr></table></figure>

<p>对于 jne 指令，因为需要为其填充延迟指令，所以实际我们代码运行之后，会在汇编中，jne 的下一条指令，输出一条 nop 指令，这样就可以保证在 jne 执行完毕之后，再进行后续的运行。</p>
<p>与上一节的设计类似，我们依然是设计一个 pass，专门去识别这样一个模式，并创建一个 nop 指令并与跳转指令打到一个 bundle 中。bundle 是 LLVM 在 MI 层支持的一种指令扩展，它会在 bundle emit 之前，将 bundle 看做一条指令，而 bundle 内部却可以包含多条指令。</p>
<h3 id="7-3-2-文件修改"><a href="#7-3-2-文件修改" class="headerlink" title="7.3.2 文件修改"></a>7.3.2 文件修改</h3><h4 id="1-CMakeLists-txt-1"><a href="#1-CMakeLists-txt-1" class="headerlink" title="(1) CMakeLists.txt"></a>(1) CMakeLists.txt</h4><p>添加新增的文件 Cpu0DelaySlotFiller.cpp。</p>
<h4 id="2-Cpu0-h-1"><a href="#2-Cpu0-h-1" class="headerlink" title="(2) Cpu0.h"></a>(2) Cpu0.h</h4><p>添加创建新 pass 的工厂函数。</p>
<h4 id="3-Cpu0TargetMachine-cpp-1"><a href="#3-Cpu0TargetMachine-cpp-1" class="headerlink" title="(3) Cpu0TargetMachine.cpp"></a>(3) Cpu0TargetMachine.cpp</h4><p>在 addPreEmitPass() 函数中增加我们的 pass，和上一小节同理。</p>
<h4 id="4-Cpu0AsmPrinter-cpp"><a href="#4-Cpu0AsmPrinter-cpp" class="headerlink" title="(4) Cpu0AsmPrinter.cpp"></a>(4) Cpu0AsmPrinter.cpp</h4><p>这里是汇编代码发射的地方，需要检查要发射的指令是否是 bundle，如果是，则将 bundle 展开，依次发射其中的每一条指令。这一个 while 代码在之前的章节已经添加。如果不做这个检查，则只有 bundle 中的第一条指令会被发射，这将会导致代码错误。</p>
<h3 id="7-2-3-文件新增-1"><a href="#7-2-3-文件新增-1" class="headerlink" title="7.2.3 文件新增"></a>7.2.3 文件新增</h3><h4 id="1-Cpu0DelaySlotFiller-cpp"><a href="#1-Cpu0DelaySlotFiller-cpp" class="headerlink" title="(1) Cpu0DelaySlotFiller.cpp"></a>(1) Cpu0DelaySlotFiller.cpp</h4><p>新 pass 的实现代码。和上一小节类似的实现就不赘述了。</p>
<p>定义了一个 <code>hasUnoccupiedSlot()</code> 函数，用来判断某条指令是否满足我们上文指定的模式，首先判断这条指令是否具有延迟槽，调用 <code>hasDelaySlot()</code> 函数，然后判断这条指令是否已经属于一个 bundle 或者是最后一条指令，调用 <code>isBundledWithSucc()</code> 函数。这两个函数都是 LLVM 内置函数，在 MachineInstr.h 中实现。</p>
<p>当满足条件时，先使用 BuildMI 创建 nop 指令，并插入到跳转指令的后边；然后调用 <code>MIBundleBuilder</code> 函数，将跳转指令和 nop 指令打到一个 bundle。</p>
<h3 id="7-3-4-检验成果"><a href="#7-3-4-检验成果" class="headerlink" title="7.3.4 检验成果"></a>7.3.4 检验成果</h3><p>我没有额外提供测试用例，可以通过编译上一节的 ch7_2_deluselessjmp.cpp，查看输出的汇编内容，加 <code>-stats</code> 参数，输出共填充了 5 个这样模式的延迟槽。</p>
<h2 id="7-4-条件-MOV-指令"><a href="#7-4-条件-MOV-指令" class="headerlink" title="7.4 条件 MOV 指令"></a>7.4 条件 MOV 指令</h2><h3 id="7-4-1-简要说明"><a href="#7-4-1-简要说明" class="headerlink" title="7.4.1 简要说明"></a>7.4.1 简要说明</h3><p>条件 MOV 指令也叫做 Select 指令，和 C 语言中的 select 操作语义一致，由一个条件值、两个指定值和一个定义值（输出）组成。在满足一个条件时，将指定值赋给定义值，否则把另一个指定值赋给定义值。我们在 Cpu0 中将实现两条 MOV 指令，分别是 <code>movz</code> 和 <code>movn</code>，表示当条件成立时（或条件不成立时），赋值第一个值，否则，赋值另一个值。</p>
<p>由于编码位有限，通常的条件 MOV 指令和 Select 指令均设计为其中一个指定值与定义值是同一个操作数（或者也有设计为条件值与定义值是同一个操作数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">movz $1, $2, $3;    @ $3 为条件值，当 $3 满足（为 true）时，将 $2 赋值给 $1,<br>                    @ 否则，保持 $1 值不变<br>movn $1, $2, $3;    @ $3 为条件值，当 $3 不满足（为 false）时，将 $2 赋值给 $1,<br>                    @ 否则，保持 $1 值不变<br></code></pre></td></tr></table></figure>

<p>可以发现，<code>movz</code> 和 <code>movn</code> 是可以相互替代的，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">movz $1, $2, $3;    @ 等价于<br>movn $2, $1, $3;    @ 当然，还需要保证上下文数据正确<br></code></pre></td></tr></table></figure>

<p>在 LLVM IR 中，只有一个指令来处理这个情况，叫做 <code>select</code> 指令：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-variable">%ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">select</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%cond</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%a</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%b</span><br></code></pre></td></tr></table></figure>

<p>所以我们需要做的就是在后端代码中，将这个 IR 转换为正确的指令表示。</p>
<h3 id="7-4-2-文件修改"><a href="#7-4-2-文件修改" class="headerlink" title="7.4.2 文件修改"></a>7.4.2 文件修改</h3><h4 id="1-Cpu0InstrInfo-td"><a href="#1-Cpu0InstrInfo-td" class="headerlink" title="(1) Cpu0InstrInfo.td"></a>(1) Cpu0InstrInfo.td</h4><p>新增和条件 MOV 相关的指令实例和用于窥孔优化的 Pattern 描述。</p>
<p>前者即定义 <code>movz</code> 和 <code>movn</code> 指令。注意到在 class 中使用 <code>let Constraints = &quot;$F = $ra&quot;</code> 的属性来指定两个操作符是同一个值，这种写法通常用于当其中一个 def 操作数同时也需要作为 use 操作数的情况下，比如当前的 select 示例中。</p>
<p>后者是将 IR 过来的 <code>select</code> + <code>cmp</code> 节点组合优化为一条 <code>movz</code> 或 <code>movn</code> 指令。<code>select</code> 指令的 condition 需要一条比较（或其他起相同作用的）指令来得出条件结果，在 Cpu032I 机器中是 <code>cmp</code> 指令，在 Cpu032II 机器中是 <code>slt</code> 指令。因为通常比较两个值是否相等，还可以采用 <code>xor</code> 指令，所以对于低效的 Cpu032I 比较 <code>cmp</code> 指令，可以使用 <code>xor</code> 做替换，但对于大于、小于等条件代码则只能继续使用 <code>cmp</code> 指令，体现在 .td 文件中就是不特别去优化 <code>select</code> 指令组合下的条件指令。</p>
<p>这个优化的路径是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">IR:   icmp + (eq, ne, sgt, sge, slt, sle) + br<br>DAG:  ((seteq, setne, setgt, setge, setlt, setle) + setcc) + select<br>Cpu0: movz, movn<br></code></pre></td></tr></table></figure>


<h4 id="2-Cpu0ISelLowering-h-cpp"><a href="#2-Cpu0ISelLowering-h-cpp" class="headerlink" title="(2) Cpu0ISelLowering.h&#x2F;.cpp"></a>(2) Cpu0ISelLowering.h&#x2F;.cpp</h4><p>需要做一点配置。首先，LLVM 的后端会默认把 <code>SetCC</code> 和 <code>Select</code> 两个 Node 合并成一条 <code>Select_cc</code> 指令，这是为能够支持 <code>Select_cc</code> 指令的后端而准备的，这种指令是通过 condition code 来作为 <code>select</code> 指令的条件，比如在 X86 机器中。我们的 Cpu0 不支持这种指令，所以需要在 Cpu0ISelLowering.cpp 中，将 <code>Select_cc</code> 设置为 Expand 类型，表示我们希望 LLVM 帮我们替代这个类型的节点。</p>
<p>另一件事是将 <code>ISD::SELECT</code> 这个 Node 的默认下降关掉，也就是设置其为 Custom 类型，在我们自定义的下降中，直接将这个 Node 返回。因为我们不希望 select Node 在 lowering 阶段被选择为 select，这样它会无法选到指令。我们的条件 MOV 指令和这里的 select 指令有一些差异，所以只能通过在指令选择时的优化合并来实现从 select Node 到后端指令的 lowering。</p>
<h3 id="7-4-3-检验成果"><a href="#7-4-3-检验成果" class="headerlink" title="7.4.3 检验成果"></a>7.4.3 检验成果</h3><p>这一小节提供了 3 个 case，第一个 case （ch7_4_select.c）是最简单的情况，直接使用 C 语言中的三目运算符，clang 会在不开优化的情况下将其生成为 IR Select。</p>
<p>第二个 case (ch7_4_select2.c) 没有使用三目运算符，clang 在不开优化的编译下，会生成两个 BB 块，通过跳转实现功能，只有在启用至少 <code>-O1</code> 优化下，才会生成为 IR Select。</p>
<p>第三个 case (ch7_4_select_global_pic.c) 引入了全局变量，测试在全局变量与 select 混合的情况下是否能正常处理代码。</p>
<p>三个 case 的编译命令均与之前相同。</p>
<h2 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h2><p>以上就是本章的全部内容。最后再补充几个知识点。静态单赋值形式的表示形式，在对待多分支的控制流时，会遇到多赋值的问题。LLVM IR 处理这个问题的方式是引入 Phi 节点，Phi 节点是一种特殊的操作，它允许操作中通过判断控制流的流向来选择要赋值的值，从而避免了多赋值问题。</p>
<p>这种操作只有在 clang 启用优化的情况下才会生成，如果是 O0 不开优化时，LLVM 则会使用内存访问来解决问题，也就是将值写入同一个内存位置，再在需要赋值时从内存位置读出值，这样也能避免数据的多赋值。但也很显然，这种依赖于内存访问的方式会导致性能变差，所以只会在不开优化的情况下生成这种代码。</p>
<p>测试路径下也有这样的一个测试用例：ch7_5_phinode.c，可以通过 clang -O0 和 clang -O1 来编译生成 LLVM IR，查看代码并确认在 O1 优化下生成了 Phi 节点。</p>
<p>需要注意的是，因为我们目前还没有处理传参的问题，所以将 LLVM IR 编译成汇编代码的过程会出错：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Assertion failed: (InVals.size() == Ins.size() &amp;&amp; &quot;LowerFormalArguments didn&#x27;t emit the correct number of values!&quot;), function LowerArguments, file <br></code></pre></td></tr></table></figure>

<p>我们会在下一章开始处理和函数调用有关的功能。</p>
<p>有关于 Phi 节点更多的细节，可以查看静态单赋值代码形式的 Wiki： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">https://en.wikipedia.org/wiki/Static_single_assignment_form</a>。</p>
<hr>
<div class="note note-info">
            <p>本文同步发布在知乎账号下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386457923">LLVM 后端实践笔记 7：控制流 - 知乎 (zhihu.com)</a></p>
          </div>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/" class="category-chain-item">软件开发</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/LLVM/" class="print-no-link">#LLVM</a>
      
        <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" class="print-no-link">#编译器</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LLVM 后端实践笔记 7：控制流</div>
      <div>http://p2tree.github.io/2021/07/04/LLVM后端实践笔记-7-控制流/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>P2Tree</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>July 4, 2021</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/24/LLVM%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-8-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" title="LLVM 后端实践笔记 8：函数调用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LLVM 后端实践笔记 8：函数调用</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'p2tree/p2tree.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
