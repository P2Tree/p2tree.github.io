<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P2Tree&#39;s Mill</title>
  
  
  <link href="https://p2tree.top/atom.xml" rel="self"/>
  
  <link href="https://p2tree.top/"/>
  <updated>2024-12-15T12:21:03.351Z</updated>
  <id>https://p2tree.top/</id>
  
  <author>
    <name>P2Tree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书推荐：活着</title>
    <link href="https://p2tree.top/posts/dc0bdc19.html"/>
    <id>https://p2tree.top/posts/dc0bdc19.html</id>
    <published>2024-12-15T20:16:05.000Z</published>
    <updated>2024-12-15T12:21:03.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/12/15/book.51.webp" alt="book.51"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/hhBc47ZA4v86a4YOQCZj3Q">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="与生活妥协" scheme="https://p2tree.top/tags/%E4%B8%8E%E7%94%9F%E6%B4%BB%E5%A6%A5%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git果壳：什么是版本控制</title>
    <link href="https://p2tree.top/posts/86730351.html"/>
    <id>https://p2tree.top/posts/86730351.html</id>
    <published>2024-11-24T22:29:12.000Z</published>
    <updated>2024-12-15T12:21:03.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“Git 菜谱” 系列文章：</p><ol class="series-items"><li><a href="/posts/86730351.html" title="Git果壳：什么是版本控制">Git果壳：什么是版本控制</a></li></ol><hr><blockquote><p>©️ 本文演绎自 Atlassian 编写的 <a href="https://www.atlassian.com/git/tutorials/what-is-version-control"><em>What is version control</em></a>。页面上所有内容采用知识共享-署名（<a href="http://creativecommons.org/licenses/by/2.5/au/deed.zh">CC BY 2.5 AU</a>）许可协议。</p></blockquote><h3 id="版本控制的优点"><a href="#版本控制的优点" class="headerlink" title="版本控制的优点"></a>版本控制的优点</h3><p>版本控制系统是软件工具的一个类别，它可以辅助软件开发团队管理软件代码随着时间的更改。版本控制软件可以通过特殊的数据库来追踪代码的每一次变更。如果软件开发中发生错误，开发者可以利用版本控制来将代码和早期的版本做对比，从而能够以对其他团队成员干扰最小的前提下修复错误。</p><p>对于几乎所有的软件工程来说，软件源代码就是最重要的部分（<em>译注：原文比喻为皇冠上的宝石，也就是最需要保护的珍宝</em>）。对于大多数软件团队，源代码仓库是他们认真努力积累和完善的宝贵知识财富的存储库，而版本控制可以保护源代码免受灾难性的破坏以及人为操作失误或故意破坏。</p><p>软件开发人员工作过程中会持续性的产出新的代码以及修改已经存在的代码。一个工程软件、应用软件或者软件组件通常被组织在一个文件夹或者说一个目录树中。团队中的一个开发者可能在增加一个新特性，而另一个开发者可能在修复不相关的bug，每一个开发者都在这个目录树的不同位置对代码内容进行着更改。</p><p>版本控制可以帮助软件团队解决这样的问题，追踪每一个开发者产生的每一个独立的变更，以及帮助预防并发工作中的冲突。并发工作的冲突是指软件一部分的修改可能与另一个开发者同时的修改不兼容。这个问题应该有条不紊的被发现和解决，从而不能影响团队其他成员的工作。此外，在软件开发中，任何更改都有可能引入新的 bugs，故而在测试之前，新的软件版本不能被完全信任，所以直到新版本发布之前，测试和开发的进程都应该同时被执行。</p><p>好的版本控制软件可以支持开发者首选的工作流程，而不会强加一种特别的工作方式。理想情况下，它应该能在任何平台上工作，而不是特别要求开发者必须使用某种操作系统或者工具链。好的版本控制系统可以促进代码变更平稳连续的进行，而不是使用将文件锁定的这种糟糕而笨拙的机制（这是指某个文件只允许一名开发人员工作，而阻止其他开发人员开发）</p><p>不使用任何版本控制的软件团队经常会遇到一些问题，比如不知道已经完成的哪些变更可以被用户使用，或者在两个不相关的工作内容之间创建了互不兼容的更改，然后必须进行繁琐的整理和重做。如果你是一个从未使用过版本控制的开发者，你可能会这样命名你的不同版本的文件，比如加一个“最终版”或“最新版”的文件名后缀，然后不得不之后再处理新的最终版本。也许你会为了禁用某个功能但不愿删除代码，因为害怕代码未来还将会用到而注释掉代码块。版本控制可以解决如上这些问题。</p><p>版本控制软件是现代软件团队日常开发中必不可少的一部分。习惯于团队中使用功能强大的版本控制系统的软件开发人员会显然意识到版本控制所带来的不可思议的价值，即使是在小型项目中也是如此。一旦习惯了版本控制系统的强大优势，很多开发者就不再考虑去做没有版本控制支持的工作，即使是完成非软件开发的工作。</p><h3 id="版本控制系统的优点"><a href="#版本控制系统的优点" class="headerlink" title="版本控制系统的优点"></a>版本控制系统的优点</h3><p>开发软件时不使用版本控制系统是危险的，比方说没有做备份。版本控制也能允许开发人员更灵活的人员变动，允许软件团队在团队规模扩大时保持高效率和敏捷性。</p><p>版本控制系统（<code>Version Control System</code>,<code>VCS</code>）在过去的几十年内取得了非常大的进步，并且有些更为突出。有些时候被称作代码管理工具（<code>Source Code Management</code>,<code>SCM</code>）或者修订控制系统（<code>Revision Control System</code>,<code>RCS</code>）。其中一个很流行的版本控制工具叫做 Git，它是一个分布式的版本控制系统（<code>Distributed VCS</code>,<code>DVCS</code>），之后会详细介绍。就像很多现在流行的版本控制系统一样，Git 是自由的也是开源的。不管它们叫什么名字，又或者是什么系统使用，版本控制系统主要的优点有以下几点。</p><ol><li><strong>记录每一个文件的完整的长期的变更历史</strong>。这意味着它能记录长期以来每一个贡献者提交的每一个变更。这些变更包括文件的创建、删除以及内容修改。<em>不同的 VCS 工具的一个区别在于它们处理重命名和移动文件的能力</em>。每次变更将包括作者名、时间和每一次修改的纪要。具有完整的历史可以允许我们退回到之前的版本中，从而帮助分析 bugs，当需要在旧版本中修复软件问题时，这确实很重要。如果正在积极开发一个软件，则几乎所有的内容都将被看做这个软件的旧版本。<em>译注：因为软件更新快，原文旨在说明旧版本不是你想象中的那么“旧”。</em></li><li><strong>分支和合并特性</strong>。这些特性可以让团队协作工作更加便捷，也可以让独立工作的开发者能从中受益。在 VCS 工具中创建一个分支可以维持多个独立的开发工作流，同时也提供了将这些工作合并回去的功能，能允许开发者验证分支之间的变更是否冲突。很多软件团队使用独立分支来开发特性或者是维护一个版本，或者两者都有。软件团队可以利用分支和合并特性来选择不同的工作方式。</li><li><strong>可追溯性</strong>。能够追踪软件的每一次变更，进而可以让其能够搭配工程管理系统和 bug 追踪软件，比如 <a href="https://www.atlassian.com/software/jira">Jira</a>。可以通过消息来描述变更的目的和意图，从而注释每一次变更，这样不但能有助于关键问题分析也可协助其他的检查工作。在阅读代码，或尝试理解代码作用和设计意图时，这样的代码描述历史消息可以帮助开发者做出正确的和相匹配的修改，能够与系统预期的长期设计思想相符合。这种方式对于在遗留代码上高效工作是非常重要的，对于开发人员准确估计未来工作也是非常重要的。</li></ol><p>当然，不使用版本控制系统来开发软件也是可行的，但是这样的工程具有很大的风险，任何专业的开发团队都不会愿意接受。所以问题并不会在于是否使用版本控制系统，而是使用哪种版本控制系统。</p><p>这会有多种选择，但这里的教程我们专注于 Git。从<a href="https://bitbucket.org/product/version-control-software?_ga=2.63967023.1846059181.1575290049-386918931.1575091845">这里</a>可以了解到其他的版本控制软件。</p><hr><div class="note info flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@nganduong93?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Duong Ngan</a> on <a href="https://unsplash.com/photos/a-white-table-topped-with-white-christmas-trees-dTBhA3zP3yA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="译文" scheme="https://p2tree.top/tags/%E8%AF%91%E6%96%87/"/>
    
    <category term="Git" scheme="https://p2tree.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>他们</title>
    <link href="https://p2tree.top/posts/b5919f86.html"/>
    <id>https://p2tree.top/posts/b5919f86.html</id>
    <published>2024-11-19T22:53:22.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0 到 3 岁，你是他们的全部；<br>3 到 7 岁，你是他们的晚上；<br>7 到 18 岁，你是他们的周末；<br>18 到 22 岁，你是他们的寒暑假；<br>之后，你是他们的春节。</p><hr><p><img src="https://img.p2tree.top/2024/11/19/Chapter.401.webp" alt="Chapter.401"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，秋天、老照片和时光流逝。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/YPAAsZC_tWvoecqUv01Azg">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>开始阅读很多的书，但读完很少的书</title>
    <link href="https://p2tree.top/posts/1da6b0bc.html"/>
    <id>https://p2tree.top/posts/1da6b0bc.html</id>
    <published>2024-11-03T20:25:40.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>阅读应追求对自身产生的影响，若仅仅是为读完而读，那实则毫无意义。</p><p>读书与实践相关，有人开始时会阅读大量书籍，但真正读完的却寥寥无几。读书就如同结识朋友，如果感觉不适，便可放弃。即便某本书在他人眼中是佳作，但只要对自己无益，就没必要去读。因为时间有限，在相同的时间里，我们当然更希望阅读一本对自己有帮助且能吸引自己的书。</p><p>清理书单最快的方法，不是把书读完，而是将它们从书单中删除。</p><hr><p><img src="https://img.p2tree.top/2024/11/03/Chapter.89.webp" alt="Chapter.89"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，一只阅读的花栗鼠。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/XEIIGx4FP8gRGfmWUC4EKA">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="学习方法" scheme="https://p2tree.top/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：宝贵的人生建议</title>
    <link href="https://p2tree.top/posts/2626ad0e.html"/>
    <id>https://p2tree.top/posts/2626ad0e.html</id>
    <published>2024-10-27T17:09:22.000Z</published>
    <updated>2024-12-15T12:21:03.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/10/27/book.49.webp" alt="book.49"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/Y337qOZMNBw4UqbBhUC-ww">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="个人发展" scheme="https://p2tree.top/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>死亡搁浅配乐收藏</title>
    <link href="https://p2tree.top/posts/a28b3899.html"/>
    <id>https://p2tree.top/posts/a28b3899.html</id>
    <published>2024-10-24T23:07:57.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《死亡搁浅》是我玩过的游戏中，音乐和配乐设计最为出色的一款作品。它的音乐完全可以独立于游戏本身享受，玩家无需具备游戏体验也能轻松欣赏其中的旋律。这些歌曲展现了极强的亲和力和感染力，每一曲都令人陶醉。游戏中恰到好处的配乐增强了玩家的沉浸感，使人愈加沉迷于其中。音乐在这款游戏中的地位不可忽视，成为了推动体验的重要元素。</p><p>推荐收听：</p><ul><li>Don’t Be So Serious：Death Stranding，一个讲述有关离别、联结和自我接纳的故事</li><li>Bones：第一次踏上旅程，面对恬静广阔的自然景观，音乐声恰好响起</li><li>BB’s Theme：最后一次走出首都节点城，再一次被音乐震撼，“我，是你吗？”</li><li>I’ll Keep Coming：面对挫折后，能否在心底保留希望，继续前行</li><li>Death Stranding：当明知注定会失去一切时，还会满怀激情，走向故事的结尾吗？</li></ul><hr><p><strong>[ 点击图标可以在线播放 ]</strong></p>        <div id="aplayer-HRzBbbIU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#99988D","preload":"metadata","listmaxheight":"513px","music":[{"title":"Almost Nothing","author":"Silent Poets、Okay Kaya","url":"https://music.p2tree.top/death_strandling/Almost%20Nothing%20-%20Silent%20Poets%E3%80%81Okay%20Kaya.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Almost%20Nothing%20-%20Silent%20Poets%E3%80%81Okay%20Kaya.lrc"},{"title":"Anything You Need","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Anything%20You%20Need%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Anything%20You%20Need%20-%20Low%20Roar.lrc"},{"title":"Asylums for the Feeling","author":"Silent Poets、Leila Adu","url":"https://music.p2tree.top/death_strandling/Asylums%20for%20the%20Feeling%20-%20Silent%20Poets%E3%80%81Leila%20Adu.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Asylums%20for%20the%20Feeling%20-%20Silent%20Poets%E3%80%81Leila%20Adu.lrc"},{"title":"BB's Theme","author":"Ludvig Forssell、Jenny Plant","url":"https://music.p2tree.top/death_strandling/BB's%20Theme%20-%20Ludvig%20Forssell%E3%80%81Jenny%20Plant.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/BB's%20Theme%20-%20Ludvig%20Forssell%E3%80%81Jenny%20Plant.lrc"},{"title":"Because We Have To","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Because%20We%20Have%20To%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Because%20We%20Have%20To%20-%20Low%20Roar.lrc"},{"title":"Bones","author":"Low Roar、Jofridur Akadottir","url":"https://music.p2tree.top/death_strandling/Bones%20-%20Low%20Roar%E3%80%81Jofridur%20Akadottir.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Bones%20-%20Low%20Roar%E3%80%81Jofridur%20Akadottir.lrc"},{"title":"Breathe In","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Breathe%20In%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Breathe%20In%20-%20Low%20Roar.lrc"},{"title":"Death Stranding","author":"CHVRCHES","url":"https://music.p2tree.top/death_strandling/Death%20Stranding%20-%20CHVRCHES.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Death%20Stranding%20-%20CHVRCHES.lrc"},{"title":"Don't Be So Serious","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Don't%20Be%20So%20Serious%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Don't%20Be%20So%20Serious%20-%20Low%20Roar.lrc"},{"title":"Easy Way Out","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Easy%20Way%20Out%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Easy%20Way%20Out%20-%20Low%20Roar.lrc"},{"title":"Give Up","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Give%20Up%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Give%20Up%20-%20Low%20Roar.lrc"},{"title":"Gosia","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Gosia%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Gosia%20-%20Low%20Roar.lrc"},{"title":"I'll Keep Coming","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/I'll%20Keep%20Coming%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/I'll%20Keep%20Coming%20-%20Low%20Roar.lrc"},{"title":"I'm Leaving","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/I'm%20Leaving%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/I'm%20Leaving%20-%20Low%20Roar.lrc"},{"title":"Not Around","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Not%20Around%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Not%20Around%20-%20Low%20Roar.lrc"},{"title":"Once in a Long, Long While…","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Once%20in%20a%20Long%2C%20Long%20While%E2%80%A6%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Once%20in%20a%20Long%2C%20Long%20While%E2%80%A6%20-%20Low%20Roar.lrc"},{"title":"Patience","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Patience%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Patience%20-%20Low%20Roar.lrc"},{"title":"Please Don't Stop (Chapter 1)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%201)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%201)%20-%20Low%20Roar.lrc"},{"title":"Please Don't Stop (Chapter 2)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%202)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%202)%20-%20Low%20Roar.lrc"},{"title":"Pop Virus","author":"星野源","url":"https://music.p2tree.top/death_strandling/Pop%20Virus%20-%20%E6%98%9F%E9%87%8E%E6%BA%90.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Pop%20Virus%20-%20%E6%98%9F%E9%87%8E%E6%BA%90.lrc"},{"title":"Poznań","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Pozna%C5%84%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Pozna%C5%84%20-%20Low%20Roar.lrc"},{"title":"Rolling Over","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Rolling%20Over%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Rolling%20Over%20-%20Low%20Roar.lrc"},{"title":"St. Eriksplan","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/St.%20Eriksplan%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/St.%20Eriksplan%20-%20Low%20Roar.lrc"},{"title":"The Machine","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/The%20Machine%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/The%20Machine%20-%20Low%20Roar.lrc"},{"title":"Tonight, Tonight, Tonight","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Tonight%2C%20Tonight%2C%20Tonight%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Tonight%2C%20Tonight%2C%20Tonight%20-%20Low%20Roar.lrc"},{"title":"Waiting (10 Years)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Waiting%20(10%20Years)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Waiting%20(10%20Years)%20-%20Low%20Roar.lrc"},{"title":"Without You","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Without%20You%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Without%20You%20-%20Low%20Roar.lrc"}]};  options.element = document.getElementById("aplayer-HRzBbbIU");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><hr><div class="note primary flat"><p>音乐资源来自网络，若存在侵权，请联系我删除。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="音乐" scheme="https://p2tree.top/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
    <category term="音乐" scheme="https://p2tree.top/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>C++20 特性杂谈</title>
    <link href="https://p2tree.top/posts/49819b87.html"/>
    <id>https://p2tree.top/posts/49819b87.html</id>
    <published>2024-10-20T20:31:41.000Z</published>
    <updated>2024-12-15T12:21:03.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 的发展方向最重要的就是 C++ 标准委员会的统一决策，这种从不同行业、公司、国家和组织中集合的一群人，能达成共识并推出一些有价值的成果，已经非常难得。然而，C++ 仍然因此和其他新兴语言之间产生了差距。</p><p>C++ 标准的一种最重要的宗旨就是确保 C++ 在更新的过程中，看起来还是同一个语言，所以它需要满足一种统一的演化标准。这些标准概括起来有：</p><ul><li>基于过去已有的成功模式作为演化方向，比如 RAII、类型安全检查</li><li>简单的事情用简单的方法做</li><li>从代码到硬件的零开销原则和直接映射</li><li>基于意见反馈来发展</li><li>保持稳定性和兼容性</li><li>维持与硬件的直接映射，简单的抽象机制，最小化的运行时系统</li></ul><p>然而，过去很长一段时间，C++ 标准委员会都只专注于编程语言特性和标准库的方向，而没有在语言工具链方面做额外的事情，比如构建系统、包管理、链接原则等方面，这导致了 C++ 语言没有标准统一的开发和运行环境，每个操作系统、平台，甚至编程框架都可以规定自己的开发模式，各自为政。相关的软件也都依赖第三方企业或开源社区维护，用法和实现五花八门，没有统一标准的指导方针。</p><p>说回 C++20，这一次标准版本是可以和 C++11 不相上下的发布，其中包括了好几个大型特性，比如模块、概念、协程。C++20 对 C++ 的影响可以说又是改头换面的。</p><hr><p>本文是 C++ 特性杂谈系列文章的第四篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="模块"><a href="#模块" class="headerlink" title="# 模块"></a># 模块</h2><p>模块用来替代之前 C++ 中的头文件机制。</p><p>头文件引入的机制存在一些明显的缺点，已经饱受诟病：</p><ul><li>头文件的引入只是通过宏对代码的直接展开，不同头文件中的代码相互之间可见，可能发生名字冲突问题，不同头文件的来源不同，很难做到统一和安全。</li><li>已经有太多的代码被放入头文件中。过去 C++ 继承 C 的头文件机制时，头文件中只会放一些 export 的函数声明，但现在，一个工程中大于 90% 的代码都在头文件中。</li><li>常见的头文件可能在其他文件中被 include 很多次，虽然有避免重复编译的头文件宏，但依然无法阻止预处理器一遍又一遍的展开这些重复的 include 文件代码。这导致编译效率降低。</li></ul><p>模块机制的优势是：</p><ul><li>同一个模块，编译器只需要处理一次，这会一定程度上减少编译时间</li><li>避免了不同头文件中可能存在的名字冲突</li><li>模块中区分导出的符号和内部符号，只保留必要的接口，保证了实现上的封装性</li><li>编译过程中的代码整洁很多，只会引入被调用的符号，没有调用但也被暴露出来的符号不会被编译</li></ul><p>之后，标准委员会最大的困难便是如何兼容过去的 include 机制与新引入的模块机制，最后应该是基本解决了。模块的引入方式可以做到比头文件的引入方式在编译上快一个数量级。</p><p>模块的引入，不可避免地会彻底改变 C++ 代码的导入导出方式，对过去几十年人们已经在头文件系统上做过的大量工作来说，是一个明显的冲击。但理念和技术都在发展进步，有些东西确实只能被时代抛弃。</p><p>虽然模块是 C++20 中的一个正式特性，但因为特性比较复杂，存在对旧代码的影响，所以目前（2024年9月）编译器（比如 gcc）还是需要用额外的参数来指定启用该功能，编译器实现也有可能存在 bug 和不完善。未来编译器实现稳定之后，编译参数会被取消。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c+<span class="number">+20</span> -fmodules-ts -o main main.cpp math_module.cppm</span><br><span class="line">clang++ -std=c+<span class="number">+20</span> -fmodules -o main main.cpp math_module.cppm</span><br></pre></td></tr></table></figure><p>后缀 <code>.cppm</code> 是标准规定的后缀形式，但编译器并不强依赖后缀来区分模块文件。</p><h2 id="协程"><a href="#协程" class="headerlink" title="# 协程"></a># 协程</h2><p>协程是一种比线程更高效的并发机制。看似是一种很新的概念，但实际上，协程在 C++最初版本中就存在，当时利用协程来实现一个任务库，进而支持一些常见算法的仿真。然而，由于实现比较丑陋，移植性差，在后来的 C++98 版本中，没有继续支持，直到 C++20 中才重新实现。</p><p>如果你还不了解协程，我简单介绍一下。协程就是用户态的线程，多个协程运行在同一个线程上，通过用户程序控制下做分时复用，以伪并发的状态执行。协程可以暂停和恢复运行。比如，我可以让一个协程函数暂停，然后去执行其他内容，回过头来再继续执行协程函数。操作系统不感知协程，它是一种语言级的行为。C++20 的协程是无栈协程，所以效率很高。</p><p>协程之间切换不需要内核参与，所以效率更高，但协程需要配合异步 IO 操作，在计算密集型任务中，协程没有用武之地。</p><p>C++20 的协程使用 co_await, co_yield, co_return 关键字，又是一个考虑兼容性的命名。它使用普通函数，而不是 lambda 来实现协程函数。如果一个普通函数中存在这 3 个关键字之一，它就会被编译器处理为一个协程。</p><p>这个协程提案被批评的主要原因是不利于学习、没有和现有语言特性融合、过于灵活。解决方案便是提供一套标准库来包装接口，再提供给普通用户使用。然而，由于时间原因，协程的标准库并没有被添加到 C++20 中。</p><h2 id="增强的-constexpr"><a href="#增强的-constexpr" class="headerlink" title="# 增强的 constexpr"></a># 增强的 constexpr</h2><p>之前我们在 C++14 的总结中，提到过 C++14 中的 constexpr 是对 C++11 的一个增强，当时的改进相对来说比较温和，应该理解为一种完善。在 C++20 中，constexpr 才被进一步的增强，这次更新，constexpr 中加入了一些新的修饰符、一些标准类库支持、constexpr 函数中允许使用 new&#x2F;delete、虚函数、RTTI 等特性。</p><p>C++20 进一步增强 constexpr 的目的，是继续将 C++ 的编译期计算推举到更重要的位置，从而让更多的运行时计算变成静态计算，进一步改进运行时性能。</p><p>但是，在工程中，将运行时函数修改为编译期函数的努力可能很艰难，我们应该学着评判什么是值得花精力去改善的。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="# 运算符 &lt;=&gt;"></a># 运算符 <code>&lt;=&gt;</code></h2><p>这个运算符应该怎么称呼，目前中文 C++ 社区还没有完全达成一致，英文是 Three-way comparison operator，也许应该叫三向比较运算符。它返回一个特殊的类型 <code>std::strong_ordering</code> ，有三个取值，分别是 <code>less</code> <code>equal</code> <code>greater</code> ，用于确定两个值的大小关系。</p><p>它的引入最大的意义是，允许编译器能有更多的优化空间。</p><p>另一个话题是重载 <code>&lt;=&gt;</code> 运算符，和其他运算符一样，也可以重载它，或者让编译器生成 default 版的重载函数。如果重载这个运算符，那么其他比较运算符也会自动由编译器生成。一个例外是字符串的 <code>==</code> 运算符不会自动生成，理由是性能很差，我很难给出积极的评价，这让整个语法变的不统一，不过，C++ 里这种操作也挺多的，为了性能会妥协语言的复杂性和优雅性。</p><h2 id="范围-ranges-和视图-view"><a href="#范围-ranges-和视图-view" class="headerlink" title="# 范围 ranges 和视图 view"></a># 范围 ranges 和视图 view</h2><p>千呼万唤始出来的特性，使用 ranges 终于可以在很多场合里摆脱 <code>func(vec.begin(), vec.end())</code> 这种写法了，换之 <code>func(vec)</code>，这才是现代编程语言应该有的特性。</p><p>奈何我们在 2020 年之后的 C++ 中才用到了这个特性。</p><p>C++20 的 STL 中所有容器都已经支持了 ranges。</p><p>另外，STL 中还加入了很多与 ranges 相关的算法，比如 filter、take 等，这些算法定义在 std::ranges::views 中。与此同时，引入了管道 pipe 运算，使用这种编程风格让 C++ 更像是函数式编程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::ranges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="keyword">auto</span> valid = [](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> x % <span class="number">4</span> == <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : views::<span class="built_in">iota</span>(<span class="number">1</span>) | views::<span class="built_in">transform</span>(square) | views::<span class="built_in">filter</span>(valid) | views::<span class="built_in">take</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，<code>views.iota(1)</code> 会生成从 1 开始，步进是 1 的 ranges 序列（注意不是 <code>itoa</code>），通过管道运算符传递，之后会经过 2 个我们自定义的 predicate 函数，最后使用 <code>views.take</code> 来获取前 5 个元素，并返回给 for 循环遍历。</p><p>C++ 被人吐槽很多的一个话题是，它提供的 std::string 中，没有 split 操作（实现很简单，但一直没有通过委员会，因为性能和类型统一等问题），这让过去很多项目都需要自己写 split 函数。C++20 中终于有了 split view，便可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> sv = s | ranges::views::<span class="built_in">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><p>返回的类型是 split_view，可以通过 <code>ranges::to&lt;&gt;</code> 进一步转换为自己想要的容器类型。</p><h2 id="span"><a href="#span" class="headerlink" title="# span"></a># span</h2><p>在目前的 C++ 中，通过下标访问一个数组的元素，是没办法通过编译器检查是否发生访问越界的，而这种错误经常会出现在工程代码中，动态的越界检查又很难因性能开销而被接受。一种简单的实现，就是把数组的长度绑定到数组指针中，统一引用这个复合的指针类型。曾经，有提案给到 C 标准委员会，但没有得到通过。</p><p>C++20 中，引入了 span 这个特性，从而让编译器的数组静态越界检查成为可能。因为数组长度是静态的，并且跟着 span 类型的传递到达任何需要遍历数组的地方，所以编译器便有机会在这些遍历和下标访问的地方检查越界操作。</p><p>同时，span 也扩展了数组类型的遍历，可以让它和其他复合容器一样操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(span&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，便可以检查可能的越界操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">func</span>(arr);        <span class="comment">// 合法，通过类型推导到 void func(span&lt;int&gt; arr)</span></span><br><span class="line"><span class="built_in">func</span>(&#123;arr, <span class="number">50</span>&#125;);  <span class="comment">// 合法，初始化为 span&lt;int&gt; 类型实参</span></span><br><span class="line"><span class="built_in">func</span>(&#123;arr, <span class="number">101</span>&#125;); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="# 格式化字符串"></a># 格式化字符串</h2><p>又是一个应该属于现代化的编程语言中一个常用的特性。</p><p>因为 pre-C++20 中没有原生的类型安全的格式化字符串方法，所以过去涌现出了好多第三方的库。我使用过 LLVM 实现的 llvm::formatv 和 fmt，用起来还算可以。C++20 之后，终于可以使用原生的实现了，它的参照原型是 fmt 库，所以基本可以无缝切过去。</p><p>除了类型安全这个特点外，format 和 C 的 printf 之间另一个区别是，format 可以支持用户自定义的类型输出格式，对于一些复杂且在特定领域很常用的格式化模板，就非常的方便。</p><h2 id="并发"><a href="#并发" class="headerlink" title="# 并发"></a># 并发</h2><p>C++20 中引入了一些非常有意义的并发编程的特性。比如，使用 RAII 的 thread 对象，被命名为 jthread，当 thread 对象超出作用域时，触发 join 行为，直到 thread 终止后，才完成 join 并退出主线程的当前作用域。</p><p>另外一个之前便已经提到过的，通过主线程终止子线程执行，通过在主线程中设置一个 flag，然后要求子线程去周期性地检查这个 flag，如果主线程需要终止子线程，则置位 flag。</p><h2 id="新增的一些属性"><a href="#新增的一些属性" class="headerlink" title="# 新增的一些属性"></a># 新增的一些属性</h2><p>像我之前提到的那样，在必要的时候，去尝试使用属性，可以让代码更优雅，也有助于编译器做一些分析。C++20 中增加了 <code>[[likely]]</code> 和 <code>[[unlinkely]]</code> 属性，用于指导编译器在处理分支逻辑时，更好地做优化。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1820204765">C++20 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片来自：Photo by <a href="https://unsplash.com/@oww?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Geio Tischler</a> on <a href="https://unsplash.com/photos/an-aerial-view-of-an-island-in-the-middle-of-the-ocean-_D_zFmpg8nE?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>时间的速度是可控的</title>
    <link href="https://p2tree.top/posts/7a90bc13.html"/>
    <id>https://p2tree.top/posts/7a90bc13.html</id>
    <published>2024-10-14T22:25:17.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间是最强大的力量，虽然每个人都有，但不同的人使用时间会产生完全不同的结果。</p><p>时间对每个人是公平的吗？是，也不是。从客观角度观察，每个人的时间是一样长的，但从主观上体验，时间的长度是可调的，越忽略时间，时间过得越快，越关注时间，时间过得越慢。将时间主观上拉长，可以做更多事情，忽略时间而沉迷没有价值的事情，就是在荒废这最精妙而宝贵的资源。</p><p>怎么使用时间，每个人的选择都不同，主观上时间可以调出大于之前几倍的长度，就看会不会调，以及如何利用。</p><hr><p><img src="https://img.p2tree.top/2024/10/14/Chapter.317.webp" alt="Chapter.317"></p><div class="note primary flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@aronvisuals?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Aron Visuals</a> on <a href="https://unsplash.com/photos/selective-focus-photo-of-brown-and-blue-hourglass-on-stones-BXOXnQ26B7o?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/JWy_i2PybV2m72M--DH9dQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="管理时间" scheme="https://p2tree.top/tags/%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>C++17 特性杂谈</title>
    <link href="https://p2tree.top/posts/3d315b3e.html"/>
    <id>https://p2tree.top/posts/3d315b3e.html</id>
    <published>2024-09-30T20:28:04.000Z</published>
    <updated>2024-12-15T12:21:03.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++17 相比于 C++14 来说，新增了不少新特性，然而，它并没有做到它被期望做到的发布版本，也就是没有特别重大的改变。</p><p>尽管在 C++17 之前，一些特性已经经过了深思熟虑的考虑，但最终依然出于各种原因，没有进入最终的版本中，有一些特性，方案讨论其实很早就开始并得到确定，但在后来的评定中被搁置，直到在 C++20 中才最终加入，比如概念（Concept），协程（Coroutine），这些大的特性任何一个放入 C++17 中，都可以让其变成一个大的版本发布。</p><p>因为按预期，C++ 标准发布采用一大一小的模式，C++17 作为继 C++11 之后的又一个大版本发布，所以当时有人主张将 C++17 延迟发布，以增加更多的重要特性，不过被 Bjarne Stroustrup 拒绝，拒绝理由其实也非常合理，“如果一项特性值得为之改变 C++ 标准的发布周期，那么就会有更多特性要求这么做”，C++11 已经是一个延迟的版本，并带来了很多因延迟导致的遗憾。</p><p>然而不可否认的是，C++17 依然是一个非常有价值的版本，其中有一些特性实实在在的帮助了程序员改善他们使用 C++ 的体验。</p><hr><p>本文是 C++ 特性杂谈系列文章的第三篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="构造函数模板参数推导"><a href="#构造函数模板参数推导" class="headerlink" title="# 构造函数模板参数推导"></a># 构造函数模板参数推导</h2><p>举个例子来说明这个特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_lock&lt;std::mutex&gt; lock &#123;mtx&#125;;  <span class="comment">// pre-C++17 只能这样写</span></span><br><span class="line">std::unique_lock lock &#123;mtx&#125;;  <span class="comment">// pre-C++17 会出错，C++17 支持</span></span><br></pre></td></tr></table></figure><p>例子中，std::mutex 是 std::unique_lock 的一个模板类型参数，在 C++17 中，允许通过 std::unique_lock 的构造函数推导出这个模板类型参数（因为 mtx 是 std::mutex 类型的）。</p><p>这种简化的写法让代码看起来更清爽，在一些常用的标准库类型中，非常常用，比如智能指针、锁、pair 和 tuple 等。</p><h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="# 结构化绑定"></a># 结构化绑定</h2><p>非常实用的一个特性，在其他语言中已经得到非常普及的用法，比如 python：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def options():</span><br><span class="line">  # ...</span><br><span class="line">  return arg1, arg2, arg3</span><br><span class="line"></span><br><span class="line">def func()</span><br><span class="line">  a1, a2, a3 = options()</span><br></pre></td></tr></table></figure><p>在 C++14 中，我们引入了一种略微方便的返回多个值的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;Type1, Type2, Type3&gt; func() &#123;</span><br><span class="line">  return &#123;a, b, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，当时却没有好好的处理接受 tuple 类型时的解包语法，以至于只能用这些写法来实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 第一种做法是继续用 tuple 类型接收返回值，并用 get&lt;T&gt;() 解包</span><br><span class="line">tuple&lt;Type1, Type2, Type3&gt; res = func();</span><br><span class="line">Type1 t1 = std::get&lt;0&gt;(res);</span><br><span class="line">Type2 t2 = std::get&lt;1&gt;(res);</span><br><span class="line">Type3 t3 = std::get&lt;2&gt;(res);</span><br><span class="line">// 这种写法实际上很丑，尤其是要把 0,1,2 这种字面量数字写入模板参数中，而且还带来了运行时创建后赋值开销</span><br><span class="line">// 第二种做法是使用 tie</span><br><span class="line">Type1 t1; Type2 t2; Type3 t3;</span><br><span class="line">std::tie(t1, t2, t3) = func();</span><br><span class="line">// 看起来似乎整洁了一些，带却带来了更多问题，比如引入未初始化的变量，事实上也躲不开创建后赋值开销</span><br></pre></td></tr></table></figure><p>C++17 中，终于拿出了像样的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto [t1, t2, t3] = func();</span><br></pre></td></tr></table></figure><p>干净清晰，而且没有创建后赋值的开销，类型自动推导。</p><h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="# 折叠表达式"></a># 折叠表达式</h2><p>折叠表达式是 C++17 中的一个重要特性，我认为它可以排到前三，虽然很多介绍 C++17 新特性的文章中并不愿意提及折叠表达式。</p><p>它很大程度上改变了变长参数模板的使用方式。在这之前，想要对变长参数模板做解包，代码逻辑相对复杂，只能使用递归解包或者用逗号表达式解包，无论是可读性，还是排查问题，都很困难。折叠表达式是一个非常好的设计，让变长参数的解包变的轻松。</p><p>除了单纯的解包，折叠表达式还可以直接对解包参数做运算，比如，我们想要对折叠参数做累加时：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">auto sum(Args... args) &#123;</span><br><span class="line">  return (... + args);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  std:: cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; std::endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替代-union"><a href="#替代-union" class="headerlink" title="# 替代 union"></a># 替代 union</h2><p>传统的 union 是一种可以将不同类型的值复用相同的内存空间，然后由程序员来管理当前使用 union 时的值类型。如果在这种地方犯错，就会取到奇怪的值，编译器并不会为这种错误操作做任何检查。</p><p>C++17 中引入了 variant，它是标准库的一个类型，用来取代 union 的一部分工作。它能够实现 union 的特性，同时还能允许编译器对非法的使用做检查。</p><p>我不认为这个特性在目前的时间上会产生什么重大的影响，使用 union 的人，并不是想要创建混合类型来用，而是想要极度的压缩内存，或者使用 union 来实现快速的数据分割或转换。</p><p>按 C++ 委员会的设想，variant 可以用于创建混合类型，进而可以创建动态类型容器，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using var_t = std::variant&lt;int, long, double, std::string&gt;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;var_t&gt; vec = &#123;10, 20L, 30.4, &quot;hello&quot;&#125;;</span><br></pre></td></tr></table></figure><p>目前看来用处并不大，也许将来配合模式匹配的功能，可以让 variant 大放异彩。另外，C++17 中还拿出了 std::any，任意数据类型，好吧，总之，从这里来看，C++ 向着动态类型语言迈出了一步。</p><h2 id="并发补丁"><a href="#并发补丁" class="headerlink" title="# 并发补丁"></a># 并发补丁</h2><p>C++11 中引入的并发特性其实缺少一些很常用的特性，在 C++17 中终于打了补丁：</p><ul><li>scoped_lock：可以同时获得多个锁</li><li>shared_mutex&#x2F;shared_lock：读写锁</li></ul><p>等了这么多年才补充，不是忘记疏忽了，而是在曾经的提案中没有得到通过。这些特性的迟迟到来，让 C++ 程序员已经不太习惯在并发中使用它们了。但只要你能想起来去用它们优化你的代码，就非常有益。</p><h2 id="并行算法"><a href="#并行算法" class="headerlink" title="# 并行算法"></a># 并行算法</h2><p>在 C++17 之前，我们在使用 STL 中的算法接口时，没办法让其利用好硬件提供的并行计算能力，比如通过多核来加速排序算法。这些在 C++17 中终于成为了可能。虽然 C++17 并不是最完善的一个版本（C++20 中对其做了补充），但也足够使用其改进我们的程序性能。</p><p>用法是在 STL 算法接口中，加入一个参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(par_unseq, begin(v), end(v));</span><br></pre></td></tr></table></figure><p>除了要求程序尝试并行化之外，程序也会尝试使用向量化来加速算法，也就是使用硬件的 SIMD 来优化运算，这在很早期就应该得到支持，避免程序员手写 builtin 自己组装数据了。SIMD 是硬件少有的还能在单线程上提升性能的贡献了，一定要用起来。</p><p>然而，C++17 依然不支持取消线程的操作，这实际上增加了并行算法的开销，比如并行查找一个元素，我们希望有线程查到元素时，停止其他线程，但目前还是做不到。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="# 文件系统"></a># 文件系统</h2><p>我只能说 C++ 标准委员会的工作可能真的太多了，这种实用的功能，在 C++17 才拿出来真的不应该，类似的还有网络库（它没有加入 C++17，甚至没有加入 C++20）。因为它们太常用了，以至于大家在过去都需要自己造轮子实现。</p><p>这时就体现出有一个活跃的包管理机制有多重要了，虽然有 Boost，但一方面，大家并不愿意在自己的项目中引入这个沉重的包，另一方面，也是习惯问题，毕竟 Boost 被定位为 C++ 新标准的测试库，拿到工程中用总感觉不太合适。最后，大多数项目都选择自己写一套，有需求随便改，有 bug 自己修。</p><p>话说回来，C++17 引入的这套文件系统操作还是很全面的，如果不是用其他成熟的框架（比如 LLVM 的 llvm::fs），切换到 C++17 的接口还是值得的。</p><h2 id="新增的一些属性"><a href="#新增的一些属性" class="headerlink" title="# 新增的一些属性"></a># 新增的一些属性</h2><p>C++ 中有一些属性，用来对代码中的一些内容给编译器做提示，C++17 中加入了以下的一些属性：</p><ul><li><code>[[nodiscard]]</code>：用来指示函数的返回值不应该被忽略，编译器会在没有接收返回值时报警告</li><li><code>[[maybe_unused]]</code>：用来指示某个变量，参数或类型可能不会被使用，避免编译器报告变量等未使用的警告</li><li><code>[[fallthrought]]</code>：用于在 switch case 中，如果两个分支使用相同的处理逻辑块，前一个分支想要进入后边的代码块时使用，避免编译器报告可能丢失 break 语句的警告</li></ul><p>在 C++11 和后续的版本中，还引入了其他一些属性，这些属性看似不影响功能，但实际上对代码的可读性有着很大的改善，强烈建议学会怎么使用。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/779489353">C++17 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片是巴厘岛的一个海滩，来自：Photo by <a href="https://unsplash.com/@iswanto?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Iswanto Arif</a> on <a href="https://unsplash.com/photos/aerial-photography-of-seashore-OJ74pFtrYi0?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>历史成为传说，传说成为神话</title>
    <link href="https://p2tree.top/posts/3e7e0054.html"/>
    <id>https://p2tree.top/posts/3e7e0054.html</id>
    <published>2024-09-19T22:22:20.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很喜欢一句话，来自指环王：“历史成为传说，传说成为神话”。</p><p>很多神话故事，在曾经都是一些真实的事情，因为人类的想象力和创造力，随着时间的推移，这些有代表性的事情就会被不断修改，使之更易于传播，慢慢的，九成了故事，就成了传说。</p><p>比如中国古代的很多故事和人物，后羿、女娲、黄帝、精卫，曾经都是一个个充满个性和勇气，完成过辉煌成就的人。</p><p><img src="https://img.p2tree.top/2024/09/19/Chapter.429.webp" alt="Chapter.429"></p><hr><div class="note info simple"><p>封面图片来自：Photo by <a href="https://unsplash.com/@andrewtneel?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Andrew Neel</a> on <a href="https://unsplash.com/photos/maps-lying-on-the-floor-1-29wyvvLJA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s?__biz=MzI0MDkzNDA2Ng==&mid=2247483977&idx=1&sn=7eb0aa590dee3de6af598f5cb4e5f830&chksm=e9120f94de658682feaa2e6d909fa3cc0cadb088a18700707f8ac231a332e49f1f456e685e2f&token=1320776432&lang=zh_CN#rd">目的地</a> ，欢迎关注</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="历史" scheme="https://p2tree.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>不能忘记的日子</title>
    <link href="https://p2tree.top/posts/dd4fe3d1.html"/>
    <id>https://p2tree.top/posts/dd4fe3d1.html</id>
    <published>2024-09-18T22:06:37.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为中国人，总是需要记住一些过去的日子，忘记历史，是最可怕的。我很震惊，现在已经很少有人或者有媒体在这些重要的日子里提到这些话题了，然而很多事情过去还没有一百年，一些见证者甚至还活着。</p><p>如果一个人忘记了历史，也就忘记了自己的身份，丢掉了自己活着的一个使命——<strong>把故事，讲给后人听</strong>。</p><p>今天是 9 月 18 日，一个普普通通的九·一八事变纪念日，我打算把这些有意义，值得被传承的日子再次记录一遍，贡献自己绵薄的搜索流量。</p><p>在本站点，每年的这几个日期全站会改成灰色，以示对遇难同胞的缅怀。</p><h2 id="五·一二汶川大地震遇难同胞纪念日"><a href="#五·一二汶川大地震遇难同胞纪念日" class="headerlink" title="五·一二汶川大地震遇难同胞纪念日"></a>五·一二汶川大地震遇难同胞纪念日</h2><p>汶川大地震发生在北京时间 <strong>2008 年 5 月 12 日</strong>，震中位于中国四川省汶川县，震级 8.3 级，烈度达到 11 级。</p><p>地震共造成 69227 人遇难，17923 人失踪，374643 人不同程度受伤，1993 余万人流离失所，受灾总人口达到 4625.6 万人。是中华人民共和国建国以来伤亡最惨重的一次地震，直接经济损失 8451 亿人民币。</p><p>因为地震发生在山区，很多村落就坐落在山脚缝隙中，地震发生后，山体直接塌陷，把整个村子的人都埋在地下，没有地方可躲避。也因为在山区，救援和补给很难快速到达现场，也进一步加重了灾害的后果。</p><p>2008 年，我还在读中学，对此印象并不是特别深刻，犹记得当时学校组织大家开展了很多地震相关的教育和实践活动。虽然没有亲身经历，但从网络上看了很多报道和讨论，应该是我过去这段记忆以来（应该也是很多人的记忆），最印象深刻的一次地震。</p><p>2008 年是中国最波折的一年，这一年，年初南方暴雪灾害，年中又发生了汶川大地震，也承办了奥运会，以及奶制品污染问题等。当时时任国务院总理的温家宝同志，亲身赶赴灾区参与指挥救援工作，让我对他产生了由衷的尊敬。</p><p>2009 年，国务院宣布将每年的 5 月 12 日定为防灾减灾日，暨汶川大地震灾害遇难同胞纪念日。</p><h2 id="七七事变"><a href="#七七事变" class="headerlink" title="七七事变"></a>七七事变</h2><p>七七事变，又称卢沟桥事变，是 <strong>1937 年 7 月 7 日</strong>发生在河北省宛平县卢沟桥的日本军队和中国国民革命军之间的军事冲突。它被认为是中国抗日战争（八年抗战）全面爆发的起点，中国抗日战争转为全面战争。</p><p>具体发生的细节，至少上过中学历史课，都会有印象，但过去了太久，每天繁忙的工作和日复一日的生活，让我们逐渐忘记了这些故事。那天，日本军队在卢沟桥附近军事演习，然后谎称有个士兵失踪，要求进宛平城（位于北京西南方一座卫城）搜查，被当时守城的国民革命军第二十九军拒绝。之后日本军队攻击城西卢沟桥，之后炮轰宛平城。</p><p>现在，提到卢沟桥，很多人的印象是一个很有特色的旅游景点，卢沟桥上有很多的石狮子，每个狮子都造型各异，是一座有名的石拱桥，是重点保护文物。为什么日本兵会在这么近的地方和我们发生冲突，因为当时整个东北已经被日本殖民很久了，这要从九一八事变，甚至更早开始聊。</p><p> 1901 年清政府签订了丧权辱国的 《辛丑条约》，日本开始在华北驻军。清政府倒闭后，国内陷入动乱，日本乘机扩大在东北的势力范围，扶持傀儡政权，建立伪满洲国。</p><p>七七事变后，日本军队开启对中国的全面侵略战争，中国军民团结一致，奋起反抗，最终经过八年艰苦的抗战，将日本军队彻底赶回了老家。但期间有太多的人被迫害和牺牲，他们很少留下名字，但值得我们铭记。</p><p>七七事变这一天，是中国法定纪念日，虽然过去还没有一百年，但已经很少有人记得在这一天想到，“哦，几十年前，我们的前辈还在被外敌迫害，还在为国家和人民英勇献身”。</p><h2 id="抗战胜利纪念日"><a href="#抗战胜利纪念日" class="headerlink" title="抗战胜利纪念日"></a>抗战胜利纪念日</h2><p>第二次世界大战过去离我们也就 70 年，70 年还没有一个普通人的寿命长，也就意味着那个年代出生的前辈，现在很多都还活着。</p><p><strong>1945 年 9 月 2 日</strong>，日本在停泊在东京湾的美国军舰上签署了投降书，标志着抗日战争的胜利结束，中国将每年的 9 月 3 日定为抗日战争胜利纪念日。因为日本是轴心国中最后一个投降的国家，所以这也标志着整个第二次世界大战的结束。</p><p>中国抗日战争是国际反法西斯战争的一个重要组成部分，是反法西斯战争的东方主战场，永远不能被忽视。网上一些信息总是说道抗日战争的胜利是靠着美国给日本本土投下原子弹才胜利的，这是实打实的谬论，美国加入第二次世界大战确实加速了战争的结束，但中国军民为此付出的努力和牺牲，永远都不应该被漠视和否定，如果没有中国在亚太战场上牵制日本军队，日本军队将快速占据土地和资源，并不断扩大战争。</p><p>9 月 3 日是一个不容易被记住的日子，但我们应该记住曾经的那些血与泪的日子，记住我们民族曾经遭受过的苦难，记住日本掌权者依然不愿承认历史，坦然道歉。历史可能会被篡改，可能会被教育抹掉，更可怕的是，这只需要一代人。</p><h2 id="九一八事变"><a href="#九一八事变" class="headerlink" title="九一八事变"></a>九一八事变</h2><p>九一八事变是日本军队在 <strong>1931 年 9 月 18 日</strong>，在中国东北发动的日本侵略战争，是日本帝国主义侵略中国的开始。</p><p>和很多故事一样，九一八事变也是写入中国历史教科书的重要历史事件。9 月 18 日，日本军队炸毁南满铁路部分路段，并谎称是中国军队所为，并开始炮轰沈阳，同时进攻其他几个东北城市。战争，都是需要借口的，重要的不是嘴上说的原因，重要的是日本对中国的土地和资源已经觊觎已久。</p><p>冲突发生后，当时的东北军领袖张学良听从蒋介石的命令，下令不抵抗，并撤军，让日本军队快速占领了东北，半年后，整个东北沦陷。当时，以蒋介石为首的中央国民政府正在忙着第一次国共内战，便下令对日本的入侵不抵抗，并寄希望于国际压力。蒋没有大局观，实际上那个时候就输了。</p><p>日本占领东北后，成立了伪满洲国，扶持当时的清政府残余势力，谋划通过政治隔离分裂中国。次后，东北发生了什么，成为了难以言表的悲剧，731、病毒实验、人体活体研究，日本露出了它的残忍兽性。这些让多少中国人以生命作为代价，产生的实验成果，战后被美国收走，并用于他们的生物武器研制。</p><p>客观来说，我们并不应该仇恨日本这个国家，而是仇恨日本民族中一部分极端民族主义者，如果让他们或相关势力掌权，日本这个国家就会变得危险。而且事实上，后来大多数时间，都处于这个状态。</p><p>对于整个中国来说，七七事变通常被看作是中国被侵略的开始，但对于整个东北地区和东北人民来说，九一八事变才是最初的国耻日，是真正的国耻日，是没有抵抗，被抛弃的国耻日！</p><h2 id="南京大屠杀遇难同胞悼念日"><a href="#南京大屠杀遇难同胞悼念日" class="headerlink" title="南京大屠杀遇难同胞悼念日"></a>南京大屠杀遇难同胞悼念日</h2><p>有些战争，是政体和政体之间的战争，而有些战争，是民族和民族的战争。政体之间的战争，随着政体的覆亡，也一并被历史淡忘了，但民族是跨越政体的存在，民族战争的记忆，永远不会被时间冲淡。</p><p>日本军队在侵华战争中，犯下过非常多的惨无人道的战争罪行。既然已经是战争了，为什么还要单独提罪行，因为国际法规定了战争行为不能触碰的红线，突破了红线，战争就是毫无人性的，就是突破了作为人这种动物，作为一种高智商生物的底线。</p><p>南京大屠杀是日本军队在众多迫害中国人民的事件中，最典型、影响最恶劣的一件。大屠杀<strong>从 1937 年 12 月 13 日开始，整整持续了六周</strong>，到底具体有多少人遇害，已经不可考证，但至少有 30 万无辜的平民百姓被日本兵杀害，其中几万民中国妇女被奸杀，南京城内三分之一的建筑被破坏烧毁。</p><p>那些天的南京，是人间地狱，魔鬼拿着刀枪，肆无忌惮。</p><p>日本军队在屠杀期间，组织杀人比赛；他们将婴儿抛在空中，再用刺刀串起来；他们将男女老少赶到江边，逼着他们跳河，也将他们活埋，南京码头尸体堆积如山；他们排着队轮奸妇女，当着受害女性家人的面，甚至强迫受害者乱伦；孕妇被刺刀刨腹，身上插满木棍，劈开脑袋；他们强奸几岁的女孩，甚至七旬的老人。</p><p>所有这一切，都是日本军官默许甚至鼓励的。这些人是野兽，并且他们一直还活着。</p><p>所有信息都是有据可考的，是真实发生的。战争结束后，有一些对中国幸存者和日本老兵的采访和记录，以及大屠杀发生时，国际记者在现场的拍摄照片和新闻内容，甚至也包括了日本国内媒体的报道。然而，日本直至目前为止，依然没有承认这件事情的严重性，也没有公开为之道歉，而且继续扭曲历史，妄图把这段历史从时间中抹去。</p><p>我之前去过一次南京，便抽时间去了一次南京大屠杀纪念馆。建议每一个中国人，如果第一次去南京，一定要去一次南京大屠杀纪念馆。</p><p>2014 年，中国将每年的 12 月 13 日，设立为南京大屠杀死难同胞国家公祭日。而且，在中国几千年历史中，南京大屠杀只是比较恶劣的一次大屠杀，它只是一个象征，象征着只有国家强大了，才能保护人民，只有人民团结一致，才能抵抗外敌。</p><hr><div class="note info simple"><p>封面图片为侵华日军南京大屠杀遇难同胞纪念馆入口，来自：作者 x li - <a href="https://commons.wikimedia.org/w/index.php?curid=14620108">入口</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="历史" scheme="https://p2tree.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++14 特性杂谈</title>
    <link href="https://p2tree.top/posts/41507ee5.html"/>
    <id>https://p2tree.top/posts/41507ee5.html</id>
    <published>2024-09-11T22:23:27.000Z</published>
    <updated>2024-12-15T12:21:03.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 标准从 C++11 开始，采用一个大版本后接一个小版本的更新思路，所以 C++14 是一个小版本更新的标准，它的主要目的是完善 C++11 标准。</p><p>一些 C++11 标准发布时还不稳定的特性，在 C++14 中被加入标准中。另外，这么做也是给编译器实现者们提供一个缓冲，在 C++11 标准实现之后的晚一些时间，提出一些小型的完善性的提案。</p><p>为了能完整的使用现代 C++ 特性，通常不会开启 C++11，而是会选择开启 C++14。</p><hr><p>本文是 C++ 特性杂谈系列文章的第二篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字分隔符是 C++14 中的一个小特性，但却引起了很大的讨论。讨论的根源在于，使用什么分隔符可以最大程度上既能有效表示分隔符的意义，同时还能兼容旧代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> num = <span class="number">1&#x27;234&#x27;456</span>s;  <span class="comment">// 1234456 秒</span></span><br></pre></td></tr></table></figure><p>最终选定的分隔符是 ‘ ，这在我看来并不是一个特别好的决定，’ 用来包裹字符，虽然从语义上讲，数字分隔符不可能出现在一串数字的最前边，所以不会与字符产生冲突，但依然容易让人有困扰。</p><p>只能说，感谢静态分析工具和语法高亮吧。</p><hr><h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><p>坦白说，我没有在哪里看到过这个特性的用途。它用于定义一个带有模板参数的变量（而不是函数），对定义的表达式做泛化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.14159</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">circular_area</span><span class="params">(T r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pi&lt;T&gt; * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用途可能比较少，不过在 C++20 中定义 concept 时开始变地常用。</p><hr><h2 id="函数返回值类型推导"><a href="#函数返回值类型推导" class="headerlink" title="函数返回值类型推导"></a>函数返回值类型推导</h2><p>C++11 中的 lambda 函数，可以不写返回值类型。编译器可以通过 return 位置的类型来推导返回值类型。这种技术显然也可以应用在普通函数中，所以 C++14 中增加了这个特性，函数的返回类型为 auto。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">size</span><span class="params">(<span class="type">const</span> T&amp; a)</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果多个不同的 return 位置推导出了不同的类型，编译时会报错。</p><p>但这种推导返回值的函数会产生一个限制：函数签名是不稳定的，它由它的定义所决定。所以在调用这种函数时，函数定义必须已经可见（不能只给声明）。</p><hr><h2 id="泛型-lambda-表达式"><a href="#泛型-lambda-表达式" class="headerlink" title="泛型 lambda 表达式"></a>泛型 lambda 表达式</h2><p>泛型的 lambda 表达式在 C++11 提出时就已经经过了广泛的讨论，但最后认为还没有准备好，故没有出现在 C++11 标准中。因为 lambda 表达式本质上也是一种对象类型，所以支持泛型是显然合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_size = [](<span class="keyword">auto</span> &amp;m) &#123; <span class="keyword">return</span> m.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>使用 auto 来作为标记，指出类型是通过推导得出的。</p><hr><h2 id="增强的-constexpr"><a href="#增强的-constexpr" class="headerlink" title="增强的 constexpr"></a>增强的 constexpr</h2><p>constexpr 特性是 C++ 编译期编程的基础。</p><p>C++11 中的 constexpr 函数是要求比较严格的，只允许对纯函数的表达式进行求值，后来有一些人对此提出新的要求。在 C++14 中，可以允许 constexpr 函数中包含局部变量和循环，前提是它们不会对函数外部产生副作用。这个改进让编写 constexpr 函数更加自由灵活。</p><p>这些局部变量仅对编译器可见，编译器在编译时就会对函数求值。</p><p>在后续的 C++ 标准中，constexpr 的用法被进一步放宽，这得益于编译器实现的完善。尽可能将更多的计算从运行期移动到编译期是 C++ 设计的其中一个倾向，也即在最大程度上保证 C++ 编译的程序在运行时的性能。</p><hr><h2 id="make-unique"><a href="#make-unique" class="headerlink" title="make_unique"></a>make_unique</h2><p>std::make_shared 是一个 C++11 标准接口，它可以使得在创建一个 shared_ptr 对象时，不需要显式的暴露出来 new 关键字。但可惜的是，make_unique 没有出现在 C++11 中，而在 C++14 中才被加入标准库。在 C++11 中，只能自己编写一个 make_unique。</p><p>对我自己来说，这是 C++14 中最常用的一个特性。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/719519481">C++14 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片是一只海鸥，来自：Photo by <a href="https://unsplash.com/@carl_newton?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Carl Newton</a> on <a href="https://unsplash.com/photos/white-and-black-bird-on-brown-grass-during-daytime-AWJpalN_0yE?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>我们存在，是所有我们与爱我们的情感的总和</title>
    <link href="https://p2tree.top/posts/c82ee02e.html"/>
    <id>https://p2tree.top/posts/c82ee02e.html</id>
    <published>2024-09-01T19:24:53.000Z</published>
    <updated>2024-09-01T19:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感官经验的观察与描述具有独特价值，只要拥有同一段记忆，便为同一个人。这也恰如其分地解释了为何现在的自己与过去的自己是一个连续的整体。</p><p>进一步深入理解，我们的存在乃是所有关于自身记忆的总和。这记忆不仅存于自己的大脑，也在所有认识我们的人的记忆之中。由此可见，情感成为另一个度量人存在的重要维度。</p><p>这与看完《寻梦环游记》后的感悟不谋而合。一个人去世并不意味着其不复存在，只有当现世中无人记得他时，才是这个人真正的消失。换言之，人的存在是他自身与所有关于他的记忆的总和。</p><p>反观自身，我们亦存在于那些爱我们的人的记忆里。所以，即便我们去世，也并未消失，而依旧存在。我们的存在，是所有我们和爱我们的情感的总和。</p><hr><p><img src="https://webp.p2tree.top/2024/09/01/WechatIMG157.jpeg" alt="Chapter.72"></p><hr><div class="note default flat"><p>封面图片是北京奥林匹克塔，来自：<a href="https://unsplash.com/photos/white-and-black-spiral-light-EnUiazG5ROw">White and black spiral light photo – Free Wallpapers Image on Unsplash</a></p></div><div class="note primary flat"><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s/33_DDzgybNwRii89ikYq8w">目的地</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="哲学" scheme="https://p2tree.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++11 特性杂谈</title>
    <link href="https://p2tree.top/posts/e40506ec.html"/>
    <id>https://p2tree.top/posts/e40506ec.html</id>
    <published>2024-08-31T22:04:59.000Z</published>
    <updated>2024-12-15T12:21:03.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++11 就像是一个新的语言，它弥补了之前 C++ 中的很多问题，引入的大量新特性，使 C++ 变成了一个非常易用的计算机语言，这让很多新程序员开始学习 C++，也让 C++ 重新焕发生机。</p><p>可以说，C++11 代表着现代 C++，使用 C++11 标准编写 C++ 代码已经成为一个最基本的项目管理要求，下一个这样的分界线应该是 C++20 了。</p><p>然而，C++11 的推出实际上困难重重，它最初提案时的版本是 C++0x，因为就没打算在 2010 年之后推出。很多 C++11 的新特性，在 2000 年之前就已经被提出了，一些特性已经在 Boost 库中被实现。C++ 语言作为一种非集权的计算机语言，在推出新标准时，需要考虑非常多的问题，又因为有各种领域、行业、公司的人一起参与拟定和决策，让 C++ 标准的最终成型变得更为艰难。</p><p>另外，C++ 的教学和很多行业的接受度并没有那么积极，导致 C++11 在推出十几年后，很多软件和库依然没有得到全面的更新和替代。对于标准委员会、编译器厂商来说已经是过去的东西，但对大多数普通 C++ 用户来说，却是未来。结果就是，这么多年后，C++11 的一些内容依然没有得到普遍接受。我在面试时问到的一些面试者，他们的项目依然采用 C with class 的 C++ 编程风格。</p><p>我学习了 C++之父 Bjarne Stroustrup 编写的 HOPL4（History of Programming Languages），整理了以下一些笔记。<strong>每隔一段时间，就应该把这些东西拿出来看看，和自己的业务代码对比一下，看看哪些地方值得改进，不要让自己和团队永远地困惑下去。</strong></p><hr><p>本文是 C++ 特性杂谈系列文章的第一篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><p>如果你有充足的时间和英文阅读能力，推荐直接读：<a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></p><p>如果你有充足的时间，但不想阅读原文，这是一些大佬翻译的中文版：<a href="https://github.com/Cpp-Club/Cxx_HOPL4_zh/tree/main">https://github.com/Cpp-Club/Cxx_HOPL4_zh&#x2F;tree&#x2F;main</a></p><p>如果你没有充足的时间，请看本文和后续我发布的几篇文章。我的笔记中不会详细介绍每个特性具体的内容，所以如果你看不懂其中部分内容，可能需要自行查找其他资料补充。</p><hr><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>C++11 中最重要的一块新功能就是引入了并发编程的接口，在这之前，使用 C++ 编写并发程序只能依赖操作系统提供的库工具完成，从而影响了软件的可移植性。2006 年左右是一个转折点，在那之后，CPU 处理器厂商意识到单核处理器随着频率提高，性能到达了天花板，而需要转向多核处理器设计来实现性能提升。利用好这种新的硬件结构非常重要，C++ 标准便及时地更新了这块的能力。</p><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>对于并发编程中，内存模型的重要性有时会被低估，由于我们在学习并发编程时，内存模型总是很靠后的一节内容。然而在 C++ 标准委员会订立这块特性时，内存模型却需要优先考虑。</p><p>内存模型是描述计算机系统内存布局和访问行为的一系列约定。在并发编程中，内存模型用于规定不同线程或处理器如何访问共享内存中的数据，从而在并发程序中能够有可遵循的读写操作可见性和顺序性，确保并发访问时程序的正确性。</p><p>C++ 的内存模型基本采用了先行发生关系（happens-before），既支持宽松的内存模型，也支持顺序一致模型。另外，C++ 也支持了原子类型和无锁编程。</p><p>C++ 订立内存模型要比其他高级语言复杂的多，因为 C++ 需要考虑多个不同硬件平台的应用厂商的需求，比如以 Intel 为代表的 x86 体系结构下的内存同步模型，以及以 IBM 为代表的 PowerPC 体系结构模型。因为这些难以忽视的差异，导致 C++ 的内存模型要复杂的多。</p><p>涉及到的内容，本文不展开，类似的介绍可以在其他书籍和网络资料中找到。主要的几个关键点有：</p><ul><li><strong>序列一致性</strong>：C++ 不要求严格的序列一致性，而是提供了松散的一致性保证，可以确保在一定程度上的有序执行。</li><li><strong>原子操作</strong>：当使用原子类型操作时，原子操作在并发层面上是不可细分的，避免了线程之间的竞争。</li><li><strong>内存序</strong>：不同的内存序可以配置序列执行顺序的不同约束。</li><li><strong>数据竞争</strong>：明确了数据竞争的条件和后果。</li></ul><h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><p>是并发编程中使用并发相对较差的一种并发模型，但使用简单，不容易出错。</p><p>相关的内容包括：</p><ul><li><strong>thread</strong>：系统级的线程对象，支持 join() 和 detach()</li><li><strong>mutex</strong>：系统级的互斥锁，支持 lock()、unlock() 和 RAII 实现的加锁解锁（unique_lock 和 lock_guard）</li><li><strong>condition_variable</strong>：系统级的条件变量</li><li><strong>thread_local</strong>：线程本地存储</li></ul><p>欠缺的一块内容是线程取消操作，即通过一个线程向正在运行的其他线程发送停止命令。在订立这块特性时，C 委员会的一些代表反对支持这块特性。C++20 中提供了一种机制来实现这个目的。</p><h3 id="Future-和-Promise"><a href="#Future-和-Promise" class="headerlink" title="Future 和 Promise"></a>Future 和 Promise</h3><p>我一直不知道这个特性应该怎么翻译。一种更现代的、高层次的并发编程模型。</p><p>相关的内容包括：</p><ul><li><strong>future</strong>：通过它可以从一个共享的缓冲区中获取 <code>.get()</code> 一个值，可能要等待 promise 将值提前放入缓冲区</li><li><strong>promise</strong>：通过它可以将一个值放入 <code>.put()</code> 到一个共享的缓冲区，并唤醒等待 future 的线程</li><li><strong>packaged_task</strong>：一个类，将一个函数和一个异步线程绑定，并由 future 来获取返回的结果</li><li><strong>async</strong>：一个函数，用来启动任务并在一个线程上执行，将任务包装在 packaged_task 中，并利用 future 和 promise 来实现数据传输</li></ul><hr><h2 id="简化使用"><a href="#简化使用" class="headerlink" title="简化使用"></a>简化使用</h2><p>C++ 容易被人批评的一个缺点是，它写起来非常啰嗦，有不少冗余重复的键入。在 C++11 中，引入了一些特性来改善这种问题。</p><p>被程序员们快速接受的新特性是 auto、范围 for 循环和 lambda 表达式。</p><p>这些改进的新功能并没有改变之前的任何问题，或者是引入新的有用的功能，仅仅只是让代码写起来更简洁、清晰，但这也足够有意义。</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>很早之前，auto 被用于指明某个变量位于栈上，但这个属性是默认的，可以不指定。类似的，要求变量存在寄存器中的关键字 register 一直存在，当然用途也并不多。据 Bjarne Stroustrup 说，他在 1982 年就支持了这个特性，但因为和 C 的不兼容性问题，特性被搁置，最终在 C++11 中才再次拿了出来。</p><p>C++11 中的 <strong>auto</strong> 只能用于声明变量类型时使用，由编译器来根据给变量赋值的表达式的类型，来推导变量的类型。这大大简化了很多代码的录入，尤其是一些类型非常复杂，甚至无法写出类型（如 lambda 对象）的变量。</p><blockquote><p>NOTE：auto 用于变量声明时，并不是泛型，而是由编译器来推导的静态类型。</p></blockquote><p>C++ 使用指南中，建议使用 auto 来避免类型名称的多余重复。但在一些场合下，使用 auto 也会带来歧义，比如表达式返回类型不明确时，使用 auto 会让代码不易读：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto ret = function(x, 3);  // 不易读，看不出来 ret 是什么类型</span><br></pre></td></tr></table></figure><p>然而，C++11 中的 auto 依然做的很保守，它只能用于变量的自动推导。C++17 中支持了对函数返回值的 auto 类型和对 lambda 表达式的参数和返回值的 auto 类型；C++20 中才支持了函数参数的 auto 类型。</p><h3 id="范围-for-循环"><a href="#范围-for-循环" class="headerlink" title="范围 for 循环"></a>范围 for 循环</h3><p>大多数现代编程语言中都提供了 for each 的语法，C++ 也不会例外。</p><p>这种语法简化了循环，在不需要关心循环细节时，使用它可以避免一些常见的错误，比如边界判断、错误的索引变量等。</p><h3 id="移动语义和右值引用"><a href="#移动语义和右值引用" class="headerlink" title="移动语义和右值引用"></a>移动语义和右值引用</h3><p>在这个特性出现之前，从函数返回大数据时，为了避免复制数据带来的性能开销，只能通过在自由存储区中分配内存，并通过指针传递数据的引用，无论是从参数传入返回指针，还是将指针从返回值返回。这种写法确实能用，但却很难在运算符重载中应用在自定义类型，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix* <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp;, <span class="type">const</span> Matrix&amp;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">(<span class="type">const</span> Matrix&amp; m1, <span class="type">const</span> Matrtix&amp; m2, <span class="type">const</span> Matrix&amp; m3)</span> </span>&#123;</span><br><span class="line">  Matrix* mret = m1 + m2;  <span class="comment">// 这个可以用 (1)</span></span><br><span class="line">  <span class="comment">// Matrix* mret = m1 + m2 + m3;  // 这个做不了 (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动语义通过移动构造函数来实现，而移动构造函数为了要和复制构造函数区分，采用右值引用作为参数。右值引用作为对右值的引用，也刚好符合移动后，之前位置的所有权便不存在的这一语义。从移动构造函数内部视角来看，形参是右值引用，表示当前构造函数拥有该资源的唯一所有权，也符合 “移动到该函数内” 的定义。</p><blockquote><p>NOTE：符号 <code>&amp;&amp;</code> 用在模板参数时，被叫做引用转发（或完美转发），配合 std::forward 来实现保持传参过程中左值引用或右值引用的类型。</p></blockquote><p>现在，STL 中的所有容器类都实现了移动语义，可以使得大型数据能够高效的移动。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11 中提供了 <strong>shared_ptr</strong> 和 <strong>unique_ptr</strong>，它们利用了 RAII 机制，实现了不需要手动 delete 资源的资源管理，也就是将资源 delete 和对象生命周期绑定，在对象析构时同时 delete 相关的资源。</p><p>shared_ptr 比 unique_ptr 出现更早一些，它利用引用计数来标记当前资源有多少个指针在引用，当计数为 0 时才 delete 资源。然而，在多线程程序中，这会导致同步带来的性能问题，所以并不建议滥用 shared_ptr。</p><p>也因此，标准中又提供了 unique_ptr，unique_ptr 是和裸指针一样高效的指针，没有额外开销，它有资源的独占所有权，也就是只实现了移动构造函数和移动赋值运算符，而删掉了拷贝构造函数和拷贝赋值运算符。它取代了之前的 auto_ptr。</p><p>虽然智能指针足够智能，但过分随意的使用依然会带来很严重的问题。前边提到的 shared_ptr 在多线程程序中的性能问题是其中之一，而没有理解 unique_ptr 的所有权性质便乱用，比如 unique_ptr &amp; 这种，无视了智能指针带来的优势。另外，项目中混合使用智能指针和裸指针的操作，也可能引入难以发现的 bug。</p><p>仅在必要时使用智能指针，大多数时候，使用局部变量和更好的类结构和移动语义来实现数据流动。</p><h3 id="统一初始化器"><a href="#统一初始化器" class="headerlink" title="统一初始化器"></a>统一初始化器</h3><p>在该特性之前，不同类型的初始化有不同的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x;      // 基本类型可以有默认初始化，这里给 x 初始化了 0</span><br><span class="line">int x = 7;  // 使用 = 来对值进行初始化</span><br><span class="line">int a[] = &#123; 1, 2 &#125;;  // 使用 &#123;&#125; 来对数组进行初始化，注意只能用于数组</span><br><span class="line">string s;            // 调用了默认构造函数做初始化</span><br><span class="line">vector&lt;int&gt; v(10);   // 使用 vector 的带有 int 参数的构造函数初始化</span><br><span class="line">// vector&lt;int&gt; v = &#123; 1, 2 &#125;;  // 非法操作</span><br></pre></td></tr></table></figure><p>不同的初始化方式带来了很多不确定性，尤其是另一个问题，既同样是列表类型，但自定义容器类型就不能使用 <code>&#123;&#125;</code> 来完成初始化。</p><p>这些需求驱动了 C++ 标准委员会为其拟定一套统一的初始化方式。</p><p>在新的初始化方式下，采用初始化器来初始化，同时允许对其中一些语法做省略：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = &#123;0&#125;;               // 也可写作 int x &#123;0&#125;;</span><br><span class="line">int a[] = &#123; 1, 2 &#125;;        // 也可写作 int a[] &#123;1, 2&#125;;</span><br><span class="line">vector&lt;int&gt; v = &#123; 1, 2 &#125;;  // 也可写作 vector&lt;int&gt; v &#123;1, 2&#125;;</span><br></pre></td></tr></table></figure><p>然而，这种语法的引入事实上为本就混乱的初始化语法带来了更多的混乱，很多人依然习惯于使用过去的写法，而另一些人使用了初始化器的写法。虽然 C++ 标准中保证了编译时不会带来歧义，但从阅读上来说，还是带来了新的负担，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1(10);          // 初始化 10 个值为 0 的元素</span><br><span class="line">vector&lt;int&gt; v2&#123;10, 20, 30&#125;;  // 初始化 3 个值为 10 20 30 的元素</span><br><span class="line">vector&lt;int&gt; v3&#123;10&#125;;          // 应该怎么理解？是 10 个值为 0 的元素，还是 1 个值为 10 的元素</span><br></pre></td></tr></table></figure><p>第三行就是容易引起歧义的用法。虽然 C++ 标准规定了这种写法属于 “1 个值为 10 的元素”，但对于语法表示上来说，确实不是那么清晰。然而，为了兼容旧代码，过去的写法不可能删除，这种问题大概率会一直保持下去。<strong>唯一能做的就是约束软件项目的编程规范（拟定项目的 C++ 标准子集），再通过人工或工具做 code review 来避免项目代码中出现类似的问题。</strong></p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>不需要过多解释的一个特性。它用于避免之前空指针和 0 值的混用，尤其是在类型推导时，一个值为 0 的空指针，既可以推导为指针类型，也可以推导为 int 类型。</p><p>之所以没有使用更简短的名称，原因是在拟定这个特性时，之前的旧代码中已经广泛的使用了如 null、nil 等名字。C++ 标准中引入一个关键词时需要考虑到向前兼容，不能破坏之前的代码，所以新的关键词可能都不会太简单。</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>使用 <strong>constexpr</strong> 修饰的函数，是在编译期就可以运算和求值的函数，将运行时行为提前到编译期，可以提高运行时效率。除此之外，还有一些场景用到 constexpr：</p><ul><li>编译期检查的类型安全计算</li><li>在嵌入式系统编程中减少代码内存占用</li><li>支持元编程</li></ul><p>虽然应用代码中能用到 constexpr 的地方并不多，但 STL 中却有非常多的用途。比如对一些数学计算的查表和固定换算。</p><p>C++11 中引入的 constexpr 特性还只是一部分，在之后的 C++20 中，这个特性才得到完善，并逐渐成为元编程的关键支持特性。</p><h3 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h3><p>对字面量做扩展，可以理解为自定义对字面量做处理的一种语法糖。</p><p>这个特性提供了程序员可以自定义任何符合规范的字面量后缀形式，而不仅限于语言提供的那些。这给一些特殊的场景提供了很大的便利性，比如对数字添加单位：<code>10m</code> 表示 10 米，<code>1.2i</code> 表示虚数 1.2。</p><p>定义方法是一个特殊的字面量运算符，比如虚数字面量的定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constexpr Imaginary operator&quot;&quot;i(long double x) &#123; return Imaginary(x); &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>operator””</code> 为字面量自定义函数，后边接一个标识符，表示后缀内容。</p><p>这个特性也比较小众，一般用不到。</p><p>值得提出的是，在 C++14 中，内建类型的一些字面量后缀才加入到标准库中，比如 <code>100ul</code> 表示 100 且类型是 unsigned long，<code>”10”s</code> 表示 <code>“10”</code> 且类型是 std::string。</p><h3 id="原始字符串字面量"><a href="#原始字符串字面量" class="headerlink" title="原始字符串字面量"></a>原始字符串字面量</h3><p>另外一个小细节。C++11 支持了 regex 特性，正则模式中，大量使用了 <code>\</code> 和 <code>&quot;</code> 这些符号，而 C++ 字符串中，这两个符号却需要转义才能表示其自身。</p><p>为了让正则模式字符串看起来更清晰，这个特性提供了原始字符串标记，使用 <code>R&quot; &quot;</code> 这种模式来标记其中的字符串字面量是原始字符串，不需要转义任何特殊字符。</p><p>这是一个小细节，但在特定的场景下非常实用。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是一些通过 <code>[[ ]]</code> 包含着的特定名词，用来向编译器传递一些信息。C++11 标准中支持的属性有：</p><ul><li><code>[[noreturn]]</code>：表示函数不会返回，比如一些终止程序的函数、和固定抛出异常的函数，编译器可以据此属性做优化，比如不用额外生成针对这种函数调用的上下文恢复的代码。</li><li><code>[[carries_dependency]]</code> ：用于指示一个操作具有依赖关系，通常用在多线程编程中，编译器可以参考这个属性，保证多线程代码的正确优化</li></ul><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>C++11 不是最早引入泛型编程的版本，早在 C++98 之前，泛型编程已经得到了广泛的使用，然而，当时的语法比较拙劣，导致非常复杂的编码实现和出错信息显示，即使这样，很多程序员依然忍受着痛苦而继续使用泛型编程。人们对泛型编程的需求非常大，C++11 中提出了一些特性来改善泛型编程的使用体验。</p><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>lambda 表达式是 C++11 中提出的新概念，一经提出，便得到了广泛认可和使用。简单来说，lambda 表达式解决了这样的一些需求：</p><ul><li>在需要完整代码块的位置定义代码块（而不是在函数外边或类里边定义成员函数）</li><li>从代码块里访问代码的上下文（也就是闭包）</li><li>代码块是完整独立的封装，可以以统一方式引用</li></ul><p>lambda 表达式的语法并不复杂，但需要简单熟悉，捕获列表中的按引用捕获和按值捕获，以及能够指定捕获某个确定的上下文变量的能力，让 lambda 表达式非常灵活。</p><p>通常，编译器实现 lambda 表达式的方式是将其构建为一个函数对象，并传递这个函数对象。捕获的变量成为函数对象的数据成员，函数体成为函数对象的调用运算符函数（<code>operator()</code>）。<strong>这很可能成为一个有趣的面试题。</strong></p><p>在 C++14 中，进一步对 lambda 表达式支持了参数泛型和移动捕获，从而让它在泛型编程中更易于使用。</p><h3 id="变长模板参数"><a href="#变长模板参数" class="headerlink" title="变长模板参数"></a>变长模板参数</h3><p>这是一个必要的功能，它解决了两个问题：</p><ul><li>实例化包含任意长度的模板类或模板函数</li><li>不能以类型安全的方式传递变长参数</li></ul><p>其基本语法是 <code>...</code> ，通过在类型或模板类型后边添加 <code>...</code> 来表示这个类型或模板类型参数是变长参数。</p><p>在变长参数展开时，传统的做法是通过递归调用当前函数，每次递归中，处理变长参数的第一个参数。然后提供一个非变长参数的特化函数（变长参数的位置只是单独的参数类型）作为递归的出口。</p><p>这种写法实际上会带来一些问题，比如递归本身带来的调用栈空间开销，以及可能大量的模板实例化开销。</p><p>在C++17 中，增加了折叠表达式的特性，允许用简洁方便的语法展开变长模板参数。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>C 的别名机制使用 typedef 来实现，C++ 也支持这种语法。但众所周知，这种语法在某些表现下非常难以阅读，所以 C++11 中提出了 using 来代替 typedef。</p><p>它们的主要区别就是，using 把别名的名称放到了前边，用 <code>=</code> 来连接别名名称和要定义的类型模式。</p><p>在用于给复杂的模板类和模板函数定义起别名中，非常有用。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>tuple 是 C++11 引入的新功能，在这之前，pair 已经出现在标准中。C++ 委员会希望能引入一种可以不限制其中元素数量的打包对象。</p><p>最终，元组 tuple 以库的形式加入到 C++11，而不是以语言特性的形式。C++ 标准在添加新特性时，总是倾向于优先以库的形式增加特性，这样有一些优势：</p><ul><li>在测试时，测试库比测试语言特性更方便</li><li>库可以早于编译器支持新的语言特性之前便投入使用</li></ul><p>然而在我看来，tuple 和 pair 的设计并不是非常优雅，它们本身是未命名的对象集合，所以在传递后，其物理意义可能会被丢弃或被误解，从而降低代码的可读性。建议仅在明显具有打包形式的物理值中使用这种功能，而不是随意使用。比如描述颜色，RGB 三个值可以用 tuple 包装，但将普通参数和返回状态包装在一起就不是好的设计。</p><hr><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>C++ 是静态类型语言，虽然支持泛型，但泛型不等于动态类型。静态类型有一些明显的好处：</p><ul><li>程序表现更清晰，无论是方便程序员理解代码还是梳理编程逻辑</li><li>编译器更容易检查出隐藏的程序问题</li><li>编译器可以生成更优化的程序</li></ul><p>将任何基础类型（int、string 等）都使用具有物理意义的自定义类型（PersonID、PersonName 等）取代，是一种好的编程实践。无论是直接阅读，还是在自定义类型中加入更多的类型合法性检查，都可以进一步加强代码的质量。</p><p>C++11 代码中应当使用以下具有类型安全的指导原则：</p><ul><li>不要再使用 Linux POSIX 和 Windows 提供的并发接口，既不安全，也缺少移植性。使用新的 thread 系列工具</li><li>如无必要（比如必须要获取下标），使用范围 for 循环遍历容器和数组类型</li><li>尽量少的使用指针，同时也不要混合使用指针和引用。使用移动语义时也需要考虑好所有权问题</li><li>放心的使用智能指针，自己实现资源管理类时也要有意识使用 RAII，不要混合使用普通指针和智能指针</li><li>为了避免混乱的初始化语法，使用 C++11 提供的统一初始化语法，同时使用 auto 类型</li><li>使用 constexpr 尽可能地代替宏用法，宏容易出错，出错后报错信息可能很复杂</li><li>用户自定义字面量可以改善字面值的表现力，也加强了类型安全</li><li>用 enum class 代替 enum，收益很大</li><li>在使用内置数组时，考虑用 std::array 替代</li></ul><p><strong>C++ 没有办法删除之前不合理的遗留设计，因为需要考虑兼容老代码。C++ 语言的这种顾虑，就像是 Windows 一样，把困难的东西留给自己，把便捷留给用户，才成就了 C++ 语言历久弥新的特质。</strong></p><hr><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>C++11 的标准库中增加了大量的新特性和接口，同时也提供了很多有利于开发标准库的实践方法。</p><h3 id="复杂的实现"><a href="#复杂的实现" class="headerlink" title="复杂的实现"></a>复杂的实现</h3><p>C++ 标准库的设计中，存在着很多复杂的实现，很多实现就像是 “黑魔法”，在可读性上简直就是灾难，但它们确实好用，在 C++20 之前，很多奇怪的用法在标准库的实现中不断出现和进化。</p><p>认为 C++ 比较复杂和难以学习的一个原因，便是标准库的实现，Bjarne Stroustrup 大佬直白的指出，<strong>C++ 的那些所谓“专家”，一股脑地涌入标准库中，去研究这些复杂的语言实现，并且是是而非的通过网络和演讲向其他人解释这些内容，以换取成就感和名望。</strong>在其他计算机语言中，这种复杂性通常被隐藏在编译器内部或者库源码中而不开放给普通用户学习。</p><p>比如有代表性的技巧是 SFINAE（Substitution Failure Is Not An Error），它在标准库代码中被大量使用，但单独拿出来理解时比较困难，它以奇怪的缩写而被广泛传播。这里不展开，有很多网络资料中介绍这个概念。</p><h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>另一个有意义的支持是元编程。C++11 之前，人们已经使用基础的模板和宏等语法特性实现了复杂的元编程，但这些实现非常糟糕，无论是编译时间，对计算机资源的浪费，还是可读性和出错后调试的难度。</p><p>C++11 中提供的大量新特性改善了 C++ 元编程的难度。比如 lambda 表达式、模板别名、constexpr、type trait 以及 enable_if 等内建函数。C++20 才引入的 concept，早在 C++11 中就被提案，但却遗憾的没有被采纳。</p><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>它用来指明一个函数不会抛出异常，编译器可以静态的检查代码中是否有错误的异常设计。</p><p>这在用户代码中用处并不大，但在库实现中用处很大。库的实现时，需要考虑到一些操作是否会抛出异常，从而以更无感的方式来处理异常。如果操作明确不会抛出异常，那么便不需要做任何可能的异常假设，这使得那些担心异常带来性能问题的人放心。</p><p>然而，不抛出异常不代表不需要处理程序错误，没有异常时，很可能需要通过添加其他逻辑代码来处理如返回值、errno 等状态，所以也可能带来工程的复杂化。</p><p>在是否使用 noexcept 的回答之前，需要先搞清楚，异常仅代表着一种处理程序故障的方式，尤其是一些非本地错误。<strong>虽然异常发生时并不是零开销的，但这里的 “零开销设计”，应该被理解为，当其他同样严重的错误出现时，和使用非异常的方式处理相比，没有额外的开销。</strong></p><h3 id="标准库组件"><a href="#标准库组件" class="headerlink" title="标准库组件"></a>标准库组件</h3><p>一些典型的新组件（不完整列表）：</p><ul><li><strong>unique_ptr</strong> 和 <strong>shared_ptr</strong>：依赖 RAII 实现的智能指针类型</li><li><strong>thread</strong>、<strong>mutex</strong>、<strong>condition_variable</strong>：支持多线程编程</li><li><strong>future</strong>、<strong>promise</strong>、<strong>packaged_task</strong>：支持更高级和现代的并发编程</li><li><strong>tuple</strong>：匿名复合类型</li><li><strong>regex</strong>：支持正则表达式</li><li><strong>chrono</strong>：支持和时间有关的操作</li><li><strong>random</strong>：支持不同类型随机数的产生</li><li><strong>unordered_map</strong> 和 <strong>unordered_set</strong>：无序的 map 和 set 容器，使用哈希表实现</li><li><strong>array</strong> 和 <strong>forward_list</strong>：更实用的列表类型</li><li><strong>类型特征</strong>，比如 is_copy_assignable 等，常用于元编程</li></ul><p>很多标准库组件来自于 Boost，一个非常重要的 C++ 三方库，它被用来预先验证 C++ 的功能，并在成熟后被引入 C++ 标准库。Boost 的优势是其非常活跃，有很多不同领域的 C++ 的大佬参与其中，促成了它的高质量和广泛性。</p><p>unordered_map 和 unordered_set 之所以没有被命名为更显然的 hash_map 和 hash_set，也是因为过去已经有一些项目中使用了这些名字（C++ 引入新名称变得越来越困难了），当然现在的名字也并不差，指明了这些容器的特性，不过，只是名字有点太长了。</p><p>chrono 是一个设计非常好且易用的库，用途很广泛。</p><p>除此之外，还有新的一些算法库被引入。</p><hr><p>文章已经很长了，本来没打算写这么多，阅读起来会挺累，为此也删了一些内容。奈何 C++11 中有趣的特性太多了，围绕着他们产生的故事也很多，值得说道说道。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/717474726">C++11 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片是加拿大的 Kinney Lake，来自：<a href="https://unsplash.com/photos/a-lake-surrounded-by-mountains-with-a-sky-filled-with-clouds-_eW1bHhufBg">A lake surrounded by mountains with a sky filled with clouds photo – Free Kinney lake Image on Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>个人说明书 v2.2.4</title>
    <link href="https://p2tree.top/posts/b32e3378.html"/>
    <id>https://p2tree.top/posts/b32e3378.html</id>
    <published>2024-08-23T19:59:27.000Z</published>
    <updated>2024-12-15T12:21:03.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是个人说明书"><a href="#什么是个人说明书" class="headerlink" title="什么是个人说明书"></a>什么是个人说明书</h2><p>很喜欢《纳瓦尔宝典》中的一个观点，“把自己当做产品，努力推销出去”。无论是面对雇主还是朋友，当我将自己视作一件产品时，首先想到的便是如何以最快、最全面的方式展示自己，就像一份精心编写的产品说明书，突出最重要、最有意思的部分，也就是你最感兴趣的东西。</p><p>当然，通过整理这样一份说明书，也让我更深入地认识自己，明确自己的优势和不足，理清生活的目标和未来的发展方向。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>当前版本号：<strong>2.2.4</strong></p><p>作为一个软件工程师，发布版本是再熟悉不过的事情了。将自己视为产品，自然也需要不断的更新和完善，所以就需要版本号。</p><p>我的版本号采用三段式，更新策略为：</p><ul><li>职业赛道发生变化时，更新 Major version</li><li>就职公司或岗位发生变化时，更新 Minor version</li><li>每个版本内的修改和完善，更新 Patch version</li></ul><h2 id="我的基本情况"><a href="#我的基本情况" class="headerlink" title="我的基本情况"></a>我的基本情况</h2><ul><li><strong>网名</strong>：<strong>P2Tree</strong></li><li><strong>职业方向</strong>：目前我专注于基础软件开发，也就是编译器、操作系统驱动软件、工具软件及嵌入式软件等方向</li><li><strong>职级</strong>：Senior Software Engineer</li><li><strong>性格特质</strong>：我的 16 型人格是 <strong>INTJ-A</strong><ul><li>个性是<strong>建筑师</strong>。他们是富有想象力和战略性的思想家，喜欢利用创造力和理性来完善生活</li><li>角色是<strong>分析师</strong>（不典型）。崇尚理性和公正，擅长智力辩论、科学和技术领域，思想独立、开放，意志坚强</li><li>执行策略是<strong>自信的个人主义</strong>。喜欢独立完成任务，知道自己适合和擅长什么，选择依靠自己的直觉和技能，而不是依靠他人</li></ul></li><li><strong>我倾向的环境</strong>：喜欢有条理有秩序、安静整洁的环境</li><li><strong>我的爱好</strong>：<ul><li>玩电脑游戏：一个好游戏，可以扩展我生命的宽度和广度</li><li>阅读好书：这是与跨越时空的智者沟通的唯一途径</li><li>养花：植物有生长与凋零，人生有潮起和潮落</li><li>医学常识：生命是大自然最精妙的设计</li></ul></li></ul><h2 id="我的沟通方式"><a href="#我的沟通方式" class="headerlink" title="我的沟通方式"></a>我的沟通方式</h2><p>对于正式严谨的沟通和讨论，我更喜欢通过邮件或聊天工具交流，一方面可以方便整理思路，另一方面也便于回顾和总结。</p><p>对于技术讨论和头脑风暴，我希望面对面拿着笔和白板聊，这样更有利于准确传递没有经过修饰的信息。</p><p>非技术性的会议，我不喜欢讨论超过半小时，比如工作汇报。类似的沟通内容我更愿意落实到文字中。</p><h2 id="我的技术栈"><a href="#我的技术栈" class="headerlink" title="我的技术栈"></a>我的技术栈</h2><h3 id="我能解决的问题"><a href="#我能解决的问题" class="headerlink" title="我能解决的问题"></a>我能解决的问题</h3><p>任何在 Linux 操作系统上的软件开发工作。很长一段时间我都在 Linux 上工作，曾经做嵌入式设备时，有一些平台部署了 RT Linux 系统，我也完成过一些驱动软件和应用软件的项目。即使我没做过，我也可以很快通过学习掌握相关技能。</p><p>任何在 LLVM 软件栈上的软件开发工作。我过去的工作都在 LLVM 项目上完成，无论是编译器，还是现在正在做的模拟器等工具。我对 LLVM 提供的软件库和工具都比较熟悉，可以快速搭建原型，也可以对老项目做维护和重构。</p><p>虽然很久没有做嵌入式的工作了，但我依然可以提供技术咨询的工作。过去大概有三四年的时间，我负责或参与了一些很有挑战性的嵌入式项目开发工作，积累了不少经验。另外我还有一些能力很强的朋友，可以提供咨询。</p><p>我很乐意做一些文档整理、格式排版、UI 设计的工作，虽然我并没有系统的学习过类似内容，但我也确实完成过一些反响不错的业余作品，我对此充满热情。</p><h3 id="我不擅长的工作"><a href="#我不擅长的工作" class="headerlink" title="我不擅长的工作"></a>我不擅长的工作</h3><ul><li>通过说服对方来接受自己观点的工作</li><li>枯燥乏味且重复性强的工作</li><li>要求经验积累多于专业深度的工作</li></ul><h3 id="我期待的工作"><a href="#我期待的工作" class="headerlink" title="我期待的工作"></a>我期待的工作</h3><p>我特别希望能做一份和机器人相关的工作。我喜欢智能化控制的设备，也特别看好这个行业的发展，尤其是智能驾驶和自动化工业。我过去的履历中相关的工作非常少，所以大概率不会贸然切换到这个赛道，但我依然埋下这个种子，期待未来时机成熟时，能够迎接新的挑战。</p><h3 id="我做过的项目"><a href="#我做过的项目" class="headerlink" title="我做过的项目"></a>我做过的项目</h3><h4 id="LLVM-后端入门实践教程"><a href="#LLVM-后端入门实践教程" class="headerlink" title="LLVM 后端入门实践教程"></a>LLVM 后端入门实践教程</h4><p>业余期间，整理完善了一份 LLVM 后端入门实践教程，原本是整理自己学习的笔记成文，结果发表出来后在网络上反响很好，于是便重新整理了全部内容，并提交了项目的代码。</p><p>这个教程采用相对通俗的语言，使用流程化的步骤编写，旨在指导以最轻松的方式接触 LLVM 后端开发的内容。</p><p>这个项目教会我最多的并不是 LLVM 技术本身，事实上我在几年后的今天，已经忘记了其中大多数的内容（遇到问题还会没事翻翻）。它教会我最多的是，输出自己的认识，总有你可以帮得到的人和事，而且，反过来，这件看似无偿付出的行为，一定会回报自己。</p><p>项目代码：<a href="https://github.com/P2Tree/LLVM_for_cpu0">P2Tree&#x2F;LLVM_for_cpu0 (github.com)</a>。方便的话，可以帮我点个 star 吗？实话说，现在工作忙，没空重写这份教程了，将来有空一定翻新一下。</p><h4 id="蓝牙手套与行走姿态捕捉设备"><a href="#蓝牙手套与行走姿态捕捉设备" class="headerlink" title="蓝牙手套与行走姿态捕捉设备"></a>蓝牙手套与行走姿态捕捉设备</h4><p>第二份实习工作期间的主要成果，是可穿戴式移动助力设备的一部分。蓝牙采用 BLE 4.0 协议，使用芯片配套的库开发应用层业务，主要功能是手套上设计了几个触摸按钮，按钮连接蓝牙 SOC，通过协议发送到背部的计算设备。</p><p>手套部分的电气硬件和软件开发由我独立完成。花费较多时间的地方是平衡蓝牙功耗和唤醒响应速度的需求。</p><p>第二部分工作是行走姿态捕捉设备，也是可穿戴式移动助力设备的一部分。在腿部服装上安装有多个数据采集器，由蓝牙 BLE、陀螺仪、加速度计组成的微型模块。采集姿态数据，并发送给背部计算设备汇总。汇总后的数据使用隐马尔可夫链来推测关键行走姿态。</p><p>腿部捕捉设备的软件开发由我独立完成，行走姿态估计由我和另一位同学一起完成。比较困难的地方是姿态估计的部分，需要大量时间调参，最终效果自认为不太理想。</p><p>实习公司叫 <strong>北京铁甲钢拳科技</strong>，老板是一位非常潮的北京人儿，公司氛围很好，有一帮有梦想有志向的年轻人，如果不是要回学校做课题，舍不得走。第一次体会了真正的创业公司风味。</p><h4 id="室内定位机器人"><a href="#室内定位机器人" class="headerlink" title="室内定位机器人"></a>室内定位机器人</h4><p>这是我的研究生毕业课题，也是我的导师参与的一个项目。我将项目的一部分单独拿出来，实验验证和引入新的技术，并编写了毕业论文。</p><p>机器人为圆形轮式底盘，传感器有激光雷达、红外测距、超声波测距、Wifi。这些是我主要负责的部分。机器人上其实还有双目摄像头和机械臂结构，是另一位老同学（我现在的好伙伴）负责的部分，他负责的视觉定位理论上可以和我的结果做融合，不过最后没时间做完就毕业了。</p><p>我的主要工作是通过采集的距离数据对机器人周边环境做二维建模，实现室内小范围精准定位和避障；再通过 Wifi 标签的原理在室内较大空间做到精准定位。定位精度可以做到 10cm。</p><p>机器人的主控操作系统是 Linux，运行 ROS，如果你懂这块内容，就会知道我的很多工作在 ROS 上已经被支持了，我当时还只有 ROS 1，功能并不完备，所以我自己也完善了很多内容，包括编写 Linux 驱动采集数据输入 ROS、gmapping 时调参来过滤无关数据。</p><p>机器人技术一直是我的一个爱好，可惜造化弄人，现在再想回头换到机器人赛道，需要太多的勇气。如果有机会，我还是会选择抓住它。</p><p>项目代码：<a href="https://github.com/P2Tree/movingCatchRobot">P2Tree&#x2F;movingCatchRobot (github.com)</a>。没啥值得看的，曾经的小打小闹。</p><h4 id="建筑材料分析测试仪"><a href="#建筑材料分析测试仪" class="headerlink" title="建筑材料分析测试仪"></a>建筑材料分析测试仪</h4><p>我的第一份实习经历。主要工作是开发几款不同的建筑材料分析测试仪器，用于测试不同建筑材料的一些参数，比如混凝土的导电率。</p><p>我和另外一位老同学（我现在的好伙伴）一起，负责仪器的电控部分，我负责上位机与通信，他负责板卡的数据采样和滤波。老同学比我能力强，从他那里学到了好多好多知识，我很庆幸在求学的最后一个阶段遇到了他。他留学回来后，现在在高校任教，强的可怕。</p><p>期间我学习了工控机的开发、工业通讯协议 RS422 和 modbus，以及点出了可观的抗压能力。我们经常需要熬夜开发，出差现场调试，以及为理解能力很差的用户做培训。</p><p>我实习的公司是中国建科院下属的建筑材料研究所，当时带我们的余老师是我见过最有耐心的人，虽然我们当时年轻气盛，有过一些不礼貌的行为，但余老师总是包容我们，当然，还有在学校负责对接项目的邹老师，给我们提供了很多帮助。这也是我第一次和社会接触，庆幸是一次珍贵的、充满回忆的经历。</p><h2 id="我常用的工具"><a href="#我常用的工具" class="headerlink" title="我常用的工具"></a>我常用的工具</h2><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>工作中，我在 Linux 系统上开发软件，fish 作为 Shell 环境（曾经用了很久 zsh），使用 NeoVim 来编程，Git 工作流管理项目，使用 Obsidian 整理成系统的笔记。</p><p>工作沟通和协作软件按公司规定执行，目前用到的是（部分）：</p><ul><li>Jira：任务管理</li><li>Confluence：知识管理和共享</li><li>GitLab：代码管理</li><li>Jenkins：代码部署、测试和自动化运维</li><li>腾讯会议：多人会议、外部会议</li><li>企业微信：内部沟通</li></ul><p>生活中，我在 MacOS 上管理生活、学习和娱乐。除了上述提到的几个软件，我还用 Notion 做个人知识管理和生活整理，用 flomo 记录自己的灵感和从各种网络媒体上学到的东西。</p><p>使用 DayOne 写日记，使用微信读书看电子书，使用 iCost 管理家庭财务（曾经用了很久 MoneyWiz），使用滴答清单来记录提醒事项。</p><p>喜欢得到头条和有知有行小酒馆的内容，对我启发很多。使用小鹤双拼输入法，推荐喜欢折腾的朋友试试。</p><p>网络上，使用 Google 搜索，GitHub 管理自己的那些垃圾代码，常混迹的社交媒体有微信公众号、知乎、bilibili、小红书和即刻，不过大多数时间都在潜水。和个人建站相关的网站和工具，我写在了博客的 About 页。</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>家里使用 MacBook 工作、学习和管理生活，用自己组的 Windows 机器玩游戏。上班时使用 Thinkpad，三屏扩展。家里自建了 NAS，用来存储照片和电影，间断性做备份，再不用为数据安全焦虑了。</p><p>手机双持小米和 iPhone，同时享受国产安卓系统的本地化服务和先进流畅的移动应用系统，不做选择，我都要。</p><h2 id="我的社交媒体"><a href="#我的社交媒体" class="headerlink" title="我的社交媒体"></a>我的社交媒体</h2><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><p>我一直都有自己的网络博客，但早期并没有想要自己搭建博客，原因很多，最主要的原因还是维护成本高。最早我在 CSDN 博客建站，当时主要发一些和嵌入式开发有关系的教程和分享文章。转到编译工具链赛道后，我开始把内容输出转移到知乎，因为 CSDN 的商业化味道太严重，让我非常不喜欢。</p><p>然而，现在我也对知乎失望了，想来想去，还是有个自己的博客比较好，干净、整洁，这就是我想要的网络生活空间。</p><p>现在和可预见的将来，我的博客域名是 <a href="https://p2tree.top/">https://p2tree.top</a></p><h3 id="个人生活公众号"><a href="#个人生活公众号" class="headerlink" title="个人生活公众号"></a>个人生活公众号</h3><p>疫情那段时间，被隔离了一个月，后来居家办公了一段时间，那段时间突然心血来潮，想学别人搞自媒体，发点自己的生活感悟和读书笔记，于是开了自己的公众号。</p><p>但我当时并没有了解自媒体这个行业，也选错了平台。微信公众号在 16 年之后就开始走向没落，我在之后的运营中并不顺利，所以停更了三年。但现在我又续更了，我的心态变了，不应该被平台牵着走。</p><p>我的公众号名称是：<a href="https://p2tree.top/posts/e8d522db.html">二树说</a></p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p>从 CSDN 转到了知乎，虽然现在知乎也已经商业味很浓了，但当时刚来时，知乎还是非常专业的，有不少大佬在这里出没，有很多高质量的回答，所以我曾经也非常看好知乎。</p><p>虽然我在知乎上活动不再积极了，但依然感谢知乎，它让我有了一个环境能接触到其他的牛人，也让我自己一定程度上在专业领域内露了脸。</p><p>你依然可以在知乎上和我联系，主页链接是：<a href="https://www.zhihu.com/people/p2tree">https://www.zhihu.com/people/p2tree</a></p><hr><blockquote><p>有关标题图片：这是人类拍摄到的第一张黑洞的照片，虽然非常模糊，但却是最接近真相的一张照片。在可预见的将来，我们会拍摄到更多更清晰的黑洞照片，这些照片见证着人类探索的脚步。</p></blockquote>]]></content>
    
    
    <summary type="html">这份个人说明书，记录着我的基本信息和所思所想，希望能以最快的方式介绍我自己</summary>
    
    
    
    <category term="自我介绍" scheme="https://p2tree.top/categories/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="个人发展" scheme="https://p2tree.top/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>如何展开可变参数模板的参数包</title>
    <link href="https://p2tree.top/posts/5afd8958.html"/>
    <id>https://p2tree.top/posts/5afd8958.html</id>
    <published>2024-08-15T22:08:39.000Z</published>
    <updated>2024-08-15T22:08:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++11 引入可变参数模板（variadic template），可以接受任意数量的模板参数，这对模板的用法是一个很大的改进。然而，可变参数模板的使用也很复杂，在 C++11 中，模板参数包不能直接展开，需要使用递归或者逗号表达式的方式展开，写法比较繁琐。C++17 引入了折叠表达式的语法，用来对可变参数模板中的参数做展开。</p><p>本文介绍与之相关的内容，方便有需要的读者在自己的项目中实践可变参数模板特性。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="什么是可变参数模板"><a href="#什么是可变参数模板" class="headerlink" title="什么是可变参数模板"></a>什么是可变参数模板</h3><p>模板参数列表可变的模板，如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T arg)</span></span>;</span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T... args)</span></span>;</span><br></pre></td></tr></table></figure><p>注意其中的省略号用法，两个地方出现了省略号：</p><ul><li>在模板参数列表中，<code>...</code> 出现在 typename 后边，用来表示 <code>T</code> 是一个可变长的模板参数</li><li>在模板函数参数列表中，<code>...</code> 出现在模板参数类型 <code>T</code> 后边，用来表示 <code>args</code> 是一个模板参数包 我们在函数内部需要使用 <code>args</code> 时，要遵循模板参数包的使用规则。</li></ul><p>注意，参数的数量范围是 <code>[0, N)</code> ，包括 0，也就是说可以实例化没有参数的模板函数。</p><h3 id="不想展开参数包"><a href="#不想展开参数包" class="headerlink" title="不想展开参数包"></a>不想展开参数包</h3><p>有些时候，我们不需要展开参数包，那也是可以的，可以直接使用整个参数包，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取模板参数包的大小</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传递给另一个可变参数模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="type">void</span> <span class="title">another_f</span><span class="params">(T... args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">another_f</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些更复杂的用法，我在最后一节介绍。</p><h2 id="不同的包展开方式"><a href="#不同的包展开方式" class="headerlink" title="不同的包展开方式"></a>不同的包展开方式</h2><h3 id="递归展开"><a href="#递归展开" class="headerlink" title="递归展开"></a>递归展开</h3><p>通过递归展开的实现代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数存在是必要的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归展开可变参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的 print 函数是必要的，处理没参数的情况，也处理递归调用最后一层出口，因为我们上边提到，<code>Ts...</code> 是包括 0 个模板参数的。</p><h3 id="逗号表达式展开"><a href="#逗号表达式展开" class="headerlink" title="逗号表达式展开"></a>逗号表达式展开</h3><p>递归展开的方式需要引入递归，还得单独实现出口函数，比较啰嗦。可以使用逗号表达式展开，实现代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_item</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; (<span class="built_in">print_item</span>(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中逗号表达式中第一项，表示对逗号表达式按序求值（也就是调用 print_item），之后 <code>&#123; ... &#125;</code> 是利用初始化列表的语法，对一个 <code>(print_item(args), 0)</code> 的逗号表达式做大小为 <code>sizeof...(args)</code> 的初始化，大概等效于伪代码 <code>&#123; (print_item(args[1]), 0), (print_item(args[1]), 0), ..., (print_item(args[N]), 0)&#125;</code>。</p><p>0 在这里的用途只是让逗号表达式 <code>(print_item(args), 0)</code> 的类型是 int，从而避免编译器报错，int 类型赋给 <code>int arr[]</code> 是合法的，如果不写 0，<code>int arr[] = &#123; print_item(args)... &#125;;</code> ，编译器会报错无法把 void 类型绑定到 int 的 array 上。</p><p>展开后的形式为（伪代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>),</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="string">&quot;2&quot;</span>), <span class="number">0</span>),</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="number">3</span>), <span class="number">0</span>),</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="number">4</span>), <span class="number">0</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其叫逗号表达式的展开法，不如叫<strong>初始化列表的展开法</strong>，因为逗号表达式并不是必须的，而初始化列表却是必须的，进而，没有被调用的 <code>int arr[]</code> 也是必须存在的，或者你也可以真的需要它（见后文章节）。比如说，不使用逗号表达式的办法是让 print_item 返回 int 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_item</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="built_in">print_item</span>(args)... &#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以留意下 <code>...</code> 的位置，当它位于参数左边时，表示这个参数的类型是 <code>T...</code> 也就是变长类型 T 的类型，此时参数时折叠状态，比如 <code>T... args</code> 中的 args；当它位于参数（或表达式）右边时，表示将折叠参数展开，比如 <code>args...</code>，展开的参数列表并不是逗号表达式，而是用逗号分隔开的表达式列表，C++标准规定了可以接受的范围。</p><h3 id="折叠表达式展开（C-17）"><a href="#折叠表达式展开（C-17）" class="headerlink" title="折叠表达式展开（C++17）"></a>折叠表达式展开（C++17）</h3><p>折叠表达式展开的语法看起来更奇怪，但它符合一种约定的语法形式，具体的实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一元右折叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    ((std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot;, &quot;</span>), ...) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一元左折叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printL</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    (..., (std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot;, &quot;</span>)) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printR</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printL</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种折叠的展开形式等价于（伪代码）：</p><p>一元右折叠：<code>(std::cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot;, &quot;, (std::cout &lt;&lt; &quot;2&quot; &lt;&lt; &quot;, &quot;, (std::cout &lt;&lt; 3 &lt;&lt; &quot;, &quot;, std::cout &lt;&lt; 4 &lt;&lt; &quot;, &quot;)))</code></p><p>一元左折叠：<code>(((std::cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot;, &quot;, std::cout &lt;&lt; &quot;2&quot; &lt;&lt; &quot;, &quot;), std::cout &lt;&lt; 3 &lt;&lt; &quot;, &quot;), std::cout &lt;&lt; 4 &lt;&lt; &quot;, &quot;)</code></p><p>回归到折叠表达式的定义中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一元左折叠表达式</span><br><span class="line">(pack op ...)</span><br><span class="line">// 一元右折叠表达式</span><br><span class="line">(... op pack)</span><br><span class="line">// 二元左折叠表达式</span><br><span class="line">(pack op ... op init)</span><br><span class="line">// 二元右折叠表达式</span><br><span class="line">(init op ... op pack)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>op</code> 是运算符，支持多种运算符</li><li><code>pack</code> 是包含未展开参数包的表达式</li><li><code>init</code> 是顶层参数，是二元折叠展开的出口，是不包含未展开参数包的表达式</li><li><code>...</code> 是折叠标记</li><li>注意 <code>()</code> 不能省略。</li></ul><p>如果使用一元表达式实现二元表达式的目的，需要给定一个二元出口的特化版本（即空参数包），而直接使用二元表达式，可以用 <code>init</code> 来指定出口值。</p><p>再回头看前边的示例，其中 <code>((std::cout &lt;&lt; args &lt;&lt; &quot;, &quot;), ...)</code> 中，<code>pack</code> 是 <code>(std::cout &lt;&lt; args &lt;&lt; &quot;, &quot;)</code>, <code>op</code> 是 <code>,</code>，也就是逗号表达式的逗号运算符。</p><p>左折叠和右折叠的区别就是先展开左侧参数，还是先展开右侧参数，这在一些要求结合顺序的运算符连接时很重要，比如 <code>-</code> 和 <code>/</code>。</p><p>使用二元折叠表达式实现的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元右折叠表达式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    ((std::cout &lt;&lt; args), ... , <span class="built_in">void</span>()) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二元左折叠表达式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printL</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">void</span>(<span class="number">0</span>), ... , (std::cout &lt;&lt; args)) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们示例中逗号运算符是二元运算符，之所以可以使用一元折叠表达式而不需要指定特化版本，原因是有一些一元折叠表达式拥有默认的空参数包值，是 <code>void()</code>，另外还有 &amp;&amp; 的默认空参数值是 true，|| 的默认空参数值是 false，它们也不需要定义特化版本（只有这 3 个特例）。</p><p>我项目中用到的一个例子，更直观的展示一下折叠表达式在语义上的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(std::convertible_to&lt;<span class="type">int</span>&gt; <span class="keyword">auto</span> ... i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span> + ... + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>std::convertible_to&lt;&gt;</code> 是 C++20 引入的一种 concept，它用来约束 <code>i</code> 的类型必须满足可转换为特定类型的条件；auto 作为泛型参数的用法也是 C++20 中的特性，本质还是模板，这里可以忽略。</p><h3 id="折叠表达式和逗号表达式的对比"><a href="#折叠表达式和逗号表达式的对比" class="headerlink" title="折叠表达式和逗号表达式的对比"></a>折叠表达式和逗号表达式的对比</h3><p>折叠表达式 <code>(args op ...)</code> 和逗号表达式展开 <code>((args, 0)...)</code> 的区别是，折叠表达式更灵活，它将折叠参数按 op 连接，并返回连接之后的整体参数列表，op 可以是逗号，此时和逗号表达式的意义是一样的。</p><p>比如，C++11 中的 <code>args...</code> 的展开虽然是通过逗号分隔，但它并不是逗号表达式，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args...;   <span class="comment">// compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp; ...)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">pass</span>(args...);   <span class="comment">// compiler pass</span></span><br></pre></td></tr></table></figure><p>参数展开时处理参数的函数，如 <code>print</code> 必须提供一个无参的终止类型。 <code>args...</code> 参数包用逗号表达式展开时，没有明确的展开顺序，所以在展开且求值的过程中，顺序是随机的。如果想严格展开顺序，就只能使用折叠表达式，折叠表达式的左折叠和右折叠可以约束展开顺序。</p><h2 id="不展开参数包"><a href="#不展开参数包" class="headerlink" title="不展开参数包"></a>不展开参数包</h2><p>模板参数包可以以 <code>T...</code> 类型来传递，比如将可变长参数模板和完美转发结合起来，实现一个可以创建任意类型的模板工厂函数。</p><p>举例来说，假设我们的目标是通过定义函数 <code>createT</code> 来实现以下用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"><span class="built_in">MyType</span>(<span class="type">int</span>, <span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lvalue</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T1 = <span class="built_in">createT</span>&lt;<span class="type">int</span>&gt;();        <span class="comment">// 不带构造参数的 int 类型对象构造</span></span><br><span class="line"><span class="keyword">auto</span> T2 = <span class="built_in">createT</span>&lt;<span class="type">int</span>&gt;(<span class="number">2011</span>);   <span class="comment">// 带有 1 个右值的 int 类型对象构造</span></span><br><span class="line"><span class="keyword">auto</span> T3 = <span class="built_in">createT</span>&lt;<span class="type">int</span>&gt;(lvalue); <span class="comment">// 带有 1 个左值的 int 类型对象构造</span></span><br><span class="line"><span class="keyword">auto</span> T4 = <span class="built_in">createT</span>&lt;MyType&gt;(lvalue, <span class="number">2011</span>);  <span class="comment">// 带有左值和右值作为构造参数的自定义类型对象构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，但要注意语法，其中的 <code>Args &amp;&amp; ...</code> 是万能引用类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">createT</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库中 std::make_unique 等工厂函数就是这么实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们将 args 整个打包传递给了内部的 <code>std::forward</code>，注意其语法。</p><h3 id="可变长基类继承结构"><a href="#可变长基类继承结构" class="headerlink" title="可变长基类继承结构"></a>可变长基类继承结构</h3><p>还有一些有意思的用法，比如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Base&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base ... &#123;</span><br><span class="line">  <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">using</span> Base::func...;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它表示 Derived 可由模板类中模板参数指定的所有类型作为基类。</p><p>其中的 <code>using Base::func...</code> 可等价于 using 所有在模板参数列表中的基类类型中的 func 函数。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/714536540">如何展开可变参数模板的参数包 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>hexo butterfly 主题插件</title>
    <link href="https://p2tree.top/posts/6861d72c.html"/>
    <id>https://p2tree.top/posts/6861d72c.html</id>
    <published>2024-08-11T13:57:00.000Z</published>
    <updated>2024-12-15T12:21:03.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本博文为笔记性质的内容，全部内容来自于网络，有一些是官方描述，也有一些个人博客上的内容，另外我会把自己操作过程中遇到的问题记下来。<br>如果涉及到版权信息，请联系我删除。</p><p>本文汇总了我的博客中用到的（或者曾经用到的）hexo butterfly 主题插件。</p><h2 id="NPM-使用"><a href="#NPM-使用" class="headerlink" title="NPM 使用"></a>NPM 使用</h2><p>使用以下命令来管理插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有插件</span></span><br><span class="line">npm list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装插件到博客目录</span></span><br><span class="line">npm install xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新插件</span></span><br><span class="line">npm update xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除插件</span></span><br><span class="line">npm remove xxxx</span><br></pre></td></tr></table></figure><h2 id="Hexo-相关的插件"><a href="#Hexo-相关的插件" class="headerlink" title="Hexo 相关的插件"></a>Hexo 相关的插件</h2><ul><li>hexo-server：Hexo 的服务器模块</li><li>hexo-generator-archive：实现博客 archive 功能</li><li>hexo-generator-category：实现博客 category 功能</li><li>hexo-generator-tag：实现博客 tags 功能</li><li>hexo-renderer-ejs：EJS 的渲染器</li><li>hexo-renderer-marked：Markdown 的渲染器（渲染引擎 marked）</li><li>hexo-renderer-pug：PUG 的渲染器</li><li>hexo-renderer-stylus：支持 Stylus</li></ul><h2 id="文章置顶：hexo-generator-index-pin-top"><a href="#文章置顶：hexo-generator-index-pin-top" class="headerlink" title="文章置顶：hexo-generator-index-pin-top"></a>文章置顶：hexo-generator-index-pin-top</h2><p>安装 hexo-generator-index-pin-top 工具，删除 hexo-generator-index 工具。</p><p>之后，在需要置顶的文章的 metadata 中，增加 top 标记，值为数字，数字越大，越靠前。</p><p>在文章的 front_matter 中增加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="轮播置顶：hexo-butterfly-swiper"><a href="#轮播置顶：hexo-butterfly-swiper" class="headerlink" title="轮播置顶：hexo-butterfly-swiper"></a>轮播置顶：hexo-butterfly-swiper</h2><p>本来是打算支持置顶功能的，顺便搜索了一下，发现大家都在用置顶轮播的插件，样式也挺好看，而且折叠起来也节省空间。</p><p>使用 hexo-butterfly-swiper 插件来实现这个功能。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-swiper --save</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在博客全局 <code>_config.yml</code> 中或者主题的 <code>_config.yml</code> 中添加以下内容（我是在 <code>_config.butterfly.yml</code> 中加入的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-butterfly-swiper  </span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/8e1264d1/  </span></span><br><span class="line"><span class="attr">swiper:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关  </span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权  </span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面  </span></span><br><span class="line">  <span class="attr">timemode:</span> <span class="string">date</span> <span class="comment">#date/updated  </span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型  </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span>  </span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span>  </span><br><span class="line">  <span class="attr">default_descr:</span> <span class="string">再怎么看我也不知道怎么描述它的啦！</span>  </span><br><span class="line">  <span class="attr">swiper_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css</span> <span class="comment">#swiper css依赖  </span></span><br><span class="line">  <span class="attr">swiper_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js</span> <span class="comment">#swiper js依赖  </span></span><br><span class="line">  <span class="attr">custom_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css</span> <span class="comment"># 适配主题样式补丁  </span></span><br><span class="line">  <span class="attr">custom_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js</span> <span class="comment"># swiper初始化方法</span></span><br></pre></td></tr></table></figure><p>需要注意，插件官网（github）上的配置中，js 和 css 的 CDN 已经失效，请使用上边的链接。</p><p>然后，在你想要加入置顶的文章的 front_matter 中，加入一个段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">swiper_index:</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>这个数字是任意正整数，数字越大，越靠前。</p><p>配置之后，<code>hexo clean &amp;&amp; hexo g</code> 即可。</p><h2 id="生成永久链接：hexo-abbrlink"><a href="#生成永久链接：hexo-abbrlink" class="headerlink" title="生成永久链接：hexo-abbrlink"></a>生成永久链接：hexo-abbrlink</h2><p>Hexo 中的博文 URL 链接默认是采用日期和文章题目组成，格式如：<code>:year/:month/:day/:title/</code>。这种格式，当文章的标题或日期发生变化后，原来的 URL 链接就会失效，这对于需要在其他地方保存博文链接来说非常不友好。</p><p>Hexo 的 <code>_config.yml</code> 文件中可以配置 permalink 参数来设置永久链接，或者也可以在每篇博文的 Front-matter 中指定 permalink 参数来为这篇博文指定永久链接。<br>具体可以参考这篇文章：<a href="https://hexo.io/zh-cn/docs/permalinks">永久链接（Permalinks） | Hexo</a></p><p>目前，我们可以使用 hexo-abbrlink 来为博文生成一个永久链接。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>在 hexo 全局 <code>_config.yml</code> 文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可选 permalink: abbrlink 短链接模式  </span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:abbrlink/</span> <span class="comment">#文章的永久链接 或者 permalink: posts/:abbrlink.html 如：http://localhost:4000/post/abaf7e89.html  </span></span><br><span class="line"><span class="comment"># abbrlink config  </span></span><br><span class="line"><span class="attr">abbrlink:</span>  </span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment">#算法: crc16(default) | crc32  </span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#进制: dec(default) | hex</span></span><br></pre></td></tr></table></figure><p>之后，需要重新清理工程文件 <code>hexo clean</code> 再生成一次 <code>hexo g</code>，博文链接就会被全部替换为永久链接，默认格式是：<code>/post/xxxxx.html</code>，这个后缀是通过算法计算出来的唯一值。</p><p>测试时，可能要清理一下浏览器缓存，让浏览器重新拉取新的链接。</p><h2 id="字数统计：hexo-wordcount"><a href="#字数统计：hexo-wordcount" class="headerlink" title="字数统计：hexo-wordcount"></a>字数统计：hexo-wordcount</h2><p>该插件可以统计文章字数，并在文章页的标题下边显示文章字数、阅读时间信息。</p><p>安装插件 hexo-wordcount 后，在主题配置文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Feed-订阅服务：hexo-generator-feed"><a href="#Feed-订阅服务：hexo-generator-feed" class="headerlink" title="Feed 订阅服务：hexo-generator-feed"></a>Feed 订阅服务：hexo-generator-feed</h2><p>Feed 是伴随着个人博客的兴起而出现的。Feed 是一种能够将自己博客中的更新内容以一种约定的格式分享到外部，通过 RSS 的方式由其他客户端订阅和展示的技术。简单说 Feed 就是 RSS 的信源。虽然现在这个年代使用 RSS 已经不是主流了，但依然有一小部分网友热衷于逃脱这个个性化订阅的时代，而是把网络信息来源和内容把握在自己的手里。</p><p>尽管个人博客没落了，但 Feed 已经被各种内容平台广泛使用和发展，作为信息推送的重要环节。</p><p>Hexo 中，可以使用 hexo-generator-feed 来实现对自己的网站生成 Feed 信源。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>在 hexo 全局 <code>_config.yml</code> 文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span>  <span class="comment"># atom | rss2</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>type: RSS的类型(atom&#x2F;rss2)  </li><li>path: 文件路径，默认是 atom.xml&#x2F;rss2.xml  </li><li>limit: 展示文章的数量,使用 0 或则 false 代表展示全部  </li><li>hub: URL of the PubSubHubbub hubs (如果使用不到可以为空)  </li><li>content: （可选）设置 true 可以在 RSS 文件中包含文章全部内容，默认：false  </li><li>content_limit: （可选）摘要中使用的帖子内容的默认长度。 仅在内容设置为false且未显示自定义帖子描述时才使用。  </li><li>content_limit_delim: （可选）如果content_limit用于缩短post内容，则仅在此分隔符的最后一次出现时进行剪切，然后才达到字符限制。默认不使用。  </li><li>icon: （可选）自定义订阅图标，默认设置为主配置中指定的图标。  </li><li>order_by: 订阅内容的顺序。 (默认: -date)</li></ul><p>之后，重新生成一次静态文件：<code>hexo clean &amp;&amp; hexo g</code>，在 publish 路径下会出现 atom.xml 就可以了。在页面需要的地方，通过 <code>/atom.xml</code> 来引用这个文件。</p><h2 id="页脚标签：hexo-butterfly-footer-beautify"><a href="#页脚标签：hexo-butterfly-footer-beautify" class="headerlink" title="页脚标签：hexo-butterfly-footer-beautify"></a>页脚标签：hexo-butterfly-footer-beautify</h2><p>一个纯美化的配置，可以在页面页脚处增加自定义的标签，也可增加 “本网站已运行 xxx 时间“ 的计时器。</p><p>使用 hexo-butterfly-footer-beautify 插件可以做到。</p><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-footer-beautify --save</span><br></pre></td></tr></table></figure><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># footer_beautify  </span></span><br><span class="line"><span class="comment"># 页脚计时器：[Native JS Timer](https://akilar.top/posts/b941af/)  </span></span><br><span class="line"><span class="comment"># 页脚徽标：[Add Github Badge](https://akilar.top/posts/e87ad7f8/)  </span></span><br><span class="line"><span class="attr">footer_beautify:</span>  </span><br><span class="line">  <span class="attr">enable:</span>  </span><br><span class="line">    <span class="attr">timer:</span> <span class="literal">true</span> <span class="comment"># 计时器开关  </span></span><br><span class="line">    <span class="attr">bdage:</span> <span class="literal">true</span> <span class="comment"># 徽标开关  </span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权  </span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面  </span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="comment">#屏蔽页面  </span></span><br><span class="line">    <span class="comment"># - /posts/  </span></span><br><span class="line">    <span class="comment"># - /about/  </span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型  </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">footer-wrap</span>  </span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span>  </span><br><span class="line">  <span class="comment"># 计时器部分配置项  </span></span><br><span class="line">  <span class="attr">runtime_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js</span>  </span><br><span class="line">  <span class="attr">runtime_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css</span>  </span><br><span class="line">  <span class="comment"># 徽标部分配置项  </span></span><br><span class="line">  <span class="attr">swiperpara:</span> <span class="number">3</span> <span class="comment">#若非0，则开启轮播功能，每行徽标个数  </span></span><br><span class="line">  <span class="attr">bdageitem:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://hexo.io/</span> <span class="comment">#徽标指向网站链接  </span></span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo</span> <span class="comment">#徽标API  </span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">博客框架为Hexo_v5.4.0</span> <span class="comment">#徽标提示语  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://butterfly.js.org/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">主题版本Butterfly_v3.8.2</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://www.jsdelivr.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站使用JsDelivr为静态资源提供CDN加速</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://vercel.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站采用双线部署，默认线路托管于Vercel</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://vercel.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站采用双线部署，联通线路托管于Coding</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://github.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站项目由Github托管</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">http://creativecommons.org/licenses/by-nc-sa/4.0/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可</span>  </span><br><span class="line">  <span class="attr">swiper_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css</span>  </span><br><span class="line">  <span class="attr">swiper_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js</span>  </span><br><span class="line">  <span class="attr">swiperbdage_init_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js</span></span><br></pre></td></tr></table></figure><p>之后 <code>hexo clean &amp;&amp; hexo g</code> 就可以了。</p><h2 id="顶部加载条（非插件）"><a href="#顶部加载条（非插件）" class="headerlink" title="顶部加载条（非插件）"></a>顶部加载条（非插件）</h2><p>引入 css 文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pace</span> &#123;</span><br><span class="line">-webkit-<span class="attribute">pointer-events</span>: none;</span><br><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line"></span><br><span class="line">-webkit-user-<span class="selector-tag">select</span>: none;</span><br><span class="line">-moz-user-<span class="selector-tag">select</span>: none;</span><br><span class="line">user-<span class="selector-tag">select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pace-inactive</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#06e1bf</span>;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">2000</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>_config.butterfly.yml</code> 文件中的 preloader 部分注入 css：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source</span></span><br><span class="line">  <span class="comment"># 1. fullpage-loading</span></span><br><span class="line">  <span class="comment"># 2. pace (progress bar)</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># pace theme (see https://codebyzach.github.io/pace/)</span></span><br><span class="line">  <span class="comment"># pace_css_url: https://cdn.jsdelivr.net/npm/pace-js@latest/themes/green/pace-theme-minimal.css</span></span><br><span class="line">  <span class="attr">pace_css_url:</span> <span class="string">/css/pace-theme-minimal.css</span></span><br></pre></td></tr></table></figure><p>重新加载 hexo 后生效。</p><h2 id="自动化部署：hexo-deploy-git"><a href="#自动化部署：hexo-deploy-git" class="headerlink" title="自动化部署：hexo-deploy-git"></a>自动化部署：hexo-deploy-git</h2><p>我之前的博客发布流程离不开几个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其中 <code>hexo d</code> 是由插件 <code>hexo-deploy-git</code> 提供的功能，通过手动执行在本地对博客源码进行编译，然后自动把编译后的产物推送到部署服务器。</p><p>自动化部署是希望避免在本地手动编译源码，而是通过自动化的流程，和 git 操作绑定，在每一次 git push 之后，平台自动捕获推送动作，并拉取源码做一次构建和部署。</p><p>类似的工具有很多，其中我接触到的是 Vercel 平台和 Github 自带的 github action。</p><h2 id="站内搜索：hexo-butterfly-algoliasearch"><a href="#站内搜索：hexo-butterfly-algoliasearch" class="headerlink" title="站内搜索：hexo-butterfly-algoliasearch"></a>站内搜索：hexo-butterfly-algoliasearch</h2><p>搜索功能依赖于 algolia 平台，需要在平台上先注册账户，获取各种 AppKey。</p><p>本地安装 hexo-butterfly-algoliasearch 插件（替代过去的 hexo-butterfly-algolia），在博客配置文件中添加简单的配置，在主题配置文件中开启 search 功能。</p><p>这个插件会将文章内容以某种方式整理上传到 algolia 平台，同时提供搜索匹配的功能。</p><h2 id="资源压缩：hexo-all-minifier"><a href="#资源压缩：hexo-all-minifier" class="headerlink" title="资源压缩：hexo-all-minifier"></a>资源压缩：hexo-all-minifier</h2><p>是站点优化的一种方式，可以将站点的静态资源做压缩后上传，删除对渲染页面没有用的内容，从而提高网站的载入速度。</p><p>本地安装 hexo-all-minifier 插件，在博客配置文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">all_minifier:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">html_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ignore_error:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">source/about/index.html</span></span><br><span class="line"><span class="attr">css_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;*.min.css&quot;</span></span><br><span class="line"><span class="attr">js_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;*.min.js&quot;</span></span><br><span class="line"><span class="attr">image_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">interlaced:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">multipass:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">optimizationLevel:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">pngquant:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">progressive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="哀悼日网页变灰：hexo-filter-mourning"><a href="#哀悼日网页变灰：hexo-filter-mourning" class="headerlink" title="哀悼日网页变灰：hexo-filter-mourning"></a>哀悼日网页变灰：hexo-filter-mourning</h2><p>在一些特别的日期，让整个网页变成灰色。</p><p>安装插件 hexo-filter-mourning，之后在博客配置文件中配置，可以自定义需要调整的日期：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mourning:</span></span><br><span class="line">  <span class="comment"># It&#x27;s recommended to disable it when not in use</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Specify the date(s) to be greyed out. You can set dates in the format yyyy-MM-dd or MM-dd</span></span><br><span class="line">  <span class="attr">day:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">05</span><span class="number">-12</span> <span class="comment"># 汶川大地震遇难同胞悼念日</span></span><br></pre></td></tr></table></figure><h2 id="站点地图：hexo-generator-sitemap-hexo-generator-baidu-sitemap"><a href="#站点地图：hexo-generator-sitemap-hexo-generator-baidu-sitemap" class="headerlink" title="站点地图：hexo-generator-sitemap &amp; hexo-generator-baidu-sitemap"></a>站点地图：hexo-generator-sitemap &amp; hexo-generator-baidu-sitemap</h2><p>站点地图是提供给搜索引擎爬取网站信息的指导文件。这个文件在我们的博客通过这两个插件来生成。</p><p>提供给 Google 的站点地图，通过 hexo-generator-sitemap 插件生成。提供给 Baidu 的站点地图，通过 hexo-generator-baidu-sitemap 插件生成。生成的文件放在博客资源文件的根路径下。</p><hr><div class="note info simple"><p>本文标题图片来源于 <a href="https://www.pinterest.jp/pin/466333736393779796">Pin page (pinterest.jp)</a>。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="博客" scheme="https://p2tree.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://p2tree.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>雨幕下的城市映像</title>
    <link href="https://p2tree.top/posts/22b58fab.html"/>
    <id>https://p2tree.top/posts/22b58fab.html</id>
    <published>2024-08-10T17:59:37.000Z</published>
    <updated>2024-08-10T17:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>城市最美的时刻莫过于它在雨中的夜景。</p><p>朦胧的雨雾笼罩了城市往日的喧嚣，路上匆匆走过的行人，雨点沙沙落下的声音，伴随着梦幻般的光影，路灯、车灯和广告牌闪烁着的光，映射在光滑湿润的柏油路面，充满了未来感。</p><p>抬头望去，身边的高楼一支支高耸入雨幕之中，似乎有无数层高，云端隐约闪现的微光照亮了周围的一片朦胧，仿佛置身于梦幻世界中。</p><hr><p><img src="https://webp.p2tree.top/2024/08/10/WechatIMG140.jpg" alt="Chapter.413"></p><hr><div class="note primary flat"><p>封面图片来自我一位好朋友的摄影作品。</p><p>转载自我自己的微信公众号，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="这个美丽的世界" scheme="https://p2tree.top/tags/%E8%BF%99%E4%B8%AA%E7%BE%8E%E4%B8%BD%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>寻找生活的意义，就是意义所在</title>
    <link href="https://p2tree.top/posts/eaf9e695.html"/>
    <id>https://p2tree.top/posts/eaf9e695.html</id>
    <published>2024-08-06T22:12:25.000Z</published>
    <updated>2024-08-06T22:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们总是匆忙地过完每一天，以至于忽略了生活本身的宁静与美好。当追求目标成为我们心中的执念，它便可能转化为焦虑与不安，让我们无法全心投入于每一个当下。我们所追求的目标，就已经偏离了生活的真谛。</p><p>生活的意义，不是静态的终点，而是一段流动的旅程。它不应该是我们不断追问的谜题，而是我们生活过程中自然涌现的答案。若我们总是驻足于思考生活的意义，便可能错失了那些让生活有意义的瞬间。</p><p>生活的意义不是预设的标签，而是我们内心所向往的生活状态的映像。<strong>追求自己所满足的生活状态，本身就成为了生活的意义。</strong></p><hr><p><img src="https://webp.p2tree.top/2024/08/06/Chapter445.jpg" alt="Chapter.445"></p><hr><div class="note primary flat"><p>转载自我自己的微信公众号，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="与生活妥协" scheme="https://p2tree.top/tags/%E4%B8%8E%E7%94%9F%E6%B4%BB%E5%A6%A5%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号 P2Tree</title>
    <link href="https://p2tree.top/posts/e8d522db.html"/>
    <id>https://p2tree.top/posts/e8d522db.html</id>
    <published>2024-08-05T22:50:32.000Z</published>
    <updated>2024-08-05T22:50:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我自己维护着一个微信公众号，公众号名字是 P2Tree。</p><p>公众号上会同步发布我自己写的一些非技术类文章，比如心得感悟，好书推荐等。为了节省亲爱的你的时间，公众号上的文章都会保证在 5 分钟内读完，这可能会让内容没那么有文采，但绝对压缩到全部是干货。</p><p>我曾经停更过一段时间，因为一度怀疑自己是不是不适合写东西，但最后又想开了，如果感兴趣，可以到公众号里翻翻。</p><p>公众号的文章也会同步发布在博客上。欢迎通过下边二维码关注，也可搜索 P2Tree，握握手～</p><p><img src="https://img.p2tree.top/2024/08/05/WechatIMG111.webp" alt="公众号 P2Tree"></p>]]></content>
    
    
    <summary type="html">我维护的微信公众号，欢迎来交个朋友</summary>
    
    
    
    
  </entry>
  
</feed>
