<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P2Tree&#39;s Mill</title>
  
  
  <link href="https://p2tree.top/atom.xml" rel="self"/>
  
  <link href="https://p2tree.top/"/>
  <updated>2025-07-25T15:07:55.153Z</updated>
  <id>https://p2tree.top/</id>
  
  <author>
    <name>P2Tree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective Modern C++ 读书笔记：auto</title>
    <link href="https://p2tree.top/posts/f3206605.html"/>
    <id>https://p2tree.top/posts/f3206605.html</id>
    <published>2025-07-25T22:58:23.000Z</published>
    <updated>2025-07-25T15:07:55.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="条款-5：优先选用-auto"><a href="#条款-5：优先选用-auto" class="headerlink" title="条款 5：优先选用 auto"></a>条款 5：优先选用 auto</h2><p>使用 <code>auto</code> 会带来很多好处，比如：</p><ul><li>不需要关注一些复杂的类型声明，比如模板函数和 lambda 表达式类型</li><li>不会忘记初始化变量（<code>auto</code> 要求必须初始化）</li><li>一些不希望发生的隐式类型转换</li><li>代码类型变化时，不需要在多处修改类型，<code>auto</code> 自适应</li></ul><p>使用 <code>auto</code> 来取代显式指定类型的建议，一个很大的反对声音，就是无法从代码中直观地看出一个变量的类型。针对这种强有力地反对声浪，实际上有多种理由来反驳，比如说：</p><ul><li>大多数现代编程语言，基本都支持类型推导的特性</li><li>一个好的名字，比一个类型要重要的多。比如我们不需要知道迭代器的类型，但只要从名字中看出这是一个迭代器，就可以</li><li>一些现代化的编辑器，都支持显示类型，这包括 vim&#x2F;emacs 这些有年代感的软件</li><li>默认使用 <code>auto</code>，但在一些特殊情况，比如需要明确指定类型时，显式声明类型</li></ul><p>有关于 <code>auto</code> 的讨论，网络上有很多，我这里不一一列举。下面看几个书中的例子。</p><h3 id="案例-1：使用-auto-替代函数对象"><a href="#案例-1：使用-auto-替代函数对象" class="headerlink" title="案例 1：使用 auto 替代函数对象"></a>案例 1：使用 auto 替代函数对象</h3><p>以下代码，我们希望使用一个类型来接受 lambda 表达式，通常的做法是使用 <code>auto</code>，让编译器去推导实际的类型，但另外，也可以通过一个 <code>std::function</code> 来接受 lambda 表达式。注意，lambda 表达式的类型并不是 <code>std::function</code>，它只有编译器知道。因为 <code>std::function</code> 可以接受任何可调用对象，所以也就可以接受 lambda 表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常见的写法，使用 auto 类型 </span></span><br><span class="line"><span class="keyword">auto</span> derefLess = [](<span class="type">const</span> <span class="keyword">auto</span> &amp;p1, <span class="type">const</span> <span class="keyword">auto</span> &amp;p2) &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::function 的写法</span></span><br><span class="line"><span class="comment">// 必须指定一种形参类型，这里选择 std::unique_ptr&lt;Widget&gt; </span></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;, </span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt;   </span><br><span class="line">derefLess2 = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p1, </span><br><span class="line">                <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p2) &#123; </span><br><span class="line">  <span class="keyword">return</span> *p1 &lt; *p2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::function</code> 的版本，首先看着非常啰嗦。除此之外，还有一些背后的差异。</p><p>第一点是，<code>std::function</code> 比 <code>auto</code> 的版本，更占用内存。<code>auto</code> 在类型推导后，和它的实际类型的占用空间是一致的，而 <code>std::function</code> 是一个模板函数，它的大小是固定的（不依实际类型而变化），除了其本身，还包含固定大小的闭包变量。如果固定的内存并不够用，编译器就会生成在堆上分配额外空间来存储闭包变量，也就导致了更多的内存开销。</p><p>第二点是，<code>std::function</code> 通常不会内联，所以结合第一点，也就会更慢。</p><h3 id="案例-2：遗漏类型修饰导致性能开销"><a href="#案例-2：遗漏类型修饰导致性能开销" class="headerlink" title="案例 2：遗漏类型修饰导致性能开销"></a>案例 2：遗漏类型修饰导致性能开销</h3><p>以下代码中，我们在一个循环中对 <code>unordered_map</code> 的容器做遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt; &amp;p : m) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>实际上，变量 <code>m</code> 的类型写错了，因为字典的键值应该是 <code>const</code>，所以其类型应该是 <code>std::unordered_map&lt;const std::string, int&gt;</code>。</p><p>这种错误编译器可以处理，它会在遍历键值对时，主动一个个将键值类型转换为 <code>const std::string</code>，实现方法是重新拷贝一份，再将拷贝后的 <code>const</code> 版本和 <code>p</code> 绑定在一起。<br>这就带来了性能开销。</p><p>使用 <code>auto</code> 既安全又简洁地解决了这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : m) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="条款-6：当-auto-推导不符合时，使用显式类型的初始化"><a href="#条款-6：当-auto-推导不符合时，使用显式类型的初始化" class="headerlink" title="条款 6：当 auto 推导不符合时，使用显式类型的初始化"></a>条款 6：当 auto 推导不符合时，使用显式类型的初始化</h2><p>大多数情况下，auto 推导出来的类型，和实际我们希望它应该是的类型是一致的。<br>但有一种情况是例外。讨论以下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个函数声明，返回 vector&lt;bool&gt; </span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget &amp;w)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是对函数的使用 </span></span><br><span class="line">Widget w; </span><br><span class="line"><span class="type">bool</span> res = <span class="built_in">features</span>(w)[<span class="number">5</span>];   <span class="comment">// 获取第 5 个 bit 的 bool </span></span><br><span class="line"><span class="built_in">processWidget</span>(w, res);       <span class="comment">// 使用返回的 bool</span></span><br></pre></td></tr></table></figure><p>这个代码没有任何问题，但如果我们将使用 <code>features</code> 的代码改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = <span class="built_in">features</span>(w)[<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">processWidget</span>(w, res);   <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure><p>问题就出现了。</p><p>表面原因可能很容易理解，如果了解过一些 <code>std::vector</code> 的知识，就会知道，获取 <code>std::vector&lt;bool&gt;</code> 的元素，并不会直接返回 <code>bool</code>。C++ STL 中，<code>std::vector&lt;bool&gt;</code> 的 <code>operator[]</code> 操作，返回的是一个特别的类型，<code>std::vector&lt;bool&gt;::reference</code>。也就是说，<code>auto</code> 类型推导的结果并不是 <code>bool</code>，而是 <code>std::vector&lt;bool&gt;::reference</code> 类型。</p><p>这是因为，通常 <code>operator[]</code> 操作返回的应该是某个元素的引用，而 C++ 中不允许对位进行引用，所以设计了这样一种结构。类似的问题也存在于 <code>std::bitset</code> 中。</p><p>由于 <code>std::vector&lt;bool&gt;::operator[]</code> 返回的是 <code>std::vector&lt;bool&gt;::reference</code> 类型，而后者的实现，有可能是一个指向 word 字内存的引用和一个字中位的偏移（<code>std::vector&lt;bool&gt;</code> 中使用 word 字来保存每个 bit）。</p><p>另外，我们注意到，<code>features(w)</code> 返回的实际是一个临时对象，那么，当临时对象被销毁时，<code>std::vector&lt;bool&gt;::reference</code> 中的内存引用就会失效，这个失效即发生在 <code>auto res</code> 被初始化后，从而导致下一行代码出现悬挂引用。</p><p>如果不使用 <code>auto</code>，使用 <code>bool</code> 指定实际类型，就不会有这个问题，原因是 <code>std::vector&lt;bool&gt;::reference</code> 实现了向 <code>bool</code> 的隐式类型转换。<code>std::vector&lt;bool&gt;::reference</code> 这种结构被称为<strong>代理类</strong>，在 C++ 实践中其实广泛存在，最常见的就是 <code>std::shared_ptr&lt;T&gt;</code>和 <code>std::unique_ptr&lt;T&gt;</code>。如果使用 <code>auto</code> 来推导返回代理类类型的对象类型，便会发生上述问题。</p><p>既想使用 <code>auto</code> 还想解决这个问题的办法，只能是使用显式的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = std::<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>这种写法相比于最开始 <code>bool res = features(w)[5]</code> 的写法，是更值得推荐的，原因是，它可以显式表达出来这种类型转换，不容易引起错误。事实上，<code>static_cast</code> 总是应该被推荐的，任何隐式类型转换，都可能引入潜在的问题，而迷惑程序员。</p><p>这可能是唯一一个会阻碍你使用 <code>auto</code> 的理由，我认为这也是 C++ 设计的一个遗憾，能做的就是，在编码时，使用 <code>auto</code> 但不要忽视类型，C++ 依然是一个强类型语言。另外，对这种常见的代理类要有足够的敏感度，比如获取 <code>std::vector&lt;bool&gt;</code> 的元素，获取 <code>std::bitset</code> 的位，获取智能指针的原始裸指针。</p><p><em>陷阱：auto 固然好用，但不是万能的，使用 auto 时，时刻还需要留意背后推导的类型是什么。</em></p><hr><p>这一章比较短，也没有什么难以理解的内容，更多的是一种编程习惯。<br>本系列其他文章：</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1932162651242340425">https://zhuanlan.zhihu.com/p/1932162651242340425</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ 读书笔记：类型推导</title>
    <link href="https://p2tree.top/posts/9bb75fe1.html"/>
    <id>https://p2tree.top/posts/9bb75fe1.html</id>
    <published>2025-06-17T23:33:14.000Z</published>
    <updated>2025-07-25T15:07:55.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先开一小节介绍下我写这个的缘由。</p><p>很多年前，看过《Effective C++》，是一本好书，把一些 C++ 的细节抽出来深入探索，能学到好多东西。不过，这本书太老了，里边一些内容需要更新，著书时应该 C++14 还没出。前段时间工作有点空，就看了《Effective Modern C++》，可以认为是前者的重构版，引入了一些更新的 C++ 规范，如果你两本书都没看过，那只推荐去看《Effective Modern C++》。</p><p>然而，虽然两本书的原作者都是 Scott Meyers，但译者却不是同一个人，《Effective C++》的译者侯捷老师的翻译非常出色，然而，我在阅读《Effective Modern C++》时，却感到晦涩难懂。我不知道是我的理解能力不足，还是译者的中文水平有限，阅读时让我不得不找出英文原文，对照着理解一些中文版云里雾里的内容。</p><p>网络上除了官方出版的这个中译版，还有一些积极地团体对该著作重新翻译，所以我大不可能去做重复的事情。以下这个系列文章，只是我阅读笔记的整理。整理笔记可以梳理思路，发现理解的漏洞，并温习知识，甚至，还能发现一些书中的小错误，是大有脾益的。</p><p>如果你打算阅读这份笔记，我很欣慰，但我还是建议你如果有时间有精力，去阅读原著。我的笔记中会省略掉很多重复的、用于前后衔接的、以及众所周知的内容，而只整理出作者想要强调的部分。该系列书籍的内容采用罗列一些常用的 C++ 技巧而成文，每一条都称为一个条款，我将以相同的结构整理。我也适当地调整了条款的标题，正文的结构顺序和示例代码（通常改地更简单），并将值得关注的细节摘出高亮，唯一的目的就是让重点更突出，更快速地吸收知识。</p><p>摘录的重点分为<strong>技巧</strong>、<strong>陷阱</strong>和<strong>谬误</strong>，技巧是指可以学习并应用在工程实践中小 tip，陷阱是指容易在工程实践中犯错，导致程序 bug 的要点，谬误呢，是可能对 C++ 知识的错误理解。这些内容除了在正文中出现时列出，我还会在最后一章中单独列出，作为一个 check list 使用。</p><h2 id="条款-1：理解模板类型推导"><a href="#条款-1：理解模板类型推导" class="headerlink" title="条款 1：理解模板类型推导"></a>条款 1：理解模板类型推导</h2><p>模板是泛型的一种体现。编译器在对模板做实例化时，其中一部分工作就是将泛型推导为实际的类型。<br>对于不同的情况，C++ 规范要求的模板类型推导方式略有差别，这也就导致了可能产生的误解和陷阱。</p><p>为什么要了解模板类型推导？这里给出书中一个有意思的例子。<br>提问，如果在声明一个数组 A 时，通过另一个未知长度的数组 B 的长度，作为数组 A 的长度，应该怎么做？<br>答案是可以利用模板类型推导，来静态推导出数组 B 的长度。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模板函数可以返回任意一个数组的长度 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> N; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 假设 arrayB 是一个未知长度的数组（注意是数组，不能是指针） </span></span><br><span class="line"><span class="comment">// arrayA 声明长度一定和 arrayB 相同 </span></span><br><span class="line"><span class="type">int</span> arrayA[<span class="built_in">arraySize</span>(B)];</span><br></pre></td></tr></table></figure><blockquote><p><strong>技巧</strong>：使用模板类型推导方法，可以在函数内推导出数组实参的长度。</p></blockquote><h3 id="情况-1：ParamType-是指针或引用，但不是万能引用"><a href="#情况-1：ParamType-是指针或引用，但不是万能引用" class="headerlink" title="情况 1：ParamType 是指针或引用，但不是万能引用"></a>情况 1：ParamType 是指针或引用，但不是万能引用</h3><p>一个简单的模板示例代码如下，后续会基于这个示例代码做分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数声明 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数的调用 </span></span><br><span class="line"><span class="built_in">f</span>(expr);</span><br></pre></td></tr></table></figure><p>模板函数声明中，<code>T</code> 和 <code>ParamType</code> 可能是相同类型，也可能是不同类型，<code>ParamType</code> 是看到的代码所显示的类型，而 <code>T</code> 是编译器实际推导的类型。<code>expr</code> 为实参，<code>param</code> 为形参。</p><p>情况 1 的类型推导规则是：</p><ol><li>去掉指针或引用类型</li><li>剩余部分做模式匹配</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = x; </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T 类型是 int, param 类型是 int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T 类型是 const int, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T 类型是 const int, param 类型是 const int&amp; </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(x);  <span class="comment">// T 类型是 int, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">g</span>(cx); <span class="comment">// T 类型是 int, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">g</span>(rx); <span class="comment">// T 类型是 int, param 类型是 const int&amp;</span></span><br></pre></td></tr></table></figure><h3 id="情况-2：ParamType-是万能引用"><a href="#情况-2：ParamType-是万能引用" class="headerlink" title="情况 2：ParamType 是万能引用"></a>情况 2：ParamType 是万能引用</h3><p>这里不介绍什么是万能引用，它的形参声明方式类似右值引用。<br>类型推导规则是：</p><ol><li>如果实参是左值，<code>T</code> 和 <code>param</code> 都会推导为左值引用。这是模板类型推导中，唯一一种会推导出引用类型的情况</li><li>如果实参是右值，则按情况 1 处理</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// 这是万能引用 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = x; </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T 类型是 int&amp;, param 类型是 int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T 类型是 const int&amp;，param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T 类型是 const int&amp;, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// 因为 27 是右值，按规则 1 处理，T 类型是 int，param 类型是 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="情况-3：ParamType-非指针和引用"><a href="#情况-3：ParamType-非指针和引用" class="headerlink" title="情况 3：ParamType 非指针和引用"></a>情况 3：ParamType 非指针和引用</h3><p>按值传递的类型推导规则是：</p><ol><li>如果实参有指针和引用类型，去掉指针或引用类型</li><li>如果是 cv 类型（const 或 volatile，下同），忽略 cv 类型。这是唯一会被忽略的情况</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = x; </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T 类型是 int, param 类型是 int </span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T 类型是 int, param 类型是 int </span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T 类型是 int，param 类型是 int</span></span><br></pre></td></tr></table></figure><h3 id="实参类型退化"><a href="#实参类型退化" class="headerlink" title="实参类型退化"></a>实参类型退化</h3><p>数组类型和指针类型在编译器里是不相同的，我们经常混淆两者，是因为数组类型会在一些场合退化为指针类型，比如传参时。</p><p>但如果我们传参时，就是想传入数组类型（带有数组长度），而不是指针类型，其实也是有办法的，前边已经给出示例，也就是用引用类型来传递。</p><blockquote><p><strong>谬误</strong>：不要混淆数组类型和指针类型，它是 C++ 兼容 C 语言的一些遗迹。</p></blockquote><p>另外，函数类型通过传参后，默认也会退化为函数指针。如果想要保留推导为函数类型，也可以按引用传递。</p><h2 id="条款-2：理解-auto-类型推导"><a href="#条款-2：理解-auto-类型推导" class="headerlink" title="条款 2：理解 auto 类型推导"></a>条款 2：理解 auto 类型推导</h2><p>绝大多数 <code>auto</code> 类型推导的规则，和模板类型推导的规则是完全一致的，它也同样遵守 <strong>条款1：理解模板类型推导</strong> 涉及到的 3 个规则。</p><p>只有一个例外。</p><p>当使用 C++11 中引入的初始化列表来初始化 auto 类型时，不符合上述规则。</p><p>先看个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下显式声明为 int 的变量，它们的类型显然都是 int </span></span><br><span class="line"><span class="type">int</span> x1 = <span class="number">27</span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>; </span><br><span class="line"><span class="type">int</span> x3 = &#123;<span class="number">27</span>&#125;; <span class="comment">// 这是统一初始化方式 </span></span><br><span class="line"><span class="type">int</span> x4&#123;<span class="number">27</span>&#125;;    <span class="comment">// 这个也是统一初始化方式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但以下使用 auto 来声明的变量，类型不一致 </span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;   <span class="comment">// 类型为 int </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;    <span class="comment">// 类型为 int </span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;; <span class="comment">// 类型为 std::initializer_list&lt;int&gt;，值为 &#123;27&#125;，注意，带大括号 </span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;    <span class="comment">// 同 x3</span></span><br></pre></td></tr></table></figure><p>这条规则是：<strong>当</strong> <strong><code>auto</code></strong> <strong>类型推导时，变量的初始化表达式是通过大括号括起来时，<code>auto</code></strong> <strong>的推导结果类型是</strong> <strong><code>std::initializer_list</code>。</strong></p><p>而我们注意到，<code>std::initializer_list</code> 是一个模板，所以初始化表达式下的 <code>auto</code> 类型推导，实际发生了两次类型推导，第一次是推导变量类型是 <code>std::initializer_list</code>，第二次是推导初始化列表类型的模板类型，比如上例中的 <code>int</code>。所以，下边这种初始化会推导失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译失败，因为 std::initizalizer_list 的模板参数类型推导失败（int 还是 double？） </span></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>类似的，将初始化表达式传递给一个模板函数，模板函数的模板类型也会推导失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 </span></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(std::initializer_list&lt;T&gt; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以推导成功，T 的类型是 int </span></span><br><span class="line"><span class="built_in">g</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>陷阱</strong>：C++11 中，auto 推导初始化列表类型时，会推导为 std::initializer_list，其本意可能并非如此。</p></blockquote><p>另外，C++14 中支持了使用 <code>auto</code> 来推导函数返回值或 lambda 表达式的形参类型。然而其本质依然是模板类型推导，所以如果函数返回值和 lambda 表达式参数给定的是初始化列表，同样无法完成推导。</p><h2 id="条款-3：理解-decltype"><a href="#条款-3：理解-decltype" class="headerlink" title="条款 3：理解 decltype"></a>条款 3：理解 decltype</h2><p><code>decltype</code> 是一个古老的语法，它可以获得一个名字（变量、函数等）或者表达式的类型。<br>在工程应用中，它常用于指代那些函数返回值类型需要依赖参数类型来决定的模板函数。比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">access</span><span class="params">(Container &amp;c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(c[i])</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回一个任意容器中一个元素的类型，类型推导通过 <code>decltype</code> 和函数返回值尾序声明的语法来完成。</p><p>但它存在一个问题，从 <strong>条款2：理解 auto 类型推导</strong> 中，我们知道，<code>auto</code> 作为模板函数返回值时，会忽略引用类型，所以，这个函数只能返回一个右值。如果我们希望操作容器中的原始元素，就无能为力了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; </span><br><span class="line"><span class="built_in">access</span>(vec, <span class="number">1</span>) = <span class="number">0</span>; <span class="comment">// 错误，右值不能被赋值</span></span><br></pre></td></tr></table></figure><h3 id="推导返回引用类型"><a href="#推导返回引用类型" class="headerlink" title="推导返回引用类型"></a>推导返回引用类型</h3><p>上边的问题，在 C++14 中，可以利用 <code>decltype</code> 做到，一种比较奇怪的语法。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">access</span><span class="params">(Container &amp;c, Index i)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>decltype(auto)</code> 可以在 <code>auto</code> 类型推导的规则下，不忽略引用性，从而使模板函数的返回值为一个引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; </span><br><span class="line"><span class="built_in">access</span>(vec, <span class="number">1</span>) = <span class="number">0</span>; <span class="comment">// 正常编译</span></span><br></pre></td></tr></table></figure><h3 id="巧用万能引用实现传递原始引用类型"><a href="#巧用万能引用实现传递原始引用类型" class="headerlink" title="巧用万能引用实现传递原始引用类型"></a>巧用万能引用实现传递原始引用类型</h3><p>上述办法可以让模板函数返回左值，但为了同时可以支持左值返回值和右值返回值类型，只能通过重载写两套代码。</p><p>但如果你了解万能引用，那么就知道他可以只写一套代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">access</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 C++14 的版本，C++11 中不支持 <code>decltype(auto)</code>，可以改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">access</span><span class="params">(Container&amp;&amp; c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(std::forward&lt;Container&gt;(c)[i])</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>技巧</strong>：使用万能引用和完美转发来实现传递引用性。</p></blockquote><h3 id="另外一个话题"><a href="#另外一个话题" class="headerlink" title="另外一个话题"></a>另外一个话题</h3><p>抛开上边的话题，单独聊一下 <code>decltype(auto)</code>，它的使用需要注意一个细节。</p><p>decltype 对简单变量的名字（变量名字是左值表达式）做推导时，会给出类型本身（非引用类型），但如果是复杂一些的左值表达式，比如把变量名字放在小括号里，就会推导出左值引用类型。这可能导致一些潜在的问题。</p><p>比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f1 的返回值类型是 int </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// f2 的返回值类型是 int&amp; </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> (x); <span class="comment">// 因为 (x) 是一个表达式 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>陷阱</strong>：用 decltype 推导复杂的左值表达式时，会推导出左值引用类型。</p></blockquote><h2 id="条款-4：掌握查看类型推导结果的方法"><a href="#条款-4：掌握查看类型推导结果的方法" class="headerlink" title="条款 4：掌握查看类型推导结果的方法"></a>条款 4：掌握查看类型推导结果的方法</h2><p>除了使用编辑器的功能来显示名字的类型之外，C++ 提供了运行时的类型信息以及可操作的方法，即 <code>typeid()</code>。</p><p>大多数情况下，它运行地很好。但需要注意有些场景下，它可能输出让你意外的结果。</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span> </span>&#123;  </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl; </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;param = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是哪个编译器，两个名字的类型都被推导为相同类型。但从代码中直观的看，<code>param</code> 类型应该总会比 <code>T</code> 多一个常量引用修饰才对。</p><p>编译器是正确的，实现符合 C++ 标准。所以这只能在使用时多留意。</p><p>boost 库提供了一个替代工具，可以推导出直观的类型，使用 <code>boost::typeindex::type_id_with_cvr</code> 来代替 <code>typeid</code> 即可。</p><blockquote><p><strong>陷阱</strong>：谨慎使用 typeid 来推导类型，可能会得到不预期的结果。</p></blockquote><hr><p>第一章结束了，如果有什么疑问或错误，请不吝指出。作者把类型推导作为第一章的内容，实话说有点劝退 C++ 新人，不过，这部著作确实也不适合新人阅读，适当的门槛也没问题。当然，最重要的是，类型推导实在太重要了，它一定程度上，可以作为 modern C++ 的基础去看待，后边很多问题都和类型推导有关系。</p><p>后续章节的内容也都准备好，整理格式后会陆续发出。</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1916895541884858605">https://zhuanlan.zhihu.com/p/1916895541884858605</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Chapter.152 鉴别网络信息</title>
    <link href="https://p2tree.top/posts/6fa98d5.html"/>
    <id>https://p2tree.top/posts/6fa98d5.html</id>
    <published>2025-05-21T21:27:30.000Z</published>
    <updated>2025-07-25T15:07:55.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>创造信息的门槛变低了。曾经，只有有学识的人才能教授和传播知识；后来，越来越多的人可以投稿和写书；现在，一个没有背景和知识积累的人，也可以创造出传播力远大于曾经的信息，比如软文，短视频，直播，播客等等。</p><p>门槛变低的后果就是，信息的质量变差了，良莠不齐，如果没有一定辨别信息准确性和价值的判断力，就会被信息海洋淹没，浪费掉自己的注意力，甚至带来错误的引导。</p><p><em><strong>永远不要随便把网上看到的信息当做真理，只有经得起推敲的道理才是真理。</strong></em></p><p><img src="https://img.p2tree.top/2025/5/21/Chapter.152.webp" alt="Chapter.152"></p><hr><div class="note primary flat"><p>封面图片来自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/eTP3i0G3mIK7B6KUjcCyiA">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="网络安全" scheme="https://p2tree.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：SmallSet</title>
    <link href="https://p2tree.top/posts/8a9047b8.html"/>
    <id>https://p2tree.top/posts/8a9047b8.html</id>
    <published>2025-04-27T23:43:26.000Z</published>
    <updated>2025-07-25T15:07:55.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本系列文章以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><p>在现代编程语言开发中，集合（Set）是一种非常有用的数据结构，它可以高效存储唯一元素。本文介绍一种更轻量级的集合实现：<code>SmallSet</code>。它非常适合存储少量元素，同时保持出色的性能和内存效率。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>SmallSet</code> 是一种小型集合类型，它实现了基本的集合操作，比如插入、删除和查找等。它的设计目标是优化在存储小规模数据时的性能和内存占用，它结合了小对象优化和动态内存调节技术，非常适合频繁访问的小集合场景。<br>如果你已经对 <code>SmallVector</code> 有了解，那么 <code>SmallSet</code> 和它有着类似的实现思路。</p><p><code>llvm::SmallSet</code> 定义在 <code>llvm/ADT/SmallSet.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N, <span class="keyword">typename</span> C = std::less&lt;T&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> SmallSet;</span><br></pre></td></tr></table></figure><p>当集合中存储的元素数量少于模板参数 <code>N</code> 时，将采取更优化的存储策略；如果数量超出指定范围后，采用和 <code>std::set</code> 一样的实现方案（事实上，其内部直接调用了 <code>std::set</code> 来管理数据）。<br>并不建议给 <code>N</code> 的值过大，所以在实现中，限制了 <code>N &lt;= 32</code>，因为小对象优化利用了 <code>SmallVector</code> 来管理数据，其搜索效率是线性的，如果数据量过大，则会失去作为集合的高效查找的属性。如果希望管理更多的数据，使用 <code>DenseSet</code> 是一个替代的方案。<br>第三个模板参数是自定义比较函数，默认是使用 <code>std::less</code>，它将用于在集合内部做元素排序和查找时的比较规则，它会传给内部管理数据的 <code>std::set</code> 使用。我们知道，集合内部通常使用平衡二叉树来优化检索效率，所以需要元素比较算法的支持。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>关联容器：和 <code>std::set</code> 一样，<code>SmallSet</code> 满足符合集合类型的特征。</li><li>小规模数据优化：<code>SmallSet</code> 内部使用了一个 <code>SmallVector</code> 来存储少量数据（小于 32 个），从而在小规模数据时，避免了构建和维护二叉树结构带来的性能开销。</li><li>操作一致：它和 <code>std::set</code> 拥有一样的操作接口。</li></ul><h3 id="与标准库-set-的对比"><a href="#与标准库-set-的对比" class="headerlink" title="与标准库 set 的对比"></a>与标准库 set 的对比</h3><ul><li>性能优势：在数据量较小时，由于不会涉及到分配二叉树结构和自平衡等开销，性能会优于 <code>std::set</code>。</li><li>退化时性能损失：当容器中存储元素超出给定值后，需要将原来的数据拷贝或移动到 <code>std::set</code> 容器中，这带来了瞬时的性能下降。所以，需要谨慎决定 <code>N</code> 的大小。</li><li>可能浪费空间：当数据量较小时，<code>SmallSet</code> 采用 <code>SmallVector</code> 作为内部的数据存储类型，如果 <code>N</code> 值大于实际存储的元素数量，会带来空间浪费。</li><li>只适合小规模数量集合：它适合使用在简单场景，尤其是基本明确容量，且需要快速创建和销毁集合时。尽量让其工作在小数据优化状态，当数据量较大时，使用 <code>std::set</code> 更合适。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>整个 <code>SmallSet</code> 的主要成员有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N, <span class="keyword">typename</span> C = std::less&lt;T&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> SmallSet &#123;   </span><br><span class="line">  SmallVector&lt;T, N&gt; Vector; <span class="comment">// 用来存储小规模数据   </span></span><br><span class="line">  std::set&lt;T, C&gt; Set; <span class="comment">// 数据量超出 N 后，存放数据 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/SmallSet.h</code> 中的代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>使用默认构造函数，因为我们不会在构造集合时初始化整个集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmallSet&lt;<span class="type">int</span>&gt; theSet;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>因为有两个存储位置，所以我们不得不为这个容器类型实现自己的迭代器。使用方法和常规迭代器相同，支持 <code>begin()</code> <code>end()</code> 访问元素。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;const_iteraotr, <span class="type">bool</span>&gt; ret = theSet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>如果插入元素时，是小数据模式，便手动实现一个不含重复元素的 <code>SmallVector</code> 插入；否则，直接插入 <code>std::set</code>，如果 <code>SmallVector</code> 容量超出 <code>N</code>，则将 <code>SmallVector</code> 中全部数据转移到 <code>std::set</code> 中。<br>返回一个 <code>std::pair</code>，第一个值是指向这个元素的迭代器，第二个值是标记是否插入成功，如果插入失败，表示相同值已存在，第一个值将是指向那个相同值的迭代器。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theSet.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>和插入相反的动作，但数据量缩减到小于 <code>N</code> 并不会退化回小数据优化模式。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> existed = theSet.<span class="built_in">contains</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> elements = theSet.<span class="built_in">size</span>(); </span><br><span class="line"><span class="keyword">auto</span> ele = theSet.<span class="built_in">count</span>(<span class="number">10</span>); <span class="comment">// 因为是集合，只会返回 0 或 1，表示这个元素值的数量</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>支持几种比较运算符的使用。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不保证异常安全"><a href="#不保证异常安全" class="headerlink" title="不保证异常安全"></a>不保证异常安全</h3><p><code>SmallSet</code> 不是异常安全的。和标准库 <code>std::set</code> 不同。</p><h3 id="不合适的预分配大小"><a href="#不合适的预分配大小" class="headerlink" title="不合适的预分配大小"></a>不合适的预分配大小</h3><p>和 <code>SmallVector</code> 一样，在声明类型时，如果给定的 <code>N</code> 值相对较大，会存在内存空间的浪费；但如果给定的值过小，又发挥不出 <code>SmallSet</code> 容器的性能优势，反而带来性能下降。</p><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>虽然集合容器作为一种非线性容器，不会在插入和删除元素时，导致其他迭代器失效，但我们应该注意到 <code>SmallSet</code> 中存在 <code>SmallVector</code> 和数据量变大导致内存扩展时的问题。所以，<code>SmallSet</code> 中的操作是可能导致迭代器失效的。</p><h3 id="元素为指针类型"><a href="#元素为指针类型" class="headerlink" title="元素为指针类型"></a>元素为指针类型</h3><p><code>SmallSet</code> 的实现中，特别针对当元素类型 <code>T</code> 为指针类型时，一种特化的实现方案，它将完全采用 <code>SmallPtrSet</code> 来实现。后者拥有前者的所有特质，区别在于，当发生内存扩展时，它的实现是一个哈希表（而没有使用 <code>std::set</code>）。因为指针和普通元素的一个区别是，指针不需要排序，且比较代价更大，如果做动态再平衡，开销比普通元素更大。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="不适合存储大量数据"><a href="#不适合存储大量数据" class="headerlink" title="不适合存储大量数据"></a>不适合存储大量数据</h3><p>首先，模板参数 <code>N</code> 不能超过 32，否则会导致编译失败，<code>N</code> 值较大时，检索元素的效率会降低（<code>SmallVector</code> 中线性查找复杂度），所以实现上强行约束了最大值。<br>其次，它本身也不适合存储大量元素，尽量避免存储超出 <code>N</code> 值的元素数量。大量数据时，它使用 <code>std::set</code> 管理数据，反而还带来了当数据扩展时的瞬时性能下降问题。</p><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>添加和删除元素会带来性能开销，一方面是保证元素唯一性和当数据量较大时 <code>std::set</code> 的再平衡开销，另一方面时当数据扩展时（添加元素），所有 <code>SmallVector</code> 元素复制或移动到 <code>std::set</code> 的开销。<br>当插入数据的数量少于 <code>N</code> 时，不会带来动态分配开销，因为构造时已经分配了 <code>N</code> 这么大的内存。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>SmallVector</code>：和 <code>SmallSet</code> 设计初衷和思路相同的顺序型可变长数组容器，见：<a href="https://zhuanlan.zhihu.com/p/28641819827">学习 LLVM 数据结构：SmallVector</a></li><li><code>SmallPtrSet</code>：管理指针类型的 <code>SmallSet</code> 变体。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallset-h">LLVM Programmer’s Manual</a></li><li><a href="https://en.cppreference.com/w/cpp/container/set">cppreference set</a></li><li>LLVM 16.0 源码</li><li>LLVM 20.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1899164450520536088">学习LLVM数据结构-SmallSet - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：南京大屠杀</title>
    <link href="https://p2tree.top/posts/1e952ac7.html"/>
    <id>https://p2tree.top/posts/1e952ac7.html</id>
    <published>2025-04-26T23:25:26.000Z</published>
    <updated>2025-07-25T15:07:55.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忘记历史的人，就一定会重蹈覆辙，这既是指日本人忘记过去会再次犯错，更是指中国人忘记过去，会让历史重演。张纯如老师一生最伟大的这部作品，最大的价值就在于，让距离那场灾难将近 100 年后的现代人，能再次回顾那段不堪往事，能不忘国耻，能时刻谨记身为这个民族的一员，所应该承担的责任和价值。</p><p>这本书相当地克制，换作我，无论如何也做不到保持理性和客观地介绍当时的情况，从日本人的角度、中国人的角度、西方人的角度去展现事实。虽然我已经对南京大屠杀有过了解，也参观过南京大屠杀遇难同胞纪念馆，但读完本书，还是收获很多。</p><p>南京是当时中国的首都，在南京发生这种事情，远比当时其他惨剧影响更恶劣。而南京大屠杀只是日本发动侵华战争中，犯下的其中一个罪行，类似的悲剧也在其他城市和乡村发生。书中提到，就仅仅是日本士兵在向南京进发时，途径苏州，在短短几天内，苏州 35 万人口，锐减到不足 500 人。</p><p>书中给我留下深刻印象的是拉贝前辈，我曾听说过他是大屠杀发生时的一个异国志士，但没想到帮助他能保护中国人民的重要力量是他的政党，纳粹党。同一时期，纳粹在欧洲大陆上开展种族屠杀，在亚洲大陆上却在进行着一场人道救援，这让我反省，个人的光辉是否总会被集体所掩盖？除了拉贝，还有一些国际友人，在危险的那段日子，和中国人共存亡，他们突破了个人和民族的限制，成为真正站在光里的人，为那段黑暗的故事，带来希望。</p><p>当我看到日本神道教所推崇的，只有天皇和其子民才是上等民族时，让我想到现在的犹太人，似乎必然是会被周围民族所鄙视和排斥的种族。在日本人眼中，中国人就像是虫子和动物，所以，他们在中国杀人，就像杀掉一头猪一样心安理得。为什么？因为懦弱！当几千个日本士兵进入拥有几十万人口的南京城时，中国人在撤退；当两三个日本人在开枪处决排成队的几十个中国人时，中国人呆若木鸡；当这座几千年历史的古城里，每时每刻都在发生着屠杀、抢劫、强奸和焚烧时，也只有很少人奋起反抗。这就是当时的中国。懦弱只会让敌人鄙视和肆无忌惮，而不会换来同情，渴求怜悯只会换来变本加厉，至少，在我们的日本邻居这里，一定是这样的。</p><p>研究这场灾难，不能不去研究日本这个民族，我始终认为，虽然是日本政府发动了战争，默许纵容了惨无人道的屠杀，但政府和皇族本质上都是一个民族，精神文化和传统认知是一样的，纯如老师在这里过于谨慎了，同样是战败国，同样是被法律审判的国家，德国对二战的忏悔和对纳粹的抵制，已经成为一种文化，甚至是政治正确，但日本却没有道歉和赔款，而是把二战战犯供奉在靖国神社。而现在的中国人，似乎已经在主动原谅曾经的敌人。</p><p>每个中国人都应该去了解这段历史，读读这本书，如果没有勇气读下去，就没有勇气在未来保护自己的家庭，自己的人民和自己的国家。日本人用被原子弹攻击来包装自己是受害者，而且他们的文化影响力也在影响着中国的年轻一代，每个作为父母的中国人，都应该把那段屈辱的历史讲给孩子听，让他们树立正确的是非观。</p><p>如今的南京，是国际知名的大都市，时代在发展，新的城市在旧城上生长出来，历史逐渐被埋入泥土中，如果没有那些客观理性的历史学家们，很多故事都会被永远尘封。纯如老师，向您致敬 ！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="历史" scheme="https://p2tree.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：StringRef</title>
    <link href="https://p2tree.top/posts/a198516a.html"/>
    <id>https://p2tree.top/posts/a198516a.html</id>
    <published>2025-03-25T21:14:24.000Z</published>
    <updated>2025-07-25T15:07:55.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::StringRef</code> 定义在 <code>llvm/ADT/StringRef.h</code> 头文件中。 它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRef</span>;</span><br></pre></td></tr></table></figure><p>和 <code>ArrayRef</code> 类似，<code>StringRef</code> 是一种轻量级的字符串引用类型，它用于实现高效地表示和操作字符串数据，尤其是在一些高频处理字符串，但同时不希望维护实际内存开销地场景下。 它是不可变引用，主要用于向函数内传递字符串同时避免深拷贝。它只包含了指向字符串的指针和字符串的长度信息，从而使得对它的操作直接而高效。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>轻量级</strong>：只存储一个指向字符串的指针和字符串的长度，不存储实际的数据，所以拷贝时很高效。</li><li><strong>简单易用</strong>：支持许多常用的字符串操作，比如比较、查找和子串提取，使用很方便。</li><li><strong>操作一致</strong>：它的大多数操作，和标准库中 string 保持一致。</li></ul><h3 id="与标准库-string-对比"><a href="#与标准库-string-对比" class="headerlink" title="与标准库 string 对比"></a>与标准库 string 对比</h3><ul><li><strong>所有权</strong>：<code>StringRef</code> 是对字符串数据的引用，不拥有字符串的所有权。需要确保 <code>StringRef</code> 对象的生命周期，小于实际引用字符串的生命周期，否则会带来悬空引用。</li><li><strong>大小</strong>：<code>StringRef</code> 只占用很小的内存，和实际字符串相比可以忽略不计。<code>std::string</code> 不仅包括了指针、长度，还包括了数据的内存管理信息，它在内部维护了一个动态分配的缓存区来存储字符串内容。</li><li><strong>可变性</strong>：<code>StringRef</code> 是不可变的，它引用的内容不能被修改。而 <code>std::string</code> 则提供了完整的可操作空间。</li><li><strong>性能</strong>：<code>StringRef</code> 不涉及内存分配，在传递和使用时，具有更高的性能，特别是在函数传参时，可以避免深拷贝。而 <code>std::string</code> 在按值传参时，会对保存字符串的内存做完整的复制。现在编译器可以通过移动语义和短字符串优化等方式来减少深拷贝的性能开销，但整体上，传递引用还是要更轻量级。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>由于 <code>llvm::StringRef</code> 只拥有数据的引用，而不管理实际字符串的内存，所以它的结构很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>事实上，使用 <code>const std::string &amp;</code> 基本可以取代 <code>llvm::StringRef</code>，然而，<code>StringRef</code> 的另一个优势是，它提供了更多更易用的操作方法，比如 <code>split</code> 函数。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><code>StringRef</code> 可以方便地从字符串字面量、<code>std::string</code> 或 <code>char *</code> 指针来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串字面量初始化</span></span><br><span class="line">llvm::StringRef Str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串指针和长度来初始化</span></span><br><span class="line"><span class="type">char</span> *Cstr = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">llvm::StringRef Str2&#123;Cstr, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 std::string 来初始化</span></span><br><span class="line">std::string Sstr&#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">llvm::StringRef Str3&#123;Sstr&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供了迭代器 <code>begin()</code> 和 <code>end()</code>，以及返回字符指针的 <code>bytes_begin()</code> 和 <code>bytes_end()</code>，这是为了处理宽字符编码的字符串。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到字符串原始位置</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *Data = Str.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到字符串的长度</span></span><br><span class="line"><span class="type">bool</span> IsEmpty = Str.<span class="built_in">empty</span>();</span><br><span class="line"><span class="type">size_t</span> Length = Str.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> FirstChar = Str.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> LastChar = Str.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也支持任意的下标操作，越界用 assert 来检查</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> C = Str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str1, Str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否相等</span></span><br><span class="line"><span class="type">bool</span> IsEqual1 = Str<span class="number">1.</span><span class="built_in">equals</span>(Str2);</span><br><span class="line"><span class="type">bool</span> IsEqual2 = Str1 == Str2;</span><br><span class="line"><span class="type">bool</span> IsEqual3 = Str<span class="number">1.</span><span class="built_in">equals_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="comment">// 其他操作也有忽略大小写的版本，不再单独列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断大小，当结果小于、等于、大于时，值是 -1、0、1</span></span><br><span class="line"><span class="type">int</span> Cmp1 = Str<span class="number">1.</span><span class="built_in">compare</span>(Str2);</span><br><span class="line"><span class="type">int</span> Cmp2 = Str<span class="number">1.</span><span class="built_in">compare_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="type">int</span> Cmp3 = Str<span class="number">1.</span><span class="built_in">compare_numeric</span>(Str2);  <span class="comment">// 由数字字符组成的字符串，按数字来比较</span></span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>编辑距离（edit distance）是指将一个字符串完全改为另一个字符串时，所需要的最小单字符操作的次数。这些操作可以是： - 插入一个字符 - 删除一个字符 - 替换一个字符（分为将替换看作一次操作，还是看作两次操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str1, Str2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Distance1 = Str<span class="number">1.</span><span class="built_in">edit_distance</span>(Str2);</span><br><span class="line"><span class="type">int</span> Distance2 = Str<span class="number">1.</span><span class="built_in">edit_distance_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两个隐藏参数，第一个是替换被看作几次，默认是 1 次操作</span></span><br><span class="line"><span class="type">bool</span> AllowReplacements = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 第二个是最大编辑距离，如果编辑距离超过最大编辑距离，则返回最大编辑距离+1</span></span><br><span class="line"><span class="type">bool</span> MaxEditDistance = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Distance3 = Str<span class="number">1.</span><span class="built_in">edit_distance</span>(Str2, AllowReplacements, MaxEditDistance);</span><br></pre></td></tr></table></figure><h3 id="获取副本"><a href="#获取副本" class="headerlink" title="获取副本"></a>获取副本</h3><p>使用 <code>str()</code> 来获取一个 <code>std::string</code> 类型的副本。 使用 <code>string_view()</code> 来获取一个 <code>std::string_view</code> 类型的副本。 同时，也提供了 <code>copy</code> 函数，来获取一个 <code>StringRef</code> 的副本，但需要提供分配器，用于分配新的空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 包含 std::allocator</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/BumpPtrAllocator.h&quot;</span>  <span class="comment">// 包含 BumpPtrAllocator</span></span></span><br><span class="line"></span><br><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 C++ 的内存分配器</span></span><br><span class="line">std::allocator&lt;<span class="type">char</span>&gt; Alloc;</span><br><span class="line">llvm::StringRef NewStr1 = Str.<span class="built_in">copy</span>(ALloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 LLVM 的内存分配器</span></span><br><span class="line">llvm::BumpPtrAllocator BumpAlloc;</span><br><span class="line">llvm::StringRef NewStr2 = Str.<span class="built_in">copy</span>(BumpAlloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以自定义分配器，需要提供 Allocate&lt;&gt; 模板方法</span></span><br><span class="line"><span class="comment">// 使用时，需要确保分配器对象的生命周期超过 StringRef 对象，否则会带来引用失效问题</span></span><br></pre></td></tr></table></figure><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否开始于一个特定前缀字符</span></span><br><span class="line"><span class="type">bool</span> Ret1 = Str.<span class="built_in">starts_with</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="type">bool</span> Ret2 = Str.<span class="built_in">startswith</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否结束于一个特定后缀字符</span></span><br><span class="line"><span class="type">bool</span> Ret3 = Str.<span class="built_in">ends_with</span>(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"><span class="type">bool</span> Ret4 = Str.<span class="built_in">endswith</span>(<span class="string">&#x27;z&#x27;</span>);  <span class="comment">// 语法糖</span></span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规查找，返回下标位置，内部调用了 std::string_view::find()，当找不到时，返回 StringRef::npos，其值是 ~size_t(0)</span></span><br><span class="line"><span class="type">size_t</span> Ret1 = Str.<span class="built_in">find</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="comment">// 第二个隐藏参数是从什么位置开始查，默认是从 0（字符串开头）开始查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定查找条件</span></span><br><span class="line"><span class="type">size_t</span> Ret2 = Str.<span class="built_in">find_if</span>([](<span class="type">char</span> c) &#123; <span class="keyword">return</span> c &gt; <span class="string">&#x27;r&#x27;</span> &amp;&amp; c &lt; <span class="string">&#x27;x&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// 还有取反的 find_if_not</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向查找</span></span><br><span class="line"><span class="type">size_t</span> Ret3 = Str.<span class="built_in">rfind</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找是否包含特定字符</span></span><br><span class="line"><span class="type">bool</span> IsContain = Str.<span class="built_in">contains</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="comment">// 查找是否包含特定子串</span></span><br><span class="line">llvm::StringRef SubStr;</span><br><span class="line"><span class="type">bool</span> IsContainsSubStr = Str.<span class="built_in">contains</span>(SubStr);</span><br></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数特定字符出现的次数</span></span><br><span class="line"><span class="type">size_t</span> Cnt = Str.<span class="built_in">count</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将由数字字符组成的字符串，转换为整型，第一个参数是选择进制，置为 0 表示按 C 整形规则自动选择进制。若转换失败，会返回 true。</span></span><br><span class="line"><span class="type">int</span> Res;</span><br><span class="line">Str.<span class="built_in">getAsInteger</span>(<span class="number">0</span>, Res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 getAsInteger 类似，但会剔除开头的数字部分，如果开头不是数字，返回 true 表示失败。</span></span><br><span class="line"><span class="comment">// 实际上，是修改了指针位置，并没有改变字符串</span></span><br><span class="line">Str.<span class="built_in">consumeInteger</span>(<span class="number">0</span>, Res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串按大小写转换，并返回 std::string 类型</span></span><br><span class="line">std::string LowerStr = Str.<span class="built_in">lower</span>();</span><br><span class="line">std::string UpperStr = Str.<span class="built_in">upper</span>();</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取子字符串的操作，实际上是修改指针指向位置和长度的结果</span></span><br><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line">llvm::StringRef SubStr1 = Str.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 截取从 2 下标开始，长度为 3 的子串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前 N 个字符的子串</span></span><br><span class="line">llvm::StringRef SubStr2 = Str.<span class="built_in">take_front</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 删除前 N 个字符，返回剩余字符的子串，是 drop_front</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回后 N 个字符的子串</span></span><br><span class="line">llvm::StringRef SubStr3 = Str.<span class="built_in">take_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 同理，返回剩余字符的子串，是 drop_back</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果以给定前缀开头，删除该前缀，返回剩余字符子串</span></span><br><span class="line">Str.<span class="built_in">consume_front</span>(<span class="string">&quot;prefix&quot;</span>);  <span class="comment">// 在原始引用上操作</span></span><br><span class="line"><span class="comment">// 同理，还有给定后缀的 consume_back()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取任意子串</span></span><br><span class="line">llvm::StringRef SubStr4 = Str.<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 截取从 1 下标到 3 下标的子串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split 操作，即按给定字符来分割子串</span></span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair1 = Str.<span class="built_in">split</span>(<span class="string">&#x27;:&#x27;</span>);  <span class="comment">// 分成两个子串</span></span><br><span class="line">llvm::StringRef SeparatorStr = <span class="string">&quot;::&quot;</span>;</span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair2 = Str.<span class="built_in">split</span>(SeparatorStr);  <span class="comment">// 使用给定子字符串分隔子串</span></span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair3 = Str.<span class="built_in">rsplit</span>(SeparatorStr);  <span class="comment">// 从末尾开始搜索分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split 操作，所有都分隔</span></span><br><span class="line">llvm::SmallVector&lt;llvm::StringRef&gt; SplitStrs;</span><br><span class="line">Str.<span class="built_in">split</span>(SplitStrs, <span class="string">&quot;::&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// trim 操作</span></span><br><span class="line">llvm::StringRef TrimStr1 = Str.<span class="built_in">ltrim</span>(<span class="string">&#x27;\0&#x27;</span>);  <span class="comment">// 切掉左侧连续多个 &#x27;\0&#x27; 字符</span></span><br><span class="line">llvm::StringRef TrimStr2 = Str.<span class="built_in">ltrim</span>();  <span class="comment">// 切掉左侧连续多个空白字符</span></span><br><span class="line"><span class="comment">// 对应还有右侧版 rtrim 和 两侧版 trim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否包含 EOL 字符，EOL 字符是 end of line 标记</span></span><br><span class="line"><span class="type">bool</span> HasEOLStr = Str.<span class="built_in">detactEOL</span>();</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="引用失效"><a href="#引用失效" class="headerlink" title="引用失效"></a>引用失效</h3><p>和 <code>llvm::ArrayRef</code> 一样，<code>llvm::StringRef</code> 本身是一个引用类型，所以它会存在引用失效的风险。 另外，也不建议直接返回一个内部临时对象引用的 <code>llvm::StringRef</code> 类型，可以返回经过调整，但指向外部字符串的新的 <code>llvm::StirngRef</code> 类型。 它的生命周期一定要短于它所引用的字符串的生命周期，从而避免悬挂引用。</p><h3 id="不可修改"><a href="#不可修改" class="headerlink" title="不可修改"></a>不可修改</h3><p>它是对目标字符串的常量引用，所以不可以直接通过它修改目标字符串。不过，可以通过 <code>data</code> 来获取到它原始字符串的指针，从而去修改原始字符串，但这样存在一些潜在的风险，并不是推荐的做法。如果需要修改字符串，使用 <code>std::string &amp;</code> 可能更好。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p><code>llvm::StringRef</code> 并不处理字符编码问题，它能提供的最大能力就是使用迭代器时，可以选择按字符迭代，还是获得底层的字符指针，由开发者自己选择怎么解析。 所以，如果需要处理宽字符编码的字符串，需要额外做一些包装。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>llvm::StringLiteral</code>：处理字符串字面量的子类，高效管理字符串字面量。</li><li><code>llvm::ArrayRef</code>：顺序型容器的只读引用，见 <a href="https://p2tree.top/posts/cdf6959f.html">学习 LLVM 数据结构：ArrayRef</a>。</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/32410920552">学习LLVM数据结构-StringRef - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：SmallVector</title>
    <link href="https://p2tree.top/posts/e9ae65d7.html"/>
    <id>https://p2tree.top/posts/e9ae65d7.html</id>
    <published>2025-03-09T21:21:34.000Z</published>
    <updated>2025-07-25T15:07:55.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::SmallVector</code> 定义在 <code>llvm/ADT/SmallVector.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N = CalculateSmallVectorDefaultInlinedElements&lt;T&gt;::value&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVector;</span><br></pre></td></tr></table></figure><p><code>llvm::SmallVector</code> 是一个可变长数组，类似于 <code>std::vector</code>，同时它对较小长度的数组做了优化。<br>它的内存管理方式采用局部缓存的设计思路，在对象内部预留一小块空间，用于存储数据。当数据量超出预留空间的大小时，才会将数据放在堆上。它本身保存一部分元素，这便使得在小数组中，避免进行堆分配的操作，提高了效率。<br>注意到，它带有一个含默认值的模板参数 <code>N</code>，它用来指定预留空间的大小，默认不指定时，编译器会自动选择一个合理的阈值（通常考虑依据是栈空间的占用情况）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>顺序容器</strong>：<code>SmallVector</code> 是一个顺序容器，可以在末尾添加和删除元素，可以通过下标访问任意元素。</li><li><strong>小长度数组优化</strong>：它结合了定长数组在栈上快速分配和动态数组在堆上的灵活性，当管理的数据长度小于阈值（默认值或声明时给定值），会将数据保存在栈上，从而避免堆分配和内存管理带来的性能开销。</li><li><strong>操作一致</strong>：它的大多数操作，和 STL vector 保持一致。</li></ul><h3 id="与标准库-vector-的对比"><a href="#与标准库-vector-的对比" class="headerlink" title="与标准库 vector 的对比"></a>与标准库 vector 的对比</h3><ul><li><strong>性能优势</strong>：在数据量较小时，由于不会涉及到堆内存分配和管理的开销，性能会优于 <code>std::vector</code>。另外，它可以识别平凡可复制的特性，从而更细粒度地做内存管理。</li><li><strong>退化时的性能损失</strong>：当发生从栈到堆的退化时，<code>llvm::SmallVector</code> 会带来数据拷贝的开销。所以需要仔细考虑阈值的设定。</li><li><strong>可能浪费空间</strong>：<code>llvm::SmallVector</code> 会在定义时预分配设定的 <code>N</code> 的空间，如果实际数据少于 <code>N</code>，那么会存在空间浪费的问题。<code>std::vector</code> 也存在类似问题。</li></ul><h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p>简单的继承结构如：</p><p><img src="https://img.p2tree.top/2025/3/9/SmallVector-Derive-Structure.webp" alt="继承结构图"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVector</span> : <span class="keyword">public</span> SmallVectorImpl&lt;T&gt;, SmallVectorStorage&lt;T, N&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只用于管理一块内置数组 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorStorage</span> &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了大多数操作方法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorImpl</span> : <span class="keyword">public</span> SmallVectorTemplateBase&lt;T&gt; &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// SmallVectorTemplateBase 有两种模板类，分别针对类型是否时 POD 做实现 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> = (is_trivially_copy_constructible&lt;T&gt;::value) &amp;&amp; </span><br><span class="line">                             (is_trivially_move_constructible&lt;T&gt;::value) &amp;&amp; </span><br><span class="line">                             std::is_trivially_destructible&lt;T&gt;::value&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVectorTemplateBase : <span class="keyword">public</span> SmallVectorTemplateCommon&lt;T&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorTemplateBase</span>&lt;T, <span class="literal">true</span>&gt; : <span class="keyword">public</span> SmallVectorTemplateCommon&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不涉及 POD 的部分 </span></span><br><span class="line"><span class="comment">// 第二个模板参数是一个 dummy 参数，只用来解决当 ArrayRef 作为类型时，避免空长度时无法实例化的问题 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVectorTemplateCommon : <span class="keyword">public</span> SmallVectorBase&lt;SmallVectorSizeType&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最基础的类，管理几个数据成员，Size_T 是对类型 size 的推导 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Size_T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorBase</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>SmallVector</code> 继承自 <code>SmallVectorImpl</code> 和 <code>SmallVectorStorage</code>，其中 <code>SmallVectorImpl</code> 实现了大多数通用的操作代码和管理长度等属性的数据成员。它继承的 <code>SmallVectorTemplateBase</code>、<code>SmallVectorTemplateCommon</code> 和 <code>SmallVectorBase</code> 都是用来就完成模板实例化时的公共代码，这里先按下不表。<br><code>SmallVectorStorage</code> 实现了堆内联存储的静态数组的分配和管理，它是一个 POD 类型，只含有数据。这也有利于编译器为特定长度的数组做专门的优化。<br>通过这种分离，<code>SmallVectorImpl</code> 可以用于不同模板类的复用，而 <code>SmallVectorStorage</code> 又可以方便的做模板特化（不同的 <code>N</code>）。这样，减少了模板实例化时的实例化数量，降低了编译空间占用，提高编译效率，是一种在很多 C++ 工程中普遍用到的实现技巧。</p><p>我们再回头看 <code>SmallVectorImpl</code> 的继承结构，它的父类中，<code>SmallVectorBase</code> 作为最底层的类，提供了最基本的功能，包括类型的数据，比如 size 和 capacity，一些辅助函数和虚函数定义。它作为整个继承体系的根，定义了所有 <code>SmallVector</code> 最通用的接口和行为。<br><code>SmallVectorTemplateCommon&lt;T, void&gt;</code> 抽取了 <code>SmallVectorTemplateBase</code> 的实现，它实现了不依赖于 T 是否是 POD 类型的代码。而与 POD 类型相关的代码实现，放在了 <code>SmallVectorTemplateBase</code> 中。<br><code>SmallVectorTemplateBase</code> 针对的就是非平凡的类型，根据是否可复制、可移动，又实例化了不同的模板类。它在正确性和性能之间达成平衡，在避免错误的同时，为大多数非平凡类型提供在元素操作上的最优性能。</p><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>忽略多层级的继承结构，整个 <code>SmallVector</code> 中包含几个主要的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorBase</span> &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">  <span class="comment">// 指向向量中第一个元素的指针 </span></span><br><span class="line">  <span class="type">void</span> *BeginX; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向量内存空间的总长度   </span></span><br><span class="line">  <span class="type">size_t</span> Size; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预分配的空间大小   </span></span><br><span class="line">  <span class="type">size_t</span> Capacity; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这 3 个成员决定了索引数据和判断优化阈值。<br>另外，对于小长度数组，还需要分配内置的存储空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallVectorStorage</span> &#123; </span><br><span class="line">  <span class="built_in">alignas</span>(T) <span class="type">char</span> InlineElts[<span class="function">N * <span class="title">sizeof</span><span class="params">(T)</span>]</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列了部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/SmallVector.h</code> 文件代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的容器，inline storage 大小为 4 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec1; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数值和长度 </span></span><br><span class="line"><span class="function">llvm::SmallVector&lt;<span class="type">int</span>, 4&gt; <span class="title">vec2</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 包含 3 个值为 10 的元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec3 = vec2; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 vector 中构造 </span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; stdVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; </span><br><span class="line"><span class="function">llvm::SmallVector&lt;<span class="type">int</span>, 4&gt; <span class="title">vec4</span><span class="params">(stdVec.begin(), stdVec.end())</span></span>;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>和 <code>std::vector</code> 一样，也提供了前向迭代器和反向迭代器，以及对应带 const 的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向迭代器 </span></span><br><span class="line"><span class="keyword">for</span> (llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 前向迭代器 </span></span><br><span class="line"><span class="keyword">for</span> (llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); it != vec.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 range for loop </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ele : vec) &#123;</span><br><span class="line">  std::cout &lt;&lt; ele &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持下标进行随机访问 </span></span><br><span class="line">std::cout &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl; vec[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法，内部会做越界检查 </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  std::cout &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl; </span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range &amp;e) &#123; </span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>支持常见的几种比较运算符，其中，大于、小于操作的比较逻辑采用通用的序列比较算法，在序列长度相同时，比较对应元素的大小或字典序。</p><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><p>基础元素操作与 <code>std::vector</code> 相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 末尾添加元素 </span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除末尾元素 </span></span><br><span class="line">vec.<span class="built_in">pop_back</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入元素，需要元素移动，所以性能可能较差 </span></span><br><span class="line">vec.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// it 是一个有效的迭代器 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出指定位置元素，同样可能有性能问题 </span></span><br><span class="line">vec.<span class="built_in">erase</span>(it); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有元素 </span></span><br><span class="line">vec.<span class="built_in">clear</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回向量中元素的数量 </span></span><br><span class="line">vec.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回向量中的容量，也就是 Capacity 的值 </span></span><br><span class="line">vec.<span class="built_in">capacity</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为空 </span></span><br><span class="line">vec.<span class="built_in">empty</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变向量大小 </span></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">// 调整为 5 个元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留指定容量的内存 </span></span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>使用 <code>llvm::SmallVector</code> 容器，需要引入 <code>Support</code> 组件，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LLVM_LINK_COMPONENTS Support)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不保证异常安全"><a href="#不保证异常安全" class="headerlink" title="不保证异常安全"></a>不保证异常安全</h3><p><code>SmallVector</code> 本身并不是异常安全的。这一点和 <code>std::vector</code> 不同，标准库容器能保证异常安全性。</p><h3 id="不合适的预分配大小"><a href="#不合适的预分配大小" class="headerlink" title="不合适的预分配大小"></a>不合适的预分配大小</h3><p>如果在定义 <code>SmallVector</code> 时，指定栈上预分配容量 <code>N</code> 非常大，可能会导致栈溢出，需要根据实际情况选择合适的 <code>N</code> ，避免栈溢出。<br>如果预分配容量 <code>N</code> 不合理，导致使用容器对象时，总是会发生退化到堆的问题，那么重复的数据拷贝，也会带来性能问题。</p><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>和其他顺序容器类型一样，使用迭代器时，插入和删除操作可能会导致迭代器失效。尤其是还需要考虑因为插入元素导致 <code>SmallVector</code> 重新分配内存（栈到堆的退化和堆到堆的重新分配），迭代器都会失效。<br>resize 操作也会导致迭代器失效。</p><h3 id="自定义类型的内存管理"><a href="#自定义类型的内存管理" class="headerlink" title="自定义类型的内存管理"></a>自定义类型的内存管理</h3><p>如果 <code>SmallVector</code> 存储的是自定义类型，那么需要确保自定义类型有着正确的构造、移动和拷贝操作，不正确的实现会导致内存泄漏等问题。<br>如果自定义类型是引用类型，那么使用 <code>SmallVector</code> 管理时，需要确保自定义类型的析构函数中，能够正确释放内存。如果 <code>SmallVector</code> 管理的是指针，还需要自定义析构器来处理指针指向的内存。</p><h3 id="使用-SmallVectorImpl-作为参数类型"><a href="#使用-SmallVectorImpl-作为参数类型" class="headerlink" title="使用 SmallVectorImpl 作为参数类型"></a>使用 <code>SmallVectorImpl</code> 作为参数类型</h3><p>如果需要传递一个 <code>SmallVector</code> 的容器对象时，形参参数建议使用 <code>SmallVectorImpl</code>，后者没有带有 <code>SmallVectorStorage</code>，所以不会实际分配空间，同时也不需要声明函数时指定 <code>N</code> 值，这无论从效率角度看，还是使用便利性，都非常有价值。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种声明需要指定 N </span></span><br><span class="line"><span class="built_in">funcWithVec</span>(llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; &amp;Arg); </span><br><span class="line"><span class="comment">// 而这种声明不需要指定 N</span></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(llvm::SmallVectorImpl&lt;<span class="type">int</span>&gt; &amp;Arg);  </span><br><span class="line"></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec1; </span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">8</span>&gt; vec2; </span><br><span class="line"></span><br><span class="line"><span class="built_in">funcWithVec</span>(vec1); <span class="comment">// 正常  </span></span><br><span class="line"><span class="built_in">funcWithVec</span>(vec2); <span class="comment">// 编译报错 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(vec1); <span class="comment">// 正常 </span></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(vec2); <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="不适合用于存储大量元素"><a href="#不适合用于存储大量元素" class="headerlink" title="不适合用于存储大量元素"></a>不适合用于存储大量元素</h3><p>虽然 <code>SmallVector</code> 可以在堆上动态分配内存，但它的设计关注点还是在管理小数据量的动态数组。如果已知数量比较大的动态数组，使用 <code>std::vector</code> 即可。<br>同理，也不适合管理单个元素内存较大的数据类型。</p><h3 id="拷贝成本"><a href="#拷贝成本" class="headerlink" title="拷贝成本"></a>拷贝成本</h3><p>使用 <code>SmallVector</code> 需要多留意它可能发生从内部存储到堆上退化时的性能问题。尤其是元素类型本身的拷贝开销比较大时，一个合适的 <code>N</code> 就显得尤为重要。<br>请保证你的设计中，大多数情况下，都不会发生这种拷贝。</p><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>添加和删除元素会带来性能开销，一方面是为了保证顺序性，操作位置之后的元素需要移动位置；另一方面，如果发生向堆的退化或堆内存的重新分配，也会带来性能问题。<br>尽量使用 <code>emplace_back</code> 代替 <code>push_back</code>，以避免不必要的拷贝或移动操作，提高性能。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><p>无。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[LLVM Programmers Manual](<a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h">LLVM Programmer’s Manual — LLVM 21.0.0git documentation</a>)</li><li>[cppreference vector](<a href="https://en.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a>)</li><li>[CHUNer：LLVM 数据结构 - 2.1: llvm::SmallVector 简述 &amp; llvm::SmallVectorBase 类源码详细解析](<a href="https://zhuanlan.zhihu.com/p/16425169155">LLVM 数据结构 - 2.1: llvm::SmallVector 简述 &amp; llvm::SmallVectorBase 类源码详细解析 - 知乎</a>)</li><li><a href="%5B%E7%BC%96%E8%AF%91%E5%99%A8(llvm">CompilerCoder：编译器(llvm)中的数据结构与设计模式</a>中的数据结构与设计模式 - 知乎](<a href="https://zhuanlan.zhihu.com/p/418357950">https://zhuanlan.zhihu.com/p/418357950</a>))</li><li>LLVM 16.0 源码</li><li>LLVM 20.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/28641819827">学习LLVM数据结构-SmallVector - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Chapter.404 大胆提问</title>
    <link href="https://p2tree.top/posts/b2054f60.html"/>
    <id>https://p2tree.top/posts/b2054f60.html</id>
    <published>2025-03-06T23:50:54.000Z</published>
    <updated>2025-07-25T15:07:55.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不要害怕问出愚蠢的问题，因为在大多数情况下，其他人都在思考同样的问题，只是他们不好意思问出口。<br>越早搞懂看起来幼稚问题，就越不会在未来更难以启齿时提出同样的问题。</p><p><img src="https://img.p2tree.top/2025/3/6/Chapter.404.webp" alt="Chapter.404"></p><hr><div class="note primary flat"><p>封面图片来自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/-RobsXstoStQB0ZGpk6qJQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="心理" scheme="https://p2tree.top/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：ArrayRef</title>
    <link href="https://p2tree.top/posts/cdf6959f.html"/>
    <id>https://p2tree.top/posts/cdf6959f.html</id>
    <published>2025-02-25T21:35:21.000Z</published>
    <updated>2025-07-25T15:07:55.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。  </p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::ArrayRef</code> 定义在 <code>llvm/ADT/ArrayRef.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">ArrayRef</span>;</span><br></pre></td></tr></table></figure><p><code>llvm::ArrayRef</code> 是一个轻量级的只读容器，主要用于引用一段连续的内存区域。<br>它的设计目标是提供高效的数据访问，而不需要拥有底层数据的所有权。这使得 <code>ArrayRef</code> 特别适合在函数参数中实用，从而避免了不必要的内存拷贝。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>只读</strong>：<code>ArrayRef</code> 不能修改其引用的数据，也不能添加新元素（另一个容器 <code>MutableArrayRef</code> 可以修改）。</li><li><strong>轻量级</strong>：它只存储一个指向数据的指针和数据的长度，而不存储实际的数据，所以拷贝时非常高效。</li><li><strong>按值传递</strong>：在传递 <code>ArrayRef</code> 时，实际上传递的是一个指针和其指向数据的长度，所以不需要再对其按引用传递。</li><li><strong>操作一致</strong>：它的大多数操作，与 STL array 保持一致。</li></ul><h3 id="与标准库-array-对比"><a href="#与标准库-array-对比" class="headerlink" title="与标准库 array 对比"></a>与标准库 array 对比</h3><ul><li><strong>所有权</strong>：<code>llvm::ArrayRef</code> 不拥有其引用数据的所有权，只是对数据的引用；<code>std::array</code> 拥有数据的所有权，存储在栈上。</li><li><strong>大小</strong>：<code>llvm::ArrayRef</code> 容量是动态的，可以引用任意长度的数组。但由于数组长度是静态的，所以从程序角度看，<code>ArrayRef</code> 的具体引用类型，容量是确定的；<code>std::array</code> 大小在编译期间固定，和 C 数组一样。</li><li><strong>可变性</strong>：<code>llvm::ArrayRef</code> 是只读的，不能修改引用数据；<code>std::array</code> 允许修改其元素，提供完整的读写权限。</li><li><strong>初始化</strong>：<code>llvm::ArrayRef</code> 的初始化更灵活，可以从 C 数组、<code>std::array</code>，<code>std::vector</code> 或其他顺序容器初始化。<code>std::array</code> 只能从初始化列表或在定义时使用构造函数初始化。</li><li><strong>性能</strong>：<code>llvm::ArrayRef</code> 适合在高频传递参数时使用。<code>std::array</code> 默认按值拷贝，会带来开销，需要指定其引用类型作为参数类型。如果是 constexpr 修饰，编译器可以优化传参性能。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>由于<code>llvm::ArrayRef</code> 只拥有数据的引用，而不管理实际存储的空间，所以它实际上只是一个带有长度的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> T* data = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列了部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/ArrayRef.h</code> 文件代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个元素长度 </span></span><br><span class="line"><span class="type">int</span> A1 = <span class="number">1</span>; llvm::ArrayRef Arr1&#123;A1&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化指向一块数据首地址和数据长度 </span></span><br><span class="line"><span class="type">int</span> Ap[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; llvm::ArrayRef Arr2&#123;Ap&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个指针作为区间来初始化 </span></span><br><span class="line"><span class="type">int</span> *Ap2 = Ap + <span class="number">2</span>; llvm::ArrayRef Arr3&#123;Ap, Ap2&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 SmallVector 容器来构造 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>&gt; Vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr4&#123;Vec&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 std::vector 容器来构造 </span></span><br><span class="line">std::vector STLVec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr5&#123;Vec&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 std::array 容器来构造 </span></span><br><span class="line">std::array STLArr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr6&#123;STLArr&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表来构造 </span></span><br><span class="line">llvm::ArrayRef Arr8&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供了迭代器 <code>begin()</code> 和 <code>end()</code> ，以及反向迭代器 <code>rbegin()</code> 和 <code>rend()</code> 。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数据原始位置的操作 </span></span><br><span class="line"><span class="type">const</span> T *data = Arr.<span class="built_in">data</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数据长度的操作 </span></span><br><span class="line"><span class="type">bool</span> IsEmpty = Arr.<span class="built_in">empty</span>(); </span><br><span class="line"><span class="type">size_t</span> Length = Arr.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素 </span></span><br><span class="line"><span class="type">const</span> T&amp; FirstEle = Arr.<span class="built_in">front</span>(); </span><br><span class="line"><span class="type">const</span> T&amp; LastEle = Arr.<span class="built_in">back</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标索引 </span></span><br><span class="line"><span class="type">const</span> T&amp; Ele = Arr[I]; <span class="comment">// assert 检查是否越界</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>提供了 <code>equals(ArrayRef RHS)</code> 方法。<br>另一个语法糖是 <code>operator==</code> 运算符。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取从下标 1 的元素到末尾，作为新的 ArrayRef 返回 </span></span><br><span class="line">llvm::ArrayRef NewArr = Arr.<span class="built_in">slice</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取两端元素 </span></span><br><span class="line">llvm::ArrayRef NewArr2 = Arr.<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪切前/后部分元素，剩余数组作为新的 ArrayRef 返回 </span></span><br><span class="line">llvm::ArrayRef NewArr3 = Arr.<span class="built_in">drop_front</span>(<span class="number">2</span>); </span><br><span class="line">llvm::ArrayRef NewArr4 = Arr.<span class="built_in">drop_back</span>(); <span class="comment">// 默认是 1 个元素</span></span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>使用 <code>llvm::ArrayRef</code> 容器，需要引入 <code>Support</code> 组件，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LLVM_LINK_COMPONENTS Support)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="引用失效"><a href="#引用失效" class="headerlink" title="引用失效"></a>引用失效</h3><p>由于 <code>llvm::ArrayRef</code> 本身是一个引用类型，所以它会面临引用类型作为函数参数时，可能出现的引用失效问题。<br>同理，函数的返回类型不应该是 <code>llvm::ArrayRef</code>，如果返回的是函数局部对象，那么在 Caller 端，该对象引用的原始数据已失效；如果返回的是函数原始参数，这么做又没有意义。<br>另外，如果其引用的是一个动态数组，比如 <code>std::vector</code>，那么当动态数组扩容后，<code>llvm::ArrayRef</code> 引用可能会失效。<br>所以在使用它时，需要时刻思考它的引用对象，什么时候结束生命周期。</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><p><code>llvm::ArrayRef</code> 本身的访问不可能越界，但如果它引用的是一个动态数组，而动态数组的长度发生变化（缩小），那么 <code>ArrayRef</code> 的元素访问可能会发生越界问题。<br>这本质上也是引用失效问题。所以，最好的实践是只引用固定数组，比如用它代替 <code>const std::array &amp;</code> 类型。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>将 <code>llvm::ArrayRef</code> 转换为 <code>std::vector</code> 类型是不建议的操作，它会带来性能开销。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector Vec = Arr.<span class="built_in">vec</span>();</span><br></pre></td></tr></table></figure><p>这里实际上发生了一次数据拷贝。如果希望去修改原始数据，那么传递原始数据的可变引用是更好的做法。当然，也可以使用 <code>llvm::MutableArrayRef</code>，它是可变引用版本的 <code>llvm::ArrayRef</code>。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>llvm::MutableArrayRef</code>：可变版本的 <code>llvm::ArrayRef</code>。</li><li><code>llvm::OwningArrayRef</code>：拥有原始数据的 <code>llvm::MutableArrayRef</code>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[LLVM Programmers Manual](<a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-arrayref-h">LLVM Programmer’s Manual — LLVM 21.0.0git documentation</a>)</li><li>LLVM 16.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/26306452997">学习LLVM数据结构-ArrayRef - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>2025 新的开始</title>
    <link href="https://p2tree.top/posts/e343d97c.html"/>
    <id>https://p2tree.top/posts/e343d97c.html</id>
    <published>2025-02-11T23:00:09.000Z</published>
    <updated>2025-07-25T15:07:55.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你的每一次成功，都是将来更棘手问题的入场券。</p><hr><p><img src="https://img.p2tree.top/2025/2/11/Chapter.198.webp" alt="Chapter.198"></p><hr><div class="note primary flat"><p>封面图片生成自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/HUgkQXf7_MQTINwXuNgOEQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>你会为宝宝存储脐带血吗</title>
    <link href="https://p2tree.top/posts/dd8f25a6.html"/>
    <id>https://p2tree.top/posts/dd8f25a6.html</id>
    <published>2024-12-30T20:02:18.000Z</published>
    <updated>2025-07-25T15:07:55.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1️⃣ 什么是脐带血？<br>孩子出生时，可以从脐带中收集干细胞。干细胞在胎儿和新生儿血液中含量丰富。<br>2️⃣ 为什么收集存储脐带血？<br>脐带血可以为宝宝将来可能发生严重疾病时，用于提供完全匹配的干细胞，不会受到排斥。<br>3️⃣ 有什么坏处？<br>唯一的坏处可能是影响你的存款。<br>存储脐带血是需要初期付费以及之后持续付费的，通常不是很便宜。<br>所以，是否要为宝宝将来可能发生的疾病，而付出这笔费用，是个值得考虑的问题。<br>4️⃣ 有什么建议？<br>是否为宝宝存储脐带血，无所谓对错。疾病发生的概率很低，据统计存储了脐带血最后用到的概率也不高。<br>它就是一份保险，有它很好，但没有人希望会用到它。<br>你只需要考虑你的钱包👛。</p><hr><div class="note info simple"><p>封面图片来自豆包 AI。</p><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s/G1awN8y5AHQStLX8tSQdLQ?token=1029209527&lang=zh_CN">目的地</a> ，欢迎关注</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="育儿" scheme="https://p2tree.top/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Code Review Guide</title>
    <link href="https://p2tree.top/posts/829bc9e8.html"/>
    <id>https://p2tree.top/posts/829bc9e8.html</id>
    <published>2024-12-20T21:37:05.000Z</published>
    <updated>2025-07-25T15:07:55.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章是我曾经用于公司内部组织和培训的材料，做脱敏后分享给大家。有关于“是否要做 Code Review”相关的问题，不是本文讨论的重点。</p><p>本文的主要读者是那些需要扮演 Code reviewer 的人，即需要 review 别人代码的人，以提供建议、指导和要求来如何开展 Code review 的工作。</p><p>最后一节是写给 code reporter，比如 PR&#x2F;MR 的 owner。</p><p>下文中以 MR 指代提请 merge 的 code patch 请求。</p><hr><h2 id="1-Principle"><a href="#1-Principle" class="headerlink" title="1 Principle"></a>1 Principle</h2><ul><li>目标：Code review 的主要目的是确保逐步改善代码库的整体质量和健康度。</li><li>负责制：Reviewer 应该对被 review 的 MR 负责。这不一定要规范到流程中，但 reviewer 自身应当有这个意识。</li><li>时效性：Reviewer 应该有责任保障 MR 在 review ready 后，到 MR merge 要足够快速，从而避免延期。</li><li>避免过分严格：Reviewer 应当倾向于批准 MR 通过，只要 MR 能够在某些方面改进代码库的质量，并且代码是有意义的。而不是一味追求代码完美。</li><li>评论：MR 合入前，应当确保已解决所有 review 阶段提出的 comments。Comment 可以拒绝（备注原因并达成一致），但不可以忽略。</li><li>指导性：Code review 对于交流代码实践、设计原则和加深项目理解有益。Comments 可以是指导性的（不要求修改），但请注明 Nit。</li><li>避免个人偏好：基于技术事实讨论，而不是基于主观感受。</li><li>尊重非标准风格：如果 MR 中存在 Coding Style 中没有约束的设计，可以参考代码库现有的类似风格。但不应当强加 reviewer 的主观建议。</li><li>避免冲突：developer 和 reviewer 有冲突时，建议另行讨论，但需要将达成一致的结果记录在 MR 中。可能要有项目 owner 的参与，但要避免 MR 延期。</li><li>用户：Code review 过程中提到的用户，既包括软件的最终用户，也包括其他在相同代码库中进行开发工作的 developer。</li><li>积极的反馈：Reviewer 应当积极响应 review 请求，并给予正向的反馈，以互相激励良好的 Code review 流程。</li></ul><h2 id="2-Review-Point"><a href="#2-Review-Point" class="headerlink" title="2 Review Point"></a>2 Review Point</h2><h3 id="2-1-设计"><a href="#2-1-设计" class="headerlink" title="2.1 设计"></a>2.1 设计</h3><ul><li>代码是否经过精心设计并适合软件系统？</li><li>集成方式是否正确？</li><li>现在合入这个功能是否是正确的时间？</li></ul><h3 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2 功能"></a>2.2 功能</h3><ul><li>代码的行为是否和意图一致？</li><li>实现是否可以匹配需求？</li><li>接口变更（如库函数、外部类）通知到相关人员了吗？变更是否合理？</li><li>是否会引入随机问题？如并行导致的竞争，随机数测试等</li><li>对于无法理解的代码，可以要求 developer 澄清。对于 reviewer 来说，不能快速理解代码是正常的。澄清也会帮助所有 reviewer</li></ul><h3 id="2-3-复杂度"><a href="#2-3-复杂度" class="headerlink" title="2.3 复杂度"></a>2.3 复杂度</h3><ul><li>代码可以调整成更简单的实现吗？</li><li>其他开发人员能否轻松理解并使用这块代码？</li><li>MR 是否可以拆分？不相关的功能避免在一个 MR 中</li><li>绝大多数情况，1 个 MR 只包括 1 个 commit</li></ul><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><ul><li>代码是否带有正确、合理且有用的测试用例？</li><li>紧急情况可以省略测试用例，但之后应当提交专门的测试 MR 补充</li><li>代码仓已有的测试用例需要维护，修改测试用例应当有确切的原因</li></ul><h3 id="2-5-命名"><a href="#2-5-命名" class="headerlink" title="2.5 命名"></a>2.5 命名</h3><ul><li>代码中的变量、类、方法是否有符合项目风格的命名规范？</li><li>名称是否清晰有意义？</li><li>名称是否难以阅读，或和其他名词有歧义？</li></ul><h3 id="2-6-注释"><a href="#2-6-注释" class="headerlink" title="2.6 注释"></a>2.6 注释</h3><ul><li>是否没有必要注释，或是否滥用注释？</li><li>注释是否冗余？是否有错误？（注释需要维护）</li><li>注释不应该用于解释代码的逻辑（代码应该可以自解释）。有些例外，比如正则表达式和复杂算法</li><li>代码的背景、决策思路应当用注释说明</li><li>标记注释很有用，比如 TODO，BUG，FIXME，ISSUE，HACK，WARN，NOTE</li><li>对外的接口函数和接口类，库的头文件，应当有必要的注释说明用法和行为</li></ul><h3 id="2-7-风格"><a href="#2-7-风格" class="headerlink" title="2.7 风格"></a>2.7 风格</h3><ul><li>代码是否满足项目规定的代码风格？</li><li>功能性 MR 不要混合对不相关代码的风格变更。风格变更应另提 MR</li></ul><h3 id="2-8-文档"><a href="#2-8-文档" class="headerlink" title="2.8 文档"></a>2.8 文档</h3><ul><li>代码实现是否需要补充新的设计文档和测试文档？</li><li>是否需要修改现有文档？包括删除已经过时的错误文档</li></ul><h3 id="2-9-上下文"><a href="#2-9-上下文" class="headerlink" title="2.9 上下文"></a>2.9 上下文</h3><ul><li>不要只关注修改的代码，也要关注修改代码的上下文，以提出改善性建议。</li><li>不要容忍微小的破坏系统健康度的 MR，任何系统都是由小的坏的变更而逐渐变差。</li></ul><h3 id="2-10-好的设计"><a href="#2-10-好的设计" class="headerlink" title="2.10 好的设计"></a>2.10 好的设计</h3><ul><li>除了查找 MR 中的问题以外，也要留意其中好的设计</li><li>提交 comments 反馈给 developer，鼓励良好的实践，也促进互相学习</li></ul><h2 id="3-Review-Step"><a href="#3-Review-Step" class="headerlink" title="3 Review Step"></a>3 Review Step</h2><p>刚开始尝试 review 的 new reviewer，可以参考这个 review step。</p><h3 id="3-1-全面了解"><a href="#3-1-全面了解" class="headerlink" title="3.1 全面了解"></a>3.1 全面了解</h3><p>查看 MR commit message，了解 MR 大致要做什么。</p><ul><li>指出不必要的 MR 变更（给予对 developer 充分的尊重）</li><li>指出 commit title 和 message 中的错误和建议</li><li>查看关联 JIRA，了解问题背景</li><li>阅读测试用例，了解 MR 影响了什么。以及检查测试相关的问题</li></ul><h3 id="3-2-主要检查"><a href="#3-2-主要检查" class="headerlink" title="3.2 主要检查"></a>3.2 主要检查</h3><p>查看代码文件的主要内容。</p><ul><li>如果不能快速定位代码的关键部分，请 comment 要求 developer 澄清</li><li>判断 MR 中是否有和当前 MR 无关的内容。比如风格修改，多余功能实现</li><li>review 关键代码的设计</li><li>发现问题时请立即 comment，避免 developer 基于问题已经在做更多工作</li></ul><h3 id="3-3-次要检查"><a href="#3-3-次要检查" class="headerlink" title="3.3 次要检查"></a>3.3 次要检查</h3><p>在主要内容没有意见之后，检查其他代码。</p><ul><li>按照文件顺序重新浏览所有变更。</li><li>检查注释，命名规范等细节。</li><li>检查代码风格是否符合规定。</li><li>检查是否需要提供或变更文档。</li></ul><h2 id="4-Efficiency"><a href="#4-Efficiency" class="headerlink" title="4 Efficiency"></a>4 Efficiency</h2><p>Reviewer 应该尽快响应 MR 的 Code review 工作。</p><p>通常我们也希望 review 的过程足够快，也就是尽快 merge 代码，但这建立在很多因素的基础上。</p><h3 id="4-1-review-低效的问题"><a href="#4-1-review-低效的问题" class="headerlink" title="4.1 review 低效的问题"></a>4.1 review 低效的问题</h3><ul><li>降低团队效率。很多工作是基于当前 MR 展开的，MR 的 merge 过慢会阻塞其他开发工作</li><li>抱怨流程。review 流程会被抱怨，甚至对 reviewer 个人的抱怨，这会让团队成员的开发积极性受到挫败</li><li>代码健康度。developer 提交的其他 MR 可能会因此变得庞大、冗余，从而影响代码仓的质量</li></ul><h3 id="4-2-review-应该有多快"><a href="#4-2-review-应该有多快" class="headerlink" title="4.2 review 应该有多快"></a>4.2 review 应该有多快</h3><ul><li>Reviewer 的响应时间应该在 1 天内</li><li>Reviewer 应该立即响应 developer 主动要求的 Code review，这是 Reviewer 的职责</li><li>Reviewer 应该在每天都找一个时间，对仓库中所有 MR 进行 review</li><li>通常一个 MR 会经过多次 review，developer 也希望当天能得到多次 review</li><li>对于跨时区的 reviewer 和 developer，reviewer 应该在 developer 第二天上班前完成审查，并可以利用带评论的 LGTM</li></ul><h3 id="4-3-权衡"><a href="#4-3-权衡" class="headerlink" title="4.3 权衡"></a>4.3 权衡</h3><p>Review 请求会打断 Reviewer 自己的工作流，所以需要权衡。但通常还是需要积极响应主动请求。</p><ul><li>选择在 Reviewer 自己的工作中断点 review 代码。比如构建代码时、午餐晚餐前后</li><li>如果没有时间，也应该对 developer 给予快速反馈，并建议其他 reviewer</li><li>可以提供一些初步 comments，并提出 need change</li><li>但不要为了快速 review，而妥协了代码质量和标准。记住，reviewer 要对自己的每一笔 review 负责</li></ul><h3 id="4-4-大型-MR"><a href="#4-4-大型-MR" class="headerlink" title="4.4 大型 MR"></a>4.4 大型 MR</h3><p>如果 MR 的代码量比较多。预估 review 的时间会超过 20 分钟。</p><ul><li>尝试和 developer 沟通，是否可以精简 MR</li><li>如果无法精简 MR，尝试请 developer 提交 Code review 会议，集体做 review。developer 需要现场阐述 MR 的设计和细节</li></ul><h3 id="4-5-紧急-MR"><a href="#4-5-紧急-MR" class="headerlink" title="4.5 紧急 MR"></a>4.5 紧急 MR</h3><p>紧急 MR 比如：</p><ul><li>确定性的 commit revert</li><li>修复影响最终用户生产的错误</li><li>有 ETA 要求的功能，在即将到达 ETA 前</li><li>法律问题相关</li><li>明确的系统安全漏洞</li></ul><p>看似紧急但不紧急的 MR 比如：</p><ul><li>想赶在周末前合入，下周能开展新工作</li><li>跨时区的 review</li><li>commit revert 之后，导致的新问题</li></ul><p>紧急 MR 应该这么做：</p><ul><li>优先关注 review 过程的速度</li><li>先确保正确性，其他 review 发现的问题，如格式、测试用例等，可以要求 developer 之后补充 MR 修改</li><li>紧急 MR 合入后，应当再次对该 MR 做细致的 review，并要求 developer 补充</li><li>让所有项目组成员了解紧急 MR 的合入事件，并明确可能带来的风险</li></ul><p>尽量避免发生紧急 MR，这也有 PM 的责任，处理紧急 MR 应该极力避免项目积累技术债务。</p><h2 id="5-Comments"><a href="#5-Comments" class="headerlink" title="5 Comments"></a>5 Comments</h2><p>提交 Code review comments 也需要 reviewer 注意。</p><h3 id="5-1-保持友善"><a href="#5-1-保持友善" class="headerlink" title="5.1 保持友善"></a>5.1 保持友善</h3><p>不必说，在工作沟通中，都应该尽可能注意自己的措辞会给对方带来的压力和抵触，尤其是在挑别人毛病的时候。</p><h3 id="5-2-技术性解释"><a href="#5-2-技术性解释" class="headerlink" title="5.2 技术性解释"></a>5.2 技术性解释</h3><p>提供更多的技术性解释，来说明你的疑问或顾虑，比单纯的抛出问题更有利于 developer 处理。</p><h3 id="5-3-指导性-comment"><a href="#5-3-指导性-comment" class="headerlink" title="5.3 指导性 comment"></a>5.3 指导性 comment</h3><p>reviewer 虽然并没有义务帮助 developer 提供新的解决方案，但这并不意味着 reviewer 对提高 MR 的代码质量没有作用。</p><p>reviewer 可以适度的提供自己的建议方案，这通常有利于互相学习和加深对软件系统的理解。</p><p>毕竟，code review 的第一目标是保障代码质量，第二目标是提高软件开发人员的技能。</p><h3 id="5-4-解释性请求"><a href="#5-4-解释性请求" class="headerlink" title="5.4 解释性请求"></a>5.4 解释性请求</h3><p>对于不能快速理解的 MR，可以请求 developer 阐述 MR 中的主要内容和关键代码。</p><p>同时，对于 developer 提出的问题，reviewer 也应该给予充分的解释。</p><p>通常来说，请求解释无可厚非，这并不代表着 reviewer 个人水平如何。只有 developer 自己对自己编写的代码最熟悉。更充分的解释也有助于其他 reviewer 的 review 工作。</p><h3 id="5-5-同步线下的讨论"><a href="#5-5-同步线下的讨论" class="headerlink" title="5.5 同步线下的讨论"></a>5.5 同步线下的讨论</h3><p>很多时候，在 review 过程中，可能 reviewer 和 developer 会线下（或者线上 1 by 1 会议）讨论 MR 的细节。这是没问题的。</p><p>但需要在讨论结束后，将讨论的主要结论同步在 MR 中，以方便其他 reviewer 阅读和了解 review 的过程。</p><p>当然，也有助于将来回溯 MR 合入过程中的细节。</p><h3 id="5-6-Nit"><a href="#5-6-Nit" class="headerlink" title="5.6 Nit"></a>5.6 Nit</h3><p>Nit 是指 review 过程中，发现的一些小的，无关紧要的问题，reviewer 并不要求必须在当前 MR 做修改。</p><p>Nit 是重要的，鼓励 reviewer 和 developer 在 code reviewer 时多使用。</p><p>可能使用 Nit 的地方：</p><ul><li>注释和变量中的小错误，比如语法错误和拼写错误。</li><li>不易理解的一些符号。</li><li>可以将代码提炼和改善的地方。</li><li>冗余的注释说明。</li><li>reviewer 认可当前方案，但想分享他建议的更好方案。</li></ul><h2 id="6-冲突"><a href="#6-冲突" class="headerlink" title="6 冲突"></a>6 冲突</h2><p>Code review 的过程中，很容易对一些技术细节产生不同的观点。应当避免持续冲突影响了 MR 的合入效率。</p><ul><li>讨论时，要始终注意自己的措辞是否会伤害到对方</li><li>developer 通常对代码的细节，包括项目的细节，比 reviewer 了解更多和详细</li><li>讨论不应该过于频繁。应该留出独立思考的时间</li><li>如果代码存在严重问题，则 reviewer 不能妥协让步</li><li>无论什么时候，都应该对事不对人</li><li>避免妥协 “之后再处理” 的措辞。时间过的越久，“之后再处理” 就越不可能发生。（紧急 MR 例外）</li><li>如果 developer 一定坚持 “之后再处理”，那么要有 JIRA 跟踪，以避免后续遗忘。同时，代码中应当留下充分的解释，如 TODO 注释</li></ul><h2 id="7-MR-建议"><a href="#7-MR-建议" class="headerlink" title="7 MR 建议"></a>7 MR 建议</h2><p>本节内容是写给任何需要扮演 developer 角色的人员，提供一个开发代码和提交 MR 的实践指导。</p><h3 id="7-1-重视-MR-message"><a href="#7-1-重视-MR-message" class="headerlink" title="7.1 重视 MR message"></a>7.1 重视 MR message</h3><p>MR message 并不只是一个标题。不要省略详情内容，这是很不负责任的。</p><p>MR message 应当和 git commit message 保持一致，有利于回溯问题。</p><p>MR message 中应该包括典型的关键字，按照不同仓库的要求，这些关键字可能写在标题行，也可能写在详情文本中。这些关键字通常会作为将来检索相关内容的依据。</p><p>避免拼写错误和语法错误。</p><p>以下是一些具体说明：</p><p>标题行：</p><ul><li>简洁地描述 MR 做了什么</li><li>注意格式要求，比如不要超出格式要求的宽度、首字母大写且行尾不加标点</li><li>标题行要添加必要的关键字（遵从仓库规则）。如 llvm 中会使用 [ARM]，[MIPS] 来标注 MR 的类型</li><li>尽量避免笼统地总结 MR。比如一个反例：”Fix a bug of mma“。应该让其他人通过标题了解到 MR 独特的地方</li></ul><p>详情文本：</p><ul><li>应该包括对问题的详细描述、为什么要做这个事情、为什么用这种方法</li><li>还要包括需求背景和 JIRA 链接</li><li>如果需要，还可以包括目前方法的缺陷分析、未来计划、基准测试状态以及设计文档位置</li></ul><h3 id="7-2-尽可能小的-MR"><a href="#7-2-尽可能小的-MR" class="headerlink" title="7.2 尽可能小的 MR"></a>7.2 尽可能小的 MR</h3><p>一个 MR 应该只解决一个事情。小的 MR 会有很多优点：</p><ul><li>Code review 更快。这体现在 reviewer 可以更快的理解代码和排查可能存在的问题。当然也更容易得到 approve</li><li>大的 MR 会审查不彻底（人的惰性使然），对 reviewer 的要求也更高。小 MR 更容易发现问题</li><li>被 Disapproved 之后，调整更方便</li><li>合入更方便，不容易和其他 MR 产生冲突</li><li>如果意外需要 revert，也会更方便，带来的影响会更小</li><li>编写小型 MR 也有助于 developer 梳理软件逻辑</li></ul><p>多大代码量的 MR 算小型 MR 通常由代码仓的特征和所有 developer 和 reviewer 的大致判断决定，但通常几千行的 MR 就不能算小型 MR。（人脑的缓存通常也只能记忆这么多代码来完成 review）</p><h3 id="7-3-可以接受的大-MR"><a href="#7-3-可以接受的大-MR" class="headerlink" title="7.3 可以接受的大 MR"></a>7.3 可以接受的大 MR</h3><p>有些情况下，大型 MR 也能接受，如：</p><ul><li>增加或删除一个文件的完整代码</li><li>对某个相同特征的问题，在很多位置做修改</li><li>仓库初始配置</li></ul><p>一个大型 MR 通常需要更多的时间和精力来 review，也会需要额外开展 Code review meeting 进行集体 review。</p><p>所有 reviewer 和与 MR 相关的 developer 都应当明确 MR merge 可能带来的风险和对项目的影响。</p><h3 id="7-4-测试用例"><a href="#7-4-测试用例" class="headerlink" title="7.4 测试用例"></a>7.4 测试用例</h3><p>大多数功能性的 MR 的合入都应该配有测试用例。避免后续补充测试用例的做法。</p><p>可以有单独的测试用例作为独立 MR 合入，但这些用例应该是对之前已存在代码的一个测试补充或对测试代码的整体重构。</p><p>以下情况可以接受没有测试用例：</p><ul><li>紧急 MR 可以不添加测试用例，但紧急情况处理完毕后，应该额外提交测试用例 MR</li><li>格式调整、文档修改等 MR</li><li>可解释的其他不添加测试用例的情况，经 reviewer 接受</li></ul><h3 id="7-5-不能破坏构建"><a href="#7-5-不能破坏构建" class="headerlink" title="7.5 不能破坏构建"></a>7.5 不能破坏构建</h3><p>任何一个 MR 都应该是自完备的。它不能破坏代码仓的构建。</p><p>如果有几个相互依赖的 MR，也应该确保找到一种方法，让每个 MR 都能通过构建。功能可以不完备，但构建不能 fail。</p><p>另外，CI 的测试应该要保障不出现这种问题。</p><h3 id="7-6-回复-Comments"><a href="#7-6-回复-Comments" class="headerlink" title="7.6 回复 Comments"></a>7.6 回复 Comments</h3><p>永远记得 Code review 的目的是提高整个代码库的质量。当看到 comment 时，先控制自己反对的冲动（这种冲动其实是人之常情），想想为什么有这个 comment。</p><p>保持礼貌和感激。reviewer 也会做到这一点。</p><p>尝试澄清代码，以对 reviewer 有疑问的地方展开解释。并且也应该主动思考自己的代码为什么没有被其他人所轻易理解，并尝试改进。</p><p>Developer 也可以要求 reviewer 澄清他们的 comment。</p><p>可能会需要解决冲突，请参见上文 <strong>冲突</strong> 小节。</p><h3 id="7-7-JIRA-同步"><a href="#7-7-JIRA-同步" class="headerlink" title="7.7 JIRA 同步"></a>7.7 JIRA 同步</h3><p>除了在 MR message 中添加 JIRA 链接外，也应该在 JIRA 页面添加 MR 链接。或者使用 CI&#x2F;CD 系统自动完成双链。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/13742893417">Code Review Guide - P2Tree@zhihu.com</a></p><p>文章标题图使用豆包 AI 生成。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="高效编程" scheme="https://p2tree.top/tags/%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B/"/>
    
    <category term="软件工程" scheme="https://p2tree.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：活着</title>
    <link href="https://p2tree.top/posts/dc0bdc19.html"/>
    <id>https://p2tree.top/posts/dc0bdc19.html</id>
    <published>2024-12-15T20:16:05.000Z</published>
    <updated>2025-07-25T15:07:55.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/12/15/book.51.webp" alt="book.51"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/hhBc47ZA4v86a4YOQCZj3Q">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="与生活妥协" scheme="https://p2tree.top/tags/%E4%B8%8E%E7%94%9F%E6%B4%BB%E5%A6%A5%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git果壳：什么是版本控制</title>
    <link href="https://p2tree.top/posts/86730351.html"/>
    <id>https://p2tree.top/posts/86730351.html</id>
    <published>2024-11-24T22:29:12.000Z</published>
    <updated>2025-07-25T15:07:55.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“Git 菜谱” 系列文章：</p><ol class="series-items"><li><a href="/posts/86730351.html" title="Git果壳：什么是版本控制">Git果壳：什么是版本控制</a></li></ol><hr><blockquote><p>©️ 本文演绎自 Atlassian 编写的 <a href="https://www.atlassian.com/git/tutorials/what-is-version-control"><em>What is version control</em></a>。页面上所有内容采用知识共享-署名（<a href="http://creativecommons.org/licenses/by/2.5/au/deed.zh">CC BY 2.5 AU</a>）许可协议。</p></blockquote><h3 id="版本控制的优点"><a href="#版本控制的优点" class="headerlink" title="版本控制的优点"></a>版本控制的优点</h3><p>版本控制系统是软件工具的一个类别，它可以辅助软件开发团队管理软件代码随着时间的更改。版本控制软件可以通过特殊的数据库来追踪代码的每一次变更。如果软件开发中发生错误，开发者可以利用版本控制来将代码和早期的版本做对比，从而能够以对其他团队成员干扰最小的前提下修复错误。</p><p>对于几乎所有的软件工程来说，软件源代码就是最重要的部分（<em>译注：原文比喻为皇冠上的宝石，也就是最需要保护的珍宝</em>）。对于大多数软件团队，源代码仓库是他们认真努力积累和完善的宝贵知识财富的存储库，而版本控制可以保护源代码免受灾难性的破坏以及人为操作失误或故意破坏。</p><p>软件开发人员工作过程中会持续性的产出新的代码以及修改已经存在的代码。一个工程软件、应用软件或者软件组件通常被组织在一个文件夹或者说一个目录树中。团队中的一个开发者可能在增加一个新特性，而另一个开发者可能在修复不相关的bug，每一个开发者都在这个目录树的不同位置对代码内容进行着更改。</p><p>版本控制可以帮助软件团队解决这样的问题，追踪每一个开发者产生的每一个独立的变更，以及帮助预防并发工作中的冲突。并发工作的冲突是指软件一部分的修改可能与另一个开发者同时的修改不兼容。这个问题应该有条不紊的被发现和解决，从而不能影响团队其他成员的工作。此外，在软件开发中，任何更改都有可能引入新的 bugs，故而在测试之前，新的软件版本不能被完全信任，所以直到新版本发布之前，测试和开发的进程都应该同时被执行。</p><p>好的版本控制软件可以支持开发者首选的工作流程，而不会强加一种特别的工作方式。理想情况下，它应该能在任何平台上工作，而不是特别要求开发者必须使用某种操作系统或者工具链。好的版本控制系统可以促进代码变更平稳连续的进行，而不是使用将文件锁定的这种糟糕而笨拙的机制（这是指某个文件只允许一名开发人员工作，而阻止其他开发人员开发）</p><p>不使用任何版本控制的软件团队经常会遇到一些问题，比如不知道已经完成的哪些变更可以被用户使用，或者在两个不相关的工作内容之间创建了互不兼容的更改，然后必须进行繁琐的整理和重做。如果你是一个从未使用过版本控制的开发者，你可能会这样命名你的不同版本的文件，比如加一个“最终版”或“最新版”的文件名后缀，然后不得不之后再处理新的最终版本。也许你会为了禁用某个功能但不愿删除代码，因为害怕代码未来还将会用到而注释掉代码块。版本控制可以解决如上这些问题。</p><p>版本控制软件是现代软件团队日常开发中必不可少的一部分。习惯于团队中使用功能强大的版本控制系统的软件开发人员会显然意识到版本控制所带来的不可思议的价值，即使是在小型项目中也是如此。一旦习惯了版本控制系统的强大优势，很多开发者就不再考虑去做没有版本控制支持的工作，即使是完成非软件开发的工作。</p><h3 id="版本控制系统的优点"><a href="#版本控制系统的优点" class="headerlink" title="版本控制系统的优点"></a>版本控制系统的优点</h3><p>开发软件时不使用版本控制系统是危险的，比方说没有做备份。版本控制也能允许开发人员更灵活的人员变动，允许软件团队在团队规模扩大时保持高效率和敏捷性。</p><p>版本控制系统（<code>Version Control System</code>,<code>VCS</code>）在过去的几十年内取得了非常大的进步，并且有些更为突出。有些时候被称作代码管理工具（<code>Source Code Management</code>,<code>SCM</code>）或者修订控制系统（<code>Revision Control System</code>,<code>RCS</code>）。其中一个很流行的版本控制工具叫做 Git，它是一个分布式的版本控制系统（<code>Distributed VCS</code>,<code>DVCS</code>），之后会详细介绍。就像很多现在流行的版本控制系统一样，Git 是自由的也是开源的。不管它们叫什么名字，又或者是什么系统使用，版本控制系统主要的优点有以下几点。</p><ol><li><strong>记录每一个文件的完整的长期的变更历史</strong>。这意味着它能记录长期以来每一个贡献者提交的每一个变更。这些变更包括文件的创建、删除以及内容修改。<em>不同的 VCS 工具的一个区别在于它们处理重命名和移动文件的能力</em>。每次变更将包括作者名、时间和每一次修改的纪要。具有完整的历史可以允许我们退回到之前的版本中，从而帮助分析 bugs，当需要在旧版本中修复软件问题时，这确实很重要。如果正在积极开发一个软件，则几乎所有的内容都将被看做这个软件的旧版本。<em>译注：因为软件更新快，原文旨在说明旧版本不是你想象中的那么“旧”。</em></li><li><strong>分支和合并特性</strong>。这些特性可以让团队协作工作更加便捷，也可以让独立工作的开发者能从中受益。在 VCS 工具中创建一个分支可以维持多个独立的开发工作流，同时也提供了将这些工作合并回去的功能，能允许开发者验证分支之间的变更是否冲突。很多软件团队使用独立分支来开发特性或者是维护一个版本，或者两者都有。软件团队可以利用分支和合并特性来选择不同的工作方式。</li><li><strong>可追溯性</strong>。能够追踪软件的每一次变更，进而可以让其能够搭配工程管理系统和 bug 追踪软件，比如 <a href="https://www.atlassian.com/software/jira">Jira</a>。可以通过消息来描述变更的目的和意图，从而注释每一次变更，这样不但能有助于关键问题分析也可协助其他的检查工作。在阅读代码，或尝试理解代码作用和设计意图时，这样的代码描述历史消息可以帮助开发者做出正确的和相匹配的修改，能够与系统预期的长期设计思想相符合。这种方式对于在遗留代码上高效工作是非常重要的，对于开发人员准确估计未来工作也是非常重要的。</li></ol><p>当然，不使用版本控制系统来开发软件也是可行的，但是这样的工程具有很大的风险，任何专业的开发团队都不会愿意接受。所以问题并不会在于是否使用版本控制系统，而是使用哪种版本控制系统。</p><p>这会有多种选择，但这里的教程我们专注于 Git。从<a href="https://bitbucket.org/product/version-control-software?_ga=2.63967023.1846059181.1575290049-386918931.1575091845">这里</a>可以了解到其他的版本控制软件。</p><hr><div class="note info flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@nganduong93?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Duong Ngan</a> on <a href="https://unsplash.com/photos/a-white-table-topped-with-white-christmas-trees-dTBhA3zP3yA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="译文" scheme="https://p2tree.top/tags/%E8%AF%91%E6%96%87/"/>
    
    <category term="Git" scheme="https://p2tree.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>他们</title>
    <link href="https://p2tree.top/posts/b5919f86.html"/>
    <id>https://p2tree.top/posts/b5919f86.html</id>
    <published>2024-11-19T22:53:22.000Z</published>
    <updated>2025-07-25T15:07:55.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0 到 3 岁，你是他们的全部；<br>3 到 7 岁，你是他们的晚上；<br>7 到 18 岁，你是他们的周末；<br>18 到 22 岁，你是他们的寒暑假；<br>之后，你是他们的春节。</p><hr><p><img src="https://img.p2tree.top/2024/11/19/Chapter.401.webp" alt="Chapter.401"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，秋天、老照片和时光流逝。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/YPAAsZC_tWvoecqUv01Azg">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>开始阅读很多的书，但读完很少的书</title>
    <link href="https://p2tree.top/posts/1da6b0bc.html"/>
    <id>https://p2tree.top/posts/1da6b0bc.html</id>
    <published>2024-11-03T20:25:40.000Z</published>
    <updated>2025-07-25T15:07:55.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>阅读应追求对自身产生的影响，若仅仅是为读完而读，那实则毫无意义。</p><p>读书与实践相关，有人开始时会阅读大量书籍，但真正读完的却寥寥无几。读书就如同结识朋友，如果感觉不适，便可放弃。即便某本书在他人眼中是佳作，但只要对自己无益，就没必要去读。因为时间有限，在相同的时间里，我们当然更希望阅读一本对自己有帮助且能吸引自己的书。</p><p>清理书单最快的方法，不是把书读完，而是将它们从书单中删除。</p><hr><p><img src="https://img.p2tree.top/2024/11/03/Chapter.89.webp" alt="Chapter.89"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，一只阅读的花栗鼠。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/XEIIGx4FP8gRGfmWUC4EKA">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="学习方法" scheme="https://p2tree.top/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：宝贵的人生建议</title>
    <link href="https://p2tree.top/posts/2626ad0e.html"/>
    <id>https://p2tree.top/posts/2626ad0e.html</id>
    <published>2024-10-27T17:09:22.000Z</published>
    <updated>2025-07-25T15:07:55.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/10/27/book.49.webp" alt="book.49"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/Y337qOZMNBw4UqbBhUC-ww">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="个人发展" scheme="https://p2tree.top/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>死亡搁浅配乐收藏</title>
    <link href="https://p2tree.top/posts/a28b3899.html"/>
    <id>https://p2tree.top/posts/a28b3899.html</id>
    <published>2024-10-24T23:07:57.000Z</published>
    <updated>2025-07-25T15:07:55.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《死亡搁浅》是我玩过的游戏中，音乐和配乐设计最为出色的一款作品。它的音乐完全可以独立于游戏本身享受，玩家无需具备游戏体验也能轻松欣赏其中的旋律。这些歌曲展现了极强的亲和力和感染力，每一曲都令人陶醉。游戏中恰到好处的配乐增强了玩家的沉浸感，使人愈加沉迷于其中。音乐在这款游戏中的地位不可忽视，成为了推动体验的重要元素。</p><p>推荐收听：</p><ul><li>Don’t Be So Serious：Death Stranding，一个讲述有关离别、联结和自我接纳的故事</li><li>Bones：第一次踏上旅程，面对恬静广阔的自然景观，音乐声恰好响起</li><li>BB’s Theme：最后一次走出首都节点城，再一次被音乐震撼，“我，是你吗？”</li><li>I’ll Keep Coming：面对挫折后，能否在心底保留希望，继续前行</li><li>Death Stranding：当明知注定会失去一切时，还会满怀激情，走向故事的结尾吗？</li></ul><hr><p><strong>[ 点击图标可以在线播放 ]</strong></p>        <div id="aplayer-qjmTHDZj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#99988D","preload":"metadata","listmaxheight":"513px","music":[{"title":"Almost Nothing","author":"Silent Poets、Okay Kaya","url":"https://music.p2tree.top/death_strandling/Almost%20Nothing%20-%20Silent%20Poets%E3%80%81Okay%20Kaya.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Almost%20Nothing%20-%20Silent%20Poets%E3%80%81Okay%20Kaya.lrc"},{"title":"Anything You Need","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Anything%20You%20Need%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Anything%20You%20Need%20-%20Low%20Roar.lrc"},{"title":"Asylums for the Feeling","author":"Silent Poets、Leila Adu","url":"https://music.p2tree.top/death_strandling/Asylums%20for%20the%20Feeling%20-%20Silent%20Poets%E3%80%81Leila%20Adu.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Asylums%20for%20the%20Feeling%20-%20Silent%20Poets%E3%80%81Leila%20Adu.lrc"},{"title":"BB's Theme","author":"Ludvig Forssell、Jenny Plant","url":"https://music.p2tree.top/death_strandling/BB's%20Theme%20-%20Ludvig%20Forssell%E3%80%81Jenny%20Plant.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/BB's%20Theme%20-%20Ludvig%20Forssell%E3%80%81Jenny%20Plant.lrc"},{"title":"Because We Have To","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Because%20We%20Have%20To%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Because%20We%20Have%20To%20-%20Low%20Roar.lrc"},{"title":"Bones","author":"Low Roar、Jofridur Akadottir","url":"https://music.p2tree.top/death_strandling/Bones%20-%20Low%20Roar%E3%80%81Jofridur%20Akadottir.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Bones%20-%20Low%20Roar%E3%80%81Jofridur%20Akadottir.lrc"},{"title":"Breathe In","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Breathe%20In%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Breathe%20In%20-%20Low%20Roar.lrc"},{"title":"Death Stranding","author":"CHVRCHES","url":"https://music.p2tree.top/death_strandling/Death%20Stranding%20-%20CHVRCHES.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Death%20Stranding%20-%20CHVRCHES.lrc"},{"title":"Don't Be So Serious","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Don't%20Be%20So%20Serious%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Don't%20Be%20So%20Serious%20-%20Low%20Roar.lrc"},{"title":"Easy Way Out","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Easy%20Way%20Out%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Easy%20Way%20Out%20-%20Low%20Roar.lrc"},{"title":"Give Up","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Give%20Up%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Give%20Up%20-%20Low%20Roar.lrc"},{"title":"Gosia","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Gosia%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Gosia%20-%20Low%20Roar.lrc"},{"title":"I'll Keep Coming","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/I'll%20Keep%20Coming%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/I'll%20Keep%20Coming%20-%20Low%20Roar.lrc"},{"title":"I'm Leaving","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/I'm%20Leaving%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/I'm%20Leaving%20-%20Low%20Roar.lrc"},{"title":"Not Around","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Not%20Around%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Not%20Around%20-%20Low%20Roar.lrc"},{"title":"Once in a Long, Long While…","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Once%20in%20a%20Long%2C%20Long%20While%E2%80%A6%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Once%20in%20a%20Long%2C%20Long%20While%E2%80%A6%20-%20Low%20Roar.lrc"},{"title":"Patience","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Patience%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Patience%20-%20Low%20Roar.lrc"},{"title":"Please Don't Stop (Chapter 1)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%201)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%201)%20-%20Low%20Roar.lrc"},{"title":"Please Don't Stop (Chapter 2)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%202)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%202)%20-%20Low%20Roar.lrc"},{"title":"Pop Virus","author":"星野源","url":"https://music.p2tree.top/death_strandling/Pop%20Virus%20-%20%E6%98%9F%E9%87%8E%E6%BA%90.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Pop%20Virus%20-%20%E6%98%9F%E9%87%8E%E6%BA%90.lrc"},{"title":"Poznań","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Pozna%C5%84%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Pozna%C5%84%20-%20Low%20Roar.lrc"},{"title":"Rolling Over","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Rolling%20Over%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Rolling%20Over%20-%20Low%20Roar.lrc"},{"title":"St. Eriksplan","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/St.%20Eriksplan%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/St.%20Eriksplan%20-%20Low%20Roar.lrc"},{"title":"The Machine","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/The%20Machine%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/The%20Machine%20-%20Low%20Roar.lrc"},{"title":"Tonight, Tonight, Tonight","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Tonight%2C%20Tonight%2C%20Tonight%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Tonight%2C%20Tonight%2C%20Tonight%20-%20Low%20Roar.lrc"},{"title":"Waiting (10 Years)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Waiting%20(10%20Years)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Waiting%20(10%20Years)%20-%20Low%20Roar.lrc"},{"title":"Without You","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Without%20You%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Without%20You%20-%20Low%20Roar.lrc"}]};  options.element = document.getElementById("aplayer-qjmTHDZj");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><hr><div class="note primary flat"><p>音乐资源来自网络，若存在侵权，请联系我删除。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="音乐" scheme="https://p2tree.top/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
    <category term="音乐" scheme="https://p2tree.top/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>C++20 特性杂谈</title>
    <link href="https://p2tree.top/posts/49819b87.html"/>
    <id>https://p2tree.top/posts/49819b87.html</id>
    <published>2024-10-20T20:31:41.000Z</published>
    <updated>2025-07-25T15:07:55.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 的发展方向最重要的就是 C++ 标准委员会的统一决策，这种从不同行业、公司、国家和组织中集合的一群人，能达成共识并推出一些有价值的成果，已经非常难得。然而，C++ 仍然因此和其他新兴语言之间产生了差距。</p><p>C++ 标准的一种最重要的宗旨就是确保 C++ 在更新的过程中，看起来还是同一个语言，所以它需要满足一种统一的演化标准。这些标准概括起来有：</p><ul><li>基于过去已有的成功模式作为演化方向，比如 RAII、类型安全检查</li><li>简单的事情用简单的方法做</li><li>从代码到硬件的零开销原则和直接映射</li><li>基于意见反馈来发展</li><li>保持稳定性和兼容性</li><li>维持与硬件的直接映射，简单的抽象机制，最小化的运行时系统</li></ul><p>然而，过去很长一段时间，C++ 标准委员会都只专注于编程语言特性和标准库的方向，而没有在语言工具链方面做额外的事情，比如构建系统、包管理、链接原则等方面，这导致了 C++ 语言没有标准统一的开发和运行环境，每个操作系统、平台，甚至编程框架都可以规定自己的开发模式，各自为政。相关的软件也都依赖第三方企业或开源社区维护，用法和实现五花八门，没有统一标准的指导方针。</p><p>说回 C++20，这一次标准版本是可以和 C++11 不相上下的发布，其中包括了好几个大型特性，比如模块、概念、协程。C++20 对 C++ 的影响可以说又是改头换面的。</p><hr><p>本文是 C++ 特性杂谈系列文章的第四篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="模块"><a href="#模块" class="headerlink" title="# 模块"></a># 模块</h2><p>模块用来替代之前 C++ 中的头文件机制。</p><p>头文件引入的机制存在一些明显的缺点，已经饱受诟病：</p><ul><li>头文件的引入只是通过宏对代码的直接展开，不同头文件中的代码相互之间可见，可能发生名字冲突问题，不同头文件的来源不同，很难做到统一和安全。</li><li>已经有太多的代码被放入头文件中。过去 C++ 继承 C 的头文件机制时，头文件中只会放一些 export 的函数声明，但现在，一个工程中大于 90% 的代码都在头文件中。</li><li>常见的头文件可能在其他文件中被 include 很多次，虽然有避免重复编译的头文件宏，但依然无法阻止预处理器一遍又一遍的展开这些重复的 include 文件代码。这导致编译效率降低。</li></ul><p>模块机制的优势是：</p><ul><li>同一个模块，编译器只需要处理一次，这会一定程度上减少编译时间</li><li>避免了不同头文件中可能存在的名字冲突</li><li>模块中区分导出的符号和内部符号，只保留必要的接口，保证了实现上的封装性</li><li>编译过程中的代码整洁很多，只会引入被调用的符号，没有调用但也被暴露出来的符号不会被编译</li></ul><p>之后，标准委员会最大的困难便是如何兼容过去的 include 机制与新引入的模块机制，最后应该是基本解决了。模块的引入方式可以做到比头文件的引入方式在编译上快一个数量级。</p><p>模块的引入，不可避免地会彻底改变 C++ 代码的导入导出方式，对过去几十年人们已经在头文件系统上做过的大量工作来说，是一个明显的冲击。但理念和技术都在发展进步，有些东西确实只能被时代抛弃。</p><p>虽然模块是 C++20 中的一个正式特性，但因为特性比较复杂，存在对旧代码的影响，所以目前（2024年9月）编译器（比如 gcc）还是需要用额外的参数来指定启用该功能，编译器实现也有可能存在 bug 和不完善。未来编译器实现稳定之后，编译参数会被取消。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c+<span class="number">+20</span> -fmodules-ts -o main main.cpp math_module.cppm</span><br><span class="line">clang++ -std=c+<span class="number">+20</span> -fmodules -o main main.cpp math_module.cppm</span><br></pre></td></tr></table></figure><p>后缀 <code>.cppm</code> 是标准规定的后缀形式，但编译器并不强依赖后缀来区分模块文件。</p><h2 id="协程"><a href="#协程" class="headerlink" title="# 协程"></a># 协程</h2><p>协程是一种比线程更高效的并发机制。看似是一种很新的概念，但实际上，协程在 C++最初版本中就存在，当时利用协程来实现一个任务库，进而支持一些常见算法的仿真。然而，由于实现比较丑陋，移植性差，在后来的 C++98 版本中，没有继续支持，直到 C++20 中才重新实现。</p><p>如果你还不了解协程，我简单介绍一下。协程就是用户态的线程，多个协程运行在同一个线程上，通过用户程序控制下做分时复用，以伪并发的状态执行。协程可以暂停和恢复运行。比如，我可以让一个协程函数暂停，然后去执行其他内容，回过头来再继续执行协程函数。操作系统不感知协程，它是一种语言级的行为。C++20 的协程是无栈协程，所以效率很高。</p><p>协程之间切换不需要内核参与，所以效率更高，但协程需要配合异步 IO 操作，在计算密集型任务中，协程没有用武之地。</p><p>C++20 的协程使用 co_await, co_yield, co_return 关键字，又是一个考虑兼容性的命名。它使用普通函数，而不是 lambda 来实现协程函数。如果一个普通函数中存在这 3 个关键字之一，它就会被编译器处理为一个协程。</p><p>这个协程提案被批评的主要原因是不利于学习、没有和现有语言特性融合、过于灵活。解决方案便是提供一套标准库来包装接口，再提供给普通用户使用。然而，由于时间原因，协程的标准库并没有被添加到 C++20 中。</p><h2 id="增强的-constexpr"><a href="#增强的-constexpr" class="headerlink" title="# 增强的 constexpr"></a># 增强的 constexpr</h2><p>之前我们在 C++14 的总结中，提到过 C++14 中的 constexpr 是对 C++11 的一个增强，当时的改进相对来说比较温和，应该理解为一种完善。在 C++20 中，constexpr 才被进一步的增强，这次更新，constexpr 中加入了一些新的修饰符、一些标准类库支持、constexpr 函数中允许使用 new&#x2F;delete、虚函数、RTTI 等特性。</p><p>C++20 进一步增强 constexpr 的目的，是继续将 C++ 的编译期计算推举到更重要的位置，从而让更多的运行时计算变成静态计算，进一步改进运行时性能。</p><p>但是，在工程中，将运行时函数修改为编译期函数的努力可能很艰难，我们应该学着评判什么是值得花精力去改善的。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="# 运算符 &lt;=&gt;"></a># 运算符 <code>&lt;=&gt;</code></h2><p>这个运算符应该怎么称呼，目前中文 C++ 社区还没有完全达成一致，英文是 Three-way comparison operator，也许应该叫三向比较运算符。它返回一个特殊的类型 <code>std::strong_ordering</code> ，有三个取值，分别是 <code>less</code> <code>equal</code> <code>greater</code> ，用于确定两个值的大小关系。</p><p>它的引入最大的意义是，允许编译器能有更多的优化空间。</p><p>另一个话题是重载 <code>&lt;=&gt;</code> 运算符，和其他运算符一样，也可以重载它，或者让编译器生成 default 版的重载函数。如果重载这个运算符，那么其他比较运算符也会自动由编译器生成。一个例外是字符串的 <code>==</code> 运算符不会自动生成，理由是性能很差，我很难给出积极的评价，这让整个语法变的不统一，不过，C++ 里这种操作也挺多的，为了性能会妥协语言的复杂性和优雅性。</p><h2 id="范围-ranges-和视图-view"><a href="#范围-ranges-和视图-view" class="headerlink" title="# 范围 ranges 和视图 view"></a># 范围 ranges 和视图 view</h2><p>千呼万唤始出来的特性，使用 ranges 终于可以在很多场合里摆脱 <code>func(vec.begin(), vec.end())</code> 这种写法了，换之 <code>func(vec)</code>，这才是现代编程语言应该有的特性。</p><p>奈何我们在 2020 年之后的 C++ 中才用到了这个特性。</p><p>C++20 的 STL 中所有容器都已经支持了 ranges。</p><p>另外，STL 中还加入了很多与 ranges 相关的算法，比如 filter、take 等，这些算法定义在 std::ranges::views 中。与此同时，引入了管道 pipe 运算，使用这种编程风格让 C++ 更像是函数式编程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::ranges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="keyword">auto</span> valid = [](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> x % <span class="number">4</span> == <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : views::<span class="built_in">iota</span>(<span class="number">1</span>) | views::<span class="built_in">transform</span>(square) | views::<span class="built_in">filter</span>(valid) | views::<span class="built_in">take</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，<code>views.iota(1)</code> 会生成从 1 开始，步进是 1 的 ranges 序列（注意不是 <code>itoa</code>），通过管道运算符传递，之后会经过 2 个我们自定义的 predicate 函数，最后使用 <code>views.take</code> 来获取前 5 个元素，并返回给 for 循环遍历。</p><p>C++ 被人吐槽很多的一个话题是，它提供的 std::string 中，没有 split 操作（实现很简单，但一直没有通过委员会，因为性能和类型统一等问题），这让过去很多项目都需要自己写 split 函数。C++20 中终于有了 split view，便可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> sv = s | ranges::views::<span class="built_in">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><p>返回的类型是 split_view，可以通过 <code>ranges::to&lt;&gt;</code> 进一步转换为自己想要的容器类型。</p><h2 id="span"><a href="#span" class="headerlink" title="# span"></a># span</h2><p>在目前的 C++ 中，通过下标访问一个数组的元素，是没办法通过编译器检查是否发生访问越界的，而这种错误经常会出现在工程代码中，动态的越界检查又很难因性能开销而被接受。一种简单的实现，就是把数组的长度绑定到数组指针中，统一引用这个复合的指针类型。曾经，有提案给到 C 标准委员会，但没有得到通过。</p><p>C++20 中，引入了 span 这个特性，从而让编译器的数组静态越界检查成为可能。因为数组长度是静态的，并且跟着 span 类型的传递到达任何需要遍历数组的地方，所以编译器便有机会在这些遍历和下标访问的地方检查越界操作。</p><p>同时，span 也扩展了数组类型的遍历，可以让它和其他复合容器一样操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(span&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，便可以检查可能的越界操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">func</span>(arr);        <span class="comment">// 合法，通过类型推导到 void func(span&lt;int&gt; arr)</span></span><br><span class="line"><span class="built_in">func</span>(&#123;arr, <span class="number">50</span>&#125;);  <span class="comment">// 合法，初始化为 span&lt;int&gt; 类型实参</span></span><br><span class="line"><span class="built_in">func</span>(&#123;arr, <span class="number">101</span>&#125;); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="# 格式化字符串"></a># 格式化字符串</h2><p>又是一个应该属于现代化的编程语言中一个常用的特性。</p><p>因为 pre-C++20 中没有原生的类型安全的格式化字符串方法，所以过去涌现出了好多第三方的库。我使用过 LLVM 实现的 llvm::formatv 和 fmt，用起来还算可以。C++20 之后，终于可以使用原生的实现了，它的参照原型是 fmt 库，所以基本可以无缝切过去。</p><p>除了类型安全这个特点外，format 和 C 的 printf 之间另一个区别是，format 可以支持用户自定义的类型输出格式，对于一些复杂且在特定领域很常用的格式化模板，就非常的方便。</p><h2 id="并发"><a href="#并发" class="headerlink" title="# 并发"></a># 并发</h2><p>C++20 中引入了一些非常有意义的并发编程的特性。比如，使用 RAII 的 thread 对象，被命名为 jthread，当 thread 对象超出作用域时，触发 join 行为，直到 thread 终止后，才完成 join 并退出主线程的当前作用域。</p><p>另外一个之前便已经提到过的，通过主线程终止子线程执行，通过在主线程中设置一个 flag，然后要求子线程去周期性地检查这个 flag，如果主线程需要终止子线程，则置位 flag。</p><h2 id="新增的一些属性"><a href="#新增的一些属性" class="headerlink" title="# 新增的一些属性"></a># 新增的一些属性</h2><p>像我之前提到的那样，在必要的时候，去尝试使用属性，可以让代码更优雅，也有助于编译器做一些分析。C++20 中增加了 <code>[[likely]]</code> 和 <code>[[unlinkely]]</code> 属性，用于指导编译器在处理分支逻辑时，更好地做优化。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1820204765">C++20 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片来自：Photo by <a href="https://unsplash.com/@oww?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Geio Tischler</a> on <a href="https://unsplash.com/photos/an-aerial-view-of-an-island-in-the-middle-of-the-ocean-_D_zFmpg8nE?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>时间的速度是可控的</title>
    <link href="https://p2tree.top/posts/7a90bc13.html"/>
    <id>https://p2tree.top/posts/7a90bc13.html</id>
    <published>2024-10-14T22:25:17.000Z</published>
    <updated>2025-07-25T15:07:55.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间是最强大的力量，虽然每个人都有，但不同的人使用时间会产生完全不同的结果。</p><p>时间对每个人是公平的吗？是，也不是。从客观角度观察，每个人的时间是一样长的，但从主观上体验，时间的长度是可调的，越忽略时间，时间过得越快，越关注时间，时间过得越慢。将时间主观上拉长，可以做更多事情，忽略时间而沉迷没有价值的事情，就是在荒废这最精妙而宝贵的资源。</p><p>怎么使用时间，每个人的选择都不同，主观上时间可以调出大于之前几倍的长度，就看会不会调，以及如何利用。</p><hr><p><img src="https://img.p2tree.top/2024/10/14/Chapter.317.webp" alt="Chapter.317"></p><div class="note primary flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@aronvisuals?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Aron Visuals</a> on <a href="https://unsplash.com/photos/selective-focus-photo-of-brown-and-blue-hourglass-on-stones-BXOXnQ26B7o?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/JWy_i2PybV2m72M--DH9dQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="管理时间" scheme="https://p2tree.top/tags/%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
</feed>
