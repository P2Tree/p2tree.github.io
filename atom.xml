<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P2Tree&#39;s Mill</title>
  
  
  <link href="https://p2tree.top/atom.xml" rel="self"/>
  
  <link href="https://p2tree.top/"/>
  <updated>2025-09-19T15:03:39.964Z</updated>
  <id>https://p2tree.top/</id>
  
  <author>
    <name>P2Tree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective Modern C++：lambda 表达式</title>
    <link href="https://p2tree.top/posts/cd605d5c.html"/>
    <id>https://p2tree.top/posts/cd605d5c.html</id>
    <published>2025-09-19T22:57:50.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>lambda 表达式是 C++ 中一个极具颠覆性的语言特性，它主要用于创建匿名函数，从而可以更便捷地在一些场合下，快速生成函数对象后传递给需要的位置。这一章中，会陈述几个和 lambda 表达式相关的问题。</p><p>首先，需要明确几个概念。lambda 表达式是一种语法，它是静态的，编译器处理 lambda 表达式时，会利用它生成一个闭包类，然后在利用 lambda 表达式定义对象时，利用这个闭包类生成一个闭包对象。闭包对象是动态行为。</p><p>虽然我们无法方便地知道 lambda 表达式生成地闭包对象是什么类型，但好在可以用 <code>auto</code> 类型来让编译器自己推导。也由于闭包对象和其他对象没有什么大的不同，也可以实现赋值和移动等操作。</p><h2 id="条款-31：避免使用默认捕获模式"><a href="#条款-31：避免使用默认捕获模式" class="headerlink" title="条款 31：避免使用默认捕获模式"></a>条款 31：避免使用默认捕获模式</h2><p>所谓默认捕获模式，就是直接使用 <code>&amp;</code> 或 <code>=</code> 捕获当前作用域中所有可以捕获的对象（按引用或按值）。本条款建议，尽量将 lambda 表达式中需要使用到的外部对象，显式写在捕获列表中。虽然无法完全避免下文可能存在的问题，但默认捕获模式，可能会带来更危险的陷阱。</p><h3 id="情况-1：通过引用捕获"><a href="#情况-1：通过引用捕获" class="headerlink" title="情况 1：通过引用捕获"></a>情况 1：通过引用捕获</h3><p>一个显而易见的问题是，lambda 表达式生成的闭包对象，其生命周期可能会超出当前作用域，如果 lambda 表达式体中捕获了只在当前作用域中生存的对象，那么当被捕获对象离开作用域被析构时，lambda 表达式中的按引用捕获，实际就变成了空悬引用。</p><p>所以第一种最简单的情况就是，按引用捕获时，注意被捕获对象的生命周期，看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局的闭包对象容器</span></span><br><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> divisor = <span class="built_in">getDivisor</span>();</span><br><span class="line">  filters.<span class="built_in">emplace_back</span>([&amp;](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码中，<code>filters</code> 会保存多个满足类型的闭包对象（闭包对象是一种可调用类型，所以可以使用 <code>std::function&lt;&gt;</code> 来定义类型）。函数 <code>func</code> 中，局部对象 <code>divisor</code> 被按默认捕获的方式捕获到 lambda 表达式中。</p><p>那么，当在其他位置访问 <code>filters</code> 中的闭包对象时，闭包中的 <code>divisor</code> 就已经是空悬引用了，它的值是否合法是不确定的。</p><p>一个可以改进的策略便是，不要使用默认捕获模式，将需要捕获的对象 <code>divisor</code> 显式写在捕获列表中：<code>filters.emplace_back([&amp;divisor](int value) &#123; return value % divisor == 0; &#125;);</code>。当然，在这个例子中，这么写依然避免不了问题，但至少更容易发现问题。当 lambda 表达式体中的代码比较复杂时，默认捕获模式会更不容易看出来 lambda 表达式依赖哪些外部对象。</p><h3 id="情况-2：通过值捕获"><a href="#情况-2：通过值捕获" class="headerlink" title="情况 2：通过值捕获"></a>情况 2：通过值捕获</h3><p>当你预料到情况 1 的结论，打算在之后的代码中，谨慎使用引用捕获，转而使用按值捕获，可能依然会带来一些潜在的问题。 虽然按值捕获可以让值对象采用复制方式传入 lambda 表达式体，但如果按值捕获的是指针，那么指针指向的内容仍然会随时变化，这依然是和引用捕获一样的问题。</p><p>看一个书中很典型的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> divisor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  filters.<span class="built_in">emplace_back</span>( [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，在一个类内，定义一个类数据 <code>divisor</code>，然后在类的成员函数中实现保存闭包对象到容器。看似没有什么问题，每一次创建闭包对象时，都会拷贝一份 <code>divisor</code> 的值进去。然而，这是误解。</p><p><strong>捕获行为只能捕获在创建 lambda 表达式所在作用域内的可见非静态局部对象</strong>，而对于例子中的这种捕获 <code>divisor</code> 的方式，编译器会将指向当前类对象的 <code>this</code> 指针，捕获到 lambda 表达式中，也就是说，等价于 <code>[=this](int value) &#123; return value % this.divisor == 0; &#125;</code>。 那么，当 <code>Widget</code> 的对象，调用完 <code>addFilter</code> 之后，早于 <code>filters</code> 的生命周期而提前被析构，那 <code>this</code> 指针就会变成悬空指针，之后使用 <code>filters</code> 中的闭包，就会遇到未定义问题。</p><p>除了 <code>this</code> 指针，其他位于当前作用域内的普通指针，一样会遇到相同的问题。一种改善的方案便是，手动复制一份需要捕获的对象（平凡类型）到当前作用域。保险起见，也建议手动把捕获列表补充上去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line">  filters.<span class="built_in">emplace_back</span>( [=divisorCopy](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况-3：捕获静态对象"><a href="#情况-3：捕获静态对象" class="headerlink" title="情况 3：捕获静态对象"></a>情况 3：捕获静态对象</h3><p>lambda 表达式除了可以通过捕获来使用局部变量和形参，也可以直接使用静态对象（和普通函数一样），也就是定义在全局或名字作用域中，或者是类中和函数中以 <code>static</code> 修饰的对象。这种静态对象，不是通过捕获来访问的，但却会给人以错觉，认为是捕获访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">auto</span> divisor = <span class="built_in">getDivisor</span>();</span><br><span class="line">  filters.<span class="built_in">emplace_back</span>([=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br><span class="line">  ++ divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，lambda 表达式使用默认值捕获，但实际上它什么也没有捕获，<code>divisor</code> 对象只是因为 <code>static</code> 属性而被直接访问的。这样，每次调用 <code>func</code> 函数时，<code>divisor</code> 都会发生变化，这可能会导致非预期的行为（我们应该是期待按值捕获 <code>divisor</code>，从而 lambda 中的值不会变化）。</p><blockquote><p>谬误：lambda 表达式访问静态对象，并不是通过捕获方式访问。</p></blockquote><p>虽然无法直接避免这种误解，但如果不使用默认值捕获方式，就更容易发现这个细节：<code>filters.emplace_back([](int value) &#123; return value % divisor == 0; &#125;);</code>，没有捕获任何东西，但访问了静态对象 <code>divisor</code>。</p><p>综上几种情况，做个总结，lambda 表达式的捕获行为可能会让程序出现一些非预期的错误，虽然从编译层面无法规避这种问题，但不要使用默认捕获方式（包括按值捕获和按引用捕获），就更容易发现问题。</p><h2 id="条款-32：将对象通过移动方式传入闭包"><a href="#条款-32：将对象通过移动方式传入闭包" class="headerlink" title="条款 32：将对象通过移动方式传入闭包"></a>条款 32：将对象通过移动方式传入闭包</h2><p>之前提到的无论是按值捕获还是按引用捕获，都无法将一个只移对象（比如 <code>std::unique_ptr</code>）传入闭包，C++ 11 做不到。在 C++14 中，支持了通过一种特殊的捕获方式，将对象移动入闭包。 这种捕获方式叫做初始化捕获（init capture），它可以实现除了默认捕获之外的任何捕获行为，所以也被称为通用 lambda 捕获（generalized lambda capture）。</p><p>它的语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();  <span class="comment">// 准备一个只移对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//... some other code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">move</span>(pw)] &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>语法很巧妙的区分了捕获列表中 <code>=</code> 左右的作用域，左边的作用域在 lambda 表达式体内部，右边的作用域位于定义 lambda 表达式所在的作用域，所以可以使用相同的名称（如例子中的 <code>pw</code>）。</p><p>如果想要在定义 lambda 表达式时初始化对象，也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()] &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>捕获列表中可以放置任何表达式，所以说它是一种通用捕获模式。例子中，表达式返回了一个只移右值，可以通过移动方式传入闭包。</p><p>以上是 C++14 中支持的语法，在 C++11 中，无法使用。如果 C++11 依然想要通过移动传入对象，可以用一些曲线救国的办法。</p><p>第一种办法是，手写一个可调用类型（仿函数），也就是带有 <code>operator()</code> 重载的类，我们知道，lambda 表达式经过编译器处理后，实际上也生成了这样一种类型。我们手动为其定义支持右值引用作为参数的构造函数，便可以在定义函数对象时，传入右值。之后使用函数对象的方法和 lambda 表达式完全一致。</p><p>第二种办法是利用 <code>std::bind</code>，虽然 C++11 不支持移动捕获 lambda，但支持绑定一个函数并通过移动方式传入参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;  <span class="comment">// 准备一个对象，希望通过移动传入闭包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">  [](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; &amp;data) &#123; ... &#125;,</span><br><span class="line">  std::<span class="built_in">move</span>(data);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个代码中，将对象 <code>data</code> 转换为右值后，绑定到 lambda 表达式中的第一个形参，以此来实现移动一个对象到 lambda 表达式中的目的。这里没有利用 lambda 表达式的捕获，所以 C++11 是支持的。</p><p>最后，要提一下，无论是 C++14 的初始化捕获，还是 C++11 的 <code>std::bind</code>，他们中涉及到的表达式求值，都是在定义 lambda 或绑定对象时求值。但 C++11 中，绑定对象只有在被调用时（也就是 <code>func()</code> 调用时），存储在绑定对象中的实参（例子中的右值 <code>std::move(data)</code> 经移动构造生成在绑定对象中的副本 ）才会传入 lambda 表达式中，所以事实上，lambda 表达式中操作的 <code>data</code> 实际上是绑定对象中的副本（注意到，lambda 表达式参数列表中的 <code>data</code> 类型是左值引用）。</p><h2 id="条款-33：泛型-lambda-表达式"><a href="#条款-33：泛型-lambda-表达式" class="headerlink" title="条款 33：泛型 lambda 表达式"></a>条款 33：泛型 lambda 表达式</h2><p>在 C++14 中，增加了一个非常实用的特性，即泛型 lambda 表达式，它允许我们编写 lambda 表达式时，对其形参类型自推导：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> <span class="built_in">g</span>(x); &#125;;</span><br></pre></td></tr></table></figure><p>它类似于模板函数中的类型推导，方便我们编写泛型的匿名函数。</p><p>然而，这里要引出本条款要讨论的问题，如果我们需要将这个 lambda 表达式编写为完美转发形参，会遇到什么问题？回忆一下，使用模板函数编写完美转发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">gg</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要利用 <code>std::forward&lt;T&gt;</code> 来对形参 <code>param</code> 做一次转换，它的作用是，如果类型 <code>T</code> 是左值引用，则转换为左值引用；如果类型 <code>T</code> 是右值引用，则转换为右值引用。</p><p>然后，我们需要利用 <code>decltype</code> 这个工具，手动推导形参的类型，好在 <code>decltype</code> 的返回类型，也是符合预期的，当传入形参是左值时，返回左值引用，传入形参是右值时，返回右值引用。 最后，我们编写的完美转发的泛型 lambda 表达式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x) &#123; <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;<span class="keyword">decltype</span>(x)&gt;(x)); &#125;;</span><br></pre></td></tr></table></figure><p>考虑不定长参数列表的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... x) &#123; <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;<span class="keyword">decltype</span>(x)&gt;(x)...); &#125;;</span><br></pre></td></tr></table></figure><p>对于书中对 <code>std::forward&lt;T&gt;</code> 和 <code>decltype</code> 在传入右值类型时的正确性讨论，我认为想地太复杂了，所以这里略掉，感兴趣的朋友可以去翻原文。</p><h2 id="条款-34：优先使用-lambda-表达式替代-std-bind"><a href="#条款-34：优先使用-lambda-表达式替代-std-bind" class="headerlink" title="条款 34：优先使用 lambda 表达式替代 std::bind"></a>条款 34：优先使用 lambda 表达式替代 std::bind</h2><p>lambda 表达式和 <code>std::bind</code> 在大多数场景下的功能是重叠的，在 C++98 那个没有 lambda 表达式可以使用的年代，想要灵活地包装一个函数，并返回一个新的函数对象，使用 <code>std::bind</code> 是非常常见的做法。</p><p>然而，随着 Modern C++ 的发展，lambda 表达式的能力越来越强大，以至于可以完全取代 <code>std::bind</code>。</p><h3 id="理由-1：lambda-表达式的语法更清晰，更易读"><a href="#理由-1：lambda-表达式的语法更清晰，更易读" class="headerlink" title="理由 1：lambda 表达式的语法更清晰，更易读"></a>理由 1：lambda 表达式的语法更清晰，更易读</h3><p>考虑一个书中的例子。现在有一个可以发出报警的函数，支持几个配置，我们希望使用 lambda 表达式或 <code>std::bind</code> 来包装这个函数，让其中一部分配置使用默认值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Time = std::chrono::steady_clock::time_point;</span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::steady_clock::duration;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Sound</span> &#123; Beep, Siren, Whistle &#125;;  <span class="comment">// 声音类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是需要包装的函数，指定开始报警事件、声音类型和持续时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure><p>如果我们想包装一个可调用对象，在调用发生时刻 1 小时后开始报警，持续 30 秒，但声音类型希望调用时指定。使用 lambda 表达式的实现方案非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL =  <span class="comment">// &#x27;L&#x27; 表示 lambda 方案</span></span><br><span class="line">  [](Sound s) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="built_in">hours</span>(<span class="number">1</span>), s, <span class="built_in">seconds</span>(<span class="number">30</span>)); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++14 中可以利用字面值常量优化：</span></span><br><span class="line"><span class="keyword">auto</span> setSoundL = </span><br><span class="line">  [](Sound s) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, s, <span class="number">30</span>s); &#125;;</span><br></pre></td></tr></table></figure><p>然而，使用 <code>std::bind</code> 的方案，不但不易读，反而还存在问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB =  <span class="comment">// &#x27;B&#x27; 表示 std::bind 方案</span></span><br><span class="line">  std::<span class="built_in">bind</span>(setAlarm, steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>首先，我们在使用 <code>setSoundB</code> 时，需要搞清楚它的参数，对应原始函数 <code>setAlarm</code> 中的哪个参数。这里，我们可以通过函数名称来确定参数是 <code>Sound</code>，但很多时候，尤其是有多个占位符同时出现时，唯一的办法就是去查看 <code>setAlarm</code> 的声明。</p><p>而且，这里还存在一个问题，表达式延迟求值的问题。对于 lambda 的版本，<code>steady_clock::now()</code> 的求值（当前时间），是 <code>setSoundL</code> 被实际调用的时候；而 <code>std::bind</code> 的版本，<code>steady_clock::now()</code> 的求值，却是在 <code>setSoundB</code> 被定义的地方，这可能产生 Bug。 一种改进 <code>setSoundB</code> 的方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = </span><br><span class="line">  std::<span class="built_in">bind</span>(setAlarm, </span><br><span class="line">            std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),</span><br><span class="line">            _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>虽然问题解决了，但这种写法就看起来更复杂了。</p><h3 id="理由-2：如果被包装函数有重载版本"><a href="#理由-2：如果被包装函数有重载版本" class="headerlink" title="理由 2：如果被包装函数有重载版本"></a>理由 2：如果被包装函数有重载版本</h3><p>如果 <code>setAlarm</code> 有重载版本，比如有个带有 4 个形参的重载版本。那么 lambda 表达式依然可以正常找到正确的 3 参数重载版本，而 <code>std::bind</code> 则不行，会发生编译报错。</p><p>如果想继续改进 <code>setSoundB</code>，可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SetAlarm3ParamType = <span class="built_in">void</span>(*)(Time t, Sound s, Duration d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = </span><br><span class="line">  std::<span class="built_in">bind</span>(<span class="built_in">static_cast</span>&lt;SetAlarm3ParamType&gt;(setAlarm),</span><br><span class="line">            std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),</span><br><span class="line">            _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>也就是手动对函数做向确定函数类型方向做类型转换。</p><p>另外，这里还会引出另一个细节。对于 lambda 表达式的方案，lambda 表达式体，可以由编译器做优化，比如对 <code>setAlarm</code> 做函数内联；但 <code>std::bind</code> 却基本无法做编译器优化。最后导致 lambda 表达式的版本会比 <code>std::bind</code> 的版本性能更好。</p><h3 id="理由-3：std-bind-无法控制参数传入方式"><a href="#理由-3：std-bind-无法控制参数传入方式" class="headerlink" title="理由 3：std::bind 无法控制参数传入方式"></a>理由 3：std::bind 无法控制参数传入方式</h3><p>对于 lambda 表达式的方案，我们想传入的 <code>Sound</code> 参数，可以通过按值捕获或按引用捕获的方式，在 C++14 中还可以选择按移动捕获。但对于 <code>std::bind</code> 则无法做到这样的自由。</p><p><code>std::bind</code> 中的默认填好的绑定参数，只能按值传递，而其占位符参数，在绑定函数对象最终被调用时，只能按引用传递。如果想要写出正确的代码和高性能的代码，必须始终牢记这个设计原理。</p><blockquote><p>技巧：总是试着使用 lambda 表达式去替代 <code>std::bind</code> 的代码。</p></blockquote><p>最后，总结一下，在 Modern C++ 中，完全可以使用 lambda 表达式替代 <code>std::bind</code>，只有 C++11 中，有 2 个场景，还是需要 <code>std::bind</code>，在前边条款中提到过：</p><ol><li>C++11 中 lambda 表达式无法做到移动捕获，只能依赖 <code>std::bind</code> 实现；</li><li>C++11 中 lambda 表达式无法做到泛型，需要编写带有调用运算符模板的函数对象，再使用 <code>std::bind</code> 来实现；</li></ol><p>对于这两种情况，都是很少见的使用场景，而且 C++14 中的 lambda 表达式都已经得到妥善的支持。</p><hr><p>本系列的其他文章：</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li><li><a href="/posts/57a898cb.html" title="Effective Modern C++ 读书笔记：转向现代C++">Effective Modern C++ 读书笔记：转向现代C++</a></li><li><a href="/posts/ce1aec80.html" title="Effective Modern C++ 读书笔记：智能指针">Effective Modern C++ 读书笔记：智能指针</a></li><li><a href="/posts/410ab8fb.html" title="Effective Modern C++：右值引用、移动语义和完美转发">Effective Modern C++：右值引用、移动语义和完美转发</a></li><li><a href="/posts/cd605d5c.html" title="Effective Modern C++：lambda 表达式">Effective Modern C++：lambda 表达式</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1952400191220094938">https://zhuanlan.zhihu.com/p/1952400191220094938</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++：右值引用、移动语义和完美转发</title>
    <link href="https://p2tree.top/posts/410ab8fb.html"/>
    <id>https://p2tree.top/posts/410ab8fb.html</id>
    <published>2025-09-10T22:38:19.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习 C++ 时，当接触到右值引用和移动语义等概念时，就会劝退很多人。一方面，是因为这些概念本身已经不再是入门知识了，即使不懂，也可以写出一些程序了；另一方面，大多数教材中，并没有以最简洁易懂的方式完成这些知识的传授。</p><p>本章节会把这部分知识最底层最细节的内容，用另一个视角展示出来。但前提是，你需要已经理解什么是左值和右值，什么是引用这些基本的概念。</p><h2 id="条款-23：理解移动语义和完美转发"><a href="#条款-23：理解移动语义和完美转发" class="headerlink" title="条款 23：理解移动语义和完美转发"></a>条款 23：理解移动语义和完美转发</h2><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>当我们写下一条赋值语句时，很多时候，实际上是完成了一次拷贝操作，也就是将数据复制一份，放入新声明的对象内存中。当数据量比较大时，并且赋值之后，原始的数据将不会再使用时，这种复制的代价会很大也很没必要。<br>直觉的理解，就是直接把地址复用一下，就能避免复制一份的开销，这种行为看起来像把数据 “移动” 到新的对象内存中，从而提高了性能。</p><p>在 Modern C++ 中，我们使用 <code>std::move</code> 这个操作，来支持移动语义。</p><p>然而，C++ 烦人的地方就在于，很多你看似显而易见的概念，实际上却暗藏玄机。比如，<code>std::move</code> 并没有移动任何东西，后边提到的 <code>std::forward</code> 也并没有转发任何东西。事实上，他们在运行期什么也不做，一个字节都不会生成。</p><p><code>std::move</code> 也不一定总是能保证会产生移动行为，它实际上只是一个强制类型转换，无条件将实参转换为右值引用。</p><p>我认为，如果你敢于说出自己 “熟练掌握” C++，那么，一定可以盲写出 <code>std::move</code> 的实现函数，因为它真的很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，核心是 <code>static_cast</code>，它将形参 <code>param</code> 转换为另一个类型。形参是一个万能引用，而不是一个右值引用（虽然有两个 <code>&amp;&amp;</code>），它即可以绑定左值引用，也可以绑定右值引用。函数返回的类型，首先使用 <code>remove_reference</code> 去除所有引用属性，然后取其类型后，再转变为右值引用，所以，返回类型一定是原始类型去掉引用之后的右值引用类型。</p><p>C++ 14 中的实现更加简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> ReturnType = remove_reference&lt;T&gt;&amp;&amp;; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以确定，<code>std::move</code> 确实是一个类型转换。</p><p>那为什么它和 “移动” 扯上关系呢？</p><p>我们的编译器，会在明确一个类型是一个右值时，调用这个类型的移动语义（移动构造函数和移动赋值运算符），而移动语义通常是更轻量级的实现，比如拷贝地址而不是拷贝值。<code>std::move</code> 帮我们确保将类型变成右值引用，从而 “尝试” 触发移动语义。</p><p>注意，我这里使用了 “尝试” 这个词，是因为 <code>std::move</code> 不保证一定会触发移动，因为它只能保证返回的是一个右值引用，两者之间还隔着一个编译器行为。书中一个典型的反例是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Obj</span>(<span class="type">const</span> std::string text) : <span class="built_in">value</span>(std::<span class="built_in">move</span>(text)) &#123;&#125; </span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  std::string value; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码中，构造函数的实参，到对象中的数据成员 <code>value</code>，就发生了拷贝而不是移动。原因是，构造函数形参是 <code>const std::string</code>，如果将一个 <code>const</code> 属性的数据，移动到一个非 <code>const</code> 属性的数据，那就会出现本不希望修改的东西可能被修改，编译器不接受这种行为，所以还是会拷贝而不是移动。</p><p>更专业的解释是，<code>std::string</code> 中只提供 <code>const string&amp;</code> 作为形参类型的拷贝构造函数和以 <code>string&amp;&amp;</code> 作为形参类型的移动构造函数，所以 <code>value</code> 的构造中，被 <code>std::move</code> 处理后的实参 <code>std::move(text)</code>，其类型虽然是 <code>const std::string&amp;&amp;</code>，但在实例化 <code>value</code> 时，选择了拷贝构造函数（常量右值引用退化为常量左值引用）。</p><blockquote><p><strong>谬误</strong>：<code>std::move</code> 只保证返回的是一个右值引用，而不保证一定发生移动语义。<br><strong>陷阱</strong>：针对常量对象的移动操作，一定会悄无声息的退化为拷贝操作。</p></blockquote><p>理论上来说，<code>std::move</code> 这个命名是有歧义的，更合适的命名是 <code>rvalue_cast</code> 之类，然而，当时 C++ 标准委员会考虑的可能是尽可能不让用户感知更下层的细节，避免陷入语法漩涡中。我个人的意见认为，既然 C++ 无法在语法层面掩藏 “右值引用” 的概念，那就不应该在 <code>std::move</code> 这里多虑，选择暴露细节并让用户权衡，或者选择隐藏细节和提供封装，二者择一即可，而不是既要又要，却引入了尴尬的歧义。</p><p>同样的，<code>std::move</code> 看似和 “移动” 千丝万缕，但即使真的发生了移动行为，移动之后的原对象，其依然是有效的，程序员需要手动关注移动后的原对象状态，比如在移动构造中将类型成员指针赋值 <code>nullptr</code>。否则，状态是未定义的。</p><p>另外，一个和 Rust 对比的有趣细节，C++ 中传递非引用类型参数时，默认的行为是拷贝，若类型实现了移动语义，且实参是右值（如临时对象或手动使用 <code>std::move</code> 的结果），传参行为变成移动；Rust 中默认的传参行为是移动（转移所有权），当类型实现 Copy trait 或手动调用 <code>.clone()</code> 方法时，传参行为变成拷贝。可见，Rust 通过默认移动语义保证了安全性和性能，而 C++ 的默认拷贝行为则需要开发者主动留意安全性和性能。</p><p>比如，在 C++ 代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(<span class="number">42</span>)</span></span>; </span><br><span class="line">Widget w2 = std::<span class="built_in">move</span>(w);  <span class="comment">// 假设真的触发了移动行为 </span></span><br><span class="line">std::cout &lt;&lt; w.<span class="built_in">getValue</span>(); <span class="comment">// 可能是垃圾值或者程序奔溃，取决于 Widget 实现</span></span><br></pre></td></tr></table></figure><p>在 Rust 代码中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">w</span> = Widget::<span class="title function_ invoke__">new</span>(<span class="number">42</span>); </span><br><span class="line"><span class="keyword">let</span> <span class="variable">w2</span> = w;                   <span class="comment">// 一定发生了移动行为 </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, w.<span class="title function_ invoke__">getValue</span>()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>之前提到过，函数形参不可能是一个右值类型，所以，如果函数调用时实参是一个右值引用，那函数形参就丢失了右值引用属性，对于 <code>void func(Widget&amp;&amp; w)</code> 来说，当 <code>func</code> 内部操作 <code>w</code> 时，就会当作一个左值引用来处理。为了能让 <code>func</code> 内部的 <code>w</code> 也是和实参一样的右值引用，使用完美转发便可以做到。</p><p>在 Modern C++ 中，我们使用 <code>std::forward</code> 这个操作，来支持完美转发。</p><p><code>std::forward</code> 是一个 “有条件” 的强制类型转换。只有当函数形参是万能引用类型，实参是一个右值时，会把形参强制转换为一个右值类型。</p><p>它的常用场景是，如果我们希望把调用函数时的右值实参的右值性，保留在函数内部（而不是转化为左值），就去使用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; arg)</span></span>; <span class="comment">// 接受左值作为参数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; arg)</span></span>;      <span class="comment">// 接受右值作为参数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">process</span>(std::forward&lt;T&gt;(param)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时 </span></span><br><span class="line">Widget w; </span><br><span class="line"><span class="built_in">func</span>(w);            <span class="comment">// a. w 是一个左值 </span></span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">move</span>(w)); <span class="comment">// b. w 被转换为一个右值</span></span><br></pre></td></tr></table></figure><p>使用时，对于 a 情况，w 作为左值传入 <code>func</code>，万能引用形参的模板被实例化为左值（T 的类型是 <code>Widget&amp;</code>，依据引用折叠规则，<code>param</code> 的类型是 <code>Widget&amp;</code>），所以 <code>std::forward</code> 什么也不会做，最终调用的是 <code>void process(const Widget&amp; arg)</code> 重载版本；对于 b 情况，w 作为右值传入 <code>func</code>，形参被实例化为右值（T 的类型是 <code>Widget</code>，<code>param</code> 的类型是 <code>Widget&amp;&amp;</code>，<strong>注意它此时是左值</strong>），所以 <code>std::forward</code> 会将其转换为右值，传入 <code>process</code> 中，最终调用的是<code>void process(Widget&amp;&amp; arg)</code>。</p><p>如果对这块类型推导不清楚，可以回到第一章，再看看模板类型推导的规则，并结合后边提到的引用折叠来理解。<br>如果读完该条款，还是没有理解万能引用，那么本章后续的内容对你可能太深奥了，万能引用只是后续模板化编程的门槛石，还是先从其他地方搞明白这些概念为好。</p><p>最后做一个总结，如果你想要将一个左值尝试通过移动的方式交给函数内部，就使用 <code>std::move</code>；如果你在函数内，希望将外边传入的右值（函数内部变成左值），保持其右值性质，就使用 <code>std::forward</code>。但要记住，两者本质都是类型转换。</p><h2 id="条款-24：区分万能引用和右值引用"><a href="#条款-24：区分万能引用和右值引用" class="headerlink" title="条款 24：区分万能引用和右值引用"></a>条款 24：区分万能引用和右值引用</h2><p>当我们在代码中看到一个类型的声明中带有 <code>&amp;&amp;</code> 的时候，按最初的学习内容，会认为这是一个右值引用，因为左值引用是 <code>&amp;</code> 来标记的。然而，还有一种叫万能引用的东西。</p><p>万能引用本身的概念很简单，它既可以绑定左值，也可以绑定右值，所以它既可能是一个左值引用，也可能是一个右值引用，具体是哪种，取决于实例化时的入参。</p><p>读懂代码，首先要能分得清万能引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Object&amp;&amp; param)</span></span>;   <span class="comment">// 右值引用  </span></span><br><span class="line">Object&amp;&amp; var = <span class="built_in">Object</span>();  <span class="comment">// 右值引用 </span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var;        <span class="comment">// 万能引用 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">// 万能引用 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// 右值引用 </span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; var3 = var;  <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure><p>区分万能引用的依据是：</p><ol><li>类型都涉及类型推导；</li><li>不能带有 cv 属性；</li><li>必须是类型本身的推导，而不是二次推导的结果（比如 <code>std::vector&lt;T&gt;</code>）；</li><li>模板类中的函数，只有自身是一个模板函数；</li></ol><p>有关于最后一点的简单解释，书中的示例为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x); <span class="comment">// 它是右值引用，而不是万能引用 </span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp;&amp; x)</span></span>; <span class="comment">// 右值引用 </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>; <span class="comment">// 万能引用 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是标准库容器 <code>vector</code> 的实现，其中 <code>push_back</code> 中的 <code>T&amp;&amp;</code> 虽然满足万能引用的语法形式，实际上却是右值引用；而 <code>emplace_back</code> 参数才是万能引用，<code>Args&amp;&amp;</code> 是属于成员函数自己的模板类型。</p><blockquote><p><strong>谬误</strong>：符合 <code>T&amp;&amp;</code> 形式的模板参数类型，不一定是万能引用。</p></blockquote><p>记住这些规则没有意义，编译器也不会去用这种类型区分什么是万能引用。事实上万能引用只是一个抽象。它的本质是引用折叠，编译器使用引用折叠规则来推导这个引用类型是左值引用还是右值引用。</p><p>引用折叠的本质是第一章中提到的模板类型推导，包括 <code>auto</code> 类型推导，在后边会继续介绍。</p><p>虽然万能引用是一种抽象，但依然有必要了解什么是万能引用，一方面，是可以更方便的和其他开发成员沟通，另一方面，也能更好的读懂代码，写出高质量的代码。</p><h2 id="条款-25：灵活使用-std-move-和-std-forward"><a href="#条款-25：灵活使用-std-move-和-std-forward" class="headerlink" title="条款 25：灵活使用 std::move 和 std::forward"></a>条款 25：灵活使用 std::move 和 std::forward</h2><p>这一章节我看地很费劲，感觉一个很简单的知识点，翻译出来的内容非常晦涩难懂。</p><p>只要已经掌握本章节前边几个条款的介绍，这个条款的内容基本可以忽略了，都是重复的内容。</p><p>简单来说，当需要拿到一个右值引用时，使用 <code>std::move</code>，当需要拿到一个万能引用（也就是想要在入参的实参是右值时，才获得右值）时，使用 <code>std::forward</code>。</p><p>书中给出了一种错误地把 <code>std::forward</code> 替换为 <code>std::move</code> 导致的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;      </span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);   <span class="comment">// 这里使用了 std::move </span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  std::string name; </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Widget w; </span><br><span class="line">std::string str = <span class="string">&quot;name&quot;</span>; </span><br><span class="line">w.<span class="built_in">setName</span>(str);   <span class="comment">// 这里将左值 str 传入</span></span><br></pre></td></tr></table></figure><p>这个例子中，<code>str</code> 是一个左值，但在 <code>setName</code> 函数中，通过 <code>std::move</code> 将其转换为右值。编译器会认为，外边的 <code>str</code> 已经是一个无效的值，在内部调用了 <code>std::string</code> 的移动赋值将内容放到了成员 <code>name</code> 中。<br>将 <code>std::move</code> 替换为 <code>std::forward</code> 就可以保证不出现意外。</p><p>另外一个值得聊的话题，是返回值优化（RVO）。考虑一下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  Widget w; </span><br><span class="line">  <span class="keyword">return</span> w; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  Widget w; </span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略地看，我们会认为第一版函数中，返回时会发生复制构造，而第二版函数中，会发生移动构造（假设 <code>Widget</code> 实现了移动语义）；然而，实际上第一版中，发生了移动构造，而第二版中，发生了复制构造。</p><p>究其原因，是因为第一版代码中，满足编译器的返回值优化，编译器会在函数外边的栈上分配 <code>Widget</code> 的内存，并将构造直接放在外边，从而避免复制操作；而在第二版中，由于手动使用了 <code>std::move</code> 操作，它返回的是右值引用，编译器不得不为引用对象生成一个原始对象，从而阻碍了编译器去做返回值优化。</p><p>有关于返回值优化不是特别难懂的一个知识点，可以从其他地方了解更多细节。</p><h2 id="条款-26：避免在重载函数中使用到万能引用类型的形参"><a href="#条款-26：避免在重载函数中使用到万能引用类型的形参" class="headerlink" title="条款 26：避免在重载函数中使用到万能引用类型的形参"></a>条款 26：避免在重载函数中使用到万能引用类型的形参</h2><p>重载是很常见的 C++ 应用技巧，万能引用作为一种函数形参的类型，自然也可以当作重载的一种实现，然而，当你这么做时，就开始掉入一个有点危险的坑里边。</p><p>考虑这样一个场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 万能引用版本的函数 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; name)</span> </span>&#123; </span><br><span class="line">  names.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代码 </span></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;name&quot;</span>)</span></span>; </span><br><span class="line"><span class="built_in">func</span>(name);   <span class="comment">// name 是一个 std::string 的左值，调用到了万能引用版本 </span></span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">string</span>(<span class="string">&quot;name&quot;</span>));   <span class="comment">// 实参是 std::string 的右值，也会调用到万能引用版本 </span></span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// 字面量字符串，也会作为右值，调用到万能引用版本</span></span><br></pre></td></tr></table></figure><p>我们可能最初希望以上述这种代码来实现功能，事实上工作地很好，第一个调用是以左值传入，会执行一次复制构造；第二个调用是以右值传入，在万能引用的加持下，实际执行了 <code>string</code> 的移动构造；第三个是字面量，编译器事实上会利用 <code>emplace</code> 的移动构造，直接在 <code>names</code> 的内存位置构造一个 <code>string</code>，省去了在 <code>func</code> 中的一次 <code>string</code> 形参实例化。</p><p>然而，当我们有一个新的需求，需要添加一个重载版本的 <code>func</code>，问题就出现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一个同名的重载函数，形参为 int </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123; </span><br><span class="line">  names.<span class="built_in">emplace_back</span>(<span class="built_in">find_name</span>(idx)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代码 </span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>); <span class="comment">// 调用到了 func(int) 这个重载版本，没有问题 </span></span><br><span class="line"><span class="type">short</span> idx = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">func</span>(idx); <span class="comment">// 编译器报错！</span></span><br></pre></td></tr></table></figure><p>讨论为什么第二个调用，没有按预期调用到 <code>func(int)</code> 的重载版本，而是报错，便是本条款要引出的问题。</p><p>实际很容易理解，第一个调用，常量 1 会被编译器当作 <code>int</code> 类型，直接匹配到 <code>func(int)</code>，而传入 <code>short idx</code>，在决策使用哪个重载版本时，却使用了万能引用所在的模板函数的实例化，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万能引用的模板函数，以 short 实例化后的结果 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">short</span> name)</span> </span>&#123; </span><br><span class="line">  names.<span class="built_in">emplace_back</span>(name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器发现，以万能引用作为参数的模板函数，实例化后的版本，能够完美匹配时，相比于另一个 <code>func(int)</code> 版本还需要类型转换，自然使用万能引用模板函数的实例化更合理。而我们也发现，<code>names</code> 的类型，是无法接收 <code>short</code> 作为构造函数参数的（<code>string</code> 类型不能通过 <code>short</code> 构造），所以编译器就报错了。</p><p>实际上的编译器报错可能会输出一大串似乎没有什么用的信息，这是 C++ 模板出现问题时，不人性化的体现。于是，当编译报错出现时，很可能不太容易发现是这里的问题。</p><p>依据 C++ 规范，编译器会认为，模板实例化后的版本，没有任何的额外成本，所以这么选择是合理的，自然不能去怪编译器。所以，也就是本条款要提的主题，避免为万能引用作为形参的函数，提供重载版本。形参为万能引用的函数，是重载版本中最贪婪的。</p><p>之所以第一个版本：<code>func(1)</code> 没有问题，是因为 C++ 也规定了，如果模板实例化后的版本和另一个重载的普通函数是一样的，那么优先使用普通函数的版本。</p><blockquote><p><strong>陷阱</strong>：盲目使用万能引用而不顾及其他，可能会带来潜在问题。</p></blockquote><p>当发现一个问题时，最好能举一反三。书中便进一步继续这个话题。当万能引用的版本作为类的构造函数，又会发生什么现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">Person</span>(T&amp;&amp; n) : <span class="built_in">name</span>(n) &#123;&#125; </span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> i) : <span class="built_in">name</span>(<span class="built_in">find_name</span>(i)) &#123;&#125; </span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  std::string name; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代码 </span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;name&quot;</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 编译报错！</span></span><br></pre></td></tr></table></figure><p>这里第一眼看上去，报错很匪夷所思，我们希望调用到 <code>Person</code> 的复制构造函数，为什么就出错呢？<br>原因还是在于万能引用，我们提供的万能引用版本的构造函数，实际上可以实例化出来一个类似复制构造函数的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化为 </span></span><br><span class="line">Person::<span class="built_in">Person</span>(Person&amp; p) : <span class="built_in">name</span>(p) &#123;&#125;</span><br></pre></td></tr></table></figure><p>万万没想到，本来只是打算通过万能引用的构造函数，来接收一个 <code>name</code> 作为参数，结果却把 <code>Person</code> 对象也实例化出来了。</p><p>而我们也知道，编译器生成的默认复制构造函数，其参数是带有 <code>const</code> 属性的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器隐式生成的复制构造函数 </span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) : <span class="built_in">name</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>编译器在实例化万能引用的模板构造函数后，经过权衡，发现使用模板实例化的版本，不需要额外添加 <code>const</code> 属性，所以选择了这个模板实例化的版本。然后，我们便看到了将 <code>name</code> 这个 <code>string</code> 类型的对象，使用 <code>Person</code> 对象（形参）来构造，自然无法实施，导致报错。</p><p>事实上，如果调用代码中，采用以下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Person <span class="title">p3</span><span class="params">(<span class="string">&quot;name&quot;</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p4</span><span class="params">(p3)</span></span>; <span class="comment">// 正常，调用复制构造函数</span></span><br></pre></td></tr></table></figure><p>问题便不存在了，原因和之前非类内的阐述是一样的。</p><p>当这个话题出现在继承结构中，也会出现类似的问题。假设有个类继承自 <code>Person</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span> : <span class="keyword">public</span> Person &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) : <span class="built_in">Person</span>(rhs) &#123; ... &#125; </span><br><span class="line">  <span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs) : <span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs)) &#123; ... &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码中，对 <code>SpecialPerson</code> 的复制构造函数和移动构造函数中，对 <code>Person</code> 的构造，实际上都调用了基类 <code>Person</code> 的完美转发构造函数，并都会编译失败。</p><p>在这一条款中得到的经验就是，尽可能不要去把万能引用参数的函数去做重载。在下一条款，我们会深入介绍几个技术，来迎着困难而上。</p><blockquote><p><strong>陷阱</strong>：小心不要把万能引用参数的函数去做函数重载，很可能在调用时，会得到错误的重载版本。</p></blockquote><h2 id="条款-27：重载中出现万能引用时的替代方案"><a href="#条款-27：重载中出现万能引用时的替代方案" class="headerlink" title="条款 27：重载中出现万能引用时的替代方案"></a>条款 27：重载中出现万能引用时的替代方案</h2><p>针对 <strong>条款 26</strong>，本条款提供了一些可以解决前述问题的替代方案。</p><h3 id="方案-1：放弃重载"><a href="#方案-1：放弃重载" class="headerlink" title="方案 1：放弃重载"></a>方案 1：放弃重载</h3><p>当出现万能引用时，不要使用重载，而是用不同的函数名称来实现功能。</p><p>这是一种逃避策略，但逃避不一定意味着不好。事实上当你看完整个条款后，再回过头，会发现这种方案反而是最直接也是最推荐的做法，至少在大多数项目中，与其设计复杂的、高端的编程技巧，远不如设计简单的、易维护的代码。</p><h3 id="方案-2：将万能引用改为左值引用"><a href="#方案-2：将万能引用改为左值引用" class="headerlink" title="方案 2：将万能引用改为左值引用"></a>方案 2：将万能引用改为左值引用</h3><p>既然两个特性冲突时容易有问题，除了放弃重载，自然也可以放弃万能引用。将万能引用类型全部改为常量左值引用。<br>这种做法失去了万能引用的性能优势，但如果放弃性能能带来代码的简洁性和安全性，也不失为一种可斟酌的方案。</p><h3 id="方案-3：将引用改为传值"><a href="#方案-3：将引用改为传值" class="headerlink" title="方案 3：将引用改为传值"></a>方案 3：将引用改为传值</h3><p>虽然我们使用引用是为了改进性能，但有些时候，即便使用传值，也并不是带来额外的性能开销。在 <strong>条款 41</strong> 中会详细阐述这个问题。</p><p>实践经验中，当知道什么情况下引用类型可以改进性能时，也就有能力去判断什么情况下，传值也能带来类似的效果，反而还规避了之前的问题。</p><h3 id="方案-4：标签分派"><a href="#方案-4：标签分派" class="headerlink" title="方案 4：标签分派"></a>方案 4：标签分派</h3><p>前边 3 个方案都可以认为是逃避式的方案，不过确实有一些直接解决问题的方案。</p><p>重载决议时，编译器会考察所有重载版本的形参和传入的实参，匹配全局的最优函数。既然万能引用很强大，总是能优先吸引编译器选择自己所在的重载版本，那么我们可以给重载函数多加一个参数，用额外的这个参数来制约万能引用形参的吸引力。</p><p>我们重新修改 <strong>条款 26</strong> 中的重载函数，为了保证对外接口不变，将添加额外参数的函数设置为其内部的子函数，也将重载这个内部子函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 万能引用版本的函数 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; name)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">funcImpl</span>(std::forward&lt;T&gt;(name),             </span><br><span class="line">           std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;()); <span class="comment">// 注意这里 </span></span><br><span class="line">  <span class="comment">// 在 C++14 中，写法可以更简单 </span></span><br><span class="line">  <span class="comment">// funcImpl(std::forward&lt;T&gt;(name), </span></span><br><span class="line">  <span class="comment">//          std::is_integral&lt;std::remove_reference_t&lt;T&gt;()); </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部的子函数，添加 tag 控制重载决议 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span> </span>&#123; </span><br><span class="line">  names.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(name)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span> </span>&#123; </span><br><span class="line">  names.<span class="built_in">emplace_back</span>(<span class="built_in">find_name</span>(idx)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个额外的形参 <code>std::false_type</code> 和 <code>std::true_type</code> 被称为 tag，基于这种方式的重载决议也被叫做 <strong>标签分派（tag dispatch）</strong>。</p><p>代码中 <code>std::is_integral&lt;T&gt;</code> 和 <code>std::remove_reference&lt;T&gt;</code> 是类型特征（type traits），之前条款中已经出现过，C++ 的类型特征很多，它们用于对类型做处理或者判断。本例子中，首先注意到第二个 tag 参数返回的是一个 “是否是整形类型” 的判断。因为类型特征是一个编译期行为，所以判断的结果，也应该是一个静态的状态，所以 C++ 标准库中提供了名为 <code>std::false_type</code> 和 <code>std::true_type</code> 这样的静态类型。注意到，这些 tag 并没有形参的名字，所以它们在运行期不会起作用，编译器会在生成程序时，去除掉这种形参（即使不去掉也不影响我们理解代码）。</p><p>继续观察 <code>std::is_integral&lt;T&gt;</code> 中的 <code>T</code>，为了保证无论传入的类型是 <code>T</code> 还是 <code>T&amp;</code> 或 <code>T&amp;&amp;</code>，都应该去处理，使用了 <code>std::remove_reference&lt;T&gt;</code> 来移除引用属性。</p><p>最终，在重载决议时，如果类型 <code>T</code> 是一个整形，那么 tag 实参的判断就是 <code>true_type</code>，会选中第二个（第一个形参为 <code>int</code>）重载版本；否则，tag 判断是 <code>false_type</code>，会选中第一个（第一个形参为 <code>T&amp;&amp;</code>）重载版本。将 tag 作为重载函数参数，掩盖了万能引用影响重载决议的吸引力，最终达到我们的目的。</p><p>说句题外话，C++ 的很多复杂性的演化动力，就来自于这种不断对现有技术中的缺陷进行更多设计和改善的需求中。换句话说，不断地用一个更复杂的补丁，弥补之前的不足。</p><h3 id="方案-5：处理类构造函数中存在万能引用的问题"><a href="#方案-5：处理类构造函数中存在万能引用的问题" class="headerlink" title="方案 5：处理类构造函数中存在万能引用的问题"></a>方案 5：处理类构造函数中存在万能引用的问题</h3><p>在 <strong>条款 26</strong> 中，还提到了如果类构造函数中使用了万能引用，调用构造函数时，本欲调用复制构造函数，却实际调用到了万能引用版本的构造函数。方案 4 无法解决这个问题，因为复制构造函数有可能是编译器自己生成的，所以没办法用方案 4 中，实现一个子函数来做重载。</p><p>万能的 C++ 当然考虑到了这一点，实际上，标准库中很多代码都面临这个问题，学习这块知识有助于我们去阅读学习标准库中的代码，也有助于理解和读懂编译报错时的信息。这部分会比较复杂，但也依然是类型特征的范畴。</p><p>由于没办法自己生成带有标签分派的重构函数，所以只能另寻他法，这里引出一个新的东西：<code>std::enable_if</code>。</p><p>如果你看过一些标准库或复杂的 C++ 项目，就应该已经熟悉它，它可以指定编译器处理一个模板实例化时的条件。默认的模板总是使能的，但如果 <code>enable_if</code> 中的条件不满足，那么模板将会被禁用，有关于完整的原理这里不展开（可以在网上查一下 SFINAE）。针对我们的问题，实际上，我希望在带有万能引用形参的模板中，加入这个功能，控制仅当满足特定条件时才启用该模板。下边，我们将讨论指定什么条件可以达成我们的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt; </span><br><span class="line">                         !std::is_same&lt;Person,</span><br><span class="line">                                       <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                                       &gt;::value</span><br><span class="line">                         &gt;::type</span><br><span class="line">             &gt;</span><br><span class="line">  <span class="built_in">Person</span>(T&amp;&amp; name); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码中的条件很复杂，如果之前没看过这个代码，也没关系，现在一起来看一下。代码按关键位置做了换行，以方便阅读。</p><p>简单来说，模板参数的第二项：<code>typename = typename std::enable_if&lt;...&gt;::type</code> 是对 <code>enable_if</code> 的使用，当满足 <code>...</code> 中的条件时，该模板被启用；</p><p>展开里边的结构：<code>!std::is_same&lt;...&gt;::value</code> 是启用条件，也是一个类型特征，它的语义为，当 <code>...</code> 中指定的两个类型不同时，模板被启用；</p><p>再继续展开：<code>Person, typename std::decay&lt;T&gt;::type</code>，指定了两个要比较的类型，第一个是 <code>Person</code> 类，第二个是另一个类型特征，<code>std::decay&lt;T&gt;::type</code> 的语义是，将类型 <code>T</code> 的引用属性、CV 特性（const 和 volatile）、数组和函数等类型，简化为最简单的形式。换句话说，比如 <code>T&amp;</code> 或 <code>T&amp;&amp;</code>，<code>const T&amp;</code> 或 <code>const T&amp;&amp;</code> 等等类型，经过该类型特征，输出都是 <code>T</code>。</p><p>总结起来，这个代码设定的就是，当某个类型 <code>T</code>，将其简化后（经过 <code>decay</code>），和 <code>Person</code> 不同时，该万能引用作为形参的构造函数，将被启用；否则，不会被启用。那么，针对上一个条款中的问题，当遇到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;name&quot;</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure><p>便可正常编译，因为 <code>p1</code> 被推断为 <code>Person</code> 类型，万能引用模板构造函数被禁用了，编译器只能找到复制构造函数。</p><p>以上我们已经开始逐步地接触模板元编程（TMP），感兴趣可以到其他地方学习。类型特征是模板元编程中一块重要的内容，可以理解为是类型的类型，在 Rust 等编程语言中，被称为特征 trait。要想熟练模板元编程，对类型特征的集合要有一定的熟悉度，这在大多数 C++ 教材中，都不会大篇幅介绍。</p><h3 id="方案-6：处理继承结构中遇到的问题"><a href="#方案-6：处理继承结构中遇到的问题" class="headerlink" title="方案 6：处理继承结构中遇到的问题"></a>方案 6：处理继承结构中遇到的问题</h3><p>在继承结构中，比如 <strong>条款 26</strong> 中最后的 <code>SpecialPerson</code> 示例，目前使用方案 5 还是无法解决。因为 <code>decay</code> 无法将一个派生类型简化为其基类类型，导致 <code>enable_if</code> 通过。</p><p>C++ 标准当然为我们考虑到了这一点，使用 <code>std::is_base_of</code> 便可以处理派生类和基类之间比较的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt; </span><br><span class="line">                         !std::is_base_of&lt;Person,</span><br><span class="line">                                          <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                                           &gt;::value</span><br><span class="line">                         &gt;::type</span><br><span class="line">             &gt;</span><br><span class="line">  <span class="built_in">Person</span>(T&amp;&amp; name); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>is_base_of</code> 取代 <code>is_same</code> 即可。当两个类型相同的类型使用 <code>is_base_of</code>，如 <code>std::is_base_of&lt;Person, Person&gt;</code>，结果依然是成立的，所以可以放心大胆地取代 <code>is_same</code>。</p><p>对了，以上代码使用 C++14 均可以更简洁一些，结果是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt; </span><br><span class="line">                         !std::is_base_of&lt;Person,</span><br><span class="line">                                          std::<span class="type">decay_t</span>&lt;T&gt; &gt;::value</span><br><span class="line">                         &gt;</span><br><span class="line">            &gt; </span><br><span class="line">  <span class="built_in">Person</span>(T&amp;&amp; name); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>被绕了很久，已经逐渐忘记最初的目标是什么了，做一个简单的回顾。</p><p>在本章节开始时，我们介绍了万能引用的作用，而在 <strong>条款 26</strong> 中，却提出了当万能引用函数和重载、或者和构造函数一起出现时，会遇到的棘手问题。在本条款中，提出了几种简单的和复杂的方案，去解决这些问题。</p><p>最后的结论依然是，如果可以用前边几个简单的方案来解决这些问题，那么就去用便好了，在工程实践中，追求技术的专业和高效并不是最优的，代码的稳定性和可维护性才是更重要的事情。如果你是在编写库代码、做技术研究，或者单纯地就是想追寻极致的代码之美，试试模板元编程也并不为过。</p><p>但需要注意，C++ 一个极其让人诟病的地方就是它的报错很可能非常复杂，问题点夹杂在冗长的编译报错消息中，难以检查，即使你不去自己使用这些高深的技术，只要使用了标准库，也很可能会体会到，或已经深受其害。如果去使用这些技术，那么就要做好充分的心理准备，去面对恐怖的报错清单（C++20 的 Concept 一定程度上缓解了这里的烦恼）。</p><p>唯一值得安慰的是，当你掌握这些技术之后，你就已经超过了绝大多数 C++ 开发者，面对相同问题时，就更可能快速定位问题。</p><h2 id="条款-28：理解引用折叠"><a href="#条款-28：理解引用折叠" class="headerlink" title="条款 28：理解引用折叠"></a>条款 28：理解引用折叠</h2><p>到这里，我们终于可以展开说一下什么是万能引用。在这之前，需要先引入一个概念叫 <strong>引用折叠（reference collapse）</strong>。</p><p>C++ 中，不允许出现引用的引用，如果你这么写了，编译器会报错。但编译器自己却允许在内部推导时，出现引用的引用，它会将其合并起来，这就是引用折叠。引用折叠的规则是：</p><ol><li>如果其中存在左值引用，那么折叠后是左值引用。比如 <code>T&amp; &amp; =&gt; T&amp;</code>，<code>T&amp; &amp;&amp; =&gt; T&amp;</code> 以及 <code>T&amp;&amp; &amp; =&gt; T&amp;</code>；</li><li>如果都是右值引用，那么折叠后是右值引用。比如 <code>T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</code>；</li></ol><p>注意，这些都是编译器内的行为，不能写出这种代码。</p><p>C++ 中使用引用折叠的场合有 4 个：</p><ol><li>模板实例化（万能引用就是其中的一种实践）；</li><li>auto 类型推导（本质上和模板实例化一样）；</li><li>typedef 类型定义；</li><li>decltype 表达式类型推导；</li></ol><p>接下来我们要使用引用折叠规则了。回到我们的万能引用中，对于一个典型示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;T&gt;(arg)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>arg</code> 是一个万能引用，所以我们知道，传入 <code>f</code> 的实参是左值还是右值，会被编码到形参类型 <code>T</code> 中。<strong>万能引用能做到的是，当实参是一个左值时，<code>T</code></strong> <strong>的结果是一个左值引用，当实参是一个右值时，<code>T</code></strong> <strong>的结果是一个非引用类型</strong>（注意和引用折叠做区分，这里并不是一个右值引用，这是模板推导规则之一，可见<strong>条款 1</strong>）。</p><p>我们再将 <code>std::forward</code> 的定义写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次考虑一下。首先，当函数 <code>f</code> 的实参是一个左值时，由于万能引用的推导，<code>f</code> 的模板类型 <code>T</code> 是一个左值引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推导后： </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; &amp;&amp; arg)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;Widget&amp;&gt;(arg)) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用折叠后： </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp; arg)</span> </span>&#123;   <span class="comment">// 折叠为左值引用 </span></span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;Widget&amp;&gt;(arg)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>forward</code> 的实例化结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推导后： </span></span><br><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用折叠后： </span></span><br><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forward</code> 函数实际上什么也没做，返回了一个左值引用。<br>整体上来看，当给万能引用模板函数 <code>f</code> 传入一个左值时，传递给函数 <code>g</code> 的实参也是一个左值引用，符合完美转发的设定。</p><p>考虑第二种情况，当函数 <code>f</code> 的实参是一个右值时，由于万能引用的推导，<code>f</code> 模板类型 <code>T</code> 是一个右值（非引用类型）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推导后： </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget arg)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;Widget&gt;(arg)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>forward</code> 的实例化结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static</span>&lt;Widget&amp;&amp;&gt;(param); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>forward</code> 将一个左值引用作为输入，返回了一个类型转换后的右值引用。</p><p>整体上来看，当给万能引用模板函数 <code>f</code> 传入一个右值时，传递给函数 <code>g</code> 的实参，也是一个右值引用，同样符合完美转发的设定。</p><p>最后，对万能引用做一个定义。万能引用并非一种新的引用类型，它其实就是满足以下语境的右值引用：</p><ol><li>类型推导过程会区分左值和右值；</li><li>会发生引用折叠；</li></ol><h2 id="条款-29：假定移动操作不会发生或成本更高"><a href="#条款-29：假定移动操作不会发生或成本更高" class="headerlink" title="条款 29：假定移动操作不会发生或成本更高"></a>条款 29：假定移动操作不会发生或成本更高</h2><p>如果你已经很顺利地看完了前边的内容，那么这一条很容易理解。</p><p>C++ 的移动操作并不保证一定会发生移动操作，他仅仅只是把一个类型转换为右值，所以虽然用到了 <code>std::move</code>，移动也不一定总会发生；或者虽然没有显式使用移动语义，但编译器可能会调用移动构造和移动运算符的场景，移动也不总是会发生。</p><p>可能的一些原因有：</p><ol><li>对象没有提供移动操作，或者编译器无法自动为对象添加移动操作；</li><li>如果对象有移动操作，但移动操作可能并不会比复制操作更快；</li><li>如果移动操作本可以发生，但如果对象要求强异常安全保证，而移动没有添加 <code>noexcept</code>，那么移动操作也不会调用；</li></ol><p>对于其中的第 2 点，展开说一下。移动操作本质上没有什么神奇的，移动比复制快的原因，是因为移动是浅拷贝，也就是只复制了指向数据的指针，而没有复制数据本身。如果一些类型，它的数据本身就是其自身的一部分，比如 <code>std::array</code>，或者小数据量下的 <code>std::vector</code> 和 <code>std::string</code>，当对它们做移动操作时，和复制操作没有效率上的优势。</p><h2 id="条款-30：完美转发失败的情况"><a href="#条款-30：完美转发失败的情况" class="headerlink" title="条款 30：完美转发失败的情况"></a>条款 30：完美转发失败的情况</h2><p>最后，我们来看一下，完美转发不适用的场景。事实上，大多数使用完美转发的情形都是符合规范的，本条款中提到的一些情况，都是很罕见的用法。</p><p>首先来定义一个问题，我们要讨论的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;T&gt;(param)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以下两种用法，产生的效果是等价的，那么就可以认为完美转发成功了，否则，完美转发失败了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>( expression ); <span class="comment">// 直接调用内部函数 </span></span><br><span class="line"><span class="built_in">f</span>( expression ); <span class="comment">// 调用外部函数，通过完美转发参数，间接执行内部函数</span></span><br></pre></td></tr></table></figure><p>我们来看一下哪些场景不适用完美转发。</p><h3 id="情况-1：大括号初始化"><a href="#情况-1：大括号初始化" class="headerlink" title="情况 1：大括号初始化"></a>情况 1：大括号初始化</h3><p>在第一章 <strong>条款 1</strong> 的讨论中，我们将大括号初始化来做模板类型推导时，就发现这种推导是无法执行的，所以，很显然，如果函数 <code>f</code> 传入的是一个大括号初始化，那么就不可能通过编译。<br>比如，函数 <code>g</code> 的定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure><p>以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 可以通过编译，编译器隐式转换大括号初始化为 std::vector </span></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure><p>有意思的是，在 <strong>条款 2</strong> 的讨论中，我们知道，<code>auto</code> 类型是可以接受大括号初始化类型推导的，所以一种变通的修改方案是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 先通过 auto 将大括号初始化转换为 std::initializer_list&lt;int&gt; </span></span><br><span class="line"><span class="built_in">f</span>(temp); <span class="comment">// 模板参数被推导为 std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h3 id="情况-2：0-和-NULL-用作空指针"><a href="#情况-2：0-和-NULL-用作空指针" class="headerlink" title="情况 2：0 和 NULL 用作空指针"></a>情况 2：0 和 NULL 用作空指针</h3><p>读到这里的读者，应该不再会愿意使用 0 和 <code>NULL</code> 来指定空指针了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);       <span class="comment">// 预期想推导为 void*，结果推导为 int </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);    <span class="comment">// 同理 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// 被推导为 nullptr_t，指针类型</span></span><br></pre></td></tr></table></figure><p>由于函数 <code>f</code> 的形参需要一个万能引用，而常量因为没有地址，无法被引用，所以编译会失败。</p><h3 id="情况-3：声明为-static-const-的成员变量"><a href="#情况-3：声明为-static-const-的成员变量" class="headerlink" title="情况 3：声明为 static const 的成员变量"></a>情况 3：声明为 static const 的成员变量</h3><p>在 C++ 中有这样一个规定，如果类的成员函数中，声明了 <code>static const</code> 的成员，由于这样一个成员实际上可以被编译器当作常量来对待，所以编译器不会要求必须给这个成员做定义（只需要做声明）。</p><p>而如果这样一个成员变量，没有定义而只有声明，编译器编译不会报错，但对于将他作为 <code>f</code> 的参数绑定到万能引用类型形参，就同样遇到了无法被引用的错误。它会在链接时报错，找不到名称的定义。</p><p>修改的方案就是，为它提供定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> Val = <span class="number">18</span>; <span class="comment">// 声明 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// static const std::size_t Val;  // 定义 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(Val); <span class="comment">// 正确，等价于 g(18); </span></span><br><span class="line"><span class="built_in">f</span>(Val); <span class="comment">// 若 Val 未定义，链接报错</span></span><br></pre></td></tr></table></figure><h3 id="情况-4：重载函数和模板函数"><a href="#情况-4：重载函数和模板函数" class="headerlink" title="情况 4：重载函数和模板函数"></a>情况 4：重载函数和模板函数</h3><p>对于重载函数和模板函数，都存在着没有地方指导万能引用确定引用哪个版本的重载函数或模板实例化的问题，从而导致编译失败。</p><p>看下重载函数的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> val)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> priority)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 g 的定义为： </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; </span><br><span class="line"><span class="built_in">g</span>(processVal); <span class="comment">// 一切正常，会将第一个重载函数的地址传入函数 </span></span><br><span class="line"><span class="built_in">f</span>(processVal); <span class="comment">// 编译报错，万能引用并不知道要引用哪个重载函数</span></span><br></pre></td></tr></table></figure><p>然后再来看模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">processValTemp</span><span class="params">(T param)</span> </span>&#123; ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 g 的定义为： </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; </span><br><span class="line"><span class="built_in">g</span>(processValTemp); <span class="comment">// 一切正常，会被引用到模板参数为 int 类型的模板实例化函数 </span></span><br><span class="line"><span class="built_in">f</span>(processValTemp); <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><p>调整方案都是一样的，使用一个额外的对象，先为输入的实参做好类型签名，再传递给 <code>f</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*)(<span class="type">int</span>) processValPtr = processVal; </span><br><span class="line"><span class="built_in">f</span>(processValPtr); <span class="comment">// 正确 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">static_cast</span>&lt;<span class="built_in">int</span> (*)(<span class="type">int</span>)&gt;(processValTemp)); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="情况-5：位域"><a href="#情况-5：位域" class="headerlink" title="情况 5：位域"></a>情况 5：位域</h3><p>从前边几个情况，可以发现一个普适的规律，万能引用是一种引用，所以它需要绑定的对象，一定是要能找到地址的（可引用的）。位域是另一种无法被直接引用的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IP</span> &#123;   </span><br><span class="line">  std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">                IHL:<span class="number">4</span>,</span><br><span class="line">                DSCP:<span class="number">6</span>,</span><br><span class="line">                ECN:<span class="number">2</span>,</span><br><span class="line">                totalLength:<span class="number">16</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 g 的定义是： </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(std::<span class="type">uint32_t</span> sz)</span></span>;  </span><br><span class="line">IP ip; </span><br><span class="line"><span class="built_in">g</span>(ip.totalLength); <span class="comment">// 正确 </span></span><br><span class="line"><span class="built_in">f</span>(ip.totalLength); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>由于位域是由机器字上的若干任意部分组成的，所以无法为其取地址，从而就意味着无法引用。</p><hr><p>如果你看到这里，还比较自在，说明你对 C++ 的掌握能力，已经很不错了。有关于万能引用和模板实例化的高级技术，上文中都没有展开，但那些东西是通往高级 C++ 工程师的必经之路，谦虚地说，我还没有完全入门。</p><p>如果你到此依然充满热情，那就继续准备开下一章节吧，后半部书中，会讨论一些有不同风味的知识。</p><p>本系列的其他文章：</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li><li><a href="/posts/57a898cb.html" title="Effective Modern C++ 读书笔记：转向现代C++">Effective Modern C++ 读书笔记：转向现代C++</a></li><li><a href="/posts/ce1aec80.html" title="Effective Modern C++ 读书笔记：智能指针">Effective Modern C++ 读书笔记：智能指针</a></li><li><a href="/posts/410ab8fb.html" title="Effective Modern C++：右值引用、移动语义和完美转发">Effective Modern C++：右值引用、移动语义和完美转发</a></li><li><a href="/posts/cd605d5c.html" title="Effective Modern C++：lambda 表达式">Effective Modern C++：lambda 表达式</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1949164417171306465">https://zhuanlan.zhihu.com/p/1949164417171306465</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ 读书笔记：智能指针</title>
    <link href="https://p2tree.top/posts/ce1aec80.html"/>
    <id>https://p2tree.top/posts/ce1aec80.html</id>
    <published>2025-08-26T22:31:06.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>智能指针是现代 C++ 中的一个重要内容，以至于当使用现代 C++ 编程时，智能指针可以完全取代裸指针。</p><p>使用 C 风格裸指针，存在很多已经被人诟病已久的问题，比如：</p><ol><li>裸指针从声明中，无法看出它指向的是对象还是数组；</li><li>无法通过裸指针本身来判断，是否需要析构它的资源；</li><li>就算知道需要析构资源，也不知道应该怎么析构，是直接调用 <code>delete</code> 还是调用某个用于释放资源的函数；</li><li>另外，同第1条，也不可能知道应该调用 <code>delete</code> 还是 <code>delete[]</code>，这都带来了很多风险；</li><li>在使用裸指针的工程中，时刻都需要考虑这些资源在不同路径下的状态，除了常规代码逻辑外，还需要考虑发生异常时的路径。一旦有所疏忽，便会出现资源泄漏或未定义行为；</li><li>如果资源释放时，没有将裸指针置为 0，那么将来再次意外解引用时，就会遇到悬挂指针问题；</li></ol><p>为了解决这些问题，现代 C++ 提出了几种智能指针，它的本质是依靠 C++ 的 RAII 设计理念，将资源管理和对象生命周期绑定在一起，从而避免让程序员主动去操作资源释放的行为。<code>unique_ptr</code> 和 <code>shared_ptr</code> 是两种最常见的智能指针，另外还有 <code>weak_ptr</code> 用于解决 <code>shared_ptr</code> 的循环引用问题，在后续内容中会逐个展开讨论。<code>auto_ptr</code> 在 C++11 中被 <code>unique_ptr</code> 取代，所以不要再使用。</p><h2 id="条款-18：优先使用-unique-ptr"><a href="#条款-18：优先使用-unique-ptr" class="headerlink" title="条款 18：优先使用 unique_ptr"></a>条款 18：优先使用 unique_ptr</h2><p>当需要使用指针来引用一块资源时，考虑使用智能指针；当需要使用智能指针时，优先考虑 <code>unique_ptr</code>。这里的原则是，大多数情况下，我们分配的资源，是交给“一个”目标使用的，所以专属所有权通常就足够了。</p><p><code>unique_ptr</code> 使用移动语义来实现指针的转移，它没有复制操作，所以才能实现“唯一性”。</p><p>它最常见的用处是作为工厂函数的返回值。一个工厂函数，通常是在函数内部创建一个位于堆上的对象，返回之后，需要交接资源的所有权，这就是 <code>unique_ptr</code> 的用武之地。交接之后，资源的责任人变成了调用工厂函数的一方。</p><h3 id="自定义析构器"><a href="#自定义析构器" class="headerlink" title="自定义析构器"></a>自定义析构器</h3><p><code>unique_ptr</code> 具有自定义析构函数。一个自定义析构函数，是指当智能指针被析构时，选择调用的函数。比如，我们希望在析构智能指针时，打印一些日志，那么就可以使用自定义析构函数。</p><p>自定义析构函数可以通过智能指针的第二个模板参数来指定，它可以是函数指针，函数对象或 lambda 表达式等可调用类型，它接受一个参数，类型为原始资源的裸指针。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delFunc = [](Object* obj) &#123; </span><br><span class="line">  <span class="comment">// do some other thing  </span></span><br><span class="line">  <span class="keyword">delete</span> obj; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边是一个工厂函数，返回 Object 对象的 unique_ptr，并包含自定义析构函数 delFunc </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; </span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Object*, <span class="title">decltype</span><span class="params">(delFunc)</span>&gt; <span class="title">makeObject</span><span class="params">(Ts&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>示例中，使用 lambda 表达式作为智能指针的自定义析构函数。</p><p>通常，我们知道，<code>unique_ptr</code> 对象的大小，和裸指针的大小是一样的。不过，当引入智能指针时，问题需要进一步讨论。</p><p>当析构器是函数指针时，这个函数指针需要保存在 <code>unique_ptr</code> 的对象内，所以通常 <code>unique_ptr</code> 的大小会增加几个字节（指针大小）；当析构器是函数对象时，析构器对 <code>unique_ptr</code> 空间的影响，则取决于函数对象本身占用的存储空间；当析构器使用 lambda 表达式指定时，因为我们知道，lambda 表达式的本质也是函数对象，对于空捕获列表的 lambda 表达式，不会对 <code>unique_ptr</code> 的空间产生额外需求，但当存在捕获列表时，占用空间则与捕获列表中对象的空间占用相同。</p><p>最后，虽然 <code>unique_ptr</code> 可以用来保存一个数组资源，也就是 <code>std::unique_ptr&lt;T[]&gt;</code>，但绝大多数场景下没有这个必要，请使用 <code>vector</code>，<code>array</code> 等线性容器来替代它。</p><p>同时，当需要将 <code>unique_ptr</code> 转换为 <code>shared_ptr</code> 时，不要尝试获取它的裸指针后，初始化新的 <code>shared_ptr</code>，这样将很可能带来资源被重复释放的问题。C++ 提供了从 <code>unique_ptr</code> 向 <code>shared_ptr</code> 的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将工厂函数返回的 unique_ptr 直接转换为 shared_ptr，也是允许的 </span></span><br><span class="line">std::shared_ptr&lt;Object&gt; sp = <span class="built_in">makeObject</span>(arguments);</span><br></pre></td></tr></table></figure><h2 id="条款-19：谨慎使用-shared-ptr"><a href="#条款-19：谨慎使用-shared-ptr" class="headerlink" title="条款 19：谨慎使用 shared_ptr"></a>条款 19：谨慎使用 shared_ptr</h2><p>和 <code>unique_ptr</code> 不同，<code>shared_ptr</code> 中需要注意的使用问题更多一些，我们按书中的思路依次展开。</p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p><code>shared_ptr</code> 自身也是指针，但它是共享所有权的智能指针，这意味着多个<code>shared_ptr</code> 可以指向同一块资源，而只有当资源被一个 <code>shared_ptr</code> 指向时，这个 <code>shared_ptr</code> 析构时才负责释放资源。所以，<code>shared_ptr</code> 需要一个计数器，或者严谨点来说，是资源需要一个共享智能指针的计数器。</p><p>每个 <code>shared_ptr</code> 的实例由两个指针组成，第一个指针指向负责管理的资源位置，第二个指针指向一个<strong>资源控制块</strong>。如果有新的 <code>shared_ptr</code> 也指向这个资源，那么它的控制块指针也指向相同的资源控制块。如上提到的计数器就保存在控制块中，另外，控制块中也包括了如自定义的析构器、资源分配器等内容。</p><p>虽然 <code>shared_ptr</code> 占用了两个指针的大小，然而它的操作带来的性能开销却远大于 <code>unique_ptr</code>（<code>unique_ptr</code> 和裸指针基本一致）。这由于以下几个原因：</p><ul><li>第一个创建一块资源的 <code>shared_ptr</code> 对象，需要负责分配控制块内存；</li><li>增加或减少对资源的共享引用时，需要增减计数器，而为了避免并发问题，增减操作必须是原子操作，这就带来了额外的开销。考虑缓存和机器行为，原子操作可能带来性能的不稳定性；</li></ul><p>正因为原子操作计数器的原因，移动构造一个 <code>shared_ptr</code>（计数器不增加），要比复制构造一个 <code>shared_ptr</code>（计数器+1）要更快。</p><p>插一句，Rust 中的引用计数，直接提供了两个实现，<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>，分别用于非并发程序下的共享所有权和并发程序下的共享所有权，前者没有使用原子操作实现引用计数，这样就避免了非并发程序时引用计数的性能开销。<strong>并发导致的性能损失，应该只有在真正需要时才需要承担。</strong></p><p>除此之外，我们还需要注意在使用 <code>shared_ptr</code> 的几个问题。</p><h3 id="自定义析构器-1"><a href="#自定义析构器-1" class="headerlink" title="自定义析构器"></a>自定义析构器</h3><p>和 <code>unique_ptr</code> 不同，<code>shared_ptr</code> 的析构器并不是智能指针对象的一部分，因为它保存在控制块中，所以，不会涉及到上一节，不同析构器占用空间的讨论。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw) &#123;  </span><br><span class="line">  <span class="built_in">makeLogEntry</span>(pw);  </span><br><span class="line">  <span class="keyword">delete</span> pw; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget*, <span class="title">decltype</span><span class="params">(loggingDel)</span>&gt; <span class="title">unique_pointer</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">new</span> Widget, </span></span></span><br><span class="line"><span class="params"><span class="function">  loggingDel )</span></span>; </span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget*&gt; <span class="title">shared_pointer</span><span class="params">(  <span class="comment">// 类型中模板参数没有析构器参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">new</span> Widget, </span></span></span><br><span class="line"><span class="params"><span class="function">  loggingDel )</span></span>;</span><br></pre></td></tr></table></figure><p>正因为如此，指向相同资源的不同 <code>shared_ptr</code> 可以在初始化时，接受不同的析构器，然后，只有最后一个 shared_ptr 离开作用域时，会调用当前的析构器。注意，同一个资源，只对应一个析构器，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter1 = [](<span class="type">int</span> *p) &#123; <span class="keyword">delete</span> p; std::cout &lt;&lt; <span class="string">&quot;Deleter1\n&quot;</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> deleter2 = [](<span class="type">int</span> *p) &#123; <span class="keyword">delete</span> p; std::cout &lt;&lt; <span class="string">&quot;Deleter2\n&quot;</span>; &#125;;  </span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), deleter1)</span></span>; </span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>), deleter2)</span></span>;  </span><br><span class="line">ptr1 = ptr2;  <span class="comment">// a. 这里打印出 Deleter1 </span></span><br><span class="line">ptr<span class="number">1.</span><span class="built_in">reset</span>(); <span class="comment">// b. 这里什么也不打印 </span></span><br><span class="line">ptr<span class="number">2.</span><span class="built_in">reset</span>(); <span class="comment">// c. 这里打印出 Deleter2</span></span><br></pre></td></tr></table></figure><p>代码中有两个资源，10 和 20，他们的控制块中，自定义析构器分别指向了 <code>deleter1</code> 和 <code>deleter2</code>，初始化时，计数器的值都为 1。在 a 处，<code>ptr1</code> 被 <code>ptr2</code> 赋值为指向资源 20，那么资源 10 的计数器值为 0，触发资源 10 的析构器 <code>deleter1</code>，而此时资源 20 的计数器值为 2；在 b 处，<code>ptr1</code> 释放，但资源 20 的计数器值变为 1，不用调用资源析构；在 c 处，<code>ptr2</code> 释放，资源 20 的计数器值变为 0，调用资源 20 的析构器 <code>deleter2</code>。</p><p>因为 <code>shared_ptr</code> 本身不带有析构器类型，所以即使拥有不同的析构器，它们也可以放在同一个容器中：<code>std::vector&lt;std::shared_ptr&lt;int&gt;&gt; vp &#123;ptr1, ptr2&#125;;</code>。</p><h3 id="创建智能指针"><a href="#创建智能指针" class="headerlink" title="创建智能指针"></a>创建智能指针</h3><p>有几种方法可以创建 <code>shared_ptr</code>：</p><ul><li>使用 <code>std::make_shared</code> 接口函数。它总会分配一个新的对象，同时创建一个新的控制块，并返回一个新的 <code>shared_ptr</code>，但它不能指定自定义析构器。</li><li>从 <code>unique_ptr</code> 出发构造。由于 <code>unique_ptr</code> 并没有控制块，所以使用它创建 <code>shared_ptr</code> 时，编译器会创建一个控制块出来。这个过程，会让 <code>unique_ptr</code> 失去对资源的所有权。</li><li>从一个裸指针来构造。这是最灵活也是最危险的一种方式，使用这种方法会创建一个控制块，如上边已经用到的代码。<code>shared_ptr</code> 构造函数可以接受一个可调用对象作为自定义析构器，这也是唯一一种可以自定义析构器的方式。</li></ul><p>对第三种方式展开讨论，它存在一个很容易犯的使用错误，编译器无法报告错误。看以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget; </span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, deleter1)</span></span>; </span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, deleter2)</span></span>;  </span><br><span class="line">spw<span class="number">1.</span><span class="built_in">reset</span>(); <span class="comment">// a. 打印 Deleter1 </span></span><br><span class="line">spw<span class="number">2.</span><span class="built_in">reset</span>(); <span class="comment">// b. 报错：资源被二次析构</span></span><br></pre></td></tr></table></figure><p>我们已经知道，这种创建智能指针的方式，会创建一个控制块，那么，构造 <code>spw1</code> 和 <code>spw2</code> 时，就会分别创建一个控制块，其内部计数器的值均为 1，那么，当 a 处 <code>spw1</code> 释放时，资源 <code>pw</code> 就会被析构掉，而在 b 处，<code>spw2</code> 释放时，就会重复释放资源 <code>pw</code>。</p><p>我们应该尽量避免使用这种方式来构造智能指针，除非你真的想利用这里边的灵活性。如果一定要做，那么确保多个析构器中，只有一个析构器会去析构资源，而它作为主析构器，必须在最后被初始化，比如上例中，<code>deleter2</code> 作为主析构器，去析构资源。更合理的建议是，不要用一个裸指针对象去初始化智能指针，而是在初始化智能指针时，同时分配资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget, deleter2)</span></span>; </span><br><span class="line">std::shared_ptr&lt;Widget&gt; spw2 = spw1; <span class="comment">// spw2 和 spw1 指向同一个控制块，计数器为 2</span></span><br></pre></td></tr></table></figure><p><em>陷阱：如无必要，不要使用裸指针对象来初始化带有自定义析构器的</em> <em><code>shared_ptr</code>。</em></p><h3 id="衍生话题"><a href="#衍生话题" class="headerlink" title="衍生话题"></a>衍生话题</h3><p>看书中给出的这个示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure><p><code>process()</code> 成员函数需要做一个事情，把当前对象以 <code>shared_ptr</code> 方式保存到 <code>processedWidgets</code> 中，最容易想到的实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  processedWidgets.<span class="built_in">emplace_back</span>(<span class="keyword">this</span>); <span class="comment">// 使用 this 裸指针来初始化 shared_ptr 并存入容器 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上一小节的知识，就会意识到这里存在问题，每一个 Widget 实例对象，在 <code>process</code> 之后，都会生成自己的智能指针，并拥有自己的控制块，所以智能指针析构时，这里就会发生重复释放资源的问题！（对象自己的析构函数和智能指针管理资源的析构器都会去析构同一个资源）</p><p>C++ 委员会已经意识到这个问题，也为我们提供了解决方案，也就是使用 <code>enable_shared_from_this</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  processedWidget.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Widget</code> 对象继承自 <code>enable_shared_from_this&lt;Widget&gt;</code> 类型，它会在内部维护一个 <code>weak_ptr</code> 对象（拥有共享所有权但不会重复创建控制块），通过一个成员函数 <code>shared_from_this</code>来使用 <code>weak_ptr</code> 获取 <code>shared_ptr</code>，从而帮我们解决这个问题。</p><p>这里还有一个最佳实践，因为 <code>enable_shared_from_this</code> 使用的一个前提是，<code>Widget</code> 需要有一个控制块，也就意味着它需要有一个 <code>shared_ptr</code> 已经指向它（控制块存在），才可以正常调用 <code>shared_from_this</code>，所以，需要避免对象被多种方式管理，比如还在栈上或裸指针指向。</p><p>这个最佳实践是实现一个工厂函数，返回 <code>shared_ptr</code> 来管理对象，并禁止调用构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="type">static</span> std::shared_ptr&lt;Widget&gt; <span class="title">create</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="built_in">Widget</span>() = <span class="keyword">default</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Widget&gt; <span class="title">Widget::create</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget); <span class="comment">// 或直接 make_shared </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂函数可以确保对象只能被 <code>shared_ptr</code> 管理，且在调用 <code>process</code> 之前（或者说调用 <code>shared_from_this</code> 之前），一定已经存在一个 <code>shared_ptr</code> 指向它。</p><p><em>技巧：使用</em> <em><code>enable_shared_from_this</code></em> <em>和对外部隐藏构造函数的方式，来安全地实现在类的成员函数内，获取指向该对象的</em> <em><code>shared_ptr</code>。</em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你担心这些 <code>shared_ptr</code> 带来的性能问题和潜在陷阱，那么就应该考虑下代码中是否真的需要共享所有权。如果 <code>unique_ptr</code> 可以完成任务，还是要优先使用 <code>unique_ptr</code>。</p><p>从 <code>unique_ptr</code> 创建一个 <code>shared_ptr</code> 很容易，只需要分配一个控制块就行，C++ 已经提供了这种能力。但反过来则不行，我们永远无法将一个 <code>shared_ptr</code> 转变为一个 <code>unique_ptr</code>，即使它的计数器为 1。这也就意味着，如果不有所克制，你的工程中，一定会面临 <code>shared_ptr</code> 泛滥的问题，这意味着代码已经开始变味。</p><h2 id="条款-20：使用-weak-ptr-作为-shared-ptr-的补充"><a href="#条款-20：使用-weak-ptr-作为-shared-ptr-的补充" class="headerlink" title="条款 20：使用 weak_ptr 作为 shared_ptr 的补充"></a>条款 20：使用 weak_ptr 作为 shared_ptr 的补充</h2><p><code>weak_ptr</code> 不是一种新的智能指针，它是一种特殊的 <code>shared_ptr</code>。它使用和 <code>shared_ptr</code> 相同的控制块，所以也拥有两个指针。<code>weak_ptr</code> 使用 <code>shared_ptr</code> 创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> shared_pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(); </span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak_pointer</span><span class="params">(shared_pointer)</span></span>;  </span><br><span class="line">shared_pointer.<span class="built_in">reset</span>(); <span class="comment">// 之后，weak_pointer 变成悬挂智能指针</span></span><br></pre></td></tr></table></figure><p><code>weak_ptr</code> 不同于 <code>shared_ptr</code> 的地方在于，它不会影响 <code>shared_ptr</code> 的引用计数。但因为它依然拥有控制块，所以可以利用里边的信息，实现检查智能指针是否悬挂，这是和裸指针所不一样的地方。</p><p>因为检查是否悬挂之后，我们通常希望在没有悬挂时操作智能指针，那么“检查”和“操作”分开执行时，在并发程序中就会遇到竞争的问题，所以，它也提供了一种原子性的操作方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若 weak_pointer 悬挂，shared_pointer == nullptr </span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; shared_pointer = weak_pointer.<span class="built_in">lock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 weak_pointer 悬挂，抛出异常 </span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared_pointer2</span><span class="params">(weak_pointer)</span></span>;</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code> 最常用的地方是解决 <code>shared_ptr</code> 的环形引用导致资源泄漏的问题，想必是学习智能指针一定会接触的问题。书中还提到了另一种 <code>weak_ptr</code> 的用途，即用它来实现检查资源是否失效的需求。</p><p>如果我们想设计一个缓存机制，使用容器保存一些智能指针，它们指向一些已分配的资源。如果容器中存储的是 <code>shared_ptr</code>，那么当所有权被转移到外部时，资源就会被析构，如果想要缓存资源而不是直接析构，就用 <code>weak_ptr</code> 所取代，并在必要时，比如重新加载资源到缓存时，通过 <code>weak_ptr</code> 的悬挂检测来决定。</p><p>我个人认为不是很常用的做法，也比较取巧，就不列出代码了。</p><p>最后提一下，<code>weak_ptr</code> 只是不修改 <code>shared_ptr</code> 的引用计数，但不代表着它没有性能开销，控制块中还有关于 <code>weak_ptr</code> 的计数器，它依然会原子地修改这个计数器。</p><p><em>谬误：<code>weak_ptr</code></em> <em>并没有比</em> <em><code>shared_ptr</code></em> <em>操作效率高。</em></p><h2 id="条款-21：除非有充分的理由，否则应该使用-make-函数创建智能指针对象"><a href="#条款-21：除非有充分的理由，否则应该使用-make-函数创建智能指针对象" class="headerlink" title="条款 21：除非有充分的理由，否则应该使用 make 函数创建智能指针对象"></a>条款 21：除非有充分的理由，否则应该使用 make 函数创建智能指针对象</h2><p>C++ 有三个 make 函数，它们分别是 <code>std::make_unique</code>，<code>std::make_shared</code> 和 <code>std::allocate_shared</code>，其中，<code>std::make_unique</code> 是在 C++14 中引入的，另外两个是在 C++11 中引入的。</p><p>从前边的讨论中我们知道，可以使用 <code>new</code> 来初始化一个智能指针，而不需要考虑 <code>delete</code> 的事情，不过，还是优先推荐使用 make 函数来初始化智能指针。</p><h3 id="使用-make-函数的优点"><a href="#使用-make-函数的优点" class="headerlink" title="使用 make 函数的优点"></a>使用 make 函数的优点</h3><p>C++ 中有一种很常见的异常问题，被程序员们广泛讨论，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个函数，接受两个参数，一个智能指针，一个值 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::shared_ptr&lt;Widget&gt;, <span class="type">int</span>)</span></span>; </span><br></pre></td></tr></table></figure><p>如果，我们通过 new 来初始化智能指针，再调用一个函数来求第二个值，并把这些放在一条语句中，C++ 是允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">compute</span>());</span><br></pre></td></tr></table></figure><p>但这种写法会带来一个异常安全问题。</p><p>因为 C++ 并不规定同一个函数参数的参数列表中，各表达式的求值顺序，所以，这个参数列表中，三个操作：<code>new Widget</code>，<code>compute()</code> 和 <code>shared_ptr&lt;Widget&gt;()</code> 将会以随机的方式执行（严谨一些说，<code>new Widget</code> 会在智能指针构造前完成，但 <code>compute()</code> 会在任意位置完成）。如果，<code>compute()</code> 刚好在 <code>new Widget</code> 和智能指针构造之间执行，而它发生了异常，那么，<code>new Widget</code> 的资源便会发生资源泄漏，永远无法被释放。<br>有几种不同的方案可以避免这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 make 函数 </span></span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), <span class="built_in">compute</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 compute 计算放在之前完成 </span></span><br><span class="line"><span class="type">int</span> val = <span class="built_in">compute</span>(); </span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), val); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 或先创建智能指针</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;Widget&gt;(); </span><br><span class="line"><span class="built_in">func</span>(ptr, <span class="built_in">compute</span>());</span><br></pre></td></tr></table></figure><p>对于第三种做法，存在一个小问题。因为 <code>ptr</code> 是左值，所以默认按复制传入形参，而复制操作，会让 <code>shared_ptr</code> 的引用计数增加，带来了额外的性能开销。第二种写法，因为第一个实参是右值，按移动传入，不会带来性能开销。第三种方案可以适当改进一下：<code>func(std::move(ptr), compute());</code>。</p><p><em>陷阱：参数列表中多个表达式有存在异常时，将导致手动分配的内存出现内存泄漏，这是 C++ 很常见的一个陷阱。</em></p><p>另一个使用 make 的优点是，它的性能更好。对于 <code>shared_ptr</code> 来说，因为它除了被指向的资源外，还有一块控制块，也位于堆内存中，如果调用 <code>make_shared</code> 操作，那么只需要进行一次内存分配，同时用于资源数据使用和控制块使用。</p><p>而如果使用 <code>new</code> 的方式，将先后进行两次内存分配。向操作系统的一次内存申请，其性能将优于两次申请。这同样适用于 <code>std::allocate_shared</code> 操作。</p><h3 id="使用-make-函数的不足"><a href="#使用-make-函数的不足" class="headerlink" title="使用 make 函数的不足"></a>使用 make 函数的不足</h3><p>和之前的一些条款一样，使用 make 函数并不是一个完美替代 new 操作来创建智能指针的方案，它也存在一些无法被使用的场景。</p><p>第一个场景是自定义析构器。从前边条款中得知，make 函数不能指定自定义析构器，而只能通过 <code>new</code> 关键字来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(Deleter)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, Deleter)</span></span>; </span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, Deleter)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个场景是，当希望通过初始化列表作为参数，来调用被指向对象的特殊构造函数时，make 函数会将其按小括号初始化来对待，这在我们之前讨论初始化列表时，也提到过。这里再重复啰嗦一次，见下边代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样一条语句，它生成的是一个指向 10 个值为 20 的 <code>vector</code> 的智能指针，还是指向包含 2 个元素，值分别为 10 和 20 的 <code>vector</code> 的智能指针？想必你也比较熟悉，答案是前者。</p><p>make 函数做不到通过这一条语句实现后者，这是因为 make 函数内部的实现，在处理对形参的完美转发时，使用的是圆括号，而不是大括号。</p><p>如果一定要使用初始化列表来初始化这个资源，可以分开来写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> args = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; </span><br><span class="line"><span class="keyword">auto</span> ptr = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(args); <span class="comment">// 生成指向 [10, 20] 的智能指针</span></span><br></pre></td></tr></table></figure><p>第三个场景，前边提到，使用 make 函数可以让对资源内存的分配和对控制块内存的分配，合并在一起申请，从而提高性能，然而，当讨论 <code>weak_ptr</code> 时，这个问题变的复杂。</p><p>在控制块中，除了保存引用计数外，还保存着其他信息，比如弱引用计数（注意，<code>weak_ptr</code> 用引用计数来判断自己是否失效，而它构造和析构改变的是弱引用计数）。当引用计数为 0 但弱引用计数不为 0 时（<code>shared_ptr</code> 没有了，但 <code>weak_ptr</code> 还存在一些），我们认为资源应该被释放，这没问题，这里的问题是，如果使用 make 函数统一将资源和控制块分配在一块内存块上，因为弱引用计数还存在，所以控制块不能析构，导致位于同一块内存块的资源内存，也不能被尽早析构（虽然它已经没有用了）。只有当控制块的弱引用计数也为 0 后，整个控制块应该被析构时，操作系统才开始考虑对整个内存块（包括资源内存和控制块内存）进行析构操作。</p><p>如果我们的资源内存占用比较大，而 <code>weak_ptr</code> 长时间没有释放，那么这块内存就带来了长期驻留内存的资源占用问题。</p><p>使用 <code>new</code> 操作来初始化智能指针，反而可以避免这个问题。虽然这不是一个很急迫的问题，但讨论一下，也是蛮有意思的。技术权衡的正反面，只有了解细节才能在选型时找到最优解。</p><h2 id="条款-22：使用-Pimpl-用法时要注意的地方"><a href="#条款-22：使用-Pimpl-用法时要注意的地方" class="headerlink" title="条款 22：使用 Pimpl 用法时要注意的地方"></a>条款 22：使用 Pimpl 用法时要注意的地方</h2><p>Pimpl 是 C++ 编程中的一种习惯用法，它全称是 Pointer to implementation。具体来说，比如我们实现一个自定义类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span> </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Widget</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  Object obj; <span class="comment">// Object 是另一个自定义类型，位于其他文件中 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Widget.cpp </span></span><br><span class="line">Widget::<span class="built_in">Widget</span>() &#123;&#125;;  <span class="comment">// 构造函数定义</span></span><br></pre></td></tr></table></figure><p>通常会这么写代码。但这里有一个编译性能的问题。如果我们的 <code>Widget.h</code> 文件没有变，但 <code>Object.h</code> 文件发生了变化，那么对于引用 <code>Widget.h</code> 的用户代码来说，编译时，<code>Widget.h</code> 文件也会被重新编译一遍。当工程代码中间的此类依赖很多很复杂时，编译时间会受到很大的影响。</p><p>Pimpl 就可以解决这个问题。它的重构做法是：</p><ul><li>在 <code>Widget.h</code> 头文件中，创建一个类内定义的对象，假设名为 <code>Impl</code>，它的实现放在 <code>Widget.cpp</code> 中。</li><li>再将和 <code>Object</code> 相关的数据都放到 <code>Impl</code> 类型的实现中，而在 <code>Widget.h</code> 的类声明中，只放置一个指向 <code>Impl</code> 对象的指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Widget</span>(); </span><br><span class="line">  ~<span class="built_in">Widget</span>(); <span class="comment">// 需要添加析构函数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;   </span><br><span class="line">  Impl *pImpl; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Widget.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123; </span><br><span class="line">  Object obj; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(<span class="keyword">new</span> Impl) &#123;&#125;; </span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123; <span class="keyword">delete</span> pImpl; &#125;</span><br></pre></td></tr></table></figure><p>这样，在 <code>Widget.h</code> 中，就没有了对 <code>Object.h</code> 的引入，从而，修改 <code>Object.cpp</code> 时，引用 <code>Widget.h</code> 头文件的用户代码，就不会再重复编译。</p><h3 id="使用智能指针来重新实现"><a href="#使用智能指针来重新实现" class="headerlink" title="使用智能指针来重新实现"></a>使用智能指针来重新实现</h3><p>在现代 C++ 中，我们希望能尽可能避免显式使用 <code>new</code> 和 <code>delete</code> 关键字，而是把资源管理交给 RAII 技术。所以很容易想到使用智能指针来替代裸指针。因为 <code>pImpl</code> 是被 <code>Widget</code> 对象独占所有权的，所以使用 <code>unique_ptr</code> 是顺理成章的事情。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Widget</span>(); <span class="comment">// 看似不用写出析构函数了，实际这里是问题所在，后边介绍 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>; </span><br><span class="line">  std::unique_ptr&lt;Impl&gt; *pImpl; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Widget.cpp </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Impl</span> &#123; </span><br><span class="line">  Object obj; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个代码看似没问题，并且代码自身编译也没问题，但在调用 <code>Widget</code> 的用户代码那边，编译报错了。报错是，无法找到一个对 <code>Object</code> 的完整实例化。<code>unique_ptr</code> 作为指针，并不需要关心其指向的对象的实例化情况，所以这里看起来很奇怪。</p><p>原因是，编译器在为我们创造默认析构函数时，当看到 <code>unique_ptr</code>，会做一个 <code>static_assert</code>，检查 <code>unique_ptr</code> 是否能找到其指向对象的 <code>sizeof</code> 和 <code>delete</code> 运算符定义。这么做是考虑到生成更高效的析构代码。</p><p>为了强行解决这个问题，我们可以手动实现析构函数，但只需要生成默认版本的析构函数即可。析构函数放在 <code>Widget.cpp</code> 的末尾，这样，当编译器想要调用析构函数时，一定会先看到 <code>Impl</code> 的定义，也就能知道智能指针指向对象的信息了。另外，因为自定义析构函数后，编译器不会为我们生成默认移动构造函数和移动运算符函数，所以这两个函数也得手动实现一趟，当然，编译器默认生成的复制和移动版本是浅拷贝，就算不是这个原因，大概率也得手动生成一份深拷贝版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Widget</span>(); </span><br><span class="line">  ~<span class="built_in">Widget</span>(); </span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;&amp;); </span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;&amp;); </span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;); </span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>; </span><br><span class="line">  std::unique_ptr&lt;Impl&gt; *pImpl;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Widget.cpp </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Impl</span> &#123; </span><br><span class="line">  Object obj; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125; </span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>; <span class="comment">// 可以用 default，但要放在后边 </span></span><br><span class="line"><span class="comment">// 复制和移动函数与运算符重载函数的定义这里省略</span></span><br></pre></td></tr></table></figure><p>言归正传，虽然 <code>unique_ptr</code> 作为独占所有权指针，用在这里再合适不可，但如果想使用 <code>shared_ptr</code>，就会发现，后者并没有前述的这些问题，这是因为 <code>unique_ptr</code> 的析构器是其类型的一部分，编译器会努力生成最优的代码来让 <code>unique_ptr</code> 做到裸指针的性能，而 <code>shared_ptr</code> 的析构器却不是类型的一部分，所以它不关心析构性能，也就没有在析构时去做完整实例化对象的检查。</p><hr><p>智能指针是现代 C++ 中很重要的一部分内容，值得仔细了解。但事实上，编写 demo 时，即使知道裸指针和 <code>unique_ptr</code> 的性能相同，但大多数人还是喜欢先使用裸指针，我仔细想过，唯一的原因可能就是语法差异，语法 <code>*</code> 和写几个单词（<code>auto</code> 和 <code>unique_ptr</code>，<code>make_unique</code>）还是有差距的。</p><p>适应新技术需要一个过程，但习惯之后，便会收获便捷和安全。</p><p>本系列的其他文章：</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li><li><a href="/posts/57a898cb.html" title="Effective Modern C++ 读书笔记：转向现代C++">Effective Modern C++ 读书笔记：转向现代C++</a></li><li><a href="/posts/ce1aec80.html" title="Effective Modern C++ 读书笔记：智能指针">Effective Modern C++ 读书笔记：智能指针</a></li><li><a href="/posts/410ab8fb.html" title="Effective Modern C++：右值引用、移动语义和完美转发">Effective Modern C++：右值引用、移动语义和完美转发</a></li><li><a href="/posts/cd605d5c.html" title="Effective Modern C++：lambda 表达式">Effective Modern C++：lambda 表达式</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1943341648118547139">https://zhuanlan.zhihu.com/p/1943341648118547139</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ 读书笔记：转向现代C++</title>
    <link href="https://p2tree.top/posts/57a898cb.html"/>
    <id>https://p2tree.top/posts/57a898cb.html</id>
    <published>2025-08-15T22:36:09.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="条款-7：在创建对象时区分-和"><a href="#条款-7：在创建对象时区分-和" class="headerlink" title="条款 7：在创建对象时区分 () 和 {}"></a>条款 7：在创建对象时区分 () 和 {}</h2><p>这是一个令很多人头痛的问题，如果没有完全搞懂这里边的门道，是不会愿意使用 C++ 提供的大括号初始化语法的。或者，大多数人多少也有踩过坑的过去。</p><h3 id="大括号初始化语法的优点"><a href="#大括号初始化语法的优点" class="headerlink" title="大括号初始化语法的优点"></a>大括号初始化语法的优点</h3><p>讨论以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 使用小括号来初始化 x 值为 0 </span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>; <span class="comment">// 使用等号来初始化 y 值为 0 </span></span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;  <span class="comment">// 使用大括号来初始化 z 值为 0 </span></span><br><span class="line"><span class="type">int</span> r = &#123;<span class="number">0</span>&#125;; <span class="comment">// 使用等号和大括号来初始化 r 值为 0</span></span><br></pre></td></tr></table></figure><p>以上这几种写法，本质上有什么区别？这些初始化语法都做到了相同的目的，但作为一个高级语言，这种混乱多变的用法，事实上并不讨喜。于是 C++ 11 引入了统一初始化语法，或者书中被称为大括号初始化语法。</p><p>大括号初始化除了能初始化一个单独的值，还可以直接初始化容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 初始化 v 中存放 3 个元素：1，2，3</span></span><br></pre></td></tr></table></figure><p>小括号初始化和等号初始化，在一些场合不能使用，但都可以替换成大括号初始化语法，大括号初始化语法适用于所有初始化的场景。</p><p>另外，大括号初始化的方式还会禁止不同类型的隐式窄化类型转换，比如，以下代码无法通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y; </span><br><span class="line"><span class="type">int</span> s&#123;x + y&#125;; <span class="comment">// 编译失败 </span></span><br><span class="line"><span class="type">int</span> s = x + y; <span class="comment">// 编译成功</span></span><br></pre></td></tr></table></figure><p>这避免了一些潜在的精度损失问题。</p><p>最后，大括号初始化语法解决了 C++ 的解析语法问题。<br>讲一下这个问题。解析语法的一个示例为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>单纯看这个代码，你（和编译器）都不能判断出 <code>w</code> 到底是一个 <code>Widget</code> 的对象（调用默认构造函数），还是一个返回 <code>Widget</code> 的函数声明。编译器优先会将其解析为一个函数声明，具体要取决于上下文。</p><p>大括号初始化语法就直接将两者区分开来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w&#123;&#125;; <span class="comment">// 一定是初始化 Widget 对象，而不是函数声明</span></span><br></pre></td></tr></table></figure><h3 id="大括号初始化的缺点"><a href="#大括号初始化的缺点" class="headerlink" title="大括号初始化的缺点"></a>大括号初始化的缺点</h3><p>然而，好消息总会伴随着坏消息。大括号初始化语法也有一些不适合使用的场景。</p><p>一个常见的问题就是它和初始化列表之间的纠葛。</p><p>如果一个类型的构造函数中，没有提供任何传入初始化列表作为参数的版本，那么一切都是正常的，但反之，选择调用构造函数时，编译器就会非常强烈地选择使用传入初始化列表作为参数的构造函数版本。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); </span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">double</span>&gt; d); <span class="comment">// 这是那个很敏感的版本 </span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 提供强制转换为 float 的行为 </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 如果使用小括号来初始化，自然调用了第一个构造函数 </span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// 如果使用大括号来初始化，则一定调用第二个构造函数</span></span><br></pre></td></tr></table></figure><p>如代码中 <code>w2</code> 的初始化，编译器会强制使用初始化列表作为参数的构造函数，即使它需要额外做将 <code>int</code> 和 <code>bool</code> 转换为 <code>double</code> 的动作。这就是为什么说会 “非常强烈地”。</p><p>即使是编译器默认提供的构造函数，比如上例中的默认复制构造函数，也难逃意外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w0; </span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(w0)</span></span>; <span class="comment">// 如果使用小括号来初始化，调用了默认复制构造函数 </span></span><br><span class="line">Widget w2&#123;w0&#125;; <span class="comment">// 如果使用大括号来初始化，依然调用的是那个敏感的版本！</span></span><br></pre></td></tr></table></figure><p>编译器还是会对 <code>w2</code> 调用带有初始化列表作为参数的构造函数，它会将 <code>w0</code> 这个 <code>Widget</code> 类型转换为<code>float</code>，之后转换为 <code>double</code>，最后使用那个敏感的版本来构造 <code>w2</code>。</p><p>那么，在上边这些问题之后，以下代码声明，调用的是什么构造函数呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;   <span class="comment">// 调用无参构造函数 </span></span><br><span class="line">Widget w2&#123;&#125;; <span class="comment">// 虽然使用了大括号，但实际上调用了无参默认构造函数 </span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>; <span class="comment">// 又是解析语法问题，这是函数声明 </span></span><br><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>; <span class="comment">// 调用了带初始化列表作为参数的构造函数，初始化列表为空 </span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;; <span class="comment">// 和 w4 一样</span></span><br></pre></td></tr></table></figure><p>上边的内容可能比较太 “语言律师” 了，但它在实际工程中，确确实实会带来一些潜在的意外。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 调用了 vector 的一个构造函数，创建了包含有 10 个元素，元素值都是 20 的 vector 对象 </span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// 调用了 vector 中带有初始化列表作为参数的构造函数，创建了包含 2 个元素，值分别是 10 和 20 的 vector 对象</span></span><br></pre></td></tr></table></figure><p>事实上我就在这里犯过错。</p><p>作为类的实现者，最好能避免用户犯这种错误，让用户使用类型时，不用在意它应该怎么写，才能调用到哪个构造函数。C++ STL 中的这种设计，事实上是个败笔，当然，根源还是 C++ 语法的问题。</p><p><em>陷阱：区分一个类型使用小括号来传入多个值，和用大括号来传入多个值的区别，尤其是标准库类型。</em></p><p>事实上，在工程实践中，很难快速意识到这种问题，比如说，最一开始的实现中，没有添加带有初始化列表的构造函数，之后也在很远的地方，正常使用大括号初始化语法来初始化类的对象（它会调用到构造函数），很久之后，我们又需要给类中添加带有初始化列表的构造函数版本，添加之后，发现测试用例挂了（感谢你提前编写了测试用例吧）。</p><p><em>陷阱：在为自定义类添加带有初始化列表作为参数的构造函数时，一定要小心。</em></p><p>现在，关于现代 C++ 中，是否建议使用大括号语法来初始化对象，依然是激烈争论的议题。两者各有优缺点。对于我们，<strong>最重要的是，理解上述的这些问题，并在使用大括号初始化语法和带有初始化列表的构造函数时，多留个心眼</strong>。</p><p>对于模板的实现者来说，这个问题更为头疼，因为模板的实现者无法决定用户会使用小括号还是大括号，从而便无法决定模板中的两种不同实例化，应该怎么做到统一实现。</p><h2 id="条款-8：优先选用-nullptr"><a href="#条款-8：优先选用-nullptr" class="headerlink" title="条款 8：优先选用 nullptr"></a>条款 8：优先选用 nullptr</h2><p>一条耳熟能详的 C++11 建议，使用 <code>nullptr</code> 替代 <code>NULL</code> 或 0 来作为空指针类型。</p><p>原因是 0 可能被解析为 <code>int</code>，而 <code>NULL</code> 在大多数库中的实现也只是宏定义到 0。<code>nullptr</code> 不具备整形类型，当然，它也不是某一种类型的指针，它的类型是 <code>std::nullptr_t</code>，它的能力是提供了可以转换为任意指针类型的类型转换操作。</p><p>这一条没有什么副作用，所以大多数程序员都已经无缝切换。</p><h2 id="条款-9：优先选用别名声明"><a href="#条款-9：优先选用别名声明" class="headerlink" title="条款 9：优先选用别名声明"></a>条款 9：优先选用别名声明</h2><p>C++ 11 标准中另一个实用的改进，允许我们使用 <code>using</code> 关键字来声明一些自定义类型，也就是类型别名，替代传统 C&#x2F;C++ 中的 <code>typedef</code> 语法。</p><p>替换并不只是让代码更清晰，毕竟并没有那么多场合需要声明很复杂的类型别名，但有一些是 <code>typedef</code> 做不到的。</p><p>一个例子是类型别名可以模板化。举例来说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个存放多个类型及类型带有的自定义分配器的列表 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用代码，声明一个 lw 的对象 </span></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure><p>如果使用 <code>typedef</code>，因为不能声明模板别名，只能编写一个自定义结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">sturct MyAllocList &#123; </span><br><span class="line">  <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用代码 a </span></span><br><span class="line">MyALlocList&lt;Widget1&gt;::type lw; <span class="comment">// 不能省略 ::type </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用代码 b </span></span><br><span class="line"><span class="comment">// 如果想在模板类型定义中使用这个自定义类型 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget2</span> &#123; </span><br><span class="line">  <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list; <span class="comment">// 不能省略 typename 和 ::type </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编写的代码就要复杂一些，应用代码 b 中的用法，<code>typename</code> 不能省略，因为编译器需要知道后边的 <code>MyAllocList&lt;T&gt;::type</code> 是一个类型，而不是其他什么东西（因为从语法上来看，它仅仅只是对一个模板类内静态成员的引用）。</p><h3 id="类型特征相关的应用"><a href="#类型特征相关的应用" class="headerlink" title="类型特征相关的应用"></a>类型特征相关的应用</h3><p>也许你会认为，这种场景太少见了，然而，在库实现中，这种用法却到处都是，C++ 11 中的类型特征，就是采用这种原始的方式实现的，你会在各种地方看到诸如 <code>std::remove_const&lt;T&gt;::type</code> 这种以 <code>::type</code> 结尾的类型修饰词转换操作。如果这些场景下的应用代码都使用 <code>typedef</code>，那么将提高代码的复杂性。</p><p>当然，在 C++11 的库实现中，还是大量使用了 <code>typedef</code> 这种用法来定义类型特征，书中没有解释原因，不过，<code>using</code> 的好处在未来被人重视起来，C++14 开始，都添加了对应的类型别名版本，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type    <span class="comment">// C++11 中将 const T 类型转换为 T </span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;        <span class="comment">// C++14 中的版本，它们都会带有一个 _t 后缀来替代 ::type</span></span><br></pre></td></tr></table></figure><p>作者建议，无条件地优先使用 <code>using</code>，即使你使用的是 C++11，也去自己实现用类型别名来取代 <code>typedef</code> 实现类型特征：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure><h2 id="条款-10：优先选用枚举类"><a href="#条款-10：优先选用枚举类" class="headerlink" title="条款 10：优先选用枚举类"></a>条款 10：优先选用枚举类</h2><p>C++ 11 中的另一个新引入的语法特征，使用枚举类来取代枚举。在绝大多数场景下，你都应该这样做。下文把 <code>enum</code> 定义的类型叫做枚举，把 <code>enum class</code> 定义的类型叫做枚举类。</p><h3 id="这样替代的好处"><a href="#这样替代的好处" class="headerlink" title="这样替代的好处"></a>这样替代的好处</h3><p>我们知道，枚举是不限定作用域的，也就是说，通过枚举定义的类型，其作用域与定义枚举的作用域一致，而不是限定在枚举类型本身，这导致枚举类型的名字污染以及潜在的类型转换错误。而枚举类可以做到这一点。这带来很多好处，我相信不需要把书里的例子拿出来复述一遍了。</p><p>另外一个好处是，枚举类可以做前置声明（在表面上看）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>; <span class="comment">// 预先前置声明枚举，后边再定义，编译会出错 </span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>; <span class="comment">// 预先前置声明枚举类，可以编译</span></span><br></pre></td></tr></table></figure><p>究其原因，并不是语法上不允许，而是编译器需要在前置声明时，为枚举（或枚举类）选择一个默认的底层实现类型，而枚举没有默认的底层实现类型，所以编译器无法预先分配前置声明的类型。</p><p>所以，在 Pre-C++ 11，也可以通过手动指定枚举类型来实现将枚举做前置声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>: std::<span class="type">uint8_t</span>;</span><br></pre></td></tr></table></figure><p>枚举类不需要手动指定，就可以前置声明，因为枚举类有默认的底层实现类型：<code>int</code>。所以，这个好处是在不需要指定底层类型时，做前置声明。</p><h3 id="枚举仍然有用的地方"><a href="#枚举仍然有用的地方" class="headerlink" title="枚举仍然有用的地方"></a>枚举仍然有用的地方</h3><p>书中提到了一个枚举可能的用途。因为枚举可以做隐式类型转换，而枚举类不可以，所以在一些明确需要编译器完成隐式类型转换的场合，枚举就有用了。比如说 <code>std::tuple</code> 下的 <code>std::get&lt;&gt;</code> 操作，后者会按指定的静态下标来获取元组中的元素。</p><p>考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = std::tuple&lt;std::string, std::string, std::<span class="type">size_t</span>&gt;; </span><br><span class="line">UserInfo info; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素最常见的写法是 </span></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(info); <span class="comment">// 取下标 1 的元素</span></span><br></pre></td></tr></table></figure><p>但这种写法，从调用方来看，很难直观地看到获取的 <code>val</code> 是什么东西。<br>所以我们习惯用枚举来作为下标，因为枚举定义的默认值是从 0 开始的整形，刚好可以用来做下标值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;; </span><br><span class="line">UserInfo info; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举作为下标获取元素 </span></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(info); <span class="comment">// 明显看出是获取 Email 域</span></span><br></pre></td></tr></table></figure><p>然而，如果使用的是枚举类，则代码会冗长一些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;; </span><br><span class="line">UserInfo info; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类作为下标获取元素 </span></span><br><span class="line"><span class="comment">// 因为枚举类不能做隐式类型转换，所以需要显式完成 </span></span><br><span class="line"><span class="keyword">auto</span> val = std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(info);</span><br></pre></td></tr></table></figure><p>其他办法也不会比它更简单。</p><p>当然，在我看来，这个遗留问题，更应该拷问下，是不是 <code>std::get&lt;&gt;</code> 的设计有问题，如果 C++ 可以提供 <code>info.uiEmail</code> 这种更便捷的语法，这里的问题便不攻自破了。</p><h2 id="条款-11：优先选用-delete-来删除函数"><a href="#条款-11：优先选用-delete-来删除函数" class="headerlink" title="条款 11：优先选用 delete 来删除函数"></a>条款 11：优先选用 delete 来删除函数</h2><p>在 C++11 之前，如果我们需要删除类内的一些类成员函数，比如编译器自动生成的那些构造函数，做法是将这些函数显式声明出来，并放在 <code>private</code> 区中，同时不去实现它。</p><p>这样，如果类外部的对象调用这些被删除的函数，则编译器会因为这些函数位于 <code>private</code> 而阻止调用，如果类内调用这些被删除的函数，则编译器会因为这些函数没有被定义而报错。</p><p>在 C++11 中，无条件将这种做法替换为使用 <code>delete</code> 关键字来标记，也就是在类成员函数声明的末尾添加 <code>= delete;</code> 语法。编译器会保证这些函数不允许被实现和调用。</p><p><code>delete</code> 的第一个优点便是简单，比之前的做法少写一点代码。但其另外一个无法被取代的优点是，它可以用来修饰一个普通函数（类外定义的函数）。举例来说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有一个函数 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 C++ 会对类型做隐式变换，所以以下调用，都可以通过编译 </span></span><br><span class="line"><span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="built_in">isLucky</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="built_in">isLucky</span>(<span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p>如果我们不允许一些特殊的类型转换，就需要利用 <code>delete</code> 来删除一些 “重载版本”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下调用会报错 </span></span><br><span class="line"><span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 错误 </span></span><br><span class="line"><span class="built_in">isLucky</span>(<span class="literal">true</span>); <span class="comment">// 错误 </span></span><br><span class="line"><span class="built_in">isLucky</span>(<span class="number">3.5</span>);  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>另外，<code>delete</code> 还可以删除那些不希望被模板实例化的模板类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边这种实例化被删除 </span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span> *&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>值得一提的是，如果模板函数是类内的成员函数，则无法通过改到 <code>private</code> 中来删除实例化，只能通过 <code>delete</code> 来删除。所以，<code>private</code> 的方案也并不总是能应用在类内成员函数的删除。</p><h2 id="条款-12：留意使用-override-来声明需要改写的成员函数"><a href="#条款-12：留意使用-override-来声明需要改写的成员函数" class="headerlink" title="条款 12：留意使用 override 来声明需要改写的成员函数"></a>条款 12：留意使用 override 来声明需要改写的成员函数</h2><p>首先需要明确函数的 <strong>改写</strong> 和 <strong>重载</strong> 的区别。重载可以实现多个函数名称相同，但函数参数类型不同的一系列函数，从而方便调用使用；而改写是派生类对象中，实现和基类中 <strong>相同</strong> 的虚函数，从而可以让多态行为生效（有时也叫做 <strong>覆写</strong> 或 <strong>重写</strong>）。</p><p>上文中我高亮了 <strong>相同</strong> 两个字，在 C++ 标准中，需要满足一定的约束，才能实现改写的目的。<br>在 C++98 中，已经提出的约束有：</p><ul><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的函数必须同名（析构函数除外）。</li><li>基类和派生类中的函数参数类型必须完全一样。</li><li>基类和派生类中的函数常量性必须完全一样。</li><li>基类和派生类中的函数返回值类型和异常规格必须能够兼容。</li></ul><p>在 C++11 中，新增了一条：</p><ul><li>基类和派生类中的函数需要使用相同的引用修饰词。</li></ul><p><em>陷阱：C++11 中，需要改写的成员函数，需要保证具有相同的引用性质。</em></p><p>有关于引用修饰词，书中也在该小节予以大篇幅的介绍。引用修饰词是对成员函数的修饰，来标记该成员函数应该在对象是左值引用还是右值引用时被调用，因为有些场景中，我们希望调用左值引用对象的成员函数与调用右值引用对象的成员函数时，采用不同的实现策略。</p><p>我个人认为这部分内容和条款本身没有直接联系，所以不再做展开。</p><p>回到条款中，如果希望改写类成员函数，则无条件建议在派生类中，对要改写的函数使用 <code>override</code> 来修饰。编译器会对这种修饰词做检查，排查出任何与成员函数改写相关的意外、漏写或设计错误。</p><p>另外，C++11 还提供了另一个关键字 <code>final</code>，和 <code>override</code> 刚好相反，被修饰为 <code>final</code> 的成员函数，将拒绝被其后边继承的派生类中改写。推荐在编写类层次结构时，总是留意去使用这两个关键字，它们可能会帮你大忙。</p><h2 id="条款-13：优先选用-const-iterator-代替-iterator"><a href="#条款-13：优先选用-const-iterator-代替-iterator" class="headerlink" title="条款 13：优先选用 const_iterator 代替 iterator"></a>条款 13：优先选用 const_iterator 代替 iterator</h2><p><code>const_iterator</code> 用于指定指向带有 <code>const</code> 属性的 <code>iterator</code> 类型，所以它所指向的值，内容不可修改。建议在可能的情况下，使用 <code>const_iterator</code> 代替 <code>iterator</code>。</p><p>C++98 中 <code>const_iterator</code> 的实现不完整，所以若想在 C++98 中使用，需要做一些额外的约束。C++ 98 中没有提供 <code>cbegin()</code> 和 <code>cend()</code> 等操作，所以需要这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values; </span><br><span class="line"><span class="keyword">auto</span> ConstIterator = </span><br><span class="line">  std::<span class="built_in">find</span>( <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="type">int</span>&gt;::const_iterator&gt;(values.<span class="built_in">begin</span>()), </span><br><span class="line">             <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="type">int</span>&gt;::const_iterator&gt;(values.<span class="built_in">end</span>()), </span><br><span class="line">             <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>不需要特别了解这种用法，现在使用 C++98 的场合并不多了，即使有那种环境，使用迭代器而不是指针的场合就更少了。</p><p>在 C++11 中，标准的写法变成了调用 <code>values.cbegin()</code> 和 <code>values.cend()</code>，不需要我多举例子了。</p><p>讨论另一个话题。现代 C++ 中，除了为大多数标准库容器提供 <code>cbegin()</code> 和 <code>cend()</code> 接口之外，还提供了非成员函数版本的 <code>cbegin()</code> 和 <code>cend()</code>，那么，什么时候使用成员函数版本，什么时候使用非成员函数版本？或者说，非成员函数版本的意义是什么？</p><p>答案是，在一些容器中，或类似容器的数据结构，如数组中，是没有成员函数版本的迭代器获取接口的，如果在泛型的实现中，调用成员函数版本的迭代器获取，便会导致编译错误，而使用非成员函数的版本，则可以充分兼容这种情况。</p><p>举例来说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们实现一个泛型的容器操作，可以接受各种不同的容器类型 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt; <span class="comment">// C 是容器类型，V 是容器中元素类型 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container, <span class="type">const</span> V&amp; targetVal, <span class="type">const</span> V&amp; insertVal)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">using</span> std::cbegin; </span><br><span class="line">  <span class="keyword">using</span> std::cend; <span class="comment">// 将非成员函数版本的 cbegin 和 cend 导入命名空间 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container), <span class="built_in">cend</span>(container), targetVal);   </span><br><span class="line">  container.<span class="built_in">insert</span>(it, insertVal); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显可以看出来，如果容器 <code>C</code> 没有内置的成员函数版本 <code>cbegin()</code> 和 <code>cend()</code>，这个实现也是可以工作的。</p><p><em>谬误：非成员函数版本的</em> <em><code>cbegin()</code></em> <em>和</em> <em><code>cend()</code></em> <em>与成员函数版本的</em> <em><code>cbegin()</code></em> <em>和</em> <em><code>cend()</code>，在大多数情况下都一样，但建议在可能的情况下，还是使用非成员函数版本。</em></p><p><em>陷阱：不过需要注意，非成员函数版本的</em> <em><code>cbegin()</code></em> <em>和</em> <em><code>cend()</code></em> <em>在 C++14 中才提供，而在 C++11 中不存在。所以，将你的项目中构建参数里用</em> <em><code>--std=c++14</code></em> <em>代替</em> <em><code>--std=c++11</code></em> <em>吧。</em></p><p>如果你的项目中不得不使用 C++11，那么实现一个非成员函数版本的 <code>cbegin</code> 也非常方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span> -&gt; <span class="title">decltype</span><span class="params">(std::begin(container))</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">begin</span>(container); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方案非常取巧，直觉上，在实现体中，应该会写成：<code>return container.cbegin();</code>，但因为有一些容器，它并没有成员函数版本的 <code>cbegin()</code>，所以这样不可行。上边的实现策略，依据是：如果非成员函数版本的 <code>begin()</code> 中传入的是一个 <code>const</code> 类型容器，那么它返回的是 <code>const_iterator</code>，所以这个实现的重点在模板函数的参数声明上。这种实现，对数组也一样适用。</p><h2 id="条款-14：只要函数不发射异常，就使用-noexcept-声明"><a href="#条款-14：只要函数不发射异常，就使用-noexcept-声明" class="headerlink" title="条款 14：只要函数不发射异常，就使用 noexcept 声明"></a>条款 14：只要函数不发射异常，就使用 noexcept 声明</h2><p>这一条聊一下异常，C++ 中，异常的使用这部分话题，是高频被讨论到的话题。然而本条款更关注的是，如果在使用异常时，让编译器尽可能简化对异常代码的处理。</p><p>在实现接口函数时，如果明知道一个函数不会抛出异常，但没有使用 <code>noexcept</code> 声明，那这就是接口设计缺陷。使用 <code>noexcept</code>，可以让函数以及调用函数的其他函数，能够生成更好的代码。</p><p>在 C++11 之前，我们使用 <code>throw()</code> 来修饰一个函数会抛出异常，但这种修饰，编译器能做的优化并不多，所以不建议再使用。</p><p>使用 <code>noexcept</code> 修饰后，编译器就会做一些更激进的优化。讨论一个复杂的例子。C++11 中的移动语义，由于需要考虑异常，所以，只有在被 <code>noexcept</code> 修饰后，才会说明移动的过程不会发生异常（也就是说，不会因为中途出现异常，导致了数据被破坏），编译器才能妥善放心地使用移动操作。</p><p><code>swap()</code> 函数是 C++ 标准库中一个很常见的操作，然而，它有多种不同的实现，最容易理解的就是，我们是应该采用复制操作来交换数据，还是用移动操作来交换数据，移动操作显然更高效，但其前提便是，<code>swap(a, b)</code> 中的两个输入，都必须是 <code>noexcept</code> 的。<br>一个典型的 <code>swap</code> 函数声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair &amp;p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp; <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br></pre></td></tr></table></figure><p>末尾的声明称为 <strong>条件式 noexcept 声明</strong>，满足 <code>swap</code> 是否可以为 <code>noexcept</code> 的前提是，传入的每个输入，都必须是 <code>noexcept</code> 的。</p><p>所以可以看得出来，如果想保证函数调用时，尽可能会通过 <code>noexcept</code> 修饰，就必须让其相关函数都是 <code>noexcept</code> 的。</p><p>然而，大多数函数其实是中立的，虽然自身不抛出异常，但其内部调用的函数（和更深的调用层次中的函数），可能会抛出异常，所以它也不能使用 <code>noexcept</code> 修饰。</p><p>当然，也不能刻意为了 <code>noexcept</code> 而扭曲了函数实现，那就是主次不分了。如果已经为接口函数添加了 <code>noexcept</code> 修饰，但是在将来又删除这个修饰，那么很有可能，在很多调用该函数的其他场景中，造成很多编译错误。</p><p>在 C++11 中，所有的析构函数是默认带有 <code>noexcept</code> 属性的，不需要手动添加。</p><h2 id="条款-15：尽可能地使用-constexpr"><a href="#条款-15：尽可能地使用-constexpr" class="headerlink" title="条款 15：尽可能地使用 constexpr"></a>条款 15：尽可能地使用 constexpr</h2><p>C++11 中引入了一个新的关键字 <code>constexpr</code>，它和 <code>const</code> 的区别用一句话就可以清晰的说明。<code>const</code> 是表示对象的不可变性（后续无法修改该对象），<code>constexpr</code> 是表示对象的常量性（编译期便可求值）。过去，我们对 <code>const</code> 等价于 <strong>常量</strong> 的错误观念，应该被纠正。</p><p><em>谬误：<code>const</code></em> <em>表示的是不可变性，其反义词是</em> <em><code>mutable</code>，并不表示常量。<code>constexpr</code></em> <em>才表示常量。至于关键字的取名，属于 C++ 特色了，取名总是很难与其实际意义相契合。</em></p><p>所以，<code>constexpr</code> 的对象，一定是 <code>const</code> 的（常量是不可变的），但反过来不成立（不可变的变量可能是受约束的变量）。</p><p>由于 <code>constexpr</code> 修饰的是常量，所以编译器可以在编译期对这种对象做求值，体现出来的便是，会把运行时的一些开销，移动到编译时完成。</p><p>如果使用 <code>constexpr</code> 修饰函数，并不意味着这个函数一定可以在编译期求值，它只是表示，当函数的参数都是常量时，编译器才会对这个函数做编译期求值，否则则和正常函数没有区别。</p><p><em>谬误：使用</em> <em><code>constexpr</code></em> <em>修饰的函数，只有当其参数都是常量时，才会做编译期求值。</em></p><p>在 C++11 中，<code>constexpr</code> 修饰函数还有一些受限，比如只能有一个 <code>return</code>，也不能存在条件语句，这是为了让编译期能更好的完成求值计算。不过，在 C++14 中，这种没必要的约束被解除了。所以，有条件时，尽量用 C++14 代替 C++11。</p><h3 id="使用-constexpr-修饰类"><a href="#使用-constexpr-修饰类" class="headerlink" title="使用 constexpr 修饰类"></a>使用 <code>constexpr</code> 修饰类</h3><p>如果用 <code>constexpr</code> 修饰了类的构造函数，那么很可能会让类定义的对象，也成为一个常量。这很神奇，但确实存在，如书中示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> : x(xVal), y(yVal) &#123;</span>&#125; </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="type">double</span> x, y; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">10.1</span>, <span class="number">20.2</span>)</span></span>; <span class="comment">// 编译期求值的常量对象，值放在只读内存中</span></span><br></pre></td></tr></table></figure><p>因为它是常量对象，所以也可以用在任何使用 <code>constexpr</code> 修饰的常量函数中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midPoint</span><span class="params">(<span class="type">const</span> Point &amp;p1, <span class="type">const</span> Point &amp;p2)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123; (p<span class="number">1.</span><span class="built_in">xValue</span>() + p<span class="number">2.</span><span class="built_in">xValue</span>()) / <span class="number">2</span>, (p<span class="number">1.</span><span class="built_in">yValue</span>() + p<span class="number">2.</span><span class="built_in">yValue</span>()) / <span class="number">2</span>&#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midPoint</span>(p1, p2);</span><br></pre></td></tr></table></figure><p>这意味着，mid 这个对象，其构造过程涉及到了构造函数，访问器，以及非成员函数的调用，但它依然是一个常量，可以放在只读内存中。</p><p>不过，如果类中的成员函数修改了对象的成员数据，则在 C++11 中，不能修饰为 <code>constepxr</code>，因为我们理应认为，这种函数没有不可变性。不过，在 C++14 中，这种约束也被去掉了。所以，在 C++14 中，可以编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>constexpr</code> 没有副作用，所以在可以使用它的时候，还是尽量去使用它。但如果你是在编写接口函数，在添加 <code>constexpr</code> 修饰时，一定想清楚，不要在将来又想要删除它，那时候，可能和 <code>noexcept</code> 一样，会遇到很多编译错误。</p><h2 id="条款-16：小心-const-成员函数的线程安全性"><a href="#条款-16：小心-const-成员函数的线程安全性" class="headerlink" title="条款 16：小心 const 成员函数的线程安全性"></a>条款 16：小心 const 成员函数的线程安全性</h2><p>从条款标题上看，似乎 const 修饰的成员函数，应该不可能存在线程安全性，因为 const 修饰后，它们是只读操作，不会对外部数据产生修改和破坏性的影响。</p><p>然而，C++ 还提供了 <code>mutable</code> 这个关键字，它自相矛盾地设计了这样一种机制：在类的 const 成员函数中，允许修改被 <code>mutable</code> 修饰的成员变量。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="comment">// val1++;    // 非法，编译器报错，const 函数中无法修改     </span></span><br><span class="line">    val2++;       <span class="comment">// 合法 </span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="type">int</span> val1; <span class="keyword">mutable</span> <span class="type">int</span> val2; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来很不合理，对吧？</p><p>因为这个机制，所以 const 成员函数，并不完全可以认为是只读的，从而，在这种场合下，如果这个成员函数刚好位于多线程上下文中，就很有可能出现常见的并发问题，就如同那些普通的并发场景下的问题一样的问题。</p><p><em>陷阱：const 成员函数，不一定是完全不会对外界产生影响的函数。留意那些 mutable 修饰的成员变量。</em></p><p>解决方案，书中列举了很多，但我认为没必要展开，因为它脱离了本条款的重点，加锁、原子操作等常见的方案都可以处理，只要把那个看起来是 const 的成员函数，当作普通函数处理就好了。</p><h3 id="为什么-C-要有这种自相矛盾的设计"><a href="#为什么-C-要有这种自相矛盾的设计" class="headerlink" title="为什么 C++ 要有这种自相矛盾的设计"></a>为什么 C++ 要有这种自相矛盾的设计</h3><p><code>mutable</code> 很早就有了，事实上它不比 <code>const</code> 来的更晚。这种设计的场合，通常发生在对接口函数的维护中。</p><p>假设你有一个已经公开的接口类，其中的 const 成员函数接口已经被很多地方引用，如果此时，因为一些与 const 本身要保护的主体不太相关的需求，需要破坏该接口的 const 属性，应该怎么办？使用 <code>mutable</code> 便是一个办法。</p><p>举个具体的例子，如果有一个控制数据库的类，其中有一个 const 成员函数是查询数据库信息。但现在有一个新需求，要求在每次查询数据库信息时，将查询日志写入一个位置，在不删除 const 属性的前提下，一种解决办法，便是把日志存放对象修饰为 <code>mutable</code>，这样就可以在 const 成员函数中写入日志了。写入日志本身是非 const 的操作，但它不违背这个成员函数添加 const 的初衷，即保证该函数不会改变数据库数据。</p><p>所以，在这些场合下，如果引入多线程，便可能产生奇怪的问题，这些问题非常难定位。这就是这一条款要表达的内容。</p><h2 id="条款-17：注意特殊成员函数的隐式生成规则"><a href="#条款-17：注意特殊成员函数的隐式生成规则" class="headerlink" title="条款 17：注意特殊成员函数的隐式生成规则"></a>条款 17：注意特殊成员函数的隐式生成规则</h2><p>特殊成员函数包括默认构造函数、析构函数、复制构造函数和复制赋值运算符函数，在 C++11 之后，又增加了移动构造函数和移动赋值运算符函数。编译器可能为一些类自动生成其中部分或全部特殊成员函数。本条规则需要留意，它们的隐式行为可能导致程序错误或性能衰退。</p><p>编译器隐式生成特殊构造函数的规则是：</p><ul><li>默认构造函数：当类中不包含任何用户声明的构造函数时才生成。</li><li>析构函数：当类中不包含用户声明的析构函数时才生成。如果基类中的析构函数是 <code>virtual</code> 的，那么此时生成的析构函数，也是 <code>virtual</code> 的。C++11 引入了 <code>noexcept</code> 关键字，生成的析构函数也默认带有 <code>noexcept</code> 属性。</li><li>复制构造函数：只有当类中不包含用户自定义的复制构造函数、移动构造函数和移动复制运算符时，才会自动生成。<strong>注意，如果类中包含了用户自定义的复制赋值运算符，复制构造函数仍然会自动生成，这一点和移动操作函数不同。</strong></li><li>复制赋值运算符：和复制构造函数相同。</li><li>移动构造函数：只有当类中不包含用户自定义的复制操作、移动操作和析构函数时，才会自动生成。<strong>注意，和复制操作不同，移动构造函数和移动赋值运算符是互斥的，其中一个存在，另一个不会自动生成，而复制操作没有这个规则。</strong></li><li>移动赋值运算符：和移动构造函数相同。</li></ul><p>C++ 本有意将两者统一起来，避免上述加粗内容的歧义，但考虑到代码兼容的问题，此条只能成为建议，而不是规则。书中称为 “大三律（Rule of Three）”：如果类中声明了复制构造函数、复制赋值运算符或析构函数中的任何一个，就应该同时声明这三个。</p><p><em>陷阱：复制构造函数和复制赋值运算符的隐式生成是独立的；移动构造函数和移动赋值运算符的隐式生成是互斥的。</em></p><p><em>建议：大三律规则，如果类中声明了复制构造函数、复制赋值运算符或析构函数中的任何一个，那么就应该同时声明这三个。</em></p><p>大三律的理由是，如果一个类中涉及到了这三种特殊成员函数中的任何一个，说明这个类会做资源管理，如果它会做资源管理，那么这三个就应该同时存在。进一步地，如果用户自定义了这三个之中任何一个成员函数，那么其他成员函数就也应该交由用户自定义，而不是自动生成，但 C++98 中没有对此做约束。</p><p>在 C++11 中，成功让大三律能自动推广到移动操作，使之成为规则而不仅仅是建议，即其中之一存在自定义版本时，就不会自动生成其他几个成员函数。</p><p>需要留意，移动构造函数和移动赋值运算符函数，不一定真的会让对象以移动的方式构造或赋值，能否移动取决于这个对象的所有组成部分是否可以移动。如果不能，移动构造函数和移动赋值运算符函数会转而以复制的方式来执行。</p><p>原理上来说，它们使用了 <code>std::move()</code> 操作，而这个操作，实际做的只是尝试性把左值引用类型转换为右值引用。第五章的条款会展开这个话题。</p><p>使用 <code>=default</code> 可以强行让编译器生成默认特殊成员函数，这样将隐式生成改为显式生成，让代码更容易理解，也可以避免意外地隐式生成规则生效或失效导致的一系列问题。</p><p>比如说下边的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">StringTable</span>() &#123;&#125; ... <span class="comment">// 没有实现其他复制、移动和析构函数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; values; <span class="comment">// 沉重的负载 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们在未来的某一天，或者是其他开发人员，对此代码做了一些修改。比如想要在资源申请和释放时，添加日志记录，这需求非常常见。为了释放时记录日志，我们不得不自定义析构函数，但我们忘记了大三律规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">StringTable</span>() &#123; <span class="built_in">makeLog</span>(<span class="string">&quot;Create&quot;</span>); &#125; ... <span class="comment">// 没有实现其他复制、移动操作 </span></span><br><span class="line">  ~<span class="built_in">StringTable</span>() &#123; <span class="built_in">makeLog</span>(<span class="string">&quot;Destroy&quot;</span>); &#125; <span class="comment">// 增加了自定义的析构函数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种改动似乎合理，但却引入了很严重的性能问题。添加自定义析构函数后，会阻止移动操作的隐式生成，但不会阻止复制操作的隐式生成。所以，第一个版本中，对象可以通过移动操作来高效移动，但添加日志后，我们发现对象只能用复制操作了，因为负载很大，所以引入了严重的性能下降。</p><p>是不是很 amazing 呀！一个简单的改进：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">StringTable</span>() &#123; <span class="built_in">makeLog</span>(<span class="string">&quot;Create&quot;</span>); &#125; </span><br><span class="line">  <span class="built_in">StringTable</span>(<span class="type">const</span> StringTable &amp;) = <span class="keyword">default</span>; <span class="comment">// 显式要求编译器生成默认版本   </span></span><br><span class="line">  StringTable &amp;<span class="keyword">operator</span>=(<span class="type">const</span> StringTable &amp;) = <span class="keyword">default</span>; </span><br><span class="line">  <span class="built_in">StringTable</span>(<span class="type">const</span> StringTable &amp;&amp;) = <span class="keyword">default</span>;   </span><br><span class="line">  StringTable &amp;<span class="keyword">operator</span>=(<span class="type">const</span> StringTable &amp;&amp;) = <span class="keyword">default</span>; </span><br><span class="line">  ~<span class="built_in">StringTable</span>() &#123; <span class="built_in">makeLog</span>(<span class="string">&quot;Destroy&quot;</span>); &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>C++ 的进化和 C++ 工程师的成长，就是在这样一遍又一遍的摸索和爬坑的过程中完成的。</p><p>本系列的其他文章：</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li><li><a href="/posts/57a898cb.html" title="Effective Modern C++ 读书笔记：转向现代C++">Effective Modern C++ 读书笔记：转向现代C++</a></li><li><a href="/posts/ce1aec80.html" title="Effective Modern C++ 读书笔记：智能指针">Effective Modern C++ 读书笔记：智能指针</a></li><li><a href="/posts/410ab8fb.html" title="Effective Modern C++：右值引用、移动语义和完美转发">Effective Modern C++：右值引用、移动语义和完美转发</a></li><li><a href="/posts/cd605d5c.html" title="Effective Modern C++：lambda 表达式">Effective Modern C++：lambda 表达式</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1939768367813727100">https://zhuanlan.zhihu.com/p/1939768367813727100</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Chapter.316</title>
    <link href="https://p2tree.top/posts/ad7e4660.html"/>
    <id>https://p2tree.top/posts/ad7e4660.html</id>
    <published>2025-08-12T23:08:24.000Z</published>
    <updated>2025-09-19T15:03:39.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>人的一生可以划分成多个不同的阶段，每个阶段有不同的任务、目标和心境。我试着按每 9 年一个阶段来划分，有这样一个总结（末尾引号中一句话是对这个阶段的赠语）。</p><p><strong>0 到 9 岁</strong>：完全依赖他人生活，好奇心旺盛，学习生存技能，认识世界，满足作为一个人的基本能力。”世界是一本打开的书，每一天都是新的一页“</p><p><strong>9 到 18 岁</strong>：开始形成自我认知，开始学习专业能力，掌握和传承那些前辈留下的知识，渴望独立但又依赖他人。”现在的困惑是未来智慧的种子“</p><p><strong>18 到 27 岁</strong>：自由地规划自己的人生目标，坚实基础，追求真理，探索自己，尝试开始反哺社会，充满希望，也常感焦虑。”勇敢不是不害怕，而是害怕时仍毅然前行“</p><p><strong>27 到 36 岁</strong>：找到同路人一起前行，养育孩子，事业家庭双重责任，理想和现实冲突不断。”比较是偷走幸福的元凶，走出自己的节奏“</p><p><strong>36 到 45 岁</strong>：重新认识世界，理解很多过去的事情，与自己和解，事业小有所成或寻找新的机会，压抑但坚韧。”照顾好别人之前，先照顾好自己“</p><p><strong>45 到 54 岁</strong>：对生活的期待发生变化，子女独立，父母年迈，心态回归家庭，培养更稳定更包容的情绪。”人生可以从不同的地方多次闪光，不要太早放弃“</p><p><strong>54 到 63 岁</strong>：体力下降但心智更成熟，从给社会创造财富的岗位上退出，就像曾经年轻的自己，再次寻找自己人生的新目标。”接受变化，接受新思想，永远保持好奇心“</p><p><strong>63 到 72 岁</strong>：开始抵抗疾病的侵袭，自己过去固有的生活习惯和观念受到冲击，更努力的适应新环境。“乐于改变的人找到了自己新的生活目标”</p><p><strong>72 到 81 岁</strong>：认识的人逐渐离开自己，对人的一生有了新的看法，并尽可能把这些东西留下来，积极面对未来。“时光会带走很多，但不会带有爱和记忆”</p><p><strong>81 到 90 岁</strong>：依赖他人照顾生活，但精神上却高度自由，将自己的经历留给后人，指导晚辈成长。“你人生中写下的每一个标点，都有其意义”</p><p>虽然这只是人生的几个阶段，但如果将它们看作是不同次的生命，我们就会更加珍惜眼前的生活，理解自己。试着去体验不同的人生，扮演不同的角色，经历各具特色的故事。</p><hr><div class="note primary flat"><p>封面图片来自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/GCSvn0YcAb47_R96ENx2YQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="人生" scheme="https://p2tree.top/tags/%E4%BA%BA%E7%94%9F/"/>
    
    <category term="哲学" scheme="https://p2tree.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ 读书笔记：auto</title>
    <link href="https://p2tree.top/posts/f3206605.html"/>
    <id>https://p2tree.top/posts/f3206605.html</id>
    <published>2025-07-25T22:58:23.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="条款-5：优先选用-auto"><a href="#条款-5：优先选用-auto" class="headerlink" title="条款 5：优先选用 auto"></a>条款 5：优先选用 auto</h2><p>使用 <code>auto</code> 会带来很多好处，比如：</p><ul><li>不需要关注一些复杂的类型声明，比如模板函数和 lambda 表达式类型</li><li>不会忘记初始化变量（<code>auto</code> 要求必须初始化）</li><li>一些不希望发生的隐式类型转换</li><li>代码类型变化时，不需要在多处修改类型，<code>auto</code> 自适应</li></ul><p>使用 <code>auto</code> 来取代显式指定类型的建议，一个很大的反对声音，就是无法从代码中直观地看出一个变量的类型。针对这种强有力地反对声浪，实际上有多种理由来反驳，比如说：</p><ul><li>大多数现代编程语言，基本都支持类型推导的特性</li><li>一个好的名字，比一个类型要重要的多。比如我们不需要知道迭代器的类型，但只要从名字中看出这是一个迭代器，就可以</li><li>一些现代化的编辑器，都支持显示类型，这包括 vim&#x2F;emacs 这些有年代感的软件</li><li>默认使用 <code>auto</code>，但在一些特殊情况，比如需要明确指定类型时，显式声明类型</li></ul><p>有关于 <code>auto</code> 的讨论，网络上有很多，我这里不一一列举。下面看几个书中的例子。</p><h3 id="案例-1：使用-auto-替代函数对象"><a href="#案例-1：使用-auto-替代函数对象" class="headerlink" title="案例 1：使用 auto 替代函数对象"></a>案例 1：使用 auto 替代函数对象</h3><p>以下代码，我们希望使用一个类型来接受 lambda 表达式，通常的做法是使用 <code>auto</code>，让编译器去推导实际的类型，但另外，也可以通过一个 <code>std::function</code> 来接受 lambda 表达式。注意，lambda 表达式的类型并不是 <code>std::function</code>，它只有编译器知道。因为 <code>std::function</code> 可以接受任何可调用对象，所以也就可以接受 lambda 表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常见的写法，使用 auto 类型 </span></span><br><span class="line"><span class="keyword">auto</span> derefLess = [](<span class="type">const</span> <span class="keyword">auto</span> &amp;p1, <span class="type">const</span> <span class="keyword">auto</span> &amp;p2) &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::function 的写法</span></span><br><span class="line"><span class="comment">// 必须指定一种形参类型，这里选择 std::unique_ptr&lt;Widget&gt; </span></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;, </span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt;   </span><br><span class="line">derefLess2 = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p1, </span><br><span class="line">                <span class="type">const</span> std::unique_ptr&lt;Widget&gt; &amp;p2) &#123; </span><br><span class="line">  <span class="keyword">return</span> *p1 &lt; *p2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>std::function</code> 的版本，首先看着非常啰嗦。除此之外，还有一些背后的差异。</p><p>第一点是，<code>std::function</code> 比 <code>auto</code> 的版本，更占用内存。<code>auto</code> 在类型推导后，和它的实际类型的占用空间是一致的，而 <code>std::function</code> 是一个模板函数，它的大小是固定的（不依实际类型而变化），除了其本身，还包含固定大小的闭包变量。如果固定的内存并不够用，编译器就会生成在堆上分配额外空间来存储闭包变量，也就导致了更多的内存开销。</p><p>第二点是，<code>std::function</code> 通常不会内联，所以结合第一点，也就会更慢。</p><h3 id="案例-2：遗漏类型修饰导致性能开销"><a href="#案例-2：遗漏类型修饰导致性能开销" class="headerlink" title="案例 2：遗漏类型修饰导致性能开销"></a>案例 2：遗漏类型修饰导致性能开销</h3><p>以下代码中，我们在一个循环中对 <code>unordered_map</code> 的容器做遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt; &amp;p : m) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>实际上，变量 <code>m</code> 的类型写错了，因为字典的键值应该是 <code>const</code>，所以其类型应该是 <code>std::unordered_map&lt;const std::string, int&gt;</code>。</p><p>这种错误编译器可以处理，它会在遍历键值对时，主动一个个将键值类型转换为 <code>const std::string</code>，实现方法是重新拷贝一份，再将拷贝后的 <code>const</code> 版本和 <code>p</code> 绑定在一起。<br>这就带来了性能开销。</p><p>使用 <code>auto</code> 既安全又简洁地解决了这个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : m) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="条款-6：当-auto-推导不符合时，使用显式类型的初始化"><a href="#条款-6：当-auto-推导不符合时，使用显式类型的初始化" class="headerlink" title="条款 6：当 auto 推导不符合时，使用显式类型的初始化"></a>条款 6：当 auto 推导不符合时，使用显式类型的初始化</h2><p>大多数情况下，auto 推导出来的类型，和实际我们希望它应该是的类型是一致的。<br>但有一种情况是例外。讨论以下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个函数声明，返回 vector&lt;bool&gt; </span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget &amp;w)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是对函数的使用 </span></span><br><span class="line">Widget w; </span><br><span class="line"><span class="type">bool</span> res = <span class="built_in">features</span>(w)[<span class="number">5</span>];   <span class="comment">// 获取第 5 个 bit 的 bool </span></span><br><span class="line"><span class="built_in">processWidget</span>(w, res);       <span class="comment">// 使用返回的 bool</span></span><br></pre></td></tr></table></figure><p>这个代码没有任何问题，但如果我们将使用 <code>features</code> 的代码改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = <span class="built_in">features</span>(w)[<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">processWidget</span>(w, res);   <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure><p>问题就出现了。</p><p>表面原因可能很容易理解，如果了解过一些 <code>std::vector</code> 的知识，就会知道，获取 <code>std::vector&lt;bool&gt;</code> 的元素，并不会直接返回 <code>bool</code>。C++ STL 中，<code>std::vector&lt;bool&gt;</code> 的 <code>operator[]</code> 操作，返回的是一个特别的类型，<code>std::vector&lt;bool&gt;::reference</code>。也就是说，<code>auto</code> 类型推导的结果并不是 <code>bool</code>，而是 <code>std::vector&lt;bool&gt;::reference</code> 类型。</p><p>这是因为，通常 <code>operator[]</code> 操作返回的应该是某个元素的引用，而 C++ 中不允许对位进行引用，所以设计了这样一种结构。类似的问题也存在于 <code>std::bitset</code> 中。</p><p>由于 <code>std::vector&lt;bool&gt;::operator[]</code> 返回的是 <code>std::vector&lt;bool&gt;::reference</code> 类型，而后者的实现，有可能是一个指向 word 字内存的引用和一个字中位的偏移（<code>std::vector&lt;bool&gt;</code> 中使用 word 字来保存每个 bit）。</p><p>另外，我们注意到，<code>features(w)</code> 返回的实际是一个临时对象，那么，当临时对象被销毁时，<code>std::vector&lt;bool&gt;::reference</code> 中的内存引用就会失效，这个失效即发生在 <code>auto res</code> 被初始化后，从而导致下一行代码出现悬挂引用。</p><p>如果不使用 <code>auto</code>，使用 <code>bool</code> 指定实际类型，就不会有这个问题，原因是 <code>std::vector&lt;bool&gt;::reference</code> 实现了向 <code>bool</code> 的隐式类型转换。<code>std::vector&lt;bool&gt;::reference</code> 这种结构被称为<strong>代理类</strong>，在 C++ 实践中其实广泛存在，最常见的就是 <code>std::shared_ptr&lt;T&gt;</code>和 <code>std::unique_ptr&lt;T&gt;</code>。如果使用 <code>auto</code> 来推导返回代理类类型的对象类型，便会发生上述问题。</p><p>既想使用 <code>auto</code> 还想解决这个问题的办法，只能是使用显式的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = std::<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>这种写法相比于最开始 <code>bool res = features(w)[5]</code> 的写法，是更值得推荐的，原因是，它可以显式表达出来这种类型转换，不容易引起错误。事实上，<code>static_cast</code> 总是应该被推荐的，任何隐式类型转换，都可能引入潜在的问题，而迷惑程序员。</p><p>这可能是唯一一个会阻碍你使用 <code>auto</code> 的理由，我认为这也是 C++ 设计的一个遗憾，能做的就是，在编码时，使用 <code>auto</code> 但不要忽视类型，C++ 依然是一个强类型语言。另外，对这种常见的代理类要有足够的敏感度，比如获取 <code>std::vector&lt;bool&gt;</code> 的元素，获取 <code>std::bitset</code> 的位，获取智能指针的原始裸指针。</p><p><em>陷阱：auto 固然好用，但不是万能的，使用 auto 时，时刻还需要留意背后推导的类型是什么。</em></p><hr><p>这一章比较短，也没有什么难以理解的内容，更多的是一种编程习惯。<br>本系列其他文章：</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li><li><a href="/posts/57a898cb.html" title="Effective Modern C++ 读书笔记：转向现代C++">Effective Modern C++ 读书笔记：转向现代C++</a></li><li><a href="/posts/ce1aec80.html" title="Effective Modern C++ 读书笔记：智能指针">Effective Modern C++ 读书笔记：智能指针</a></li><li><a href="/posts/410ab8fb.html" title="Effective Modern C++：右值引用、移动语义和完美转发">Effective Modern C++：右值引用、移动语义和完美转发</a></li><li><a href="/posts/cd605d5c.html" title="Effective Modern C++：lambda 表达式">Effective Modern C++：lambda 表达式</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1932162651242340425">https://zhuanlan.zhihu.com/p/1932162651242340425</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++ 读书笔记：类型推导</title>
    <link href="https://p2tree.top/posts/9bb75fe1.html"/>
    <id>https://p2tree.top/posts/9bb75fe1.html</id>
    <published>2025-06-17T23:33:14.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先开一小节介绍下我写这个的缘由。</p><p>很多年前，看过《Effective C++》，是一本好书，把一些 C++ 的细节抽出来深入探索，能学到好多东西。不过，这本书太老了，里边一些内容需要更新，著书时应该 C++14 还没出。前段时间工作有点空，就看了《Effective Modern C++》，可以认为是前者的重构版，引入了一些更新的 C++ 规范，如果你两本书都没看过，那只推荐去看《Effective Modern C++》。</p><p>然而，虽然两本书的原作者都是 Scott Meyers，但译者却不是同一个人，《Effective C++》的译者侯捷老师的翻译非常出色，然而，我在阅读《Effective Modern C++》时，却感到晦涩难懂。我不知道是我的理解能力不足，还是译者的中文水平有限，阅读时让我不得不找出英文原文，对照着理解一些中文版云里雾里的内容。</p><p>网络上除了官方出版的这个中译版，还有一些积极地团体对该著作重新翻译，所以我大不可能去做重复的事情。以下这个系列文章，只是我阅读笔记的整理。整理笔记可以梳理思路，发现理解的漏洞，并温习知识，甚至，还能发现一些书中的小错误，是大有脾益的。</p><p>如果你打算阅读这份笔记，我很欣慰，但我还是建议你如果有时间有精力，去阅读原著。我的笔记中会省略掉很多重复的、用于前后衔接的、以及众所周知的内容，而只整理出作者想要强调的部分。该系列书籍的内容采用罗列一些常用的 C++ 技巧而成文，每一条都称为一个条款，我将以相同的结构整理。我也适当地调整了条款的标题，正文的结构顺序和示例代码（通常改地更简单），并将值得关注的细节摘出高亮，唯一的目的就是让重点更突出，更快速地吸收知识。</p><p>摘录的重点分为<strong>技巧</strong>、<strong>陷阱</strong>和<strong>谬误</strong>，技巧是指可以学习并应用在工程实践中小 tip，陷阱是指容易在工程实践中犯错，导致程序 bug 的要点，谬误呢，是可能对 C++ 知识的错误理解。这些内容除了在正文中出现时列出，我还会在最后一章中单独列出，作为一个 check list 使用。</p><h2 id="条款-1：理解模板类型推导"><a href="#条款-1：理解模板类型推导" class="headerlink" title="条款 1：理解模板类型推导"></a>条款 1：理解模板类型推导</h2><p>模板是泛型的一种体现。编译器在对模板做实例化时，其中一部分工作就是将泛型推导为实际的类型。<br>对于不同的情况，C++ 规范要求的模板类型推导方式略有差别，这也就导致了可能产生的误解和陷阱。</p><p>为什么要了解模板类型推导？这里给出书中一个有意思的例子。<br>提问，如果在声明一个数组 A 时，通过另一个未知长度的数组 B 的长度，作为数组 A 的长度，应该怎么做？<br>答案是可以利用模板类型推导，来静态推导出数组 B 的长度。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模板函数可以返回任意一个数组的长度 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> N; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 假设 arrayB 是一个未知长度的数组（注意是数组，不能是指针） </span></span><br><span class="line"><span class="comment">// arrayA 声明长度一定和 arrayB 相同 </span></span><br><span class="line"><span class="type">int</span> arrayA[<span class="built_in">arraySize</span>(B)];</span><br></pre></td></tr></table></figure><blockquote><p><strong>技巧</strong>：使用模板类型推导方法，可以在函数内推导出数组实参的长度。</p></blockquote><h3 id="情况-1：ParamType-是指针或引用，但不是万能引用"><a href="#情况-1：ParamType-是指针或引用，但不是万能引用" class="headerlink" title="情况 1：ParamType 是指针或引用，但不是万能引用"></a>情况 1：ParamType 是指针或引用，但不是万能引用</h3><p>一个简单的模板示例代码如下，后续会基于这个示例代码做分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数声明 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数的调用 </span></span><br><span class="line"><span class="built_in">f</span>(expr);</span><br></pre></td></tr></table></figure><p>模板函数声明中，<code>T</code> 和 <code>ParamType</code> 可能是相同类型，也可能是不同类型，<code>ParamType</code> 是看到的代码所显示的类型，而 <code>T</code> 是编译器实际推导的类型。<code>expr</code> 为实参，<code>param</code> 为形参。</p><p>情况 1 的类型推导规则是：</p><ol><li>去掉指针或引用类型</li><li>剩余部分做模式匹配</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = x; </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T 类型是 int, param 类型是 int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T 类型是 const int, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T 类型是 const int, param 类型是 const int&amp; </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(x);  <span class="comment">// T 类型是 int, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">g</span>(cx); <span class="comment">// T 类型是 int, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">g</span>(rx); <span class="comment">// T 类型是 int, param 类型是 const int&amp;</span></span><br></pre></td></tr></table></figure><h3 id="情况-2：ParamType-是万能引用"><a href="#情况-2：ParamType-是万能引用" class="headerlink" title="情况 2：ParamType 是万能引用"></a>情况 2：ParamType 是万能引用</h3><p>这里不介绍什么是万能引用，它的形参声明方式类似右值引用。<br>类型推导规则是：</p><ol><li>如果实参是左值，<code>T</code> 和 <code>param</code> 都会推导为左值引用。这是模板类型推导中，唯一一种会推导出引用类型的情况</li><li>如果实参是右值，则按情况 1 处理</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// 这是万能引用 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = x; </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T 类型是 int&amp;, param 类型是 int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T 类型是 const int&amp;，param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T 类型是 const int&amp;, param 类型是 const int&amp; </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// 因为 27 是右值，按规则 1 处理，T 类型是 int，param 类型是 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="情况-3：ParamType-非指针和引用"><a href="#情况-3：ParamType-非指针和引用" class="headerlink" title="情况 3：ParamType 非指针和引用"></a>情况 3：ParamType 非指针和引用</h3><p>按值传递的类型推导规则是：</p><ol><li>如果实参有指针和引用类型，去掉指针或引用类型</li><li>如果是 cv 类型（const 或 volatile，下同），忽略 cv 类型。这是唯一会被忽略的情况</li></ol><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = x; </span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T 类型是 int, param 类型是 int </span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T 类型是 int, param 类型是 int </span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T 类型是 int，param 类型是 int</span></span><br></pre></td></tr></table></figure><h3 id="实参类型退化"><a href="#实参类型退化" class="headerlink" title="实参类型退化"></a>实参类型退化</h3><p>数组类型和指针类型在编译器里是不相同的，我们经常混淆两者，是因为数组类型会在一些场合退化为指针类型，比如传参时。</p><p>但如果我们传参时，就是想传入数组类型（带有数组长度），而不是指针类型，其实也是有办法的，前边已经给出示例，也就是用引用类型来传递。</p><blockquote><p><strong>谬误</strong>：不要混淆数组类型和指针类型，它是 C++ 兼容 C 语言的一些遗迹。</p></blockquote><p>另外，函数类型通过传参后，默认也会退化为函数指针。如果想要保留推导为函数类型，也可以按引用传递。</p><h2 id="条款-2：理解-auto-类型推导"><a href="#条款-2：理解-auto-类型推导" class="headerlink" title="条款 2：理解 auto 类型推导"></a>条款 2：理解 auto 类型推导</h2><p>绝大多数 <code>auto</code> 类型推导的规则，和模板类型推导的规则是完全一致的，它也同样遵守 <strong>条款1：理解模板类型推导</strong> 涉及到的 3 个规则。</p><p>只有一个例外。</p><p>当使用 C++11 中引入的初始化列表来初始化 auto 类型时，不符合上述规则。</p><p>先看个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下显式声明为 int 的变量，它们的类型显然都是 int </span></span><br><span class="line"><span class="type">int</span> x1 = <span class="number">27</span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>; </span><br><span class="line"><span class="type">int</span> x3 = &#123;<span class="number">27</span>&#125;; <span class="comment">// 这是统一初始化方式 </span></span><br><span class="line"><span class="type">int</span> x4&#123;<span class="number">27</span>&#125;;    <span class="comment">// 这个也是统一初始化方式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但以下使用 auto 来声明的变量，类型不一致 </span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;   <span class="comment">// 类型为 int </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;    <span class="comment">// 类型为 int </span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;; <span class="comment">// 类型为 std::initializer_list&lt;int&gt;，值为 &#123;27&#125;，注意，带大括号 </span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;    <span class="comment">// 同 x3</span></span><br></pre></td></tr></table></figure><p>这条规则是：<strong>当</strong> <strong><code>auto</code></strong> <strong>类型推导时，变量的初始化表达式是通过大括号括起来时，<code>auto</code></strong> <strong>的推导结果类型是</strong> <strong><code>std::initializer_list</code>。</strong></p><p>而我们注意到，<code>std::initializer_list</code> 是一个模板，所以初始化表达式下的 <code>auto</code> 类型推导，实际发生了两次类型推导，第一次是推导变量类型是 <code>std::initializer_list</code>，第二次是推导初始化列表类型的模板类型，比如上例中的 <code>int</code>。所以，下边这种初始化会推导失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译失败，因为 std::initizalizer_list 的模板参数类型推导失败（int 还是 double？） </span></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>类似的，将初始化表达式传递给一个模板函数，模板函数的模板类型也会推导失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 </span></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(std::initializer_list&lt;T&gt; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以推导成功，T 的类型是 int </span></span><br><span class="line"><span class="built_in">g</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>陷阱</strong>：C++11 中，auto 推导初始化列表类型时，会推导为 std::initializer_list，其本意可能并非如此。</p></blockquote><p>另外，C++14 中支持了使用 <code>auto</code> 来推导函数返回值或 lambda 表达式的形参类型。然而其本质依然是模板类型推导，所以如果函数返回值和 lambda 表达式参数给定的是初始化列表，同样无法完成推导。</p><h2 id="条款-3：理解-decltype"><a href="#条款-3：理解-decltype" class="headerlink" title="条款 3：理解 decltype"></a>条款 3：理解 decltype</h2><p><code>decltype</code> 是一个古老的语法，它可以获得一个名字（变量、函数等）或者表达式的类型。<br>在工程应用中，它常用于指代那些函数返回值类型需要依赖参数类型来决定的模板函数。比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">access</span><span class="params">(Container &amp;c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(c[i])</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回一个任意容器中一个元素的类型，类型推导通过 <code>decltype</code> 和函数返回值尾序声明的语法来完成。</p><p>但它存在一个问题，从 <strong>条款2：理解 auto 类型推导</strong> 中，我们知道，<code>auto</code> 作为模板函数返回值时，会忽略引用类型，所以，这个函数只能返回一个右值。如果我们希望操作容器中的原始元素，就无能为力了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; </span><br><span class="line"><span class="built_in">access</span>(vec, <span class="number">1</span>) = <span class="number">0</span>; <span class="comment">// 错误，右值不能被赋值</span></span><br></pre></td></tr></table></figure><h3 id="推导返回引用类型"><a href="#推导返回引用类型" class="headerlink" title="推导返回引用类型"></a>推导返回引用类型</h3><p>上边的问题，在 C++14 中，可以利用 <code>decltype</code> 做到，一种比较奇怪的语法。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">access</span><span class="params">(Container &amp;c, Index i)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>decltype(auto)</code> 可以在 <code>auto</code> 类型推导的规则下，不忽略引用性，从而使模板函数的返回值为一个引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; </span><br><span class="line"><span class="built_in">access</span>(vec, <span class="number">1</span>) = <span class="number">0</span>; <span class="comment">// 正常编译</span></span><br></pre></td></tr></table></figure><h3 id="巧用万能引用实现传递原始引用类型"><a href="#巧用万能引用实现传递原始引用类型" class="headerlink" title="巧用万能引用实现传递原始引用类型"></a>巧用万能引用实现传递原始引用类型</h3><p>上述办法可以让模板函数返回左值，但为了同时可以支持左值返回值和右值返回值类型，只能通过重载写两套代码。</p><p>但如果你了解万能引用，那么就知道他可以只写一套代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">access</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 C++14 的版本，C++11 中不支持 <code>decltype(auto)</code>，可以改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">access</span><span class="params">(Container&amp;&amp; c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(std::forward&lt;Container&gt;(c)[i])</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>技巧</strong>：使用万能引用和完美转发来实现传递引用性。</p></blockquote><h3 id="另外一个话题"><a href="#另外一个话题" class="headerlink" title="另外一个话题"></a>另外一个话题</h3><p>抛开上边的话题，单独聊一下 <code>decltype(auto)</code>，它的使用需要注意一个细节。</p><p>decltype 对简单变量的名字（变量名字是左值表达式）做推导时，会给出类型本身（非引用类型），但如果是复杂一些的左值表达式，比如把变量名字放在小括号里，就会推导出左值引用类型。这可能导致一些潜在的问题。</p><p>比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f1 的返回值类型是 int </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// f2 的返回值类型是 int&amp; </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> (x); <span class="comment">// 因为 (x) 是一个表达式 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>陷阱</strong>：用 decltype 推导复杂的左值表达式时，会推导出左值引用类型。</p></blockquote><h2 id="条款-4：掌握查看类型推导结果的方法"><a href="#条款-4：掌握查看类型推导结果的方法" class="headerlink" title="条款 4：掌握查看类型推导结果的方法"></a>条款 4：掌握查看类型推导结果的方法</h2><p>除了使用编辑器的功能来显示名字的类型之外，C++ 提供了运行时的类型信息以及可操作的方法，即 <code>typeid()</code>。</p><p>大多数情况下，它运行地很好。但需要注意有些场景下，它可能输出让你意外的结果。</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span> </span>&#123;  </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl; </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;param = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是哪个编译器，两个名字的类型都被推导为相同类型。但从代码中直观的看，<code>param</code> 类型应该总会比 <code>T</code> 多一个常量引用修饰才对。</p><p>编译器是正确的，实现符合 C++ 标准。所以这只能在使用时多留意。</p><p>boost 库提供了一个替代工具，可以推导出直观的类型，使用 <code>boost::typeindex::type_id_with_cvr</code> 来代替 <code>typeid</code> 即可。</p><blockquote><p><strong>陷阱</strong>：谨慎使用 typeid 来推导类型，可能会得到不预期的结果。</p></blockquote><hr><p>第一章结束了，如果有什么疑问或错误，请不吝指出。作者把类型推导作为第一章的内容，实话说有点劝退 C++ 新人，不过，这部著作确实也不适合新人阅读，适当的门槛也没问题。当然，最重要的是，类型推导实在太重要了，它一定程度上，可以作为 modern C++ 的基础去看待，后边很多问题都和类型推导有关系。</p><p>后续章节的内容也都准备好，整理格式后会陆续发出。</p><ol class="series-items"><li><a href="/posts/9bb75fe1.html" title="Effective Modern C++ 读书笔记：类型推导">Effective Modern C++ 读书笔记：类型推导</a></li><li><a href="/posts/f3206605.html" title="Effective Modern C++ 读书笔记：auto">Effective Modern C++ 读书笔记：auto</a></li><li><a href="/posts/57a898cb.html" title="Effective Modern C++ 读书笔记：转向现代C++">Effective Modern C++ 读书笔记：转向现代C++</a></li><li><a href="/posts/ce1aec80.html" title="Effective Modern C++ 读书笔记：智能指针">Effective Modern C++ 读书笔记：智能指针</a></li><li><a href="/posts/410ab8fb.html" title="Effective Modern C++：右值引用、移动语义和完美转发">Effective Modern C++：右值引用、移动语义和完美转发</a></li><li><a href="/posts/cd605d5c.html" title="Effective Modern C++：lambda 表达式">Effective Modern C++：lambda 表达式</a></li></ol><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1916895541884858605">https://zhuanlan.zhihu.com/p/1916895541884858605</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Chapter.152</title>
    <link href="https://p2tree.top/posts/6fa98d5.html"/>
    <id>https://p2tree.top/posts/6fa98d5.html</id>
    <published>2025-05-21T21:27:30.000Z</published>
    <updated>2025-09-19T15:03:39.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>创造信息的门槛变低了。曾经，只有有学识的人才能教授和传播知识；后来，越来越多的人可以投稿和写书；现在，一个没有背景和知识积累的人，也可以创造出传播力远大于曾经的信息，比如软文，短视频，直播，播客等等。</p><p>门槛变低的后果就是，信息的质量变差了，良莠不齐，如果没有一定辨别信息准确性和价值的判断力，就会被信息海洋淹没，浪费掉自己的注意力，甚至带来错误的引导。</p><p><em><strong>永远不要随便把网上看到的信息当做真理，只有经得起推敲的道理才是真理。</strong></em></p><p><img src="https://img.p2tree.top/2025/5/21/Chapter.152.webp" alt="Chapter.152"></p><hr><div class="note primary flat"><p>封面图片来自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/eTP3i0G3mIK7B6KUjcCyiA">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="网络安全" scheme="https://p2tree.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：SmallSet</title>
    <link href="https://p2tree.top/posts/8a9047b8.html"/>
    <id>https://p2tree.top/posts/8a9047b8.html</id>
    <published>2025-04-27T23:43:26.000Z</published>
    <updated>2025-09-19T15:03:39.968Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本系列文章以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><p>在现代编程语言开发中，集合（Set）是一种非常有用的数据结构，它可以高效存储唯一元素。本文介绍一种更轻量级的集合实现：<code>SmallSet</code>。它非常适合存储少量元素，同时保持出色的性能和内存效率。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>SmallSet</code> 是一种小型集合类型，它实现了基本的集合操作，比如插入、删除和查找等。它的设计目标是优化在存储小规模数据时的性能和内存占用，它结合了小对象优化和动态内存调节技术，非常适合频繁访问的小集合场景。<br>如果你已经对 <code>SmallVector</code> 有了解，那么 <code>SmallSet</code> 和它有着类似的实现思路。</p><p><code>llvm::SmallSet</code> 定义在 <code>llvm/ADT/SmallSet.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N, <span class="keyword">typename</span> C = std::less&lt;T&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> SmallSet;</span><br></pre></td></tr></table></figure><p>当集合中存储的元素数量少于模板参数 <code>N</code> 时，将采取更优化的存储策略；如果数量超出指定范围后，采用和 <code>std::set</code> 一样的实现方案（事实上，其内部直接调用了 <code>std::set</code> 来管理数据）。<br>并不建议给 <code>N</code> 的值过大，所以在实现中，限制了 <code>N &lt;= 32</code>，因为小对象优化利用了 <code>SmallVector</code> 来管理数据，其搜索效率是线性的，如果数据量过大，则会失去作为集合的高效查找的属性。如果希望管理更多的数据，使用 <code>DenseSet</code> 是一个替代的方案。<br>第三个模板参数是自定义比较函数，默认是使用 <code>std::less</code>，它将用于在集合内部做元素排序和查找时的比较规则，它会传给内部管理数据的 <code>std::set</code> 使用。我们知道，集合内部通常使用平衡二叉树来优化检索效率，所以需要元素比较算法的支持。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>关联容器：和 <code>std::set</code> 一样，<code>SmallSet</code> 满足符合集合类型的特征。</li><li>小规模数据优化：<code>SmallSet</code> 内部使用了一个 <code>SmallVector</code> 来存储少量数据（小于 32 个），从而在小规模数据时，避免了构建和维护二叉树结构带来的性能开销。</li><li>操作一致：它和 <code>std::set</code> 拥有一样的操作接口。</li></ul><h3 id="与标准库-set-的对比"><a href="#与标准库-set-的对比" class="headerlink" title="与标准库 set 的对比"></a>与标准库 set 的对比</h3><ul><li>性能优势：在数据量较小时，由于不会涉及到分配二叉树结构和自平衡等开销，性能会优于 <code>std::set</code>。</li><li>退化时性能损失：当容器中存储元素超出给定值后，需要将原来的数据拷贝或移动到 <code>std::set</code> 容器中，这带来了瞬时的性能下降。所以，需要谨慎决定 <code>N</code> 的大小。</li><li>可能浪费空间：当数据量较小时，<code>SmallSet</code> 采用 <code>SmallVector</code> 作为内部的数据存储类型，如果 <code>N</code> 值大于实际存储的元素数量，会带来空间浪费。</li><li>只适合小规模数量集合：它适合使用在简单场景，尤其是基本明确容量，且需要快速创建和销毁集合时。尽量让其工作在小数据优化状态，当数据量较大时，使用 <code>std::set</code> 更合适。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>整个 <code>SmallSet</code> 的主要成员有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N, <span class="keyword">typename</span> C = std::less&lt;T&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> SmallSet &#123;   </span><br><span class="line">  SmallVector&lt;T, N&gt; Vector; <span class="comment">// 用来存储小规模数据   </span></span><br><span class="line">  std::set&lt;T, C&gt; Set; <span class="comment">// 数据量超出 N 后，存放数据 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/SmallSet.h</code> 中的代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>使用默认构造函数，因为我们不会在构造集合时初始化整个集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmallSet&lt;<span class="type">int</span>&gt; theSet;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>因为有两个存储位置，所以我们不得不为这个容器类型实现自己的迭代器。使用方法和常规迭代器相同，支持 <code>begin()</code> <code>end()</code> 访问元素。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;const_iteraotr, <span class="type">bool</span>&gt; ret = theSet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>如果插入元素时，是小数据模式，便手动实现一个不含重复元素的 <code>SmallVector</code> 插入；否则，直接插入 <code>std::set</code>，如果 <code>SmallVector</code> 容量超出 <code>N</code>，则将 <code>SmallVector</code> 中全部数据转移到 <code>std::set</code> 中。<br>返回一个 <code>std::pair</code>，第一个值是指向这个元素的迭代器，第二个值是标记是否插入成功，如果插入失败，表示相同值已存在，第一个值将是指向那个相同值的迭代器。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theSet.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>和插入相反的动作，但数据量缩减到小于 <code>N</code> 并不会退化回小数据优化模式。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> existed = theSet.<span class="built_in">contains</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> elements = theSet.<span class="built_in">size</span>(); </span><br><span class="line"><span class="keyword">auto</span> ele = theSet.<span class="built_in">count</span>(<span class="number">10</span>); <span class="comment">// 因为是集合，只会返回 0 或 1，表示这个元素值的数量</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>支持几种比较运算符的使用。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不保证异常安全"><a href="#不保证异常安全" class="headerlink" title="不保证异常安全"></a>不保证异常安全</h3><p><code>SmallSet</code> 不是异常安全的。和标准库 <code>std::set</code> 不同。</p><h3 id="不合适的预分配大小"><a href="#不合适的预分配大小" class="headerlink" title="不合适的预分配大小"></a>不合适的预分配大小</h3><p>和 <code>SmallVector</code> 一样，在声明类型时，如果给定的 <code>N</code> 值相对较大，会存在内存空间的浪费；但如果给定的值过小，又发挥不出 <code>SmallSet</code> 容器的性能优势，反而带来性能下降。</p><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>虽然集合容器作为一种非线性容器，不会在插入和删除元素时，导致其他迭代器失效，但我们应该注意到 <code>SmallSet</code> 中存在 <code>SmallVector</code> 和数据量变大导致内存扩展时的问题。所以，<code>SmallSet</code> 中的操作是可能导致迭代器失效的。</p><h3 id="元素为指针类型"><a href="#元素为指针类型" class="headerlink" title="元素为指针类型"></a>元素为指针类型</h3><p><code>SmallSet</code> 的实现中，特别针对当元素类型 <code>T</code> 为指针类型时，一种特化的实现方案，它将完全采用 <code>SmallPtrSet</code> 来实现。后者拥有前者的所有特质，区别在于，当发生内存扩展时，它的实现是一个哈希表（而没有使用 <code>std::set</code>）。因为指针和普通元素的一个区别是，指针不需要排序，且比较代价更大，如果做动态再平衡，开销比普通元素更大。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="不适合存储大量数据"><a href="#不适合存储大量数据" class="headerlink" title="不适合存储大量数据"></a>不适合存储大量数据</h3><p>首先，模板参数 <code>N</code> 不能超过 32，否则会导致编译失败，<code>N</code> 值较大时，检索元素的效率会降低（<code>SmallVector</code> 中线性查找复杂度），所以实现上强行约束了最大值。<br>其次，它本身也不适合存储大量元素，尽量避免存储超出 <code>N</code> 值的元素数量。大量数据时，它使用 <code>std::set</code> 管理数据，反而还带来了当数据扩展时的瞬时性能下降问题。</p><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>添加和删除元素会带来性能开销，一方面是保证元素唯一性和当数据量较大时 <code>std::set</code> 的再平衡开销，另一方面时当数据扩展时（添加元素），所有 <code>SmallVector</code> 元素复制或移动到 <code>std::set</code> 的开销。<br>当插入数据的数量少于 <code>N</code> 时，不会带来动态分配开销，因为构造时已经分配了 <code>N</code> 这么大的内存。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>SmallVector</code>：和 <code>SmallSet</code> 设计初衷和思路相同的顺序型可变长数组容器，见：<a href="https://zhuanlan.zhihu.com/p/28641819827">学习 LLVM 数据结构：SmallVector</a></li><li><code>SmallPtrSet</code>：管理指针类型的 <code>SmallSet</code> 变体。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallset-h">LLVM Programmer’s Manual</a></li><li><a href="https://en.cppreference.com/w/cpp/container/set">cppreference set</a></li><li>LLVM 16.0 源码</li><li>LLVM 20.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1899164450520536088">学习LLVM数据结构-SmallSet - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：南京大屠杀</title>
    <link href="https://p2tree.top/posts/1e952ac7.html"/>
    <id>https://p2tree.top/posts/1e952ac7.html</id>
    <published>2025-04-26T23:25:26.000Z</published>
    <updated>2025-09-19T15:03:39.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忘记历史的人，就一定会重蹈覆辙，这既是指日本人忘记过去会再次犯错，更是指中国人忘记过去，会让历史重演。张纯如老师一生最伟大的这部作品，最大的价值就在于，让距离那场灾难将近 100 年后的现代人，能再次回顾那段不堪往事，能不忘国耻，能时刻谨记身为这个民族的一员，所应该承担的责任和价值。</p><p>这本书相当地克制，换作我，无论如何也做不到保持理性和客观地介绍当时的情况，从日本人的角度、中国人的角度、西方人的角度去展现事实。虽然我已经对南京大屠杀有过了解，也参观过南京大屠杀遇难同胞纪念馆，但读完本书，还是收获很多。</p><p>南京是当时中国的首都，在南京发生这种事情，远比当时其他惨剧影响更恶劣。而南京大屠杀只是日本发动侵华战争中，犯下的其中一个罪行，类似的悲剧也在其他城市和乡村发生。书中提到，就仅仅是日本士兵在向南京进发时，途径苏州，在短短几天内，苏州 35 万人口，锐减到不足 500 人。</p><p>书中给我留下深刻印象的是拉贝前辈，我曾听说过他是大屠杀发生时的一个异国志士，但没想到帮助他能保护中国人民的重要力量是他的政党，纳粹党。同一时期，纳粹在欧洲大陆上开展种族屠杀，在亚洲大陆上却在进行着一场人道救援，这让我反省，个人的光辉是否总会被集体所掩盖？除了拉贝，还有一些国际友人，在危险的那段日子，和中国人共存亡，他们突破了个人和民族的限制，成为真正站在光里的人，为那段黑暗的故事，带来希望。</p><p>当我看到日本神道教所推崇的，只有天皇和其子民才是上等民族时，让我想到现在的犹太人，似乎必然是会被周围民族所鄙视和排斥的种族。在日本人眼中，中国人就像是虫子和动物，所以，他们在中国杀人，就像杀掉一头猪一样心安理得。为什么？因为懦弱！当几千个日本士兵进入拥有几十万人口的南京城时，中国人在撤退；当两三个日本人在开枪处决排成队的几十个中国人时，中国人呆若木鸡；当这座几千年历史的古城里，每时每刻都在发生着屠杀、抢劫、强奸和焚烧时，也只有很少人奋起反抗。这就是当时的中国。懦弱只会让敌人鄙视和肆无忌惮，而不会换来同情，渴求怜悯只会换来变本加厉，至少，在我们的日本邻居这里，一定是这样的。</p><p>研究这场灾难，不能不去研究日本这个民族，我始终认为，虽然是日本政府发动了战争，默许纵容了惨无人道的屠杀，但政府和皇族本质上都是一个民族，精神文化和传统认知是一样的，纯如老师在这里过于谨慎了，同样是战败国，同样是被法律审判的国家，德国对二战的忏悔和对纳粹的抵制，已经成为一种文化，甚至是政治正确，但日本却没有道歉和赔款，而是把二战战犯供奉在靖国神社。而现在的中国人，似乎已经在主动原谅曾经的敌人。</p><p>每个中国人都应该去了解这段历史，读读这本书，如果没有勇气读下去，就没有勇气在未来保护自己的家庭，自己的人民和自己的国家。日本人用被原子弹攻击来包装自己是受害者，而且他们的文化影响力也在影响着中国的年轻一代，每个作为父母的中国人，都应该把那段屈辱的历史讲给孩子听，让他们树立正确的是非观。</p><p>如今的南京，是国际知名的大都市，时代在发展，新的城市在旧城上生长出来，历史逐渐被埋入泥土中，如果没有那些客观理性的历史学家们，很多故事都会被永远尘封。纯如老师，向您致敬 ！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="历史" scheme="https://p2tree.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：StringRef</title>
    <link href="https://p2tree.top/posts/a198516a.html"/>
    <id>https://p2tree.top/posts/a198516a.html</id>
    <published>2025-03-25T21:14:24.000Z</published>
    <updated>2025-09-19T15:03:39.968Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::StringRef</code> 定义在 <code>llvm/ADT/StringRef.h</code> 头文件中。 它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRef</span>;</span><br></pre></td></tr></table></figure><p>和 <code>ArrayRef</code> 类似，<code>StringRef</code> 是一种轻量级的字符串引用类型，它用于实现高效地表示和操作字符串数据，尤其是在一些高频处理字符串，但同时不希望维护实际内存开销地场景下。 它是不可变引用，主要用于向函数内传递字符串同时避免深拷贝。它只包含了指向字符串的指针和字符串的长度信息，从而使得对它的操作直接而高效。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>轻量级</strong>：只存储一个指向字符串的指针和字符串的长度，不存储实际的数据，所以拷贝时很高效。</li><li><strong>简单易用</strong>：支持许多常用的字符串操作，比如比较、查找和子串提取，使用很方便。</li><li><strong>操作一致</strong>：它的大多数操作，和标准库中 string 保持一致。</li></ul><h3 id="与标准库-string-对比"><a href="#与标准库-string-对比" class="headerlink" title="与标准库 string 对比"></a>与标准库 string 对比</h3><ul><li><strong>所有权</strong>：<code>StringRef</code> 是对字符串数据的引用，不拥有字符串的所有权。需要确保 <code>StringRef</code> 对象的生命周期，小于实际引用字符串的生命周期，否则会带来悬空引用。</li><li><strong>大小</strong>：<code>StringRef</code> 只占用很小的内存，和实际字符串相比可以忽略不计。<code>std::string</code> 不仅包括了指针、长度，还包括了数据的内存管理信息，它在内部维护了一个动态分配的缓存区来存储字符串内容。</li><li><strong>可变性</strong>：<code>StringRef</code> 是不可变的，它引用的内容不能被修改。而 <code>std::string</code> 则提供了完整的可操作空间。</li><li><strong>性能</strong>：<code>StringRef</code> 不涉及内存分配，在传递和使用时，具有更高的性能，特别是在函数传参时，可以避免深拷贝。而 <code>std::string</code> 在按值传参时，会对保存字符串的内存做完整的复制。现在编译器可以通过移动语义和短字符串优化等方式来减少深拷贝的性能开销，但整体上，传递引用还是要更轻量级。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>由于 <code>llvm::StringRef</code> 只拥有数据的引用，而不管理实际字符串的内存，所以它的结构很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>事实上，使用 <code>const std::string &amp;</code> 基本可以取代 <code>llvm::StringRef</code>，然而，<code>StringRef</code> 的另一个优势是，它提供了更多更易用的操作方法，比如 <code>split</code> 函数。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><code>StringRef</code> 可以方便地从字符串字面量、<code>std::string</code> 或 <code>char *</code> 指针来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串字面量初始化</span></span><br><span class="line">llvm::StringRef Str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串指针和长度来初始化</span></span><br><span class="line"><span class="type">char</span> *Cstr = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">llvm::StringRef Str2&#123;Cstr, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 std::string 来初始化</span></span><br><span class="line">std::string Sstr&#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">llvm::StringRef Str3&#123;Sstr&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供了迭代器 <code>begin()</code> 和 <code>end()</code>，以及返回字符指针的 <code>bytes_begin()</code> 和 <code>bytes_end()</code>，这是为了处理宽字符编码的字符串。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到字符串原始位置</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *Data = Str.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到字符串的长度</span></span><br><span class="line"><span class="type">bool</span> IsEmpty = Str.<span class="built_in">empty</span>();</span><br><span class="line"><span class="type">size_t</span> Length = Str.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> FirstChar = Str.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> LastChar = Str.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也支持任意的下标操作，越界用 assert 来检查</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> C = Str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str1, Str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否相等</span></span><br><span class="line"><span class="type">bool</span> IsEqual1 = Str<span class="number">1.</span><span class="built_in">equals</span>(Str2);</span><br><span class="line"><span class="type">bool</span> IsEqual2 = Str1 == Str2;</span><br><span class="line"><span class="type">bool</span> IsEqual3 = Str<span class="number">1.</span><span class="built_in">equals_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="comment">// 其他操作也有忽略大小写的版本，不再单独列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断大小，当结果小于、等于、大于时，值是 -1、0、1</span></span><br><span class="line"><span class="type">int</span> Cmp1 = Str<span class="number">1.</span><span class="built_in">compare</span>(Str2);</span><br><span class="line"><span class="type">int</span> Cmp2 = Str<span class="number">1.</span><span class="built_in">compare_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="type">int</span> Cmp3 = Str<span class="number">1.</span><span class="built_in">compare_numeric</span>(Str2);  <span class="comment">// 由数字字符组成的字符串，按数字来比较</span></span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>编辑距离（edit distance）是指将一个字符串完全改为另一个字符串时，所需要的最小单字符操作的次数。这些操作可以是： - 插入一个字符 - 删除一个字符 - 替换一个字符（分为将替换看作一次操作，还是看作两次操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str1, Str2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Distance1 = Str<span class="number">1.</span><span class="built_in">edit_distance</span>(Str2);</span><br><span class="line"><span class="type">int</span> Distance2 = Str<span class="number">1.</span><span class="built_in">edit_distance_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两个隐藏参数，第一个是替换被看作几次，默认是 1 次操作</span></span><br><span class="line"><span class="type">bool</span> AllowReplacements = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 第二个是最大编辑距离，如果编辑距离超过最大编辑距离，则返回最大编辑距离+1</span></span><br><span class="line"><span class="type">bool</span> MaxEditDistance = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Distance3 = Str<span class="number">1.</span><span class="built_in">edit_distance</span>(Str2, AllowReplacements, MaxEditDistance);</span><br></pre></td></tr></table></figure><h3 id="获取副本"><a href="#获取副本" class="headerlink" title="获取副本"></a>获取副本</h3><p>使用 <code>str()</code> 来获取一个 <code>std::string</code> 类型的副本。 使用 <code>string_view()</code> 来获取一个 <code>std::string_view</code> 类型的副本。 同时，也提供了 <code>copy</code> 函数，来获取一个 <code>StringRef</code> 的副本，但需要提供分配器，用于分配新的空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 包含 std::allocator</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/BumpPtrAllocator.h&quot;</span>  <span class="comment">// 包含 BumpPtrAllocator</span></span></span><br><span class="line"></span><br><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 C++ 的内存分配器</span></span><br><span class="line">std::allocator&lt;<span class="type">char</span>&gt; Alloc;</span><br><span class="line">llvm::StringRef NewStr1 = Str.<span class="built_in">copy</span>(ALloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 LLVM 的内存分配器</span></span><br><span class="line">llvm::BumpPtrAllocator BumpAlloc;</span><br><span class="line">llvm::StringRef NewStr2 = Str.<span class="built_in">copy</span>(BumpAlloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以自定义分配器，需要提供 Allocate&lt;&gt; 模板方法</span></span><br><span class="line"><span class="comment">// 使用时，需要确保分配器对象的生命周期超过 StringRef 对象，否则会带来引用失效问题</span></span><br></pre></td></tr></table></figure><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否开始于一个特定前缀字符</span></span><br><span class="line"><span class="type">bool</span> Ret1 = Str.<span class="built_in">starts_with</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="type">bool</span> Ret2 = Str.<span class="built_in">startswith</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否结束于一个特定后缀字符</span></span><br><span class="line"><span class="type">bool</span> Ret3 = Str.<span class="built_in">ends_with</span>(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"><span class="type">bool</span> Ret4 = Str.<span class="built_in">endswith</span>(<span class="string">&#x27;z&#x27;</span>);  <span class="comment">// 语法糖</span></span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规查找，返回下标位置，内部调用了 std::string_view::find()，当找不到时，返回 StringRef::npos，其值是 ~size_t(0)</span></span><br><span class="line"><span class="type">size_t</span> Ret1 = Str.<span class="built_in">find</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="comment">// 第二个隐藏参数是从什么位置开始查，默认是从 0（字符串开头）开始查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定查找条件</span></span><br><span class="line"><span class="type">size_t</span> Ret2 = Str.<span class="built_in">find_if</span>([](<span class="type">char</span> c) &#123; <span class="keyword">return</span> c &gt; <span class="string">&#x27;r&#x27;</span> &amp;&amp; c &lt; <span class="string">&#x27;x&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// 还有取反的 find_if_not</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向查找</span></span><br><span class="line"><span class="type">size_t</span> Ret3 = Str.<span class="built_in">rfind</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找是否包含特定字符</span></span><br><span class="line"><span class="type">bool</span> IsContain = Str.<span class="built_in">contains</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="comment">// 查找是否包含特定子串</span></span><br><span class="line">llvm::StringRef SubStr;</span><br><span class="line"><span class="type">bool</span> IsContainsSubStr = Str.<span class="built_in">contains</span>(SubStr);</span><br></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数特定字符出现的次数</span></span><br><span class="line"><span class="type">size_t</span> Cnt = Str.<span class="built_in">count</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将由数字字符组成的字符串，转换为整型，第一个参数是选择进制，置为 0 表示按 C 整形规则自动选择进制。若转换失败，会返回 true。</span></span><br><span class="line"><span class="type">int</span> Res;</span><br><span class="line">Str.<span class="built_in">getAsInteger</span>(<span class="number">0</span>, Res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 getAsInteger 类似，但会剔除开头的数字部分，如果开头不是数字，返回 true 表示失败。</span></span><br><span class="line"><span class="comment">// 实际上，是修改了指针位置，并没有改变字符串</span></span><br><span class="line">Str.<span class="built_in">consumeInteger</span>(<span class="number">0</span>, Res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串按大小写转换，并返回 std::string 类型</span></span><br><span class="line">std::string LowerStr = Str.<span class="built_in">lower</span>();</span><br><span class="line">std::string UpperStr = Str.<span class="built_in">upper</span>();</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取子字符串的操作，实际上是修改指针指向位置和长度的结果</span></span><br><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line">llvm::StringRef SubStr1 = Str.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 截取从 2 下标开始，长度为 3 的子串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前 N 个字符的子串</span></span><br><span class="line">llvm::StringRef SubStr2 = Str.<span class="built_in">take_front</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 删除前 N 个字符，返回剩余字符的子串，是 drop_front</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回后 N 个字符的子串</span></span><br><span class="line">llvm::StringRef SubStr3 = Str.<span class="built_in">take_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 同理，返回剩余字符的子串，是 drop_back</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果以给定前缀开头，删除该前缀，返回剩余字符子串</span></span><br><span class="line">Str.<span class="built_in">consume_front</span>(<span class="string">&quot;prefix&quot;</span>);  <span class="comment">// 在原始引用上操作</span></span><br><span class="line"><span class="comment">// 同理，还有给定后缀的 consume_back()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取任意子串</span></span><br><span class="line">llvm::StringRef SubStr4 = Str.<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 截取从 1 下标到 3 下标的子串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split 操作，即按给定字符来分割子串</span></span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair1 = Str.<span class="built_in">split</span>(<span class="string">&#x27;:&#x27;</span>);  <span class="comment">// 分成两个子串</span></span><br><span class="line">llvm::StringRef SeparatorStr = <span class="string">&quot;::&quot;</span>;</span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair2 = Str.<span class="built_in">split</span>(SeparatorStr);  <span class="comment">// 使用给定子字符串分隔子串</span></span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair3 = Str.<span class="built_in">rsplit</span>(SeparatorStr);  <span class="comment">// 从末尾开始搜索分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split 操作，所有都分隔</span></span><br><span class="line">llvm::SmallVector&lt;llvm::StringRef&gt; SplitStrs;</span><br><span class="line">Str.<span class="built_in">split</span>(SplitStrs, <span class="string">&quot;::&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// trim 操作</span></span><br><span class="line">llvm::StringRef TrimStr1 = Str.<span class="built_in">ltrim</span>(<span class="string">&#x27;\0&#x27;</span>);  <span class="comment">// 切掉左侧连续多个 &#x27;\0&#x27; 字符</span></span><br><span class="line">llvm::StringRef TrimStr2 = Str.<span class="built_in">ltrim</span>();  <span class="comment">// 切掉左侧连续多个空白字符</span></span><br><span class="line"><span class="comment">// 对应还有右侧版 rtrim 和 两侧版 trim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否包含 EOL 字符，EOL 字符是 end of line 标记</span></span><br><span class="line"><span class="type">bool</span> HasEOLStr = Str.<span class="built_in">detactEOL</span>();</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="引用失效"><a href="#引用失效" class="headerlink" title="引用失效"></a>引用失效</h3><p>和 <code>llvm::ArrayRef</code> 一样，<code>llvm::StringRef</code> 本身是一个引用类型，所以它会存在引用失效的风险。 另外，也不建议直接返回一个内部临时对象引用的 <code>llvm::StringRef</code> 类型，可以返回经过调整，但指向外部字符串的新的 <code>llvm::StirngRef</code> 类型。 它的生命周期一定要短于它所引用的字符串的生命周期，从而避免悬挂引用。</p><h3 id="不可修改"><a href="#不可修改" class="headerlink" title="不可修改"></a>不可修改</h3><p>它是对目标字符串的常量引用，所以不可以直接通过它修改目标字符串。不过，可以通过 <code>data</code> 来获取到它原始字符串的指针，从而去修改原始字符串，但这样存在一些潜在的风险，并不是推荐的做法。如果需要修改字符串，使用 <code>std::string &amp;</code> 可能更好。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p><code>llvm::StringRef</code> 并不处理字符编码问题，它能提供的最大能力就是使用迭代器时，可以选择按字符迭代，还是获得底层的字符指针，由开发者自己选择怎么解析。 所以，如果需要处理宽字符编码的字符串，需要额外做一些包装。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>llvm::StringLiteral</code>：处理字符串字面量的子类，高效管理字符串字面量。</li><li><code>llvm::ArrayRef</code>：顺序型容器的只读引用，见 <a href="https://p2tree.top/posts/cdf6959f.html">学习 LLVM 数据结构：ArrayRef</a>。</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/32410920552">学习LLVM数据结构-StringRef - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：SmallVector</title>
    <link href="https://p2tree.top/posts/e9ae65d7.html"/>
    <id>https://p2tree.top/posts/e9ae65d7.html</id>
    <published>2025-03-09T21:21:34.000Z</published>
    <updated>2025-09-19T15:03:39.968Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::SmallVector</code> 定义在 <code>llvm/ADT/SmallVector.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N = CalculateSmallVectorDefaultInlinedElements&lt;T&gt;::value&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVector;</span><br></pre></td></tr></table></figure><p><code>llvm::SmallVector</code> 是一个可变长数组，类似于 <code>std::vector</code>，同时它对较小长度的数组做了优化。<br>它的内存管理方式采用局部缓存的设计思路，在对象内部预留一小块空间，用于存储数据。当数据量超出预留空间的大小时，才会将数据放在堆上。它本身保存一部分元素，这便使得在小数组中，避免进行堆分配的操作，提高了效率。<br>注意到，它带有一个含默认值的模板参数 <code>N</code>，它用来指定预留空间的大小，默认不指定时，编译器会自动选择一个合理的阈值（通常考虑依据是栈空间的占用情况）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>顺序容器</strong>：<code>SmallVector</code> 是一个顺序容器，可以在末尾添加和删除元素，可以通过下标访问任意元素。</li><li><strong>小长度数组优化</strong>：它结合了定长数组在栈上快速分配和动态数组在堆上的灵活性，当管理的数据长度小于阈值（默认值或声明时给定值），会将数据保存在栈上，从而避免堆分配和内存管理带来的性能开销。</li><li><strong>操作一致</strong>：它的大多数操作，和 STL vector 保持一致。</li></ul><h3 id="与标准库-vector-的对比"><a href="#与标准库-vector-的对比" class="headerlink" title="与标准库 vector 的对比"></a>与标准库 vector 的对比</h3><ul><li><strong>性能优势</strong>：在数据量较小时，由于不会涉及到堆内存分配和管理的开销，性能会优于 <code>std::vector</code>。另外，它可以识别平凡可复制的特性，从而更细粒度地做内存管理。</li><li><strong>退化时的性能损失</strong>：当发生从栈到堆的退化时，<code>llvm::SmallVector</code> 会带来数据拷贝的开销。所以需要仔细考虑阈值的设定。</li><li><strong>可能浪费空间</strong>：<code>llvm::SmallVector</code> 会在定义时预分配设定的 <code>N</code> 的空间，如果实际数据少于 <code>N</code>，那么会存在空间浪费的问题。<code>std::vector</code> 也存在类似问题。</li></ul><h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p>简单的继承结构如：</p><p><img src="https://img.p2tree.top/2025/3/9/SmallVector-Derive-Structure.webp" alt="继承结构图"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVector</span> : <span class="keyword">public</span> SmallVectorImpl&lt;T&gt;, SmallVectorStorage&lt;T, N&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只用于管理一块内置数组 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorStorage</span> &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了大多数操作方法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorImpl</span> : <span class="keyword">public</span> SmallVectorTemplateBase&lt;T&gt; &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// SmallVectorTemplateBase 有两种模板类，分别针对类型是否时 POD 做实现 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> = (is_trivially_copy_constructible&lt;T&gt;::value) &amp;&amp; </span><br><span class="line">                             (is_trivially_move_constructible&lt;T&gt;::value) &amp;&amp; </span><br><span class="line">                             std::is_trivially_destructible&lt;T&gt;::value&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVectorTemplateBase : <span class="keyword">public</span> SmallVectorTemplateCommon&lt;T&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorTemplateBase</span>&lt;T, <span class="literal">true</span>&gt; : <span class="keyword">public</span> SmallVectorTemplateCommon&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不涉及 POD 的部分 </span></span><br><span class="line"><span class="comment">// 第二个模板参数是一个 dummy 参数，只用来解决当 ArrayRef 作为类型时，避免空长度时无法实例化的问题 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVectorTemplateCommon : <span class="keyword">public</span> SmallVectorBase&lt;SmallVectorSizeType&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最基础的类，管理几个数据成员，Size_T 是对类型 size 的推导 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Size_T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorBase</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>SmallVector</code> 继承自 <code>SmallVectorImpl</code> 和 <code>SmallVectorStorage</code>，其中 <code>SmallVectorImpl</code> 实现了大多数通用的操作代码和管理长度等属性的数据成员。它继承的 <code>SmallVectorTemplateBase</code>、<code>SmallVectorTemplateCommon</code> 和 <code>SmallVectorBase</code> 都是用来就完成模板实例化时的公共代码，这里先按下不表。<br><code>SmallVectorStorage</code> 实现了堆内联存储的静态数组的分配和管理，它是一个 POD 类型，只含有数据。这也有利于编译器为特定长度的数组做专门的优化。<br>通过这种分离，<code>SmallVectorImpl</code> 可以用于不同模板类的复用，而 <code>SmallVectorStorage</code> 又可以方便的做模板特化（不同的 <code>N</code>）。这样，减少了模板实例化时的实例化数量，降低了编译空间占用，提高编译效率，是一种在很多 C++ 工程中普遍用到的实现技巧。</p><p>我们再回头看 <code>SmallVectorImpl</code> 的继承结构，它的父类中，<code>SmallVectorBase</code> 作为最底层的类，提供了最基本的功能，包括类型的数据，比如 size 和 capacity，一些辅助函数和虚函数定义。它作为整个继承体系的根，定义了所有 <code>SmallVector</code> 最通用的接口和行为。<br><code>SmallVectorTemplateCommon&lt;T, void&gt;</code> 抽取了 <code>SmallVectorTemplateBase</code> 的实现，它实现了不依赖于 T 是否是 POD 类型的代码。而与 POD 类型相关的代码实现，放在了 <code>SmallVectorTemplateBase</code> 中。<br><code>SmallVectorTemplateBase</code> 针对的就是非平凡的类型，根据是否可复制、可移动，又实例化了不同的模板类。它在正确性和性能之间达成平衡，在避免错误的同时，为大多数非平凡类型提供在元素操作上的最优性能。</p><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>忽略多层级的继承结构，整个 <code>SmallVector</code> 中包含几个主要的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorBase</span> &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">  <span class="comment">// 指向向量中第一个元素的指针 </span></span><br><span class="line">  <span class="type">void</span> *BeginX; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向量内存空间的总长度   </span></span><br><span class="line">  <span class="type">size_t</span> Size; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预分配的空间大小   </span></span><br><span class="line">  <span class="type">size_t</span> Capacity; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这 3 个成员决定了索引数据和判断优化阈值。<br>另外，对于小长度数组，还需要分配内置的存储空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallVectorStorage</span> &#123; </span><br><span class="line">  <span class="built_in">alignas</span>(T) <span class="type">char</span> InlineElts[<span class="function">N * <span class="title">sizeof</span><span class="params">(T)</span>]</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列了部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/SmallVector.h</code> 文件代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的容器，inline storage 大小为 4 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec1; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数值和长度 </span></span><br><span class="line"><span class="function">llvm::SmallVector&lt;<span class="type">int</span>, 4&gt; <span class="title">vec2</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 包含 3 个值为 10 的元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec3 = vec2; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 vector 中构造 </span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; stdVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; </span><br><span class="line"><span class="function">llvm::SmallVector&lt;<span class="type">int</span>, 4&gt; <span class="title">vec4</span><span class="params">(stdVec.begin(), stdVec.end())</span></span>;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>和 <code>std::vector</code> 一样，也提供了前向迭代器和反向迭代器，以及对应带 const 的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向迭代器 </span></span><br><span class="line"><span class="keyword">for</span> (llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 前向迭代器 </span></span><br><span class="line"><span class="keyword">for</span> (llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); it != vec.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 range for loop </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ele : vec) &#123;</span><br><span class="line">  std::cout &lt;&lt; ele &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持下标进行随机访问 </span></span><br><span class="line">std::cout &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl; vec[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法，内部会做越界检查 </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  std::cout &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl; </span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range &amp;e) &#123; </span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>支持常见的几种比较运算符，其中，大于、小于操作的比较逻辑采用通用的序列比较算法，在序列长度相同时，比较对应元素的大小或字典序。</p><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><p>基础元素操作与 <code>std::vector</code> 相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 末尾添加元素 </span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除末尾元素 </span></span><br><span class="line">vec.<span class="built_in">pop_back</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入元素，需要元素移动，所以性能可能较差 </span></span><br><span class="line">vec.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// it 是一个有效的迭代器 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出指定位置元素，同样可能有性能问题 </span></span><br><span class="line">vec.<span class="built_in">erase</span>(it); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有元素 </span></span><br><span class="line">vec.<span class="built_in">clear</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回向量中元素的数量 </span></span><br><span class="line">vec.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回向量中的容量，也就是 Capacity 的值 </span></span><br><span class="line">vec.<span class="built_in">capacity</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为空 </span></span><br><span class="line">vec.<span class="built_in">empty</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变向量大小 </span></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">// 调整为 5 个元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留指定容量的内存 </span></span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>使用 <code>llvm::SmallVector</code> 容器，需要引入 <code>Support</code> 组件，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LLVM_LINK_COMPONENTS Support)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不保证异常安全"><a href="#不保证异常安全" class="headerlink" title="不保证异常安全"></a>不保证异常安全</h3><p><code>SmallVector</code> 本身并不是异常安全的。这一点和 <code>std::vector</code> 不同，标准库容器能保证异常安全性。</p><h3 id="不合适的预分配大小"><a href="#不合适的预分配大小" class="headerlink" title="不合适的预分配大小"></a>不合适的预分配大小</h3><p>如果在定义 <code>SmallVector</code> 时，指定栈上预分配容量 <code>N</code> 非常大，可能会导致栈溢出，需要根据实际情况选择合适的 <code>N</code> ，避免栈溢出。<br>如果预分配容量 <code>N</code> 不合理，导致使用容器对象时，总是会发生退化到堆的问题，那么重复的数据拷贝，也会带来性能问题。</p><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>和其他顺序容器类型一样，使用迭代器时，插入和删除操作可能会导致迭代器失效。尤其是还需要考虑因为插入元素导致 <code>SmallVector</code> 重新分配内存（栈到堆的退化和堆到堆的重新分配），迭代器都会失效。<br>resize 操作也会导致迭代器失效。</p><h3 id="自定义类型的内存管理"><a href="#自定义类型的内存管理" class="headerlink" title="自定义类型的内存管理"></a>自定义类型的内存管理</h3><p>如果 <code>SmallVector</code> 存储的是自定义类型，那么需要确保自定义类型有着正确的构造、移动和拷贝操作，不正确的实现会导致内存泄漏等问题。<br>如果自定义类型是引用类型，那么使用 <code>SmallVector</code> 管理时，需要确保自定义类型的析构函数中，能够正确释放内存。如果 <code>SmallVector</code> 管理的是指针，还需要自定义析构器来处理指针指向的内存。</p><h3 id="使用-SmallVectorImpl-作为参数类型"><a href="#使用-SmallVectorImpl-作为参数类型" class="headerlink" title="使用 SmallVectorImpl 作为参数类型"></a>使用 <code>SmallVectorImpl</code> 作为参数类型</h3><p>如果需要传递一个 <code>SmallVector</code> 的容器对象时，形参参数建议使用 <code>SmallVectorImpl</code>，后者没有带有 <code>SmallVectorStorage</code>，所以不会实际分配空间，同时也不需要声明函数时指定 <code>N</code> 值，这无论从效率角度看，还是使用便利性，都非常有价值。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种声明需要指定 N </span></span><br><span class="line"><span class="built_in">funcWithVec</span>(llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; &amp;Arg); </span><br><span class="line"><span class="comment">// 而这种声明不需要指定 N</span></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(llvm::SmallVectorImpl&lt;<span class="type">int</span>&gt; &amp;Arg);  </span><br><span class="line"></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec1; </span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">8</span>&gt; vec2; </span><br><span class="line"></span><br><span class="line"><span class="built_in">funcWithVec</span>(vec1); <span class="comment">// 正常  </span></span><br><span class="line"><span class="built_in">funcWithVec</span>(vec2); <span class="comment">// 编译报错 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(vec1); <span class="comment">// 正常 </span></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(vec2); <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="不适合用于存储大量元素"><a href="#不适合用于存储大量元素" class="headerlink" title="不适合用于存储大量元素"></a>不适合用于存储大量元素</h3><p>虽然 <code>SmallVector</code> 可以在堆上动态分配内存，但它的设计关注点还是在管理小数据量的动态数组。如果已知数量比较大的动态数组，使用 <code>std::vector</code> 即可。<br>同理，也不适合管理单个元素内存较大的数据类型。</p><h3 id="拷贝成本"><a href="#拷贝成本" class="headerlink" title="拷贝成本"></a>拷贝成本</h3><p>使用 <code>SmallVector</code> 需要多留意它可能发生从内部存储到堆上退化时的性能问题。尤其是元素类型本身的拷贝开销比较大时，一个合适的 <code>N</code> 就显得尤为重要。<br>请保证你的设计中，大多数情况下，都不会发生这种拷贝。</p><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>添加和删除元素会带来性能开销，一方面是为了保证顺序性，操作位置之后的元素需要移动位置；另一方面，如果发生向堆的退化或堆内存的重新分配，也会带来性能问题。<br>尽量使用 <code>emplace_back</code> 代替 <code>push_back</code>，以避免不必要的拷贝或移动操作，提高性能。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><p>无。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[LLVM Programmers Manual](<a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h">LLVM Programmer’s Manual — LLVM 21.0.0git documentation</a>)</li><li>[cppreference vector](<a href="https://en.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a>)</li><li>[CHUNer：LLVM 数据结构 - 2.1: llvm::SmallVector 简述 &amp; llvm::SmallVectorBase 类源码详细解析](<a href="https://zhuanlan.zhihu.com/p/16425169155">LLVM 数据结构 - 2.1: llvm::SmallVector 简述 &amp; llvm::SmallVectorBase 类源码详细解析 - 知乎</a>)</li><li><a href="%5B%E7%BC%96%E8%AF%91%E5%99%A8(llvm">CompilerCoder：编译器(llvm)中的数据结构与设计模式</a>中的数据结构与设计模式 - 知乎](<a href="https://zhuanlan.zhihu.com/p/418357950">https://zhuanlan.zhihu.com/p/418357950</a>))</li><li>LLVM 16.0 源码</li><li>LLVM 20.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/28641819827">学习LLVM数据结构-SmallVector - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Chapter.404</title>
    <link href="https://p2tree.top/posts/b2054f60.html"/>
    <id>https://p2tree.top/posts/b2054f60.html</id>
    <published>2025-03-06T23:50:54.000Z</published>
    <updated>2025-09-19T15:03:39.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不要害怕问出愚蠢的问题，因为在大多数情况下，其他人都在思考同样的问题，只是他们不好意思问出口。<br>越早搞懂看起来幼稚问题，就越不会在未来更难以启齿时提出同样的问题。</p><p><img src="https://img.p2tree.top/2025/3/6/Chapter.404.webp" alt="Chapter.404"></p><hr><div class="note primary flat"><p>封面图片来自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/-RobsXstoStQB0ZGpk6qJQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="心理" scheme="https://p2tree.top/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：ArrayRef</title>
    <link href="https://p2tree.top/posts/cdf6959f.html"/>
    <id>https://p2tree.top/posts/cdf6959f.html</id>
    <published>2025-02-25T21:35:21.000Z</published>
    <updated>2025-09-19T15:03:39.968Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。  </p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li><li><a href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::ArrayRef</code> 定义在 <code>llvm/ADT/ArrayRef.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">ArrayRef</span>;</span><br></pre></td></tr></table></figure><p><code>llvm::ArrayRef</code> 是一个轻量级的只读容器，主要用于引用一段连续的内存区域。<br>它的设计目标是提供高效的数据访问，而不需要拥有底层数据的所有权。这使得 <code>ArrayRef</code> 特别适合在函数参数中实用，从而避免了不必要的内存拷贝。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>只读</strong>：<code>ArrayRef</code> 不能修改其引用的数据，也不能添加新元素（另一个容器 <code>MutableArrayRef</code> 可以修改）。</li><li><strong>轻量级</strong>：它只存储一个指向数据的指针和数据的长度，而不存储实际的数据，所以拷贝时非常高效。</li><li><strong>按值传递</strong>：在传递 <code>ArrayRef</code> 时，实际上传递的是一个指针和其指向数据的长度，所以不需要再对其按引用传递。</li><li><strong>操作一致</strong>：它的大多数操作，与 STL array 保持一致。</li></ul><h3 id="与标准库-array-对比"><a href="#与标准库-array-对比" class="headerlink" title="与标准库 array 对比"></a>与标准库 array 对比</h3><ul><li><strong>所有权</strong>：<code>llvm::ArrayRef</code> 不拥有其引用数据的所有权，只是对数据的引用；<code>std::array</code> 拥有数据的所有权，存储在栈上。</li><li><strong>大小</strong>：<code>llvm::ArrayRef</code> 容量是动态的，可以引用任意长度的数组。但由于数组长度是静态的，所以从程序角度看，<code>ArrayRef</code> 的具体引用类型，容量是确定的；<code>std::array</code> 大小在编译期间固定，和 C 数组一样。</li><li><strong>可变性</strong>：<code>llvm::ArrayRef</code> 是只读的，不能修改引用数据；<code>std::array</code> 允许修改其元素，提供完整的读写权限。</li><li><strong>初始化</strong>：<code>llvm::ArrayRef</code> 的初始化更灵活，可以从 C 数组、<code>std::array</code>，<code>std::vector</code> 或其他顺序容器初始化。<code>std::array</code> 只能从初始化列表或在定义时使用构造函数初始化。</li><li><strong>性能</strong>：<code>llvm::ArrayRef</code> 适合在高频传递参数时使用。<code>std::array</code> 默认按值拷贝，会带来开销，需要指定其引用类型作为参数类型。如果是 constexpr 修饰，编译器可以优化传参性能。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>由于<code>llvm::ArrayRef</code> 只拥有数据的引用，而不管理实际存储的空间，所以它实际上只是一个带有长度的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> T* data = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列了部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/ArrayRef.h</code> 文件代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个元素长度 </span></span><br><span class="line"><span class="type">int</span> A1 = <span class="number">1</span>; llvm::ArrayRef Arr1&#123;A1&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化指向一块数据首地址和数据长度 </span></span><br><span class="line"><span class="type">int</span> Ap[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; llvm::ArrayRef Arr2&#123;Ap&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个指针作为区间来初始化 </span></span><br><span class="line"><span class="type">int</span> *Ap2 = Ap + <span class="number">2</span>; llvm::ArrayRef Arr3&#123;Ap, Ap2&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 SmallVector 容器来构造 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>&gt; Vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr4&#123;Vec&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 std::vector 容器来构造 </span></span><br><span class="line">std::vector STLVec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr5&#123;Vec&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 std::array 容器来构造 </span></span><br><span class="line">std::array STLArr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr6&#123;STLArr&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表来构造 </span></span><br><span class="line">llvm::ArrayRef Arr8&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供了迭代器 <code>begin()</code> 和 <code>end()</code> ，以及反向迭代器 <code>rbegin()</code> 和 <code>rend()</code> 。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数据原始位置的操作 </span></span><br><span class="line"><span class="type">const</span> T *data = Arr.<span class="built_in">data</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数据长度的操作 </span></span><br><span class="line"><span class="type">bool</span> IsEmpty = Arr.<span class="built_in">empty</span>(); </span><br><span class="line"><span class="type">size_t</span> Length = Arr.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素 </span></span><br><span class="line"><span class="type">const</span> T&amp; FirstEle = Arr.<span class="built_in">front</span>(); </span><br><span class="line"><span class="type">const</span> T&amp; LastEle = Arr.<span class="built_in">back</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标索引 </span></span><br><span class="line"><span class="type">const</span> T&amp; Ele = Arr[I]; <span class="comment">// assert 检查是否越界</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>提供了 <code>equals(ArrayRef RHS)</code> 方法。<br>另一个语法糖是 <code>operator==</code> 运算符。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取从下标 1 的元素到末尾，作为新的 ArrayRef 返回 </span></span><br><span class="line">llvm::ArrayRef NewArr = Arr.<span class="built_in">slice</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取两端元素 </span></span><br><span class="line">llvm::ArrayRef NewArr2 = Arr.<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪切前/后部分元素，剩余数组作为新的 ArrayRef 返回 </span></span><br><span class="line">llvm::ArrayRef NewArr3 = Arr.<span class="built_in">drop_front</span>(<span class="number">2</span>); </span><br><span class="line">llvm::ArrayRef NewArr4 = Arr.<span class="built_in">drop_back</span>(); <span class="comment">// 默认是 1 个元素</span></span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>使用 <code>llvm::ArrayRef</code> 容器，需要引入 <code>Support</code> 组件，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LLVM_LINK_COMPONENTS Support)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="引用失效"><a href="#引用失效" class="headerlink" title="引用失效"></a>引用失效</h3><p>由于 <code>llvm::ArrayRef</code> 本身是一个引用类型，所以它会面临引用类型作为函数参数时，可能出现的引用失效问题。<br>同理，函数的返回类型不应该是 <code>llvm::ArrayRef</code>，如果返回的是函数局部对象，那么在 Caller 端，该对象引用的原始数据已失效；如果返回的是函数原始参数，这么做又没有意义。<br>另外，如果其引用的是一个动态数组，比如 <code>std::vector</code>，那么当动态数组扩容后，<code>llvm::ArrayRef</code> 引用可能会失效。<br>所以在使用它时，需要时刻思考它的引用对象，什么时候结束生命周期。</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><p><code>llvm::ArrayRef</code> 本身的访问不可能越界，但如果它引用的是一个动态数组，而动态数组的长度发生变化（缩小），那么 <code>ArrayRef</code> 的元素访问可能会发生越界问题。<br>这本质上也是引用失效问题。所以，最好的实践是只引用固定数组，比如用它代替 <code>const std::array &amp;</code> 类型。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>将 <code>llvm::ArrayRef</code> 转换为 <code>std::vector</code> 类型是不建议的操作，它会带来性能开销。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector Vec = Arr.<span class="built_in">vec</span>();</span><br></pre></td></tr></table></figure><p>这里实际上发生了一次数据拷贝。如果希望去修改原始数据，那么传递原始数据的可变引用是更好的做法。当然，也可以使用 <code>llvm::MutableArrayRef</code>，它是可变引用版本的 <code>llvm::ArrayRef</code>。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>llvm::MutableArrayRef</code>：可变版本的 <code>llvm::ArrayRef</code>。</li><li><code>llvm::OwningArrayRef</code>：拥有原始数据的 <code>llvm::MutableArrayRef</code>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[LLVM Programmers Manual](<a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-arrayref-h">LLVM Programmer’s Manual — LLVM 21.0.0git documentation</a>)</li><li>LLVM 16.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/26306452997">学习LLVM数据结构-ArrayRef - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>2025 新的开始</title>
    <link href="https://p2tree.top/posts/e343d97c.html"/>
    <id>https://p2tree.top/posts/e343d97c.html</id>
    <published>2025-02-11T23:00:09.000Z</published>
    <updated>2025-09-19T15:03:39.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你的每一次成功，都是将来更棘手问题的入场券。</p><hr><p><img src="https://img.p2tree.top/2025/2/11/Chapter.198.webp" alt="Chapter.198"></p><hr><div class="note primary flat"><p>封面图片生成自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/HUgkQXf7_MQTINwXuNgOEQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>你会为宝宝存储脐带血吗</title>
    <link href="https://p2tree.top/posts/dd8f25a6.html"/>
    <id>https://p2tree.top/posts/dd8f25a6.html</id>
    <published>2024-12-30T20:02:18.000Z</published>
    <updated>2025-09-19T15:03:39.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1️⃣ 什么是脐带血？<br>孩子出生时，可以从脐带中收集干细胞。干细胞在胎儿和新生儿血液中含量丰富。<br>2️⃣ 为什么收集存储脐带血？<br>脐带血可以为宝宝将来可能发生严重疾病时，用于提供完全匹配的干细胞，不会受到排斥。<br>3️⃣ 有什么坏处？<br>唯一的坏处可能是影响你的存款。<br>存储脐带血是需要初期付费以及之后持续付费的，通常不是很便宜。<br>所以，是否要为宝宝将来可能发生的疾病，而付出这笔费用，是个值得考虑的问题。<br>4️⃣ 有什么建议？<br>是否为宝宝存储脐带血，无所谓对错。疾病发生的概率很低，据统计存储了脐带血最后用到的概率也不高。<br>它就是一份保险，有它很好，但没有人希望会用到它。<br>你只需要考虑你的钱包👛。</p><hr><div class="note info simple"><p>封面图片来自豆包 AI。</p><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s/G1awN8y5AHQStLX8tSQdLQ?token=1029209527&lang=zh_CN">目的地</a> ，欢迎关注</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="育儿" scheme="https://p2tree.top/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Code Review Guide</title>
    <link href="https://p2tree.top/posts/829bc9e8.html"/>
    <id>https://p2tree.top/posts/829bc9e8.html</id>
    <published>2024-12-20T21:37:05.000Z</published>
    <updated>2025-09-19T15:03:39.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章是我曾经用于公司内部组织和培训的材料，做脱敏后分享给大家。有关于“是否要做 Code Review”相关的问题，不是本文讨论的重点。</p><p>本文的主要读者是那些需要扮演 Code reviewer 的人，即需要 review 别人代码的人，以提供建议、指导和要求来如何开展 Code review 的工作。</p><p>最后一节是写给 code reporter，比如 PR&#x2F;MR 的 owner。</p><p>下文中以 MR 指代提请 merge 的 code patch 请求。</p><hr><h2 id="1-Principle"><a href="#1-Principle" class="headerlink" title="1 Principle"></a>1 Principle</h2><ul><li>目标：Code review 的主要目的是确保逐步改善代码库的整体质量和健康度。</li><li>负责制：Reviewer 应该对被 review 的 MR 负责。这不一定要规范到流程中，但 reviewer 自身应当有这个意识。</li><li>时效性：Reviewer 应该有责任保障 MR 在 review ready 后，到 MR merge 要足够快速，从而避免延期。</li><li>避免过分严格：Reviewer 应当倾向于批准 MR 通过，只要 MR 能够在某些方面改进代码库的质量，并且代码是有意义的。而不是一味追求代码完美。</li><li>评论：MR 合入前，应当确保已解决所有 review 阶段提出的 comments。Comment 可以拒绝（备注原因并达成一致），但不可以忽略。</li><li>指导性：Code review 对于交流代码实践、设计原则和加深项目理解有益。Comments 可以是指导性的（不要求修改），但请注明 Nit。</li><li>避免个人偏好：基于技术事实讨论，而不是基于主观感受。</li><li>尊重非标准风格：如果 MR 中存在 Coding Style 中没有约束的设计，可以参考代码库现有的类似风格。但不应当强加 reviewer 的主观建议。</li><li>避免冲突：developer 和 reviewer 有冲突时，建议另行讨论，但需要将达成一致的结果记录在 MR 中。可能要有项目 owner 的参与，但要避免 MR 延期。</li><li>用户：Code review 过程中提到的用户，既包括软件的最终用户，也包括其他在相同代码库中进行开发工作的 developer。</li><li>积极的反馈：Reviewer 应当积极响应 review 请求，并给予正向的反馈，以互相激励良好的 Code review 流程。</li></ul><h2 id="2-Review-Point"><a href="#2-Review-Point" class="headerlink" title="2 Review Point"></a>2 Review Point</h2><h3 id="2-1-设计"><a href="#2-1-设计" class="headerlink" title="2.1 设计"></a>2.1 设计</h3><ul><li>代码是否经过精心设计并适合软件系统？</li><li>集成方式是否正确？</li><li>现在合入这个功能是否是正确的时间？</li></ul><h3 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2 功能"></a>2.2 功能</h3><ul><li>代码的行为是否和意图一致？</li><li>实现是否可以匹配需求？</li><li>接口变更（如库函数、外部类）通知到相关人员了吗？变更是否合理？</li><li>是否会引入随机问题？如并行导致的竞争，随机数测试等</li><li>对于无法理解的代码，可以要求 developer 澄清。对于 reviewer 来说，不能快速理解代码是正常的。澄清也会帮助所有 reviewer</li></ul><h3 id="2-3-复杂度"><a href="#2-3-复杂度" class="headerlink" title="2.3 复杂度"></a>2.3 复杂度</h3><ul><li>代码可以调整成更简单的实现吗？</li><li>其他开发人员能否轻松理解并使用这块代码？</li><li>MR 是否可以拆分？不相关的功能避免在一个 MR 中</li><li>绝大多数情况，1 个 MR 只包括 1 个 commit</li></ul><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><ul><li>代码是否带有正确、合理且有用的测试用例？</li><li>紧急情况可以省略测试用例，但之后应当提交专门的测试 MR 补充</li><li>代码仓已有的测试用例需要维护，修改测试用例应当有确切的原因</li></ul><h3 id="2-5-命名"><a href="#2-5-命名" class="headerlink" title="2.5 命名"></a>2.5 命名</h3><ul><li>代码中的变量、类、方法是否有符合项目风格的命名规范？</li><li>名称是否清晰有意义？</li><li>名称是否难以阅读，或和其他名词有歧义？</li></ul><h3 id="2-6-注释"><a href="#2-6-注释" class="headerlink" title="2.6 注释"></a>2.6 注释</h3><ul><li>是否没有必要注释，或是否滥用注释？</li><li>注释是否冗余？是否有错误？（注释需要维护）</li><li>注释不应该用于解释代码的逻辑（代码应该可以自解释）。有些例外，比如正则表达式和复杂算法</li><li>代码的背景、决策思路应当用注释说明</li><li>标记注释很有用，比如 TODO，BUG，FIXME，ISSUE，HACK，WARN，NOTE</li><li>对外的接口函数和接口类，库的头文件，应当有必要的注释说明用法和行为</li></ul><h3 id="2-7-风格"><a href="#2-7-风格" class="headerlink" title="2.7 风格"></a>2.7 风格</h3><ul><li>代码是否满足项目规定的代码风格？</li><li>功能性 MR 不要混合对不相关代码的风格变更。风格变更应另提 MR</li></ul><h3 id="2-8-文档"><a href="#2-8-文档" class="headerlink" title="2.8 文档"></a>2.8 文档</h3><ul><li>代码实现是否需要补充新的设计文档和测试文档？</li><li>是否需要修改现有文档？包括删除已经过时的错误文档</li></ul><h3 id="2-9-上下文"><a href="#2-9-上下文" class="headerlink" title="2.9 上下文"></a>2.9 上下文</h3><ul><li>不要只关注修改的代码，也要关注修改代码的上下文，以提出改善性建议。</li><li>不要容忍微小的破坏系统健康度的 MR，任何系统都是由小的坏的变更而逐渐变差。</li></ul><h3 id="2-10-好的设计"><a href="#2-10-好的设计" class="headerlink" title="2.10 好的设计"></a>2.10 好的设计</h3><ul><li>除了查找 MR 中的问题以外，也要留意其中好的设计</li><li>提交 comments 反馈给 developer，鼓励良好的实践，也促进互相学习</li></ul><h2 id="3-Review-Step"><a href="#3-Review-Step" class="headerlink" title="3 Review Step"></a>3 Review Step</h2><p>刚开始尝试 review 的 new reviewer，可以参考这个 review step。</p><h3 id="3-1-全面了解"><a href="#3-1-全面了解" class="headerlink" title="3.1 全面了解"></a>3.1 全面了解</h3><p>查看 MR commit message，了解 MR 大致要做什么。</p><ul><li>指出不必要的 MR 变更（给予对 developer 充分的尊重）</li><li>指出 commit title 和 message 中的错误和建议</li><li>查看关联 JIRA，了解问题背景</li><li>阅读测试用例，了解 MR 影响了什么。以及检查测试相关的问题</li></ul><h3 id="3-2-主要检查"><a href="#3-2-主要检查" class="headerlink" title="3.2 主要检查"></a>3.2 主要检查</h3><p>查看代码文件的主要内容。</p><ul><li>如果不能快速定位代码的关键部分，请 comment 要求 developer 澄清</li><li>判断 MR 中是否有和当前 MR 无关的内容。比如风格修改，多余功能实现</li><li>review 关键代码的设计</li><li>发现问题时请立即 comment，避免 developer 基于问题已经在做更多工作</li></ul><h3 id="3-3-次要检查"><a href="#3-3-次要检查" class="headerlink" title="3.3 次要检查"></a>3.3 次要检查</h3><p>在主要内容没有意见之后，检查其他代码。</p><ul><li>按照文件顺序重新浏览所有变更。</li><li>检查注释，命名规范等细节。</li><li>检查代码风格是否符合规定。</li><li>检查是否需要提供或变更文档。</li></ul><h2 id="4-Efficiency"><a href="#4-Efficiency" class="headerlink" title="4 Efficiency"></a>4 Efficiency</h2><p>Reviewer 应该尽快响应 MR 的 Code review 工作。</p><p>通常我们也希望 review 的过程足够快，也就是尽快 merge 代码，但这建立在很多因素的基础上。</p><h3 id="4-1-review-低效的问题"><a href="#4-1-review-低效的问题" class="headerlink" title="4.1 review 低效的问题"></a>4.1 review 低效的问题</h3><ul><li>降低团队效率。很多工作是基于当前 MR 展开的，MR 的 merge 过慢会阻塞其他开发工作</li><li>抱怨流程。review 流程会被抱怨，甚至对 reviewer 个人的抱怨，这会让团队成员的开发积极性受到挫败</li><li>代码健康度。developer 提交的其他 MR 可能会因此变得庞大、冗余，从而影响代码仓的质量</li></ul><h3 id="4-2-review-应该有多快"><a href="#4-2-review-应该有多快" class="headerlink" title="4.2 review 应该有多快"></a>4.2 review 应该有多快</h3><ul><li>Reviewer 的响应时间应该在 1 天内</li><li>Reviewer 应该立即响应 developer 主动要求的 Code review，这是 Reviewer 的职责</li><li>Reviewer 应该在每天都找一个时间，对仓库中所有 MR 进行 review</li><li>通常一个 MR 会经过多次 review，developer 也希望当天能得到多次 review</li><li>对于跨时区的 reviewer 和 developer，reviewer 应该在 developer 第二天上班前完成审查，并可以利用带评论的 LGTM</li></ul><h3 id="4-3-权衡"><a href="#4-3-权衡" class="headerlink" title="4.3 权衡"></a>4.3 权衡</h3><p>Review 请求会打断 Reviewer 自己的工作流，所以需要权衡。但通常还是需要积极响应主动请求。</p><ul><li>选择在 Reviewer 自己的工作中断点 review 代码。比如构建代码时、午餐晚餐前后</li><li>如果没有时间，也应该对 developer 给予快速反馈，并建议其他 reviewer</li><li>可以提供一些初步 comments，并提出 need change</li><li>但不要为了快速 review，而妥协了代码质量和标准。记住，reviewer 要对自己的每一笔 review 负责</li></ul><h3 id="4-4-大型-MR"><a href="#4-4-大型-MR" class="headerlink" title="4.4 大型 MR"></a>4.4 大型 MR</h3><p>如果 MR 的代码量比较多。预估 review 的时间会超过 20 分钟。</p><ul><li>尝试和 developer 沟通，是否可以精简 MR</li><li>如果无法精简 MR，尝试请 developer 提交 Code review 会议，集体做 review。developer 需要现场阐述 MR 的设计和细节</li></ul><h3 id="4-5-紧急-MR"><a href="#4-5-紧急-MR" class="headerlink" title="4.5 紧急 MR"></a>4.5 紧急 MR</h3><p>紧急 MR 比如：</p><ul><li>确定性的 commit revert</li><li>修复影响最终用户生产的错误</li><li>有 ETA 要求的功能，在即将到达 ETA 前</li><li>法律问题相关</li><li>明确的系统安全漏洞</li></ul><p>看似紧急但不紧急的 MR 比如：</p><ul><li>想赶在周末前合入，下周能开展新工作</li><li>跨时区的 review</li><li>commit revert 之后，导致的新问题</li></ul><p>紧急 MR 应该这么做：</p><ul><li>优先关注 review 过程的速度</li><li>先确保正确性，其他 review 发现的问题，如格式、测试用例等，可以要求 developer 之后补充 MR 修改</li><li>紧急 MR 合入后，应当再次对该 MR 做细致的 review，并要求 developer 补充</li><li>让所有项目组成员了解紧急 MR 的合入事件，并明确可能带来的风险</li></ul><p>尽量避免发生紧急 MR，这也有 PM 的责任，处理紧急 MR 应该极力避免项目积累技术债务。</p><h2 id="5-Comments"><a href="#5-Comments" class="headerlink" title="5 Comments"></a>5 Comments</h2><p>提交 Code review comments 也需要 reviewer 注意。</p><h3 id="5-1-保持友善"><a href="#5-1-保持友善" class="headerlink" title="5.1 保持友善"></a>5.1 保持友善</h3><p>不必说，在工作沟通中，都应该尽可能注意自己的措辞会给对方带来的压力和抵触，尤其是在挑别人毛病的时候。</p><h3 id="5-2-技术性解释"><a href="#5-2-技术性解释" class="headerlink" title="5.2 技术性解释"></a>5.2 技术性解释</h3><p>提供更多的技术性解释，来说明你的疑问或顾虑，比单纯的抛出问题更有利于 developer 处理。</p><h3 id="5-3-指导性-comment"><a href="#5-3-指导性-comment" class="headerlink" title="5.3 指导性 comment"></a>5.3 指导性 comment</h3><p>reviewer 虽然并没有义务帮助 developer 提供新的解决方案，但这并不意味着 reviewer 对提高 MR 的代码质量没有作用。</p><p>reviewer 可以适度的提供自己的建议方案，这通常有利于互相学习和加深对软件系统的理解。</p><p>毕竟，code review 的第一目标是保障代码质量，第二目标是提高软件开发人员的技能。</p><h3 id="5-4-解释性请求"><a href="#5-4-解释性请求" class="headerlink" title="5.4 解释性请求"></a>5.4 解释性请求</h3><p>对于不能快速理解的 MR，可以请求 developer 阐述 MR 中的主要内容和关键代码。</p><p>同时，对于 developer 提出的问题，reviewer 也应该给予充分的解释。</p><p>通常来说，请求解释无可厚非，这并不代表着 reviewer 个人水平如何。只有 developer 自己对自己编写的代码最熟悉。更充分的解释也有助于其他 reviewer 的 review 工作。</p><h3 id="5-5-同步线下的讨论"><a href="#5-5-同步线下的讨论" class="headerlink" title="5.5 同步线下的讨论"></a>5.5 同步线下的讨论</h3><p>很多时候，在 review 过程中，可能 reviewer 和 developer 会线下（或者线上 1 by 1 会议）讨论 MR 的细节。这是没问题的。</p><p>但需要在讨论结束后，将讨论的主要结论同步在 MR 中，以方便其他 reviewer 阅读和了解 review 的过程。</p><p>当然，也有助于将来回溯 MR 合入过程中的细节。</p><h3 id="5-6-Nit"><a href="#5-6-Nit" class="headerlink" title="5.6 Nit"></a>5.6 Nit</h3><p>Nit 是指 review 过程中，发现的一些小的，无关紧要的问题，reviewer 并不要求必须在当前 MR 做修改。</p><p>Nit 是重要的，鼓励 reviewer 和 developer 在 code reviewer 时多使用。</p><p>可能使用 Nit 的地方：</p><ul><li>注释和变量中的小错误，比如语法错误和拼写错误。</li><li>不易理解的一些符号。</li><li>可以将代码提炼和改善的地方。</li><li>冗余的注释说明。</li><li>reviewer 认可当前方案，但想分享他建议的更好方案。</li></ul><h2 id="6-冲突"><a href="#6-冲突" class="headerlink" title="6 冲突"></a>6 冲突</h2><p>Code review 的过程中，很容易对一些技术细节产生不同的观点。应当避免持续冲突影响了 MR 的合入效率。</p><ul><li>讨论时，要始终注意自己的措辞是否会伤害到对方</li><li>developer 通常对代码的细节，包括项目的细节，比 reviewer 了解更多和详细</li><li>讨论不应该过于频繁。应该留出独立思考的时间</li><li>如果代码存在严重问题，则 reviewer 不能妥协让步</li><li>无论什么时候，都应该对事不对人</li><li>避免妥协 “之后再处理” 的措辞。时间过的越久，“之后再处理” 就越不可能发生。（紧急 MR 例外）</li><li>如果 developer 一定坚持 “之后再处理”，那么要有 JIRA 跟踪，以避免后续遗忘。同时，代码中应当留下充分的解释，如 TODO 注释</li></ul><h2 id="7-MR-建议"><a href="#7-MR-建议" class="headerlink" title="7 MR 建议"></a>7 MR 建议</h2><p>本节内容是写给任何需要扮演 developer 角色的人员，提供一个开发代码和提交 MR 的实践指导。</p><h3 id="7-1-重视-MR-message"><a href="#7-1-重视-MR-message" class="headerlink" title="7.1 重视 MR message"></a>7.1 重视 MR message</h3><p>MR message 并不只是一个标题。不要省略详情内容，这是很不负责任的。</p><p>MR message 应当和 git commit message 保持一致，有利于回溯问题。</p><p>MR message 中应该包括典型的关键字，按照不同仓库的要求，这些关键字可能写在标题行，也可能写在详情文本中。这些关键字通常会作为将来检索相关内容的依据。</p><p>避免拼写错误和语法错误。</p><p>以下是一些具体说明：</p><p>标题行：</p><ul><li>简洁地描述 MR 做了什么</li><li>注意格式要求，比如不要超出格式要求的宽度、首字母大写且行尾不加标点</li><li>标题行要添加必要的关键字（遵从仓库规则）。如 llvm 中会使用 [ARM]，[MIPS] 来标注 MR 的类型</li><li>尽量避免笼统地总结 MR。比如一个反例：”Fix a bug of mma“。应该让其他人通过标题了解到 MR 独特的地方</li></ul><p>详情文本：</p><ul><li>应该包括对问题的详细描述、为什么要做这个事情、为什么用这种方法</li><li>还要包括需求背景和 JIRA 链接</li><li>如果需要，还可以包括目前方法的缺陷分析、未来计划、基准测试状态以及设计文档位置</li></ul><h3 id="7-2-尽可能小的-MR"><a href="#7-2-尽可能小的-MR" class="headerlink" title="7.2 尽可能小的 MR"></a>7.2 尽可能小的 MR</h3><p>一个 MR 应该只解决一个事情。小的 MR 会有很多优点：</p><ul><li>Code review 更快。这体现在 reviewer 可以更快的理解代码和排查可能存在的问题。当然也更容易得到 approve</li><li>大的 MR 会审查不彻底（人的惰性使然），对 reviewer 的要求也更高。小 MR 更容易发现问题</li><li>被 Disapproved 之后，调整更方便</li><li>合入更方便，不容易和其他 MR 产生冲突</li><li>如果意外需要 revert，也会更方便，带来的影响会更小</li><li>编写小型 MR 也有助于 developer 梳理软件逻辑</li></ul><p>多大代码量的 MR 算小型 MR 通常由代码仓的特征和所有 developer 和 reviewer 的大致判断决定，但通常几千行的 MR 就不能算小型 MR。（人脑的缓存通常也只能记忆这么多代码来完成 review）</p><h3 id="7-3-可以接受的大-MR"><a href="#7-3-可以接受的大-MR" class="headerlink" title="7.3 可以接受的大 MR"></a>7.3 可以接受的大 MR</h3><p>有些情况下，大型 MR 也能接受，如：</p><ul><li>增加或删除一个文件的完整代码</li><li>对某个相同特征的问题，在很多位置做修改</li><li>仓库初始配置</li></ul><p>一个大型 MR 通常需要更多的时间和精力来 review，也会需要额外开展 Code review meeting 进行集体 review。</p><p>所有 reviewer 和与 MR 相关的 developer 都应当明确 MR merge 可能带来的风险和对项目的影响。</p><h3 id="7-4-测试用例"><a href="#7-4-测试用例" class="headerlink" title="7.4 测试用例"></a>7.4 测试用例</h3><p>大多数功能性的 MR 的合入都应该配有测试用例。避免后续补充测试用例的做法。</p><p>可以有单独的测试用例作为独立 MR 合入，但这些用例应该是对之前已存在代码的一个测试补充或对测试代码的整体重构。</p><p>以下情况可以接受没有测试用例：</p><ul><li>紧急 MR 可以不添加测试用例，但紧急情况处理完毕后，应该额外提交测试用例 MR</li><li>格式调整、文档修改等 MR</li><li>可解释的其他不添加测试用例的情况，经 reviewer 接受</li></ul><h3 id="7-5-不能破坏构建"><a href="#7-5-不能破坏构建" class="headerlink" title="7.5 不能破坏构建"></a>7.5 不能破坏构建</h3><p>任何一个 MR 都应该是自完备的。它不能破坏代码仓的构建。</p><p>如果有几个相互依赖的 MR，也应该确保找到一种方法，让每个 MR 都能通过构建。功能可以不完备，但构建不能 fail。</p><p>另外，CI 的测试应该要保障不出现这种问题。</p><h3 id="7-6-回复-Comments"><a href="#7-6-回复-Comments" class="headerlink" title="7.6 回复 Comments"></a>7.6 回复 Comments</h3><p>永远记得 Code review 的目的是提高整个代码库的质量。当看到 comment 时，先控制自己反对的冲动（这种冲动其实是人之常情），想想为什么有这个 comment。</p><p>保持礼貌和感激。reviewer 也会做到这一点。</p><p>尝试澄清代码，以对 reviewer 有疑问的地方展开解释。并且也应该主动思考自己的代码为什么没有被其他人所轻易理解，并尝试改进。</p><p>Developer 也可以要求 reviewer 澄清他们的 comment。</p><p>可能会需要解决冲突，请参见上文 <strong>冲突</strong> 小节。</p><h3 id="7-7-JIRA-同步"><a href="#7-7-JIRA-同步" class="headerlink" title="7.7 JIRA 同步"></a>7.7 JIRA 同步</h3><p>除了在 MR message 中添加 JIRA 链接外，也应该在 JIRA 页面添加 MR 链接。或者使用 CI&#x2F;CD 系统自动完成双链。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/13742893417">Code Review Guide - P2Tree@zhihu.com</a></p><p>文章标题图使用豆包 AI 生成。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="高效编程" scheme="https://p2tree.top/tags/%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B/"/>
    
    <category term="软件工程" scheme="https://p2tree.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：活着</title>
    <link href="https://p2tree.top/posts/dc0bdc19.html"/>
    <id>https://p2tree.top/posts/dc0bdc19.html</id>
    <published>2024-12-15T20:16:05.000Z</published>
    <updated>2025-09-19T15:03:39.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/12/15/book.51.webp" alt="book.51"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/hhBc47ZA4v86a4YOQCZj3Q">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="与生活妥协" scheme="https://p2tree.top/tags/%E4%B8%8E%E7%94%9F%E6%B4%BB%E5%A6%A5%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git果壳：什么是版本控制</title>
    <link href="https://p2tree.top/posts/86730351.html"/>
    <id>https://p2tree.top/posts/86730351.html</id>
    <published>2024-11-24T22:29:12.000Z</published>
    <updated>2025-09-19T15:03:39.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“Git 菜谱” 系列文章：</p><ol class="series-items"><li><a href="/posts/86730351.html" title="Git果壳：什么是版本控制">Git果壳：什么是版本控制</a></li></ol><hr><blockquote><p>©️ 本文演绎自 Atlassian 编写的 <a href="https://www.atlassian.com/git/tutorials/what-is-version-control"><em>What is version control</em></a>。页面上所有内容采用知识共享-署名（<a href="http://creativecommons.org/licenses/by/2.5/au/deed.zh">CC BY 2.5 AU</a>）许可协议。</p></blockquote><h3 id="版本控制的优点"><a href="#版本控制的优点" class="headerlink" title="版本控制的优点"></a>版本控制的优点</h3><p>版本控制系统是软件工具的一个类别，它可以辅助软件开发团队管理软件代码随着时间的更改。版本控制软件可以通过特殊的数据库来追踪代码的每一次变更。如果软件开发中发生错误，开发者可以利用版本控制来将代码和早期的版本做对比，从而能够以对其他团队成员干扰最小的前提下修复错误。</p><p>对于几乎所有的软件工程来说，软件源代码就是最重要的部分（<em>译注：原文比喻为皇冠上的宝石，也就是最需要保护的珍宝</em>）。对于大多数软件团队，源代码仓库是他们认真努力积累和完善的宝贵知识财富的存储库，而版本控制可以保护源代码免受灾难性的破坏以及人为操作失误或故意破坏。</p><p>软件开发人员工作过程中会持续性的产出新的代码以及修改已经存在的代码。一个工程软件、应用软件或者软件组件通常被组织在一个文件夹或者说一个目录树中。团队中的一个开发者可能在增加一个新特性，而另一个开发者可能在修复不相关的bug，每一个开发者都在这个目录树的不同位置对代码内容进行着更改。</p><p>版本控制可以帮助软件团队解决这样的问题，追踪每一个开发者产生的每一个独立的变更，以及帮助预防并发工作中的冲突。并发工作的冲突是指软件一部分的修改可能与另一个开发者同时的修改不兼容。这个问题应该有条不紊的被发现和解决，从而不能影响团队其他成员的工作。此外，在软件开发中，任何更改都有可能引入新的 bugs，故而在测试之前，新的软件版本不能被完全信任，所以直到新版本发布之前，测试和开发的进程都应该同时被执行。</p><p>好的版本控制软件可以支持开发者首选的工作流程，而不会强加一种特别的工作方式。理想情况下，它应该能在任何平台上工作，而不是特别要求开发者必须使用某种操作系统或者工具链。好的版本控制系统可以促进代码变更平稳连续的进行，而不是使用将文件锁定的这种糟糕而笨拙的机制（这是指某个文件只允许一名开发人员工作，而阻止其他开发人员开发）</p><p>不使用任何版本控制的软件团队经常会遇到一些问题，比如不知道已经完成的哪些变更可以被用户使用，或者在两个不相关的工作内容之间创建了互不兼容的更改，然后必须进行繁琐的整理和重做。如果你是一个从未使用过版本控制的开发者，你可能会这样命名你的不同版本的文件，比如加一个“最终版”或“最新版”的文件名后缀，然后不得不之后再处理新的最终版本。也许你会为了禁用某个功能但不愿删除代码，因为害怕代码未来还将会用到而注释掉代码块。版本控制可以解决如上这些问题。</p><p>版本控制软件是现代软件团队日常开发中必不可少的一部分。习惯于团队中使用功能强大的版本控制系统的软件开发人员会显然意识到版本控制所带来的不可思议的价值，即使是在小型项目中也是如此。一旦习惯了版本控制系统的强大优势，很多开发者就不再考虑去做没有版本控制支持的工作，即使是完成非软件开发的工作。</p><h3 id="版本控制系统的优点"><a href="#版本控制系统的优点" class="headerlink" title="版本控制系统的优点"></a>版本控制系统的优点</h3><p>开发软件时不使用版本控制系统是危险的，比方说没有做备份。版本控制也能允许开发人员更灵活的人员变动，允许软件团队在团队规模扩大时保持高效率和敏捷性。</p><p>版本控制系统（<code>Version Control System</code>,<code>VCS</code>）在过去的几十年内取得了非常大的进步，并且有些更为突出。有些时候被称作代码管理工具（<code>Source Code Management</code>,<code>SCM</code>）或者修订控制系统（<code>Revision Control System</code>,<code>RCS</code>）。其中一个很流行的版本控制工具叫做 Git，它是一个分布式的版本控制系统（<code>Distributed VCS</code>,<code>DVCS</code>），之后会详细介绍。就像很多现在流行的版本控制系统一样，Git 是自由的也是开源的。不管它们叫什么名字，又或者是什么系统使用，版本控制系统主要的优点有以下几点。</p><ol><li><strong>记录每一个文件的完整的长期的变更历史</strong>。这意味着它能记录长期以来每一个贡献者提交的每一个变更。这些变更包括文件的创建、删除以及内容修改。<em>不同的 VCS 工具的一个区别在于它们处理重命名和移动文件的能力</em>。每次变更将包括作者名、时间和每一次修改的纪要。具有完整的历史可以允许我们退回到之前的版本中，从而帮助分析 bugs，当需要在旧版本中修复软件问题时，这确实很重要。如果正在积极开发一个软件，则几乎所有的内容都将被看做这个软件的旧版本。<em>译注：因为软件更新快，原文旨在说明旧版本不是你想象中的那么“旧”。</em></li><li><strong>分支和合并特性</strong>。这些特性可以让团队协作工作更加便捷，也可以让独立工作的开发者能从中受益。在 VCS 工具中创建一个分支可以维持多个独立的开发工作流，同时也提供了将这些工作合并回去的功能，能允许开发者验证分支之间的变更是否冲突。很多软件团队使用独立分支来开发特性或者是维护一个版本，或者两者都有。软件团队可以利用分支和合并特性来选择不同的工作方式。</li><li><strong>可追溯性</strong>。能够追踪软件的每一次变更，进而可以让其能够搭配工程管理系统和 bug 追踪软件，比如 <a href="https://www.atlassian.com/software/jira">Jira</a>。可以通过消息来描述变更的目的和意图，从而注释每一次变更，这样不但能有助于关键问题分析也可协助其他的检查工作。在阅读代码，或尝试理解代码作用和设计意图时，这样的代码描述历史消息可以帮助开发者做出正确的和相匹配的修改，能够与系统预期的长期设计思想相符合。这种方式对于在遗留代码上高效工作是非常重要的，对于开发人员准确估计未来工作也是非常重要的。</li></ol><p>当然，不使用版本控制系统来开发软件也是可行的，但是这样的工程具有很大的风险，任何专业的开发团队都不会愿意接受。所以问题并不会在于是否使用版本控制系统，而是使用哪种版本控制系统。</p><p>这会有多种选择，但这里的教程我们专注于 Git。从<a href="https://bitbucket.org/product/version-control-software?_ga=2.63967023.1846059181.1575290049-386918931.1575091845">这里</a>可以了解到其他的版本控制软件。</p><hr><div class="note info flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@nganduong93?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Duong Ngan</a> on <a href="https://unsplash.com/photos/a-white-table-topped-with-white-christmas-trees-dTBhA3zP3yA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="译文" scheme="https://p2tree.top/tags/%E8%AF%91%E6%96%87/"/>
    
    <category term="Git" scheme="https://p2tree.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>他们</title>
    <link href="https://p2tree.top/posts/b5919f86.html"/>
    <id>https://p2tree.top/posts/b5919f86.html</id>
    <published>2024-11-19T22:53:22.000Z</published>
    <updated>2025-09-19T15:03:39.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0 到 3 岁，你是他们的全部；<br>3 到 7 岁，你是他们的晚上；<br>7 到 18 岁，你是他们的周末；<br>18 到 22 岁，你是他们的寒暑假；<br>之后，你是他们的春节。</p><hr><p><img src="https://img.p2tree.top/2024/11/19/Chapter.401.webp" alt="Chapter.401"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，秋天、老照片和时光流逝。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/YPAAsZC_tWvoecqUv01Azg">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
</feed>
