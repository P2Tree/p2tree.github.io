<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P2Tree&#39;s Mill</title>
  
  
  <link href="https://p2tree.top/atom.xml" rel="self"/>
  
  <link href="https://p2tree.top/"/>
  <updated>2025-03-25T13:24:58.059Z</updated>
  <id>https://p2tree.top/</id>
  
  <author>
    <name>P2Tree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习LLVM数据结构：StringRef</title>
    <link href="https://p2tree.top/posts/a198516a.html"/>
    <id>https://p2tree.top/posts/a198516a.html</id>
    <published>2025-03-25T21:14:24.000Z</published>
    <updated>2025-03-25T13:24:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::StringRef</code> 定义在 <code>llvm/ADT/StringRef.h</code> 头文件中。 它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRef</span>;</span><br></pre></td></tr></table></figure><p>和 <code>ArrayRef</code> 类似，<code>StringRef</code> 是一种轻量级的字符串引用类型，它用于实现高效地表示和操作字符串数据，尤其是在一些高频处理字符串，但同时不希望维护实际内存开销地场景下。 它是不可变引用，主要用于向函数内传递字符串同时避免深拷贝。它只包含了指向字符串的指针和字符串的长度信息，从而使得对它的操作直接而高效。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>轻量级</strong>：只存储一个指向字符串的指针和字符串的长度，不存储实际的数据，所以拷贝时很高效。</li><li><strong>简单易用</strong>：支持许多常用的字符串操作，比如比较、查找和子串提取，使用很方便。</li><li><strong>操作一致</strong>：它的大多数操作，和标准库中 string 保持一致。</li></ul><h3 id="与标准库-string-对比"><a href="#与标准库-string-对比" class="headerlink" title="与标准库 string 对比"></a>与标准库 string 对比</h3><ul><li><strong>所有权</strong>：<code>StringRef</code> 是对字符串数据的引用，不拥有字符串的所有权。需要确保 <code>StringRef</code> 对象的生命周期，小于实际引用字符串的生命周期，否则会带来悬空引用。</li><li><strong>大小</strong>：<code>StringRef</code> 只占用很小的内存，和实际字符串相比可以忽略不计。<code>std::string</code> 不仅包括了指针、长度，还包括了数据的内存管理信息，它在内部维护了一个动态分配的缓存区来存储字符串内容。</li><li><strong>可变性</strong>：<code>StringRef</code> 是不可变的，它引用的内容不能被修改。而 <code>std::string</code> 则提供了完整的可操作空间。</li><li><strong>性能</strong>：<code>StringRef</code> 不涉及内存分配，在传递和使用时，具有更高的性能，特别是在函数传参时，可以避免深拷贝。而 <code>std::string</code> 在按值传参时，会对保存字符串的内存做完整的复制。现在编译器可以通过移动语义和短字符串优化等方式来减少深拷贝的性能开销，但整体上，传递引用还是要更轻量级。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>由于 <code>llvm::StringRef</code> 只拥有数据的引用，而不管理实际字符串的内存，所以它的结构很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>事实上，使用 <code>const std::string &amp;</code> 基本可以取代 <code>llvm::StringRef</code>，然而，<code>StringRef</code> 的另一个优势是，它提供了更多更易用的操作方法，比如 <code>split</code> 函数。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><code>StringRef</code> 可以方便地从字符串字面量、<code>std::string</code> 或 <code>char *</code> 指针来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串字面量初始化</span></span><br><span class="line">llvm::StringRef Str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串指针和长度来初始化</span></span><br><span class="line"><span class="type">char</span> *Cstr = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">llvm::StringRef Str2&#123;Cstr, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 std::string 来初始化</span></span><br><span class="line">std::string Sstr&#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">llvm::StringRef Str3&#123;Sstr&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供了迭代器 <code>begin()</code> 和 <code>end()</code>，以及返回字符指针的 <code>bytes_begin()</code> 和 <code>bytes_end()</code>，这是为了处理宽字符编码的字符串。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到字符串原始位置</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *Data = Str.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到字符串的长度</span></span><br><span class="line"><span class="type">bool</span> IsEmpty = Str.<span class="built_in">empty</span>();</span><br><span class="line"><span class="type">size_t</span> Length = Str.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> FirstChar = Str.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> LastChar = Str.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也支持任意的下标操作，越界用 assert 来检查</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> C = Str[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str1, Str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否相等</span></span><br><span class="line"><span class="type">bool</span> IsEqual1 = Str<span class="number">1.</span><span class="built_in">equals</span>(Str2);</span><br><span class="line"><span class="type">bool</span> IsEqual2 = Str1 == Str2;</span><br><span class="line"><span class="type">bool</span> IsEqual3 = Str<span class="number">1.</span><span class="built_in">equals_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="comment">// 其他操作也有忽略大小写的版本，不再单独列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断大小，当结果小于、等于、大于时，值是 -1、0、1</span></span><br><span class="line"><span class="type">int</span> Cmp1 = Str<span class="number">1.</span><span class="built_in">compare</span>(Str2);</span><br><span class="line"><span class="type">int</span> Cmp2 = Str<span class="number">1.</span><span class="built_in">compare_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="type">int</span> Cmp3 = Str<span class="number">1.</span><span class="built_in">compare_numeric</span>(Str2);  <span class="comment">// 由数字字符组成的字符串，按数字来比较</span></span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>编辑距离（edit distance）是指将一个字符串完全改为另一个字符串时，所需要的最小单字符操作的次数。这些操作可以是： - 插入一个字符 - 删除一个字符 - 替换一个字符（分为将替换看作一次操作，还是看作两次操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str1, Str2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Distance1 = Str<span class="number">1.</span><span class="built_in">edit_distance</span>(Str2);</span><br><span class="line"><span class="type">int</span> Distance2 = Str<span class="number">1.</span><span class="built_in">edit_distance_insensitive</span>(Str2);  <span class="comment">// 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两个隐藏参数，第一个是替换被看作几次，默认是 1 次操作</span></span><br><span class="line"><span class="type">bool</span> AllowReplacements = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 第二个是最大编辑距离，如果编辑距离超过最大编辑距离，则返回最大编辑距离+1</span></span><br><span class="line"><span class="type">bool</span> MaxEditDistance = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Distance3 = Str<span class="number">1.</span><span class="built_in">edit_distance</span>(Str2, AllowReplacements, MaxEditDistance);</span><br></pre></td></tr></table></figure><h3 id="获取副本"><a href="#获取副本" class="headerlink" title="获取副本"></a>获取副本</h3><p>使用 <code>str()</code> 来获取一个 <code>std::string</code> 类型的副本。 使用 <code>string_view()</code> 来获取一个 <code>std::string_view</code> 类型的副本。 同时，也提供了 <code>copy</code> 函数，来获取一个 <code>StringRef</code> 的副本，但需要提供分配器，用于分配新的空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 包含 std::allocator</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/BumpPtrAllocator.h&quot;</span>  <span class="comment">// 包含 BumpPtrAllocator</span></span></span><br><span class="line"></span><br><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 C++ 的内存分配器</span></span><br><span class="line">std::allocator&lt;<span class="type">char</span>&gt; Alloc;</span><br><span class="line">llvm::StringRef NewStr1 = Str.<span class="built_in">copy</span>(ALloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 LLVM 的内存分配器</span></span><br><span class="line">llvm::BumpPtrAllocator BumpAlloc;</span><br><span class="line">llvm::StringRef NewStr2 = Str.<span class="built_in">copy</span>(BumpAlloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以自定义分配器，需要提供 Allocate&lt;&gt; 模板方法</span></span><br><span class="line"><span class="comment">// 使用时，需要确保分配器对象的生命周期超过 StringRef 对象，否则会带来引用失效问题</span></span><br></pre></td></tr></table></figure><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否开始于一个特定前缀字符</span></span><br><span class="line"><span class="type">bool</span> Ret1 = Str.<span class="built_in">starts_with</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="type">bool</span> Ret2 = Str.<span class="built_in">startswith</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否结束于一个特定后缀字符</span></span><br><span class="line"><span class="type">bool</span> Ret3 = Str.<span class="built_in">ends_with</span>(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"><span class="type">bool</span> Ret4 = Str.<span class="built_in">endswith</span>(<span class="string">&#x27;z&#x27;</span>);  <span class="comment">// 语法糖</span></span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规查找，返回下标位置，内部调用了 std::string_view::find()，当找不到时，返回 StringRef::npos，其值是 ~size_t(0)</span></span><br><span class="line"><span class="type">size_t</span> Ret1 = Str.<span class="built_in">find</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="comment">// 第二个隐藏参数是从什么位置开始查，默认是从 0（字符串开头）开始查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定查找条件</span></span><br><span class="line"><span class="type">size_t</span> Ret2 = Str.<span class="built_in">find_if</span>([](<span class="type">char</span> c) &#123; <span class="keyword">return</span> c &gt; <span class="string">&#x27;r&#x27;</span> &amp;&amp; c &lt; <span class="string">&#x27;x&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// 还有取反的 find_if_not</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向查找</span></span><br><span class="line"><span class="type">size_t</span> Ret3 = Str.<span class="built_in">rfind</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找是否包含特定字符</span></span><br><span class="line"><span class="type">bool</span> IsContain = Str.<span class="built_in">contains</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="comment">// 查找是否包含特定子串</span></span><br><span class="line">llvm::StringRef SubStr;</span><br><span class="line"><span class="type">bool</span> IsContainsSubStr = Str.<span class="built_in">contains</span>(SubStr);</span><br></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数特定字符出现的次数</span></span><br><span class="line"><span class="type">size_t</span> Cnt = Str.<span class="built_in">count</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将由数字字符组成的字符串，转换为整型，第一个参数是选择进制，置为 0 表示按 C 整形规则自动选择进制。若转换失败，会返回 true。</span></span><br><span class="line"><span class="type">int</span> Res;</span><br><span class="line">Str.<span class="built_in">getAsInteger</span>(<span class="number">0</span>, Res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 getAsInteger 类似，但会剔除开头的数字部分，如果开头不是数字，返回 true 表示失败。</span></span><br><span class="line"><span class="comment">// 实际上，是修改了指针位置，并没有改变字符串</span></span><br><span class="line">Str.<span class="built_in">consumeInteger</span>(<span class="number">0</span>, Res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串按大小写转换，并返回 std::string 类型</span></span><br><span class="line">std::string LowerStr = Str.<span class="built_in">lower</span>();</span><br><span class="line">std::string UpperStr = Str.<span class="built_in">upper</span>();</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取子字符串的操作，实际上是修改指针指向位置和长度的结果</span></span><br><span class="line">llvm::StringRef Str;</span><br><span class="line"></span><br><span class="line">llvm::StringRef SubStr1 = Str.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 截取从 2 下标开始，长度为 3 的子串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前 N 个字符的子串</span></span><br><span class="line">llvm::StringRef SubStr2 = Str.<span class="built_in">take_front</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 删除前 N 个字符，返回剩余字符的子串，是 drop_front</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回后 N 个字符的子串</span></span><br><span class="line">llvm::StringRef SubStr3 = Str.<span class="built_in">take_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 同理，返回剩余字符的子串，是 drop_back</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果以给定前缀开头，删除该前缀，返回剩余字符子串</span></span><br><span class="line">Str.<span class="built_in">consume_front</span>(<span class="string">&quot;prefix&quot;</span>);  <span class="comment">// 在原始引用上操作</span></span><br><span class="line"><span class="comment">// 同理，还有给定后缀的 consume_back()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取任意子串</span></span><br><span class="line">llvm::StringRef SubStr4 = Str.<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 截取从 1 下标到 3 下标的子串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split 操作，即按给定字符来分割子串</span></span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair1 = Str.<span class="built_in">split</span>(<span class="string">&#x27;:&#x27;</span>);  <span class="comment">// 分成两个子串</span></span><br><span class="line">llvm::StringRef SeparatorStr = <span class="string">&quot;::&quot;</span>;</span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair2 = Str.<span class="built_in">split</span>(SeparatorStr);  <span class="comment">// 使用给定子字符串分隔子串</span></span><br><span class="line">std::pair&lt;llvm::StringRef, llvm::StringRef&gt; SubStrPair3 = Str.<span class="built_in">rsplit</span>(SeparatorStr);  <span class="comment">// 从末尾开始搜索分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split 操作，所有都分隔</span></span><br><span class="line">llvm::SmallVector&lt;llvm::StringRef&gt; SplitStrs;</span><br><span class="line">Str.<span class="built_in">split</span>(SplitStrs, <span class="string">&quot;::&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// trim 操作</span></span><br><span class="line">llvm::StringRef TrimStr1 = Str.<span class="built_in">ltrim</span>(<span class="string">&#x27;\0&#x27;</span>);  <span class="comment">// 切掉左侧连续多个 &#x27;\0&#x27; 字符</span></span><br><span class="line">llvm::StringRef TrimStr2 = Str.<span class="built_in">ltrim</span>();  <span class="comment">// 切掉左侧连续多个空白字符</span></span><br><span class="line"><span class="comment">// 对应还有右侧版 rtrim 和 两侧版 trim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否包含 EOL 字符，EOL 字符是 end of line 标记</span></span><br><span class="line"><span class="type">bool</span> HasEOLStr = Str.<span class="built_in">detactEOL</span>();</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="引用失效"><a href="#引用失效" class="headerlink" title="引用失效"></a>引用失效</h3><p>和 <code>llvm::ArrayRef</code> 一样，<code>llvm::StringRef</code> 本身是一个引用类型，所以它会存在引用失效的风险。 另外，也不建议直接返回一个内部临时对象引用的 <code>llvm::StringRef</code> 类型，可以返回经过调整，但指向外部字符串的新的 <code>llvm::StirngRef</code> 类型。 它的生命周期一定要短于它所引用的字符串的生命周期，从而避免悬挂引用。</p><h3 id="不可修改"><a href="#不可修改" class="headerlink" title="不可修改"></a>不可修改</h3><p>它是对目标字符串的常量引用，所以不可以直接通过它修改目标字符串。不过，可以通过 <code>data</code> 来获取到它原始字符串的指针，从而去修改原始字符串，但这样存在一些潜在的风险，并不是推荐的做法。如果需要修改字符串，使用 <code>std::string &amp;</code> 可能更好。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p><code>llvm::StringRef</code> 并不处理字符编码问题，它能提供的最大能力就是使用迭代器时，可以选择按字符迭代，还是获得底层的字符指针，由开发者自己选择怎么解析。 所以，如果需要处理宽字符编码的字符串，需要额外做一些包装。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>llvm::StringLiteral</code>：处理字符串字面量的子类，高效管理字符串字面量。</li><li><code>llvm::ArrayRef</code>：顺序型容器的只读引用，见 <a href="https://p2tree.top/posts/cdf6959f.html">学习 LLVM 数据结构：ArrayRef</a>。</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/32410920552">学习LLVM数据结构-StringRef - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：SmallVector</title>
    <link href="https://p2tree.top/posts/e9ae65d7.html"/>
    <id>https://p2tree.top/posts/e9ae65d7.html</id>
    <published>2025-03-09T21:21:34.000Z</published>
    <updated>2025-03-25T13:24:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。</p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::SmallVector</code> 定义在 <code>llvm/ADT/SmallVector.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N = CalculateSmallVectorDefaultInlinedElements&lt;T&gt;::value&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVector;</span><br></pre></td></tr></table></figure><p><code>llvm::SmallVector</code> 是一个可变长数组，类似于 <code>std::vector</code>，同时它对较小长度的数组做了优化。<br>它的内存管理方式采用局部缓存的设计思路，在对象内部预留一小块空间，用于存储数据。当数据量超出预留空间的大小时，才会将数据放在堆上。它本身保存一部分元素，这便使得在小数组中，避免进行堆分配的操作，提高了效率。<br>注意到，它带有一个含默认值的模板参数 <code>N</code>，它用来指定预留空间的大小，默认不指定时，编译器会自动选择一个合理的阈值（通常考虑依据是栈空间的占用情况）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>顺序容器</strong>：<code>SmallVector</code> 是一个顺序容器，可以在末尾添加和删除元素，可以通过下标访问任意元素。</li><li><strong>小长度数组优化</strong>：它结合了定长数组在栈上快速分配和动态数组在堆上的灵活性，当管理的数据长度小于阈值（默认值或声明时给定值），会将数据保存在栈上，从而避免堆分配和内存管理带来的性能开销。</li><li><strong>操作一致</strong>：它的大多数操作，和 STL vector 保持一致。</li></ul><h3 id="与标准库-vector-的对比"><a href="#与标准库-vector-的对比" class="headerlink" title="与标准库 vector 的对比"></a>与标准库 vector 的对比</h3><ul><li><strong>性能优势</strong>：在数据量较小时，由于不会涉及到堆内存分配和管理的开销，性能会优于 <code>std::vector</code>。另外，它可以识别平凡可复制的特性，从而更细粒度地做内存管理。</li><li><strong>退化时的性能损失</strong>：当发生从栈到堆的退化时，<code>llvm::SmallVector</code> 会带来数据拷贝的开销。所以需要仔细考虑阈值的设定。</li><li><strong>可能浪费空间</strong>：<code>llvm::SmallVector</code> 会在定义时预分配设定的 <code>N</code> 的空间，如果实际数据少于 <code>N</code>，那么会存在空间浪费的问题。<code>std::vector</code> 也存在类似问题。</li></ul><h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p>简单的继承结构如：</p><p><img src="https://img.p2tree.top/2025/3/9/SmallVector-Derive-Structure.webp" alt="继承结构图"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVector</span> : <span class="keyword">public</span> SmallVectorImpl&lt;T&gt;, SmallVectorStorage&lt;T, N&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只用于管理一块内置数组 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorStorage</span> &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了大多数操作方法 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorImpl</span> : <span class="keyword">public</span> SmallVectorTemplateBase&lt;T&gt; &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// SmallVectorTemplateBase 有两种模板类，分别针对类型是否时 POD 做实现 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> = (is_trivially_copy_constructible&lt;T&gt;::value) &amp;&amp; </span><br><span class="line">                             (is_trivially_move_constructible&lt;T&gt;::value) &amp;&amp; </span><br><span class="line">                             std::is_trivially_destructible&lt;T&gt;::value&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVectorTemplateBase : <span class="keyword">public</span> SmallVectorTemplateCommon&lt;T&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorTemplateBase</span>&lt;T, <span class="literal">true</span>&gt; : <span class="keyword">public</span> SmallVectorTemplateCommon&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不涉及 POD 的部分 </span></span><br><span class="line"><span class="comment">// 第二个模板参数是一个 dummy 参数，只用来解决当 ArrayRef 作为类型时，避免空长度时无法实例化的问题 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt; </span><br><span class="line"><span class="keyword">class</span> SmallVectorTemplateCommon : <span class="keyword">public</span> SmallVectorBase&lt;SmallVectorSizeType&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最基础的类，管理几个数据成员，Size_T 是对类型 size 的推导 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Size_T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorBase</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>SmallVector</code> 继承自 <code>SmallVectorImpl</code> 和 <code>SmallVectorStorage</code>，其中 <code>SmallVectorImpl</code> 实现了大多数通用的操作代码和管理长度等属性的数据成员。它继承的 <code>SmallVectorTemplateBase</code>、<code>SmallVectorTemplateCommon</code> 和 <code>SmallVectorBase</code> 都是用来就完成模板实例化时的公共代码，这里先按下不表。<br><code>SmallVectorStorage</code> 实现了堆内联存储的静态数组的分配和管理，它是一个 POD 类型，只含有数据。这也有利于编译器为特定长度的数组做专门的优化。<br>通过这种分离，<code>SmallVectorImpl</code> 可以用于不同模板类的复用，而 <code>SmallVectorStorage</code> 又可以方便的做模板特化（不同的 <code>N</code>）。这样，减少了模板实例化时的实例化数量，降低了编译空间占用，提高编译效率，是一种在很多 C++ 工程中普遍用到的实现技巧。</p><p>我们再回头看 <code>SmallVectorImpl</code> 的继承结构，它的父类中，<code>SmallVectorBase</code> 作为最底层的类，提供了最基本的功能，包括类型的数据，比如 size 和 capacity，一些辅助函数和虚函数定义。它作为整个继承体系的根，定义了所有 <code>SmallVector</code> 最通用的接口和行为。<br><code>SmallVectorTemplateCommon&lt;T, void&gt;</code> 抽取了 <code>SmallVectorTemplateBase</code> 的实现，它实现了不依赖于 T 是否是 POD 类型的代码。而与 POD 类型相关的代码实现，放在了 <code>SmallVectorTemplateBase</code> 中。<br><code>SmallVectorTemplateBase</code> 针对的就是非平凡的类型，根据是否可复制、可移动，又实例化了不同的模板类。它在正确性和性能之间达成平衡，在避免错误的同时，为大多数非平凡类型提供在元素操作上的最优性能。</p><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>忽略多层级的继承结构，整个 <code>SmallVector</code> 中包含几个主要的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallVectorBase</span> &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">  <span class="comment">// 指向向量中第一个元素的指针 </span></span><br><span class="line">  <span class="type">void</span> *BeginX; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向量内存空间的总长度   </span></span><br><span class="line">  <span class="type">size_t</span> Size; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预分配的空间大小   </span></span><br><span class="line">  <span class="type">size_t</span> Capacity; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这 3 个成员决定了索引数据和判断优化阈值。<br>另外，对于小长度数组，还需要分配内置的存储空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallVectorStorage</span> &#123; </span><br><span class="line">  <span class="built_in">alignas</span>(T) <span class="type">char</span> InlineElts[<span class="function">N * <span class="title">sizeof</span><span class="params">(T)</span>]</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列了部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/SmallVector.h</code> 文件代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的容器，inline storage 大小为 4 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec1; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数值和长度 </span></span><br><span class="line"><span class="function">llvm::SmallVector&lt;<span class="type">int</span>, 4&gt; <span class="title">vec2</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 包含 3 个值为 10 的元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec3 = vec2; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 vector 中构造 </span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; stdVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; </span><br><span class="line"><span class="function">llvm::SmallVector&lt;<span class="type">int</span>, 4&gt; <span class="title">vec4</span><span class="params">(stdVec.begin(), stdVec.end())</span></span>;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>和 <code>std::vector</code> 一样，也提供了前向迭代器和反向迭代器，以及对应带 const 的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向迭代器 </span></span><br><span class="line"><span class="keyword">for</span> (llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 前向迭代器 </span></span><br><span class="line"><span class="keyword">for</span> (llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); it != vec.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 range for loop </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ele : vec) &#123;</span><br><span class="line">  std::cout &lt;&lt; ele &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持下标进行随机访问 </span></span><br><span class="line">std::cout &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl; vec[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法，内部会做越界检查 </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  std::cout &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl; </span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range &amp;e) &#123; </span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>支持常见的几种比较运算符，其中，大于、小于操作的比较逻辑采用通用的序列比较算法，在序列长度相同时，比较对应元素的大小或字典序。</p><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><p>基础元素操作与 <code>std::vector</code> 相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 末尾添加元素 </span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除末尾元素 </span></span><br><span class="line">vec.<span class="built_in">pop_back</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入元素，需要元素移动，所以性能可能较差 </span></span><br><span class="line">vec.<span class="built_in">insert</span>(it, <span class="number">10</span>); <span class="comment">// it 是一个有效的迭代器 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出指定位置元素，同样可能有性能问题 </span></span><br><span class="line">vec.<span class="built_in">erase</span>(it); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有元素 </span></span><br><span class="line">vec.<span class="built_in">clear</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回向量中元素的数量 </span></span><br><span class="line">vec.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回向量中的容量，也就是 Capacity 的值 </span></span><br><span class="line">vec.<span class="built_in">capacity</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为空 </span></span><br><span class="line">vec.<span class="built_in">empty</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变向量大小 </span></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">// 调整为 5 个元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留指定容量的内存 </span></span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>使用 <code>llvm::SmallVector</code> 容器，需要引入 <code>Support</code> 组件，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LLVM_LINK_COMPONENTS Support)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不保证异常安全"><a href="#不保证异常安全" class="headerlink" title="不保证异常安全"></a>不保证异常安全</h3><p><code>SmallVector</code> 本身并不是异常安全的。这一点和 <code>std::vector</code> 不同，标准库容器能保证异常安全性。</p><h3 id="不合适的预分配大小"><a href="#不合适的预分配大小" class="headerlink" title="不合适的预分配大小"></a>不合适的预分配大小</h3><p>如果在定义 <code>SmallVector</code> 时，指定栈上预分配容量 <code>N</code> 非常大，可能会导致栈溢出，需要根据实际情况选择合适的 <code>N</code> ，避免栈溢出。<br>如果预分配容量 <code>N</code> 不合理，导致使用容器对象时，总是会发生退化到堆的问题，那么重复的数据拷贝，也会带来性能问题。</p><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>和其他顺序容器类型一样，使用迭代器时，插入和删除操作可能会导致迭代器失效。尤其是还需要考虑因为插入元素导致 <code>SmallVector</code> 重新分配内存（栈到堆的退化和堆到堆的重新分配），迭代器都会失效。<br>resize 操作也会导致迭代器失效。</p><h3 id="自定义类型的内存管理"><a href="#自定义类型的内存管理" class="headerlink" title="自定义类型的内存管理"></a>自定义类型的内存管理</h3><p>如果 <code>SmallVector</code> 存储的是自定义类型，那么需要确保自定义类型有着正确的构造、移动和拷贝操作，不正确的实现会导致内存泄漏等问题。<br>如果自定义类型是引用类型，那么使用 <code>SmallVector</code> 管理时，需要确保自定义类型的析构函数中，能够正确释放内存。如果 <code>SmallVector</code> 管理的是指针，还需要自定义析构器来处理指针指向的内存。</p><h3 id="使用-SmallVectorImpl-作为参数类型"><a href="#使用-SmallVectorImpl-作为参数类型" class="headerlink" title="使用 SmallVectorImpl 作为参数类型"></a>使用 <code>SmallVectorImpl</code> 作为参数类型</h3><p>如果需要传递一个 <code>SmallVector</code> 的容器对象时，形参参数建议使用 <code>SmallVectorImpl</code>，后者没有带有 <code>SmallVectorStorage</code>，所以不会实际分配空间，同时也不需要声明函数时指定 <code>N</code> 值，这无论从效率角度看，还是使用便利性，都非常有价值。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种声明需要指定 N </span></span><br><span class="line"><span class="built_in">funcWithVec</span>(llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; &amp;Arg); </span><br><span class="line"><span class="comment">// 而这种声明不需要指定 N</span></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(llvm::SmallVectorImpl&lt;<span class="type">int</span>&gt; &amp;Arg);  </span><br><span class="line"></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">4</span>&gt; vec1; </span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>, <span class="number">8</span>&gt; vec2; </span><br><span class="line"></span><br><span class="line"><span class="built_in">funcWithVec</span>(vec1); <span class="comment">// 正常  </span></span><br><span class="line"><span class="built_in">funcWithVec</span>(vec2); <span class="comment">// 编译报错 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(vec1); <span class="comment">// 正常 </span></span><br><span class="line"><span class="built_in">funcWithVecImpl</span>(vec2); <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="不适合用于存储大量元素"><a href="#不适合用于存储大量元素" class="headerlink" title="不适合用于存储大量元素"></a>不适合用于存储大量元素</h3><p>虽然 <code>SmallVector</code> 可以在堆上动态分配内存，但它的设计关注点还是在管理小数据量的动态数组。如果已知数量比较大的动态数组，使用 <code>std::vector</code> 即可。<br>同理，也不适合管理单个元素内存较大的数据类型。</p><h3 id="拷贝成本"><a href="#拷贝成本" class="headerlink" title="拷贝成本"></a>拷贝成本</h3><p>使用 <code>SmallVector</code> 需要多留意它可能发生从内部存储到堆上退化时的性能问题。尤其是元素类型本身的拷贝开销比较大时，一个合适的 <code>N</code> 就显得尤为重要。<br>请保证你的设计中，大多数情况下，都不会发生这种拷贝。</p><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>添加和删除元素会带来性能开销，一方面是为了保证顺序性，操作位置之后的元素需要移动位置；另一方面，如果发生向堆的退化或堆内存的重新分配，也会带来性能问题。<br>尽量使用 <code>emplace_back</code> 代替 <code>push_back</code>，以避免不必要的拷贝或移动操作，提高性能。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><p>无。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[LLVM Programmers Manual](<a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h">LLVM Programmer’s Manual — LLVM 21.0.0git documentation</a>)</li><li>[cppreference vector](<a href="https://en.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a>)</li><li>[CHUNer：LLVM 数据结构 - 2.1: llvm::SmallVector 简述 &amp; llvm::SmallVectorBase 类源码详细解析](<a href="https://zhuanlan.zhihu.com/p/16425169155">LLVM 数据结构 - 2.1: llvm::SmallVector 简述 &amp; llvm::SmallVectorBase 类源码详细解析 - 知乎</a>)</li><li><a href="%5B%E7%BC%96%E8%AF%91%E5%99%A8(llvm">CompilerCoder：编译器(llvm)中的数据结构与设计模式</a>中的数据结构与设计模式 - 知乎](<a href="https://zhuanlan.zhihu.com/p/418357950">https://zhuanlan.zhihu.com/p/418357950</a>))</li><li>LLVM 16.0 源码</li><li>LLVM 20.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/28641819827">学习LLVM数据结构-SmallVector - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Chapter.404 大胆提问</title>
    <link href="https://p2tree.top/posts/b2054f60.html"/>
    <id>https://p2tree.top/posts/b2054f60.html</id>
    <published>2025-03-06T23:50:54.000Z</published>
    <updated>2025-03-25T13:24:58.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不要害怕问出愚蠢的问题，因为在大多数情况下，其他人都在思考同样的问题，只是他们不好意思问出口。<br>越早搞懂看起来幼稚问题，就越不会在未来更难以启齿时提出同样的问题。</p><p><img src="https://img.p2tree.top/2025/3/6/Chapter.404.webp" alt="Chapter.404"></p><hr><div class="note primary flat"><p>封面图片来自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/-RobsXstoStQB0ZGpk6qJQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="心理" scheme="https://p2tree.top/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>学习LLVM数据结构：ArrayRef</title>
    <link href="https://p2tree.top/posts/cdf6959f.html"/>
    <id>https://p2tree.top/posts/cdf6959f.html</id>
    <published>2025-02-25T21:35:21.000Z</published>
    <updated>2025-03-25T13:24:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。  </p><p>本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。</p><ol class="series-items"><li><a href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef">学习LLVM数据结构：ArrayRef</a></li><li><a href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector">学习LLVM数据结构：SmallVector</a></li><li><a href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef">学习LLVM数据结构：StringRef</a></li></ol><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>llvm::ArrayRef</code> 定义在 <code>llvm/ADT/ArrayRef.h</code> 头文件中。<br>它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">ArrayRef</span>;</span><br></pre></td></tr></table></figure><p><code>llvm::ArrayRef</code> 是一个轻量级的只读容器，主要用于引用一段连续的内存区域。<br>它的设计目标是提供高效的数据访问，而不需要拥有底层数据的所有权。这使得 <code>ArrayRef</code> 特别适合在函数参数中实用，从而避免了不必要的内存拷贝。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>只读</strong>：<code>ArrayRef</code> 不能修改其引用的数据，也不能添加新元素（另一个容器 <code>MutableArrayRef</code> 可以修改）。</li><li><strong>轻量级</strong>：它只存储一个指向数据的指针和数据的长度，而不存储实际的数据，所以拷贝时非常高效。</li><li><strong>按值传递</strong>：在传递 <code>ArrayRef</code> 时，实际上传递的是一个指针和其指向数据的长度，所以不需要再对其按引用传递。</li><li><strong>操作一致</strong>：它的大多数操作，与 STL array 保持一致。</li></ul><h3 id="与标准库-array-对比"><a href="#与标准库-array-对比" class="headerlink" title="与标准库 array 对比"></a>与标准库 array 对比</h3><ul><li><strong>所有权</strong>：<code>llvm::ArrayRef</code> 不拥有其引用数据的所有权，只是对数据的引用；<code>std::array</code> 拥有数据的所有权，存储在栈上。</li><li><strong>大小</strong>：<code>llvm::ArrayRef</code> 容量是动态的，可以引用任意长度的数组。但由于数组长度是静态的，所以从程序角度看，<code>ArrayRef</code> 的具体引用类型，容量是确定的；<code>std::array</code> 大小在编译期间固定，和 C 数组一样。</li><li><strong>可变性</strong>：<code>llvm::ArrayRef</code> 是只读的，不能修改引用数据；<code>std::array</code> 允许修改其元素，提供完整的读写权限。</li><li><strong>初始化</strong>：<code>llvm::ArrayRef</code> 的初始化更灵活，可以从 C 数组、<code>std::array</code>，<code>std::vector</code> 或其他顺序容器初始化。<code>std::array</code> 只能从初始化列表或在定义时使用构造函数初始化。</li><li><strong>性能</strong>：<code>llvm::ArrayRef</code> 适合在高频传递参数时使用。<code>std::array</code> 默认按值拷贝，会带来开销，需要指定其引用类型作为参数类型。如果是 constexpr 修饰，编译器可以优化传参性能。</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>由于<code>llvm::ArrayRef</code> 只拥有数据的引用，而不管理实际存储的空间，所以它实际上只是一个带有长度的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> T* data = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这里罗列了部分常用的方法，完整列表和实现细节请参考 <code>llvm/ADT/ArrayRef.h</code> 文件代码。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个元素长度 </span></span><br><span class="line"><span class="type">int</span> A1 = <span class="number">1</span>; llvm::ArrayRef Arr1&#123;A1&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化指向一块数据首地址和数据长度 </span></span><br><span class="line"><span class="type">int</span> Ap[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; llvm::ArrayRef Arr2&#123;Ap&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个指针作为区间来初始化 </span></span><br><span class="line"><span class="type">int</span> *Ap2 = Ap + <span class="number">2</span>; llvm::ArrayRef Arr3&#123;Ap, Ap2&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 SmallVector 容器来构造 </span></span><br><span class="line">llvm::SmallVector&lt;<span class="type">int</span>&gt; Vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr4&#123;Vec&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 std::vector 容器来构造 </span></span><br><span class="line">std::vector STLVec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr5&#123;Vec&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 std::array 容器来构造 </span></span><br><span class="line">std::array STLArr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">llvm::ArrayRef Arr6&#123;STLArr&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过初始化列表来构造 </span></span><br><span class="line">llvm::ArrayRef Arr8&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供了迭代器 <code>begin()</code> 和 <code>end()</code> ，以及反向迭代器 <code>rbegin()</code> 和 <code>rend()</code> 。</p><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数据原始位置的操作 </span></span><br><span class="line"><span class="type">const</span> T *data = Arr.<span class="built_in">data</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数据长度的操作 </span></span><br><span class="line"><span class="type">bool</span> IsEmpty = Arr.<span class="built_in">empty</span>(); </span><br><span class="line"><span class="type">size_t</span> Length = Arr.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素 </span></span><br><span class="line"><span class="type">const</span> T&amp; FirstEle = Arr.<span class="built_in">front</span>(); </span><br><span class="line"><span class="type">const</span> T&amp; LastEle = Arr.<span class="built_in">back</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标索引 </span></span><br><span class="line"><span class="type">const</span> T&amp; Ele = Arr[I]; <span class="comment">// assert 检查是否越界</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>提供了 <code>equals(ArrayRef RHS)</code> 方法。<br>另一个语法糖是 <code>operator==</code> 运算符。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取从下标 1 的元素到末尾，作为新的 ArrayRef 返回 </span></span><br><span class="line">llvm::ArrayRef NewArr = Arr.<span class="built_in">slice</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取两端元素 </span></span><br><span class="line">llvm::ArrayRef NewArr2 = Arr.<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪切前/后部分元素，剩余数组作为新的 ArrayRef 返回 </span></span><br><span class="line">llvm::ArrayRef NewArr3 = Arr.<span class="built_in">drop_front</span>(<span class="number">2</span>); </span><br><span class="line">llvm::ArrayRef NewArr4 = Arr.<span class="built_in">drop_back</span>(); <span class="comment">// 默认是 1 个元素</span></span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>使用 <code>llvm::ArrayRef</code> 容器，需要引入 <code>Support</code> 组件，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LLVM_LINK_COMPONENTS Support)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="引用失效"><a href="#引用失效" class="headerlink" title="引用失效"></a>引用失效</h3><p>由于 <code>llvm::ArrayRef</code> 本身是一个引用类型，所以它会面临引用类型作为函数参数时，可能出现的引用失效问题。<br>同理，函数的返回类型不应该是 <code>llvm::ArrayRef</code>，如果返回的是函数局部对象，那么在 Caller 端，该对象引用的原始数据已失效；如果返回的是函数原始参数，这么做又没有意义。<br>另外，如果其引用的是一个动态数组，比如 <code>std::vector</code>，那么当动态数组扩容后，<code>llvm::ArrayRef</code> 引用可能会失效。<br>所以在使用它时，需要时刻思考它的引用对象，什么时候结束生命周期。</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><p><code>llvm::ArrayRef</code> 本身的访问不可能越界，但如果它引用的是一个动态数组，而动态数组的长度发生变化（缩小），那么 <code>ArrayRef</code> 的元素访问可能会发生越界问题。<br>这本质上也是引用失效问题。所以，最好的实践是只引用固定数组，比如用它代替 <code>const std::array &amp;</code> 类型。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>将 <code>llvm::ArrayRef</code> 转换为 <code>std::vector</code> 类型是不建议的操作，它会带来性能开销。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector Vec = Arr.<span class="built_in">vec</span>();</span><br></pre></td></tr></table></figure><p>这里实际上发生了一次数据拷贝。如果希望去修改原始数据，那么传递原始数据的可变引用是更好的做法。当然，也可以使用 <code>llvm::MutableArrayRef</code>，它是可变引用版本的 <code>llvm::ArrayRef</code>。</p><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><code>llvm::MutableArrayRef</code>：可变版本的 <code>llvm::ArrayRef</code>。</li><li><code>llvm::OwningArrayRef</code>：拥有原始数据的 <code>llvm::MutableArrayRef</code>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[LLVM Programmers Manual](<a href="https://llvm.org/docs/ProgrammersManual.html#llvm-adt-arrayref-h">LLVM Programmer’s Manual — LLVM 21.0.0git documentation</a>)</li><li>LLVM 16.0 源码</li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/26306452997">学习LLVM数据结构-ArrayRef - 知乎</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>2025 新的开始</title>
    <link href="https://p2tree.top/posts/e343d97c.html"/>
    <id>https://p2tree.top/posts/e343d97c.html</id>
    <published>2025-02-11T23:00:09.000Z</published>
    <updated>2025-03-25T13:24:58.052Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你的每一次成功，都是将来更棘手问题的入场券。</p><hr><p><img src="https://img.p2tree.top/2025/2/11/Chapter.198.webp" alt="Chapter.198"></p><hr><div class="note primary flat"><p>封面图片生成自豆包 AI。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/HUgkQXf7_MQTINwXuNgOEQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>你会为宝宝存储脐带血吗</title>
    <link href="https://p2tree.top/posts/dd8f25a6.html"/>
    <id>https://p2tree.top/posts/dd8f25a6.html</id>
    <published>2024-12-30T20:02:18.000Z</published>
    <updated>2025-03-25T13:24:58.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1️⃣ 什么是脐带血？<br>孩子出生时，可以从脐带中收集干细胞。干细胞在胎儿和新生儿血液中含量丰富。<br>2️⃣ 为什么收集存储脐带血？<br>脐带血可以为宝宝将来可能发生严重疾病时，用于提供完全匹配的干细胞，不会受到排斥。<br>3️⃣ 有什么坏处？<br>唯一的坏处可能是影响你的存款。<br>存储脐带血是需要初期付费以及之后持续付费的，通常不是很便宜。<br>所以，是否要为宝宝将来可能发生的疾病，而付出这笔费用，是个值得考虑的问题。<br>4️⃣ 有什么建议？<br>是否为宝宝存储脐带血，无所谓对错。疾病发生的概率很低，据统计存储了脐带血最后用到的概率也不高。<br>它就是一份保险，有它很好，但没有人希望会用到它。<br>你只需要考虑你的钱包👛。</p><hr><div class="note info simple"><p>封面图片来自豆包 AI。</p><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s/G1awN8y5AHQStLX8tSQdLQ?token=1029209527&lang=zh_CN">目的地</a> ，欢迎关注</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="育儿" scheme="https://p2tree.top/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Code Review Guide</title>
    <link href="https://p2tree.top/posts/829bc9e8.html"/>
    <id>https://p2tree.top/posts/829bc9e8.html</id>
    <published>2024-12-20T21:37:05.000Z</published>
    <updated>2025-03-25T13:24:58.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇文章是我曾经用于公司内部组织和培训的材料，做脱敏后分享给大家。有关于“是否要做 Code Review”相关的问题，不是本文讨论的重点。</p><p>本文的主要读者是那些需要扮演 Code reviewer 的人，即需要 review 别人代码的人，以提供建议、指导和要求来如何开展 Code review 的工作。</p><p>最后一节是写给 code reporter，比如 PR&#x2F;MR 的 owner。</p><p>下文中以 MR 指代提请 merge 的 code patch 请求。</p><hr><h2 id="1-Principle"><a href="#1-Principle" class="headerlink" title="1 Principle"></a>1 Principle</h2><ul><li>目标：Code review 的主要目的是确保逐步改善代码库的整体质量和健康度。</li><li>负责制：Reviewer 应该对被 review 的 MR 负责。这不一定要规范到流程中，但 reviewer 自身应当有这个意识。</li><li>时效性：Reviewer 应该有责任保障 MR 在 review ready 后，到 MR merge 要足够快速，从而避免延期。</li><li>避免过分严格：Reviewer 应当倾向于批准 MR 通过，只要 MR 能够在某些方面改进代码库的质量，并且代码是有意义的。而不是一味追求代码完美。</li><li>评论：MR 合入前，应当确保已解决所有 review 阶段提出的 comments。Comment 可以拒绝（备注原因并达成一致），但不可以忽略。</li><li>指导性：Code review 对于交流代码实践、设计原则和加深项目理解有益。Comments 可以是指导性的（不要求修改），但请注明 Nit。</li><li>避免个人偏好：基于技术事实讨论，而不是基于主观感受。</li><li>尊重非标准风格：如果 MR 中存在 Coding Style 中没有约束的设计，可以参考代码库现有的类似风格。但不应当强加 reviewer 的主观建议。</li><li>避免冲突：developer 和 reviewer 有冲突时，建议另行讨论，但需要将达成一致的结果记录在 MR 中。可能要有项目 owner 的参与，但要避免 MR 延期。</li><li>用户：Code review 过程中提到的用户，既包括软件的最终用户，也包括其他在相同代码库中进行开发工作的 developer。</li><li>积极的反馈：Reviewer 应当积极响应 review 请求，并给予正向的反馈，以互相激励良好的 Code review 流程。</li></ul><h2 id="2-Review-Point"><a href="#2-Review-Point" class="headerlink" title="2 Review Point"></a>2 Review Point</h2><h3 id="2-1-设计"><a href="#2-1-设计" class="headerlink" title="2.1 设计"></a>2.1 设计</h3><ul><li>代码是否经过精心设计并适合软件系统？</li><li>集成方式是否正确？</li><li>现在合入这个功能是否是正确的时间？</li></ul><h3 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2 功能"></a>2.2 功能</h3><ul><li>代码的行为是否和意图一致？</li><li>实现是否可以匹配需求？</li><li>接口变更（如库函数、外部类）通知到相关人员了吗？变更是否合理？</li><li>是否会引入随机问题？如并行导致的竞争，随机数测试等</li><li>对于无法理解的代码，可以要求 developer 澄清。对于 reviewer 来说，不能快速理解代码是正常的。澄清也会帮助所有 reviewer</li></ul><h3 id="2-3-复杂度"><a href="#2-3-复杂度" class="headerlink" title="2.3 复杂度"></a>2.3 复杂度</h3><ul><li>代码可以调整成更简单的实现吗？</li><li>其他开发人员能否轻松理解并使用这块代码？</li><li>MR 是否可以拆分？不相关的功能避免在一个 MR 中</li><li>绝大多数情况，1 个 MR 只包括 1 个 commit</li></ul><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><ul><li>代码是否带有正确、合理且有用的测试用例？</li><li>紧急情况可以省略测试用例，但之后应当提交专门的测试 MR 补充</li><li>代码仓已有的测试用例需要维护，修改测试用例应当有确切的原因</li></ul><h3 id="2-5-命名"><a href="#2-5-命名" class="headerlink" title="2.5 命名"></a>2.5 命名</h3><ul><li>代码中的变量、类、方法是否有符合项目风格的命名规范？</li><li>名称是否清晰有意义？</li><li>名称是否难以阅读，或和其他名词有歧义？</li></ul><h3 id="2-6-注释"><a href="#2-6-注释" class="headerlink" title="2.6 注释"></a>2.6 注释</h3><ul><li>是否没有必要注释，或是否滥用注释？</li><li>注释是否冗余？是否有错误？（注释需要维护）</li><li>注释不应该用于解释代码的逻辑（代码应该可以自解释）。有些例外，比如正则表达式和复杂算法</li><li>代码的背景、决策思路应当用注释说明</li><li>标记注释很有用，比如 TODO，BUG，FIXME，ISSUE，HACK，WARN，NOTE</li><li>对外的接口函数和接口类，库的头文件，应当有必要的注释说明用法和行为</li></ul><h3 id="2-7-风格"><a href="#2-7-风格" class="headerlink" title="2.7 风格"></a>2.7 风格</h3><ul><li>代码是否满足项目规定的代码风格？</li><li>功能性 MR 不要混合对不相关代码的风格变更。风格变更应另提 MR</li></ul><h3 id="2-8-文档"><a href="#2-8-文档" class="headerlink" title="2.8 文档"></a>2.8 文档</h3><ul><li>代码实现是否需要补充新的设计文档和测试文档？</li><li>是否需要修改现有文档？包括删除已经过时的错误文档</li></ul><h3 id="2-9-上下文"><a href="#2-9-上下文" class="headerlink" title="2.9 上下文"></a>2.9 上下文</h3><ul><li>不要只关注修改的代码，也要关注修改代码的上下文，以提出改善性建议。</li><li>不要容忍微小的破坏系统健康度的 MR，任何系统都是由小的坏的变更而逐渐变差。</li></ul><h3 id="2-10-好的设计"><a href="#2-10-好的设计" class="headerlink" title="2.10 好的设计"></a>2.10 好的设计</h3><ul><li>除了查找 MR 中的问题以外，也要留意其中好的设计</li><li>提交 comments 反馈给 developer，鼓励良好的实践，也促进互相学习</li></ul><h2 id="3-Review-Step"><a href="#3-Review-Step" class="headerlink" title="3 Review Step"></a>3 Review Step</h2><p>刚开始尝试 review 的 new reviewer，可以参考这个 review step。</p><h3 id="3-1-全面了解"><a href="#3-1-全面了解" class="headerlink" title="3.1 全面了解"></a>3.1 全面了解</h3><p>查看 MR commit message，了解 MR 大致要做什么。</p><ul><li>指出不必要的 MR 变更（给予对 developer 充分的尊重）</li><li>指出 commit title 和 message 中的错误和建议</li><li>查看关联 JIRA，了解问题背景</li><li>阅读测试用例，了解 MR 影响了什么。以及检查测试相关的问题</li></ul><h3 id="3-2-主要检查"><a href="#3-2-主要检查" class="headerlink" title="3.2 主要检查"></a>3.2 主要检查</h3><p>查看代码文件的主要内容。</p><ul><li>如果不能快速定位代码的关键部分，请 comment 要求 developer 澄清</li><li>判断 MR 中是否有和当前 MR 无关的内容。比如风格修改，多余功能实现</li><li>review 关键代码的设计</li><li>发现问题时请立即 comment，避免 developer 基于问题已经在做更多工作</li></ul><h3 id="3-3-次要检查"><a href="#3-3-次要检查" class="headerlink" title="3.3 次要检查"></a>3.3 次要检查</h3><p>在主要内容没有意见之后，检查其他代码。</p><ul><li>按照文件顺序重新浏览所有变更。</li><li>检查注释，命名规范等细节。</li><li>检查代码风格是否符合规定。</li><li>检查是否需要提供或变更文档。</li></ul><h2 id="4-Efficiency"><a href="#4-Efficiency" class="headerlink" title="4 Efficiency"></a>4 Efficiency</h2><p>Reviewer 应该尽快响应 MR 的 Code review 工作。</p><p>通常我们也希望 review 的过程足够快，也就是尽快 merge 代码，但这建立在很多因素的基础上。</p><h3 id="4-1-review-低效的问题"><a href="#4-1-review-低效的问题" class="headerlink" title="4.1 review 低效的问题"></a>4.1 review 低效的问题</h3><ul><li>降低团队效率。很多工作是基于当前 MR 展开的，MR 的 merge 过慢会阻塞其他开发工作</li><li>抱怨流程。review 流程会被抱怨，甚至对 reviewer 个人的抱怨，这会让团队成员的开发积极性受到挫败</li><li>代码健康度。developer 提交的其他 MR 可能会因此变得庞大、冗余，从而影响代码仓的质量</li></ul><h3 id="4-2-review-应该有多快"><a href="#4-2-review-应该有多快" class="headerlink" title="4.2 review 应该有多快"></a>4.2 review 应该有多快</h3><ul><li>Reviewer 的响应时间应该在 1 天内</li><li>Reviewer 应该立即响应 developer 主动要求的 Code review，这是 Reviewer 的职责</li><li>Reviewer 应该在每天都找一个时间，对仓库中所有 MR 进行 review</li><li>通常一个 MR 会经过多次 review，developer 也希望当天能得到多次 review</li><li>对于跨时区的 reviewer 和 developer，reviewer 应该在 developer 第二天上班前完成审查，并可以利用带评论的 LGTM</li></ul><h3 id="4-3-权衡"><a href="#4-3-权衡" class="headerlink" title="4.3 权衡"></a>4.3 权衡</h3><p>Review 请求会打断 Reviewer 自己的工作流，所以需要权衡。但通常还是需要积极响应主动请求。</p><ul><li>选择在 Reviewer 自己的工作中断点 review 代码。比如构建代码时、午餐晚餐前后</li><li>如果没有时间，也应该对 developer 给予快速反馈，并建议其他 reviewer</li><li>可以提供一些初步 comments，并提出 need change</li><li>但不要为了快速 review，而妥协了代码质量和标准。记住，reviewer 要对自己的每一笔 review 负责</li></ul><h3 id="4-4-大型-MR"><a href="#4-4-大型-MR" class="headerlink" title="4.4 大型 MR"></a>4.4 大型 MR</h3><p>如果 MR 的代码量比较多。预估 review 的时间会超过 20 分钟。</p><ul><li>尝试和 developer 沟通，是否可以精简 MR</li><li>如果无法精简 MR，尝试请 developer 提交 Code review 会议，集体做 review。developer 需要现场阐述 MR 的设计和细节</li></ul><h3 id="4-5-紧急-MR"><a href="#4-5-紧急-MR" class="headerlink" title="4.5 紧急 MR"></a>4.5 紧急 MR</h3><p>紧急 MR 比如：</p><ul><li>确定性的 commit revert</li><li>修复影响最终用户生产的错误</li><li>有 ETA 要求的功能，在即将到达 ETA 前</li><li>法律问题相关</li><li>明确的系统安全漏洞</li></ul><p>看似紧急但不紧急的 MR 比如：</p><ul><li>想赶在周末前合入，下周能开展新工作</li><li>跨时区的 review</li><li>commit revert 之后，导致的新问题</li></ul><p>紧急 MR 应该这么做：</p><ul><li>优先关注 review 过程的速度</li><li>先确保正确性，其他 review 发现的问题，如格式、测试用例等，可以要求 developer 之后补充 MR 修改</li><li>紧急 MR 合入后，应当再次对该 MR 做细致的 review，并要求 developer 补充</li><li>让所有项目组成员了解紧急 MR 的合入事件，并明确可能带来的风险</li></ul><p>尽量避免发生紧急 MR，这也有 PM 的责任，处理紧急 MR 应该极力避免项目积累技术债务。</p><h2 id="5-Comments"><a href="#5-Comments" class="headerlink" title="5 Comments"></a>5 Comments</h2><p>提交 Code review comments 也需要 reviewer 注意。</p><h3 id="5-1-保持友善"><a href="#5-1-保持友善" class="headerlink" title="5.1 保持友善"></a>5.1 保持友善</h3><p>不必说，在工作沟通中，都应该尽可能注意自己的措辞会给对方带来的压力和抵触，尤其是在挑别人毛病的时候。</p><h3 id="5-2-技术性解释"><a href="#5-2-技术性解释" class="headerlink" title="5.2 技术性解释"></a>5.2 技术性解释</h3><p>提供更多的技术性解释，来说明你的疑问或顾虑，比单纯的抛出问题更有利于 developer 处理。</p><h3 id="5-3-指导性-comment"><a href="#5-3-指导性-comment" class="headerlink" title="5.3 指导性 comment"></a>5.3 指导性 comment</h3><p>reviewer 虽然并没有义务帮助 developer 提供新的解决方案，但这并不意味着 reviewer 对提高 MR 的代码质量没有作用。</p><p>reviewer 可以适度的提供自己的建议方案，这通常有利于互相学习和加深对软件系统的理解。</p><p>毕竟，code review 的第一目标是保障代码质量，第二目标是提高软件开发人员的技能。</p><h3 id="5-4-解释性请求"><a href="#5-4-解释性请求" class="headerlink" title="5.4 解释性请求"></a>5.4 解释性请求</h3><p>对于不能快速理解的 MR，可以请求 developer 阐述 MR 中的主要内容和关键代码。</p><p>同时，对于 developer 提出的问题，reviewer 也应该给予充分的解释。</p><p>通常来说，请求解释无可厚非，这并不代表着 reviewer 个人水平如何。只有 developer 自己对自己编写的代码最熟悉。更充分的解释也有助于其他 reviewer 的 review 工作。</p><h3 id="5-5-同步线下的讨论"><a href="#5-5-同步线下的讨论" class="headerlink" title="5.5 同步线下的讨论"></a>5.5 同步线下的讨论</h3><p>很多时候，在 review 过程中，可能 reviewer 和 developer 会线下（或者线上 1 by 1 会议）讨论 MR 的细节。这是没问题的。</p><p>但需要在讨论结束后，将讨论的主要结论同步在 MR 中，以方便其他 reviewer 阅读和了解 review 的过程。</p><p>当然，也有助于将来回溯 MR 合入过程中的细节。</p><h3 id="5-6-Nit"><a href="#5-6-Nit" class="headerlink" title="5.6 Nit"></a>5.6 Nit</h3><p>Nit 是指 review 过程中，发现的一些小的，无关紧要的问题，reviewer 并不要求必须在当前 MR 做修改。</p><p>Nit 是重要的，鼓励 reviewer 和 developer 在 code reviewer 时多使用。</p><p>可能使用 Nit 的地方：</p><ul><li>注释和变量中的小错误，比如语法错误和拼写错误。</li><li>不易理解的一些符号。</li><li>可以将代码提炼和改善的地方。</li><li>冗余的注释说明。</li><li>reviewer 认可当前方案，但想分享他建议的更好方案。</li></ul><h2 id="6-冲突"><a href="#6-冲突" class="headerlink" title="6 冲突"></a>6 冲突</h2><p>Code review 的过程中，很容易对一些技术细节产生不同的观点。应当避免持续冲突影响了 MR 的合入效率。</p><ul><li>讨论时，要始终注意自己的措辞是否会伤害到对方</li><li>developer 通常对代码的细节，包括项目的细节，比 reviewer 了解更多和详细</li><li>讨论不应该过于频繁。应该留出独立思考的时间</li><li>如果代码存在严重问题，则 reviewer 不能妥协让步</li><li>无论什么时候，都应该对事不对人</li><li>避免妥协 “之后再处理” 的措辞。时间过的越久，“之后再处理” 就越不可能发生。（紧急 MR 例外）</li><li>如果 developer 一定坚持 “之后再处理”，那么要有 JIRA 跟踪，以避免后续遗忘。同时，代码中应当留下充分的解释，如 TODO 注释</li></ul><h2 id="7-MR-建议"><a href="#7-MR-建议" class="headerlink" title="7 MR 建议"></a>7 MR 建议</h2><p>本节内容是写给任何需要扮演 developer 角色的人员，提供一个开发代码和提交 MR 的实践指导。</p><h3 id="7-1-重视-MR-message"><a href="#7-1-重视-MR-message" class="headerlink" title="7.1 重视 MR message"></a>7.1 重视 MR message</h3><p>MR message 并不只是一个标题。不要省略详情内容，这是很不负责任的。</p><p>MR message 应当和 git commit message 保持一致，有利于回溯问题。</p><p>MR message 中应该包括典型的关键字，按照不同仓库的要求，这些关键字可能写在标题行，也可能写在详情文本中。这些关键字通常会作为将来检索相关内容的依据。</p><p>避免拼写错误和语法错误。</p><p>以下是一些具体说明：</p><p>标题行：</p><ul><li>简洁地描述 MR 做了什么</li><li>注意格式要求，比如不要超出格式要求的宽度、首字母大写且行尾不加标点</li><li>标题行要添加必要的关键字（遵从仓库规则）。如 llvm 中会使用 [ARM]，[MIPS] 来标注 MR 的类型</li><li>尽量避免笼统地总结 MR。比如一个反例：”Fix a bug of mma“。应该让其他人通过标题了解到 MR 独特的地方</li></ul><p>详情文本：</p><ul><li>应该包括对问题的详细描述、为什么要做这个事情、为什么用这种方法</li><li>还要包括需求背景和 JIRA 链接</li><li>如果需要，还可以包括目前方法的缺陷分析、未来计划、基准测试状态以及设计文档位置</li></ul><h3 id="7-2-尽可能小的-MR"><a href="#7-2-尽可能小的-MR" class="headerlink" title="7.2 尽可能小的 MR"></a>7.2 尽可能小的 MR</h3><p>一个 MR 应该只解决一个事情。小的 MR 会有很多优点：</p><ul><li>Code review 更快。这体现在 reviewer 可以更快的理解代码和排查可能存在的问题。当然也更容易得到 approve</li><li>大的 MR 会审查不彻底（人的惰性使然），对 reviewer 的要求也更高。小 MR 更容易发现问题</li><li>被 Disapproved 之后，调整更方便</li><li>合入更方便，不容易和其他 MR 产生冲突</li><li>如果意外需要 revert，也会更方便，带来的影响会更小</li><li>编写小型 MR 也有助于 developer 梳理软件逻辑</li></ul><p>多大代码量的 MR 算小型 MR 通常由代码仓的特征和所有 developer 和 reviewer 的大致判断决定，但通常几千行的 MR 就不能算小型 MR。（人脑的缓存通常也只能记忆这么多代码来完成 review）</p><h3 id="7-3-可以接受的大-MR"><a href="#7-3-可以接受的大-MR" class="headerlink" title="7.3 可以接受的大 MR"></a>7.3 可以接受的大 MR</h3><p>有些情况下，大型 MR 也能接受，如：</p><ul><li>增加或删除一个文件的完整代码</li><li>对某个相同特征的问题，在很多位置做修改</li><li>仓库初始配置</li></ul><p>一个大型 MR 通常需要更多的时间和精力来 review，也会需要额外开展 Code review meeting 进行集体 review。</p><p>所有 reviewer 和与 MR 相关的 developer 都应当明确 MR merge 可能带来的风险和对项目的影响。</p><h3 id="7-4-测试用例"><a href="#7-4-测试用例" class="headerlink" title="7.4 测试用例"></a>7.4 测试用例</h3><p>大多数功能性的 MR 的合入都应该配有测试用例。避免后续补充测试用例的做法。</p><p>可以有单独的测试用例作为独立 MR 合入，但这些用例应该是对之前已存在代码的一个测试补充或对测试代码的整体重构。</p><p>以下情况可以接受没有测试用例：</p><ul><li>紧急 MR 可以不添加测试用例，但紧急情况处理完毕后，应该额外提交测试用例 MR</li><li>格式调整、文档修改等 MR</li><li>可解释的其他不添加测试用例的情况，经 reviewer 接受</li></ul><h3 id="7-5-不能破坏构建"><a href="#7-5-不能破坏构建" class="headerlink" title="7.5 不能破坏构建"></a>7.5 不能破坏构建</h3><p>任何一个 MR 都应该是自完备的。它不能破坏代码仓的构建。</p><p>如果有几个相互依赖的 MR，也应该确保找到一种方法，让每个 MR 都能通过构建。功能可以不完备，但构建不能 fail。</p><p>另外，CI 的测试应该要保障不出现这种问题。</p><h3 id="7-6-回复-Comments"><a href="#7-6-回复-Comments" class="headerlink" title="7.6 回复 Comments"></a>7.6 回复 Comments</h3><p>永远记得 Code review 的目的是提高整个代码库的质量。当看到 comment 时，先控制自己反对的冲动（这种冲动其实是人之常情），想想为什么有这个 comment。</p><p>保持礼貌和感激。reviewer 也会做到这一点。</p><p>尝试澄清代码，以对 reviewer 有疑问的地方展开解释。并且也应该主动思考自己的代码为什么没有被其他人所轻易理解，并尝试改进。</p><p>Developer 也可以要求 reviewer 澄清他们的 comment。</p><p>可能会需要解决冲突，请参见上文 <strong>冲突</strong> 小节。</p><h3 id="7-7-JIRA-同步"><a href="#7-7-JIRA-同步" class="headerlink" title="7.7 JIRA 同步"></a>7.7 JIRA 同步</h3><p>除了在 MR message 中添加 JIRA 链接外，也应该在 JIRA 页面添加 MR 链接。或者使用 CI&#x2F;CD 系统自动完成双链。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/13742893417">Code Review Guide - P2Tree@zhihu.com</a></p><p>文章标题图使用豆包 AI 生成。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="高效编程" scheme="https://p2tree.top/tags/%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B/"/>
    
    <category term="软件工程" scheme="https://p2tree.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：活着</title>
    <link href="https://p2tree.top/posts/dc0bdc19.html"/>
    <id>https://p2tree.top/posts/dc0bdc19.html</id>
    <published>2024-12-15T20:16:05.000Z</published>
    <updated>2025-03-25T13:24:58.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/12/15/book.51.webp" alt="book.51"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/hhBc47ZA4v86a4YOQCZj3Q">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="与生活妥协" scheme="https://p2tree.top/tags/%E4%B8%8E%E7%94%9F%E6%B4%BB%E5%A6%A5%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git果壳：什么是版本控制</title>
    <link href="https://p2tree.top/posts/86730351.html"/>
    <id>https://p2tree.top/posts/86730351.html</id>
    <published>2024-11-24T22:29:12.000Z</published>
    <updated>2025-03-25T13:24:58.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“Git 菜谱” 系列文章：</p><ol class="series-items"><li><a href="/posts/86730351.html" title="Git果壳：什么是版本控制">Git果壳：什么是版本控制</a></li></ol><hr><blockquote><p>©️ 本文演绎自 Atlassian 编写的 <a href="https://www.atlassian.com/git/tutorials/what-is-version-control"><em>What is version control</em></a>。页面上所有内容采用知识共享-署名（<a href="http://creativecommons.org/licenses/by/2.5/au/deed.zh">CC BY 2.5 AU</a>）许可协议。</p></blockquote><h3 id="版本控制的优点"><a href="#版本控制的优点" class="headerlink" title="版本控制的优点"></a>版本控制的优点</h3><p>版本控制系统是软件工具的一个类别，它可以辅助软件开发团队管理软件代码随着时间的更改。版本控制软件可以通过特殊的数据库来追踪代码的每一次变更。如果软件开发中发生错误，开发者可以利用版本控制来将代码和早期的版本做对比，从而能够以对其他团队成员干扰最小的前提下修复错误。</p><p>对于几乎所有的软件工程来说，软件源代码就是最重要的部分（<em>译注：原文比喻为皇冠上的宝石，也就是最需要保护的珍宝</em>）。对于大多数软件团队，源代码仓库是他们认真努力积累和完善的宝贵知识财富的存储库，而版本控制可以保护源代码免受灾难性的破坏以及人为操作失误或故意破坏。</p><p>软件开发人员工作过程中会持续性的产出新的代码以及修改已经存在的代码。一个工程软件、应用软件或者软件组件通常被组织在一个文件夹或者说一个目录树中。团队中的一个开发者可能在增加一个新特性，而另一个开发者可能在修复不相关的bug，每一个开发者都在这个目录树的不同位置对代码内容进行着更改。</p><p>版本控制可以帮助软件团队解决这样的问题，追踪每一个开发者产生的每一个独立的变更，以及帮助预防并发工作中的冲突。并发工作的冲突是指软件一部分的修改可能与另一个开发者同时的修改不兼容。这个问题应该有条不紊的被发现和解决，从而不能影响团队其他成员的工作。此外，在软件开发中，任何更改都有可能引入新的 bugs，故而在测试之前，新的软件版本不能被完全信任，所以直到新版本发布之前，测试和开发的进程都应该同时被执行。</p><p>好的版本控制软件可以支持开发者首选的工作流程，而不会强加一种特别的工作方式。理想情况下，它应该能在任何平台上工作，而不是特别要求开发者必须使用某种操作系统或者工具链。好的版本控制系统可以促进代码变更平稳连续的进行，而不是使用将文件锁定的这种糟糕而笨拙的机制（这是指某个文件只允许一名开发人员工作，而阻止其他开发人员开发）</p><p>不使用任何版本控制的软件团队经常会遇到一些问题，比如不知道已经完成的哪些变更可以被用户使用，或者在两个不相关的工作内容之间创建了互不兼容的更改，然后必须进行繁琐的整理和重做。如果你是一个从未使用过版本控制的开发者，你可能会这样命名你的不同版本的文件，比如加一个“最终版”或“最新版”的文件名后缀，然后不得不之后再处理新的最终版本。也许你会为了禁用某个功能但不愿删除代码，因为害怕代码未来还将会用到而注释掉代码块。版本控制可以解决如上这些问题。</p><p>版本控制软件是现代软件团队日常开发中必不可少的一部分。习惯于团队中使用功能强大的版本控制系统的软件开发人员会显然意识到版本控制所带来的不可思议的价值，即使是在小型项目中也是如此。一旦习惯了版本控制系统的强大优势，很多开发者就不再考虑去做没有版本控制支持的工作，即使是完成非软件开发的工作。</p><h3 id="版本控制系统的优点"><a href="#版本控制系统的优点" class="headerlink" title="版本控制系统的优点"></a>版本控制系统的优点</h3><p>开发软件时不使用版本控制系统是危险的，比方说没有做备份。版本控制也能允许开发人员更灵活的人员变动，允许软件团队在团队规模扩大时保持高效率和敏捷性。</p><p>版本控制系统（<code>Version Control System</code>,<code>VCS</code>）在过去的几十年内取得了非常大的进步，并且有些更为突出。有些时候被称作代码管理工具（<code>Source Code Management</code>,<code>SCM</code>）或者修订控制系统（<code>Revision Control System</code>,<code>RCS</code>）。其中一个很流行的版本控制工具叫做 Git，它是一个分布式的版本控制系统（<code>Distributed VCS</code>,<code>DVCS</code>），之后会详细介绍。就像很多现在流行的版本控制系统一样，Git 是自由的也是开源的。不管它们叫什么名字，又或者是什么系统使用，版本控制系统主要的优点有以下几点。</p><ol><li><strong>记录每一个文件的完整的长期的变更历史</strong>。这意味着它能记录长期以来每一个贡献者提交的每一个变更。这些变更包括文件的创建、删除以及内容修改。<em>不同的 VCS 工具的一个区别在于它们处理重命名和移动文件的能力</em>。每次变更将包括作者名、时间和每一次修改的纪要。具有完整的历史可以允许我们退回到之前的版本中，从而帮助分析 bugs，当需要在旧版本中修复软件问题时，这确实很重要。如果正在积极开发一个软件，则几乎所有的内容都将被看做这个软件的旧版本。<em>译注：因为软件更新快，原文旨在说明旧版本不是你想象中的那么“旧”。</em></li><li><strong>分支和合并特性</strong>。这些特性可以让团队协作工作更加便捷，也可以让独立工作的开发者能从中受益。在 VCS 工具中创建一个分支可以维持多个独立的开发工作流，同时也提供了将这些工作合并回去的功能，能允许开发者验证分支之间的变更是否冲突。很多软件团队使用独立分支来开发特性或者是维护一个版本，或者两者都有。软件团队可以利用分支和合并特性来选择不同的工作方式。</li><li><strong>可追溯性</strong>。能够追踪软件的每一次变更，进而可以让其能够搭配工程管理系统和 bug 追踪软件，比如 <a href="https://www.atlassian.com/software/jira">Jira</a>。可以通过消息来描述变更的目的和意图，从而注释每一次变更，这样不但能有助于关键问题分析也可协助其他的检查工作。在阅读代码，或尝试理解代码作用和设计意图时，这样的代码描述历史消息可以帮助开发者做出正确的和相匹配的修改，能够与系统预期的长期设计思想相符合。这种方式对于在遗留代码上高效工作是非常重要的，对于开发人员准确估计未来工作也是非常重要的。</li></ol><p>当然，不使用版本控制系统来开发软件也是可行的，但是这样的工程具有很大的风险，任何专业的开发团队都不会愿意接受。所以问题并不会在于是否使用版本控制系统，而是使用哪种版本控制系统。</p><p>这会有多种选择，但这里的教程我们专注于 Git。从<a href="https://bitbucket.org/product/version-control-software?_ga=2.63967023.1846059181.1575290049-386918931.1575091845">这里</a>可以了解到其他的版本控制软件。</p><hr><div class="note info flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@nganduong93?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Duong Ngan</a> on <a href="https://unsplash.com/photos/a-white-table-topped-with-white-christmas-trees-dTBhA3zP3yA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="译文" scheme="https://p2tree.top/tags/%E8%AF%91%E6%96%87/"/>
    
    <category term="Git" scheme="https://p2tree.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>他们</title>
    <link href="https://p2tree.top/posts/b5919f86.html"/>
    <id>https://p2tree.top/posts/b5919f86.html</id>
    <published>2024-11-19T22:53:22.000Z</published>
    <updated>2025-03-25T13:24:58.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>0 到 3 岁，你是他们的全部；<br>3 到 7 岁，你是他们的晚上；<br>7 到 18 岁，你是他们的周末；<br>18 到 22 岁，你是他们的寒暑假；<br>之后，你是他们的春节。</p><hr><p><img src="https://img.p2tree.top/2024/11/19/Chapter.401.webp" alt="Chapter.401"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，秋天、老照片和时光流逝。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/YPAAsZC_tWvoecqUv01Azg">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="诗" scheme="https://p2tree.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>开始阅读很多的书，但读完很少的书</title>
    <link href="https://p2tree.top/posts/1da6b0bc.html"/>
    <id>https://p2tree.top/posts/1da6b0bc.html</id>
    <published>2024-11-03T20:25:40.000Z</published>
    <updated>2025-03-25T13:24:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>阅读应追求对自身产生的影响，若仅仅是为读完而读，那实则毫无意义。</p><p>读书与实践相关，有人开始时会阅读大量书籍，但真正读完的却寥寥无几。读书就如同结识朋友，如果感觉不适，便可放弃。即便某本书在他人眼中是佳作，但只要对自己无益，就没必要去读。因为时间有限，在相同的时间里，我们当然更希望阅读一本对自己有帮助且能吸引自己的书。</p><p>清理书单最快的方法，不是把书读完，而是将它们从书单中删除。</p><hr><p><img src="https://img.p2tree.top/2024/11/03/Chapter.89.webp" alt="Chapter.89"></p><hr><div class="note primary flat"><p>封面图片是由豆包 AI 生成的图片，一只阅读的花栗鼠。</p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/XEIIGx4FP8gRGfmWUC4EKA">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="学习方法" scheme="https://p2tree.top/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读书推荐：宝贵的人生建议</title>
    <link href="https://p2tree.top/posts/2626ad0e.html"/>
    <id>https://p2tree.top/posts/2626ad0e.html</id>
    <published>2024-10-27T17:09:22.000Z</published>
    <updated>2025-03-25T13:24:58.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.p2tree.top/2024/10/27/book.49.webp" alt="book.49"></p><hr><div class="note info flat"><p>转载自我自己的微信公众号<a href="https://mp.weixin.qq.com/s/Y337qOZMNBw4UqbBhUC-ww">文章</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="好书推荐" scheme="https://p2tree.top/categories/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="个人发展" scheme="https://p2tree.top/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>死亡搁浅配乐收藏</title>
    <link href="https://p2tree.top/posts/a28b3899.html"/>
    <id>https://p2tree.top/posts/a28b3899.html</id>
    <published>2024-10-24T23:07:57.000Z</published>
    <updated>2025-03-25T13:24:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《死亡搁浅》是我玩过的游戏中，音乐和配乐设计最为出色的一款作品。它的音乐完全可以独立于游戏本身享受，玩家无需具备游戏体验也能轻松欣赏其中的旋律。这些歌曲展现了极强的亲和力和感染力，每一曲都令人陶醉。游戏中恰到好处的配乐增强了玩家的沉浸感，使人愈加沉迷于其中。音乐在这款游戏中的地位不可忽视，成为了推动体验的重要元素。</p><p>推荐收听：</p><ul><li>Don’t Be So Serious：Death Stranding，一个讲述有关离别、联结和自我接纳的故事</li><li>Bones：第一次踏上旅程，面对恬静广阔的自然景观，音乐声恰好响起</li><li>BB’s Theme：最后一次走出首都节点城，再一次被音乐震撼，“我，是你吗？”</li><li>I’ll Keep Coming：面对挫折后，能否在心底保留希望，继续前行</li><li>Death Stranding：当明知注定会失去一切时，还会满怀激情，走向故事的结尾吗？</li></ul><hr><p><strong>[ 点击图标可以在线播放 ]</strong></p>        <div id="aplayer-sbSDfVYe" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#99988D","preload":"metadata","listmaxheight":"513px","music":[{"title":"Almost Nothing","author":"Silent Poets、Okay Kaya","url":"https://music.p2tree.top/death_strandling/Almost%20Nothing%20-%20Silent%20Poets%E3%80%81Okay%20Kaya.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Almost%20Nothing%20-%20Silent%20Poets%E3%80%81Okay%20Kaya.lrc"},{"title":"Anything You Need","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Anything%20You%20Need%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Anything%20You%20Need%20-%20Low%20Roar.lrc"},{"title":"Asylums for the Feeling","author":"Silent Poets、Leila Adu","url":"https://music.p2tree.top/death_strandling/Asylums%20for%20the%20Feeling%20-%20Silent%20Poets%E3%80%81Leila%20Adu.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Asylums%20for%20the%20Feeling%20-%20Silent%20Poets%E3%80%81Leila%20Adu.lrc"},{"title":"BB's Theme","author":"Ludvig Forssell、Jenny Plant","url":"https://music.p2tree.top/death_strandling/BB's%20Theme%20-%20Ludvig%20Forssell%E3%80%81Jenny%20Plant.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/BB's%20Theme%20-%20Ludvig%20Forssell%E3%80%81Jenny%20Plant.lrc"},{"title":"Because We Have To","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Because%20We%20Have%20To%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Because%20We%20Have%20To%20-%20Low%20Roar.lrc"},{"title":"Bones","author":"Low Roar、Jofridur Akadottir","url":"https://music.p2tree.top/death_strandling/Bones%20-%20Low%20Roar%E3%80%81Jofridur%20Akadottir.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Bones%20-%20Low%20Roar%E3%80%81Jofridur%20Akadottir.lrc"},{"title":"Breathe In","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Breathe%20In%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Breathe%20In%20-%20Low%20Roar.lrc"},{"title":"Death Stranding","author":"CHVRCHES","url":"https://music.p2tree.top/death_strandling/Death%20Stranding%20-%20CHVRCHES.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Death%20Stranding%20-%20CHVRCHES.lrc"},{"title":"Don't Be So Serious","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Don't%20Be%20So%20Serious%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Don't%20Be%20So%20Serious%20-%20Low%20Roar.lrc"},{"title":"Easy Way Out","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Easy%20Way%20Out%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Easy%20Way%20Out%20-%20Low%20Roar.lrc"},{"title":"Give Up","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Give%20Up%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Give%20Up%20-%20Low%20Roar.lrc"},{"title":"Gosia","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Gosia%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Gosia%20-%20Low%20Roar.lrc"},{"title":"I'll Keep Coming","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/I'll%20Keep%20Coming%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/I'll%20Keep%20Coming%20-%20Low%20Roar.lrc"},{"title":"I'm Leaving","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/I'm%20Leaving%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/I'm%20Leaving%20-%20Low%20Roar.lrc"},{"title":"Not Around","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Not%20Around%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Not%20Around%20-%20Low%20Roar.lrc"},{"title":"Once in a Long, Long While…","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Once%20in%20a%20Long%2C%20Long%20While%E2%80%A6%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Once%20in%20a%20Long%2C%20Long%20While%E2%80%A6%20-%20Low%20Roar.lrc"},{"title":"Patience","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Patience%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Patience%20-%20Low%20Roar.lrc"},{"title":"Please Don't Stop (Chapter 1)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%201)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%201)%20-%20Low%20Roar.lrc"},{"title":"Please Don't Stop (Chapter 2)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%202)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Please%20Don't%20Stop%20(Chapter%202)%20-%20Low%20Roar.lrc"},{"title":"Pop Virus","author":"星野源","url":"https://music.p2tree.top/death_strandling/Pop%20Virus%20-%20%E6%98%9F%E9%87%8E%E6%BA%90.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Pop%20Virus%20-%20%E6%98%9F%E9%87%8E%E6%BA%90.lrc"},{"title":"Poznań","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Pozna%C5%84%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Pozna%C5%84%20-%20Low%20Roar.lrc"},{"title":"Rolling Over","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Rolling%20Over%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Rolling%20Over%20-%20Low%20Roar.lrc"},{"title":"St. Eriksplan","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/St.%20Eriksplan%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/St.%20Eriksplan%20-%20Low%20Roar.lrc"},{"title":"The Machine","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/The%20Machine%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/The%20Machine%20-%20Low%20Roar.lrc"},{"title":"Tonight, Tonight, Tonight","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Tonight%2C%20Tonight%2C%20Tonight%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Tonight%2C%20Tonight%2C%20Tonight%20-%20Low%20Roar.lrc"},{"title":"Waiting (10 Years)","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Waiting%20(10%20Years)%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Waiting%20(10%20Years)%20-%20Low%20Roar.lrc"},{"title":"Without You","author":"Low Roar","url":"https://music.p2tree.top/death_strandling/Without%20You%20-%20Low%20Roar.mp3","pic":"https://img.p2tree.top/2024/10/26/pic.webp","lrc":"https://music.p2tree.top/death_strandling/Without%20You%20-%20Low%20Roar.lrc"}]};  options.element = document.getElementById("aplayer-sbSDfVYe");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><hr><div class="note primary flat"><p>音乐资源来自网络，若存在侵权，请联系我删除。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="音乐" scheme="https://p2tree.top/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
    <category term="音乐" scheme="https://p2tree.top/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>C++20 特性杂谈</title>
    <link href="https://p2tree.top/posts/49819b87.html"/>
    <id>https://p2tree.top/posts/49819b87.html</id>
    <published>2024-10-20T20:31:41.000Z</published>
    <updated>2025-03-25T13:24:58.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 的发展方向最重要的就是 C++ 标准委员会的统一决策，这种从不同行业、公司、国家和组织中集合的一群人，能达成共识并推出一些有价值的成果，已经非常难得。然而，C++ 仍然因此和其他新兴语言之间产生了差距。</p><p>C++ 标准的一种最重要的宗旨就是确保 C++ 在更新的过程中，看起来还是同一个语言，所以它需要满足一种统一的演化标准。这些标准概括起来有：</p><ul><li>基于过去已有的成功模式作为演化方向，比如 RAII、类型安全检查</li><li>简单的事情用简单的方法做</li><li>从代码到硬件的零开销原则和直接映射</li><li>基于意见反馈来发展</li><li>保持稳定性和兼容性</li><li>维持与硬件的直接映射，简单的抽象机制，最小化的运行时系统</li></ul><p>然而，过去很长一段时间，C++ 标准委员会都只专注于编程语言特性和标准库的方向，而没有在语言工具链方面做额外的事情，比如构建系统、包管理、链接原则等方面，这导致了 C++ 语言没有标准统一的开发和运行环境，每个操作系统、平台，甚至编程框架都可以规定自己的开发模式，各自为政。相关的软件也都依赖第三方企业或开源社区维护，用法和实现五花八门，没有统一标准的指导方针。</p><p>说回 C++20，这一次标准版本是可以和 C++11 不相上下的发布，其中包括了好几个大型特性，比如模块、概念、协程。C++20 对 C++ 的影响可以说又是改头换面的。</p><hr><p>本文是 C++ 特性杂谈系列文章的第四篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="模块"><a href="#模块" class="headerlink" title="# 模块"></a># 模块</h2><p>模块用来替代之前 C++ 中的头文件机制。</p><p>头文件引入的机制存在一些明显的缺点，已经饱受诟病：</p><ul><li>头文件的引入只是通过宏对代码的直接展开，不同头文件中的代码相互之间可见，可能发生名字冲突问题，不同头文件的来源不同，很难做到统一和安全。</li><li>已经有太多的代码被放入头文件中。过去 C++ 继承 C 的头文件机制时，头文件中只会放一些 export 的函数声明，但现在，一个工程中大于 90% 的代码都在头文件中。</li><li>常见的头文件可能在其他文件中被 include 很多次，虽然有避免重复编译的头文件宏，但依然无法阻止预处理器一遍又一遍的展开这些重复的 include 文件代码。这导致编译效率降低。</li></ul><p>模块机制的优势是：</p><ul><li>同一个模块，编译器只需要处理一次，这会一定程度上减少编译时间</li><li>避免了不同头文件中可能存在的名字冲突</li><li>模块中区分导出的符号和内部符号，只保留必要的接口，保证了实现上的封装性</li><li>编译过程中的代码整洁很多，只会引入被调用的符号，没有调用但也被暴露出来的符号不会被编译</li></ul><p>之后，标准委员会最大的困难便是如何兼容过去的 include 机制与新引入的模块机制，最后应该是基本解决了。模块的引入方式可以做到比头文件的引入方式在编译上快一个数量级。</p><p>模块的引入，不可避免地会彻底改变 C++ 代码的导入导出方式，对过去几十年人们已经在头文件系统上做过的大量工作来说，是一个明显的冲击。但理念和技术都在发展进步，有些东西确实只能被时代抛弃。</p><p>虽然模块是 C++20 中的一个正式特性，但因为特性比较复杂，存在对旧代码的影响，所以目前（2024年9月）编译器（比如 gcc）还是需要用额外的参数来指定启用该功能，编译器实现也有可能存在 bug 和不完善。未来编译器实现稳定之后，编译参数会被取消。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c+<span class="number">+20</span> -fmodules-ts -o main main.cpp math_module.cppm</span><br><span class="line">clang++ -std=c+<span class="number">+20</span> -fmodules -o main main.cpp math_module.cppm</span><br></pre></td></tr></table></figure><p>后缀 <code>.cppm</code> 是标准规定的后缀形式，但编译器并不强依赖后缀来区分模块文件。</p><h2 id="协程"><a href="#协程" class="headerlink" title="# 协程"></a># 协程</h2><p>协程是一种比线程更高效的并发机制。看似是一种很新的概念，但实际上，协程在 C++最初版本中就存在，当时利用协程来实现一个任务库，进而支持一些常见算法的仿真。然而，由于实现比较丑陋，移植性差，在后来的 C++98 版本中，没有继续支持，直到 C++20 中才重新实现。</p><p>如果你还不了解协程，我简单介绍一下。协程就是用户态的线程，多个协程运行在同一个线程上，通过用户程序控制下做分时复用，以伪并发的状态执行。协程可以暂停和恢复运行。比如，我可以让一个协程函数暂停，然后去执行其他内容，回过头来再继续执行协程函数。操作系统不感知协程，它是一种语言级的行为。C++20 的协程是无栈协程，所以效率很高。</p><p>协程之间切换不需要内核参与，所以效率更高，但协程需要配合异步 IO 操作，在计算密集型任务中，协程没有用武之地。</p><p>C++20 的协程使用 co_await, co_yield, co_return 关键字，又是一个考虑兼容性的命名。它使用普通函数，而不是 lambda 来实现协程函数。如果一个普通函数中存在这 3 个关键字之一，它就会被编译器处理为一个协程。</p><p>这个协程提案被批评的主要原因是不利于学习、没有和现有语言特性融合、过于灵活。解决方案便是提供一套标准库来包装接口，再提供给普通用户使用。然而，由于时间原因，协程的标准库并没有被添加到 C++20 中。</p><h2 id="增强的-constexpr"><a href="#增强的-constexpr" class="headerlink" title="# 增强的 constexpr"></a># 增强的 constexpr</h2><p>之前我们在 C++14 的总结中，提到过 C++14 中的 constexpr 是对 C++11 的一个增强，当时的改进相对来说比较温和，应该理解为一种完善。在 C++20 中，constexpr 才被进一步的增强，这次更新，constexpr 中加入了一些新的修饰符、一些标准类库支持、constexpr 函数中允许使用 new&#x2F;delete、虚函数、RTTI 等特性。</p><p>C++20 进一步增强 constexpr 的目的，是继续将 C++ 的编译期计算推举到更重要的位置，从而让更多的运行时计算变成静态计算，进一步改进运行时性能。</p><p>但是，在工程中，将运行时函数修改为编译期函数的努力可能很艰难，我们应该学着评判什么是值得花精力去改善的。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="# 运算符 &lt;=&gt;"></a># 运算符 <code>&lt;=&gt;</code></h2><p>这个运算符应该怎么称呼，目前中文 C++ 社区还没有完全达成一致，英文是 Three-way comparison operator，也许应该叫三向比较运算符。它返回一个特殊的类型 <code>std::strong_ordering</code> ，有三个取值，分别是 <code>less</code> <code>equal</code> <code>greater</code> ，用于确定两个值的大小关系。</p><p>它的引入最大的意义是，允许编译器能有更多的优化空间。</p><p>另一个话题是重载 <code>&lt;=&gt;</code> 运算符，和其他运算符一样，也可以重载它，或者让编译器生成 default 版的重载函数。如果重载这个运算符，那么其他比较运算符也会自动由编译器生成。一个例外是字符串的 <code>==</code> 运算符不会自动生成，理由是性能很差，我很难给出积极的评价，这让整个语法变的不统一，不过，C++ 里这种操作也挺多的，为了性能会妥协语言的复杂性和优雅性。</p><h2 id="范围-ranges-和视图-view"><a href="#范围-ranges-和视图-view" class="headerlink" title="# 范围 ranges 和视图 view"></a># 范围 ranges 和视图 view</h2><p>千呼万唤始出来的特性，使用 ranges 终于可以在很多场合里摆脱 <code>func(vec.begin(), vec.end())</code> 这种写法了，换之 <code>func(vec)</code>，这才是现代编程语言应该有的特性。</p><p>奈何我们在 2020 年之后的 C++ 中才用到了这个特性。</p><p>C++20 的 STL 中所有容器都已经支持了 ranges。</p><p>另外，STL 中还加入了很多与 ranges 相关的算法，比如 filter、take 等，这些算法定义在 std::ranges::views 中。与此同时，引入了管道 pipe 运算，使用这种编程风格让 C++ 更像是函数式编程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::ranges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="keyword">auto</span> valid = [](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> x % <span class="number">4</span> == <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : views::<span class="built_in">iota</span>(<span class="number">1</span>) | views::<span class="built_in">transform</span>(square) | views::<span class="built_in">filter</span>(valid) | views::<span class="built_in">take</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，<code>views.iota(1)</code> 会生成从 1 开始，步进是 1 的 ranges 序列（注意不是 <code>itoa</code>），通过管道运算符传递，之后会经过 2 个我们自定义的 predicate 函数，最后使用 <code>views.take</code> 来获取前 5 个元素，并返回给 for 循环遍历。</p><p>C++ 被人吐槽很多的一个话题是，它提供的 std::string 中，没有 split 操作（实现很简单，但一直没有通过委员会，因为性能和类型统一等问题），这让过去很多项目都需要自己写 split 函数。C++20 中终于有了 split view，便可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> sv = s | ranges::views::<span class="built_in">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><p>返回的类型是 split_view，可以通过 <code>ranges::to&lt;&gt;</code> 进一步转换为自己想要的容器类型。</p><h2 id="span"><a href="#span" class="headerlink" title="# span"></a># span</h2><p>在目前的 C++ 中，通过下标访问一个数组的元素，是没办法通过编译器检查是否发生访问越界的，而这种错误经常会出现在工程代码中，动态的越界检查又很难因性能开销而被接受。一种简单的实现，就是把数组的长度绑定到数组指针中，统一引用这个复合的指针类型。曾经，有提案给到 C 标准委员会，但没有得到通过。</p><p>C++20 中，引入了 span 这个特性，从而让编译器的数组静态越界检查成为可能。因为数组长度是静态的，并且跟着 span 类型的传递到达任何需要遍历数组的地方，所以编译器便有机会在这些遍历和下标访问的地方检查越界操作。</p><p>同时，span 也扩展了数组类型的遍历，可以让它和其他复合容器一样操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(span&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，便可以检查可能的越界操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">func</span>(arr);        <span class="comment">// 合法，通过类型推导到 void func(span&lt;int&gt; arr)</span></span><br><span class="line"><span class="built_in">func</span>(&#123;arr, <span class="number">50</span>&#125;);  <span class="comment">// 合法，初始化为 span&lt;int&gt; 类型实参</span></span><br><span class="line"><span class="built_in">func</span>(&#123;arr, <span class="number">101</span>&#125;); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="# 格式化字符串"></a># 格式化字符串</h2><p>又是一个应该属于现代化的编程语言中一个常用的特性。</p><p>因为 pre-C++20 中没有原生的类型安全的格式化字符串方法，所以过去涌现出了好多第三方的库。我使用过 LLVM 实现的 llvm::formatv 和 fmt，用起来还算可以。C++20 之后，终于可以使用原生的实现了，它的参照原型是 fmt 库，所以基本可以无缝切过去。</p><p>除了类型安全这个特点外，format 和 C 的 printf 之间另一个区别是，format 可以支持用户自定义的类型输出格式，对于一些复杂且在特定领域很常用的格式化模板，就非常的方便。</p><h2 id="并发"><a href="#并发" class="headerlink" title="# 并发"></a># 并发</h2><p>C++20 中引入了一些非常有意义的并发编程的特性。比如，使用 RAII 的 thread 对象，被命名为 jthread，当 thread 对象超出作用域时，触发 join 行为，直到 thread 终止后，才完成 join 并退出主线程的当前作用域。</p><p>另外一个之前便已经提到过的，通过主线程终止子线程执行，通过在主线程中设置一个 flag，然后要求子线程去周期性地检查这个 flag，如果主线程需要终止子线程，则置位 flag。</p><h2 id="新增的一些属性"><a href="#新增的一些属性" class="headerlink" title="# 新增的一些属性"></a># 新增的一些属性</h2><p>像我之前提到的那样，在必要的时候，去尝试使用属性，可以让代码更优雅，也有助于编译器做一些分析。C++20 中增加了 <code>[[likely]]</code> 和 <code>[[unlinkely]]</code> 属性，用于指导编译器在处理分支逻辑时，更好地做优化。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/1820204765">C++20 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片来自：Photo by <a href="https://unsplash.com/@oww?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Geio Tischler</a> on <a href="https://unsplash.com/photos/an-aerial-view-of-an-island-in-the-middle-of-the-ocean-_D_zFmpg8nE?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>时间的速度是可控的</title>
    <link href="https://p2tree.top/posts/7a90bc13.html"/>
    <id>https://p2tree.top/posts/7a90bc13.html</id>
    <published>2024-10-14T22:25:17.000Z</published>
    <updated>2025-03-25T13:24:58.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间是最强大的力量，虽然每个人都有，但不同的人使用时间会产生完全不同的结果。</p><p>时间对每个人是公平的吗？是，也不是。从客观角度观察，每个人的时间是一样长的，但从主观上体验，时间的长度是可调的，越忽略时间，时间过得越快，越关注时间，时间过得越慢。将时间主观上拉长，可以做更多事情，忽略时间而沉迷没有价值的事情，就是在荒废这最精妙而宝贵的资源。</p><p>怎么使用时间，每个人的选择都不同，主观上时间可以调出大于之前几倍的长度，就看会不会调，以及如何利用。</p><hr><p><img src="https://img.p2tree.top/2024/10/14/Chapter.317.webp" alt="Chapter.317"></p><div class="note primary flat"><p>封面图片来自：Photo by <a href="https://unsplash.com/@aronvisuals?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Aron Visuals</a> on <a href="https://unsplash.com/photos/selective-focus-photo-of-brown-and-blue-hourglass-on-stones-BXOXnQ26B7o?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p><p>转载自我自己的<a href="https://mp.weixin.qq.com/s/JWy_i2PybV2m72M--DH9dQ">微信公众号</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="管理时间" scheme="https://p2tree.top/tags/%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>C++17 特性杂谈</title>
    <link href="https://p2tree.top/posts/3d315b3e.html"/>
    <id>https://p2tree.top/posts/3d315b3e.html</id>
    <published>2024-09-30T20:28:04.000Z</published>
    <updated>2025-03-25T13:24:58.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++17 相比于 C++14 来说，新增了不少新特性，然而，它并没有做到它被期望做到的发布版本，也就是没有特别重大的改变。</p><p>尽管在 C++17 之前，一些特性已经经过了深思熟虑的考虑，但最终依然出于各种原因，没有进入最终的版本中，有一些特性，方案讨论其实很早就开始并得到确定，但在后来的评定中被搁置，直到在 C++20 中才最终加入，比如概念（Concept），协程（Coroutine），这些大的特性任何一个放入 C++17 中，都可以让其变成一个大的版本发布。</p><p>因为按预期，C++ 标准发布采用一大一小的模式，C++17 作为继 C++11 之后的又一个大版本发布，所以当时有人主张将 C++17 延迟发布，以增加更多的重要特性，不过被 Bjarne Stroustrup 拒绝，拒绝理由其实也非常合理，“如果一项特性值得为之改变 C++ 标准的发布周期，那么就会有更多特性要求这么做”，C++11 已经是一个延迟的版本，并带来了很多因延迟导致的遗憾。</p><p>然而不可否认的是，C++17 依然是一个非常有价值的版本，其中有一些特性实实在在的帮助了程序员改善他们使用 C++ 的体验。</p><hr><p>本文是 C++ 特性杂谈系列文章的第三篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="构造函数模板参数推导"><a href="#构造函数模板参数推导" class="headerlink" title="# 构造函数模板参数推导"></a># 构造函数模板参数推导</h2><p>举个例子来说明这个特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_lock&lt;std::mutex&gt; lock &#123;mtx&#125;;  <span class="comment">// pre-C++17 只能这样写</span></span><br><span class="line">std::unique_lock lock &#123;mtx&#125;;  <span class="comment">// pre-C++17 会出错，C++17 支持</span></span><br></pre></td></tr></table></figure><p>例子中，std::mutex 是 std::unique_lock 的一个模板类型参数，在 C++17 中，允许通过 std::unique_lock 的构造函数推导出这个模板类型参数（因为 mtx 是 std::mutex 类型的）。</p><p>这种简化的写法让代码看起来更清爽，在一些常用的标准库类型中，非常常用，比如智能指针、锁、pair 和 tuple 等。</p><h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="# 结构化绑定"></a># 结构化绑定</h2><p>非常实用的一个特性，在其他语言中已经得到非常普及的用法，比如 python：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def options():</span><br><span class="line">  # ...</span><br><span class="line">  return arg1, arg2, arg3</span><br><span class="line"></span><br><span class="line">def func()</span><br><span class="line">  a1, a2, a3 = options()</span><br></pre></td></tr></table></figure><p>在 C++14 中，我们引入了一种略微方便的返回多个值的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;Type1, Type2, Type3&gt; func() &#123;</span><br><span class="line">  return &#123;a, b, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，当时却没有好好的处理接受 tuple 类型时的解包语法，以至于只能用这些写法来实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 第一种做法是继续用 tuple 类型接收返回值，并用 get&lt;T&gt;() 解包</span><br><span class="line">tuple&lt;Type1, Type2, Type3&gt; res = func();</span><br><span class="line">Type1 t1 = std::get&lt;0&gt;(res);</span><br><span class="line">Type2 t2 = std::get&lt;1&gt;(res);</span><br><span class="line">Type3 t3 = std::get&lt;2&gt;(res);</span><br><span class="line">// 这种写法实际上很丑，尤其是要把 0,1,2 这种字面量数字写入模板参数中，而且还带来了运行时创建后赋值开销</span><br><span class="line">// 第二种做法是使用 tie</span><br><span class="line">Type1 t1; Type2 t2; Type3 t3;</span><br><span class="line">std::tie(t1, t2, t3) = func();</span><br><span class="line">// 看起来似乎整洁了一些，带却带来了更多问题，比如引入未初始化的变量，事实上也躲不开创建后赋值开销</span><br></pre></td></tr></table></figure><p>C++17 中，终于拿出了像样的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto [t1, t2, t3] = func();</span><br></pre></td></tr></table></figure><p>干净清晰，而且没有创建后赋值的开销，类型自动推导。</p><h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="# 折叠表达式"></a># 折叠表达式</h2><p>折叠表达式是 C++17 中的一个重要特性，我认为它可以排到前三，虽然很多介绍 C++17 新特性的文章中并不愿意提及折叠表达式。</p><p>它很大程度上改变了变长参数模板的使用方式。在这之前，想要对变长参数模板做解包，代码逻辑相对复杂，只能使用递归解包或者用逗号表达式解包，无论是可读性，还是排查问题，都很困难。折叠表达式是一个非常好的设计，让变长参数的解包变的轻松。</p><p>除了单纯的解包，折叠表达式还可以直接对解包参数做运算，比如，我们想要对折叠参数做累加时：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">auto sum(Args... args) &#123;</span><br><span class="line">  return (... + args);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  std:: cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; std::endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替代-union"><a href="#替代-union" class="headerlink" title="# 替代 union"></a># 替代 union</h2><p>传统的 union 是一种可以将不同类型的值复用相同的内存空间，然后由程序员来管理当前使用 union 时的值类型。如果在这种地方犯错，就会取到奇怪的值，编译器并不会为这种错误操作做任何检查。</p><p>C++17 中引入了 variant，它是标准库的一个类型，用来取代 union 的一部分工作。它能够实现 union 的特性，同时还能允许编译器对非法的使用做检查。</p><p>我不认为这个特性在目前的时间上会产生什么重大的影响，使用 union 的人，并不是想要创建混合类型来用，而是想要极度的压缩内存，或者使用 union 来实现快速的数据分割或转换。</p><p>按 C++ 委员会的设想，variant 可以用于创建混合类型，进而可以创建动态类型容器，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using var_t = std::variant&lt;int, long, double, std::string&gt;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;var_t&gt; vec = &#123;10, 20L, 30.4, &quot;hello&quot;&#125;;</span><br></pre></td></tr></table></figure><p>目前看来用处并不大，也许将来配合模式匹配的功能，可以让 variant 大放异彩。另外，C++17 中还拿出了 std::any，任意数据类型，好吧，总之，从这里来看，C++ 向着动态类型语言迈出了一步。</p><h2 id="并发补丁"><a href="#并发补丁" class="headerlink" title="# 并发补丁"></a># 并发补丁</h2><p>C++11 中引入的并发特性其实缺少一些很常用的特性，在 C++17 中终于打了补丁：</p><ul><li>scoped_lock：可以同时获得多个锁</li><li>shared_mutex&#x2F;shared_lock：读写锁</li></ul><p>等了这么多年才补充，不是忘记疏忽了，而是在曾经的提案中没有得到通过。这些特性的迟迟到来，让 C++ 程序员已经不太习惯在并发中使用它们了。但只要你能想起来去用它们优化你的代码，就非常有益。</p><h2 id="并行算法"><a href="#并行算法" class="headerlink" title="# 并行算法"></a># 并行算法</h2><p>在 C++17 之前，我们在使用 STL 中的算法接口时，没办法让其利用好硬件提供的并行计算能力，比如通过多核来加速排序算法。这些在 C++17 中终于成为了可能。虽然 C++17 并不是最完善的一个版本（C++20 中对其做了补充），但也足够使用其改进我们的程序性能。</p><p>用法是在 STL 算法接口中，加入一个参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(par_unseq, begin(v), end(v));</span><br></pre></td></tr></table></figure><p>除了要求程序尝试并行化之外，程序也会尝试使用向量化来加速算法，也就是使用硬件的 SIMD 来优化运算，这在很早期就应该得到支持，避免程序员手写 builtin 自己组装数据了。SIMD 是硬件少有的还能在单线程上提升性能的贡献了，一定要用起来。</p><p>然而，C++17 依然不支持取消线程的操作，这实际上增加了并行算法的开销，比如并行查找一个元素，我们希望有线程查到元素时，停止其他线程，但目前还是做不到。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="# 文件系统"></a># 文件系统</h2><p>我只能说 C++ 标准委员会的工作可能真的太多了，这种实用的功能，在 C++17 才拿出来真的不应该，类似的还有网络库（它没有加入 C++17，甚至没有加入 C++20）。因为它们太常用了，以至于大家在过去都需要自己造轮子实现。</p><p>这时就体现出有一个活跃的包管理机制有多重要了，虽然有 Boost，但一方面，大家并不愿意在自己的项目中引入这个沉重的包，另一方面，也是习惯问题，毕竟 Boost 被定位为 C++ 新标准的测试库，拿到工程中用总感觉不太合适。最后，大多数项目都选择自己写一套，有需求随便改，有 bug 自己修。</p><p>话说回来，C++17 引入的这套文件系统操作还是很全面的，如果不是用其他成熟的框架（比如 LLVM 的 llvm::fs），切换到 C++17 的接口还是值得的。</p><h2 id="新增的一些属性"><a href="#新增的一些属性" class="headerlink" title="# 新增的一些属性"></a># 新增的一些属性</h2><p>C++ 中有一些属性，用来对代码中的一些内容给编译器做提示，C++17 中加入了以下的一些属性：</p><ul><li><code>[[nodiscard]]</code>：用来指示函数的返回值不应该被忽略，编译器会在没有接收返回值时报警告</li><li><code>[[maybe_unused]]</code>：用来指示某个变量，参数或类型可能不会被使用，避免编译器报告变量等未使用的警告</li><li><code>[[fallthrought]]</code>：用于在 switch case 中，如果两个分支使用相同的处理逻辑块，前一个分支想要进入后边的代码块时使用，避免编译器报告可能丢失 break 语句的警告</li></ul><p>在 C++11 和后续的版本中，还引入了其他一些属性，这些属性看似不影响功能，但实际上对代码的可读性有着很大的改善，强烈建议学会怎么使用。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/779489353">C++17 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片是巴厘岛的一个海滩，来自：Photo by <a href="https://unsplash.com/@iswanto?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Iswanto Arif</a> on <a href="https://unsplash.com/photos/aerial-photography-of-seashore-OJ74pFtrYi0?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>历史成为传说，传说成为神话</title>
    <link href="https://p2tree.top/posts/3e7e0054.html"/>
    <id>https://p2tree.top/posts/3e7e0054.html</id>
    <published>2024-09-19T22:22:20.000Z</published>
    <updated>2025-03-25T13:24:58.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很喜欢一句话，来自指环王：“历史成为传说，传说成为神话”。</p><p>很多神话故事，在曾经都是一些真实的事情，因为人类的想象力和创造力，随着时间的推移，这些有代表性的事情就会被不断修改，使之更易于传播，慢慢的，九成了故事，就成了传说。</p><p>比如中国古代的很多故事和人物，后羿、女娲、黄帝、精卫，曾经都是一个个充满个性和勇气，完成过辉煌成就的人。</p><p><img src="https://img.p2tree.top/2024/09/19/Chapter.429.webp" alt="Chapter.429"></p><hr><div class="note info simple"><p>封面图片来自：Photo by <a href="https://unsplash.com/@andrewtneel?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Andrew Neel</a> on <a href="https://unsplash.com/photos/maps-lying-on-the-floor-1-29wyvvLJA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s?__biz=MzI0MDkzNDA2Ng==&mid=2247483977&idx=1&sn=7eb0aa590dee3de6af598f5cb4e5f830&chksm=e9120f94de658682feaa2e6d909fa3cc0cadb088a18700707f8ac231a332e49f1f456e685e2f&token=1320776432&lang=zh_CN#rd">目的地</a> ，欢迎关注</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="历史" scheme="https://p2tree.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>不能忘记的日子</title>
    <link href="https://p2tree.top/posts/dd4fe3d1.html"/>
    <id>https://p2tree.top/posts/dd4fe3d1.html</id>
    <published>2024-09-18T22:06:37.000Z</published>
    <updated>2025-03-25T13:24:58.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为中国人，总是需要记住一些过去的日子，忘记历史，是最可怕的。我很震惊，现在已经很少有人或者有媒体在这些重要的日子里提到这些话题了，然而很多事情过去还没有一百年，一些见证者甚至还活着。</p><p>如果一个人忘记了历史，也就忘记了自己的身份，丢掉了自己活着的一个使命——<strong>把故事，讲给后人听</strong>。</p><p>今天是 9 月 18 日，一个普普通通的九·一八事变纪念日，我打算把这些有意义，值得被传承的日子再次记录一遍，贡献自己绵薄的搜索流量。</p><p>在本站点，每年的这几个日期全站会改成灰色，以示对遇难同胞的缅怀。</p><h2 id="五·一二汶川大地震遇难同胞纪念日"><a href="#五·一二汶川大地震遇难同胞纪念日" class="headerlink" title="五·一二汶川大地震遇难同胞纪念日"></a>五·一二汶川大地震遇难同胞纪念日</h2><p>汶川大地震发生在北京时间 <strong>2008 年 5 月 12 日</strong>，震中位于中国四川省汶川县，震级 8.3 级，烈度达到 11 级。</p><p>地震共造成 69227 人遇难，17923 人失踪，374643 人不同程度受伤，1993 余万人流离失所，受灾总人口达到 4625.6 万人。是中华人民共和国建国以来伤亡最惨重的一次地震，直接经济损失 8451 亿人民币。</p><p>因为地震发生在山区，很多村落就坐落在山脚缝隙中，地震发生后，山体直接塌陷，把整个村子的人都埋在地下，没有地方可躲避。也因为在山区，救援和补给很难快速到达现场，也进一步加重了灾害的后果。</p><p>2008 年，我还在读中学，对此印象并不是特别深刻，犹记得当时学校组织大家开展了很多地震相关的教育和实践活动。虽然没有亲身经历，但从网络上看了很多报道和讨论，应该是我过去这段记忆以来（应该也是很多人的记忆），最印象深刻的一次地震。</p><p>2008 年是中国最波折的一年，这一年，年初南方暴雪灾害，年中又发生了汶川大地震，也承办了奥运会，以及奶制品污染问题等。当时时任国务院总理的温家宝同志，亲身赶赴灾区参与指挥救援工作，让我对他产生了由衷的尊敬。</p><p>2009 年，国务院宣布将每年的 5 月 12 日定为防灾减灾日，暨汶川大地震灾害遇难同胞纪念日。</p><h2 id="七七事变"><a href="#七七事变" class="headerlink" title="七七事变"></a>七七事变</h2><p>七七事变，又称卢沟桥事变，是 <strong>1937 年 7 月 7 日</strong>发生在河北省宛平县卢沟桥的日本军队和中国国民革命军之间的军事冲突。它被认为是中国抗日战争（八年抗战）全面爆发的起点，中国抗日战争转为全面战争。</p><p>具体发生的细节，至少上过中学历史课，都会有印象，但过去了太久，每天繁忙的工作和日复一日的生活，让我们逐渐忘记了这些故事。那天，日本军队在卢沟桥附近军事演习，然后谎称有个士兵失踪，要求进宛平城（位于北京西南方一座卫城）搜查，被当时守城的国民革命军第二十九军拒绝。之后日本军队攻击城西卢沟桥，之后炮轰宛平城。</p><p>现在，提到卢沟桥，很多人的印象是一个很有特色的旅游景点，卢沟桥上有很多的石狮子，每个狮子都造型各异，是一座有名的石拱桥，是重点保护文物。为什么日本兵会在这么近的地方和我们发生冲突，因为当时整个东北已经被日本殖民很久了，这要从九一八事变，甚至更早开始聊。</p><p> 1901 年清政府签订了丧权辱国的 《辛丑条约》，日本开始在华北驻军。清政府倒闭后，国内陷入动乱，日本乘机扩大在东北的势力范围，扶持傀儡政权，建立伪满洲国。</p><p>七七事变后，日本军队开启对中国的全面侵略战争，中国军民团结一致，奋起反抗，最终经过八年艰苦的抗战，将日本军队彻底赶回了老家。但期间有太多的人被迫害和牺牲，他们很少留下名字，但值得我们铭记。</p><p>七七事变这一天，是中国法定纪念日，虽然过去还没有一百年，但已经很少有人记得在这一天想到，“哦，几十年前，我们的前辈还在被外敌迫害，还在为国家和人民英勇献身”。</p><h2 id="抗战胜利纪念日"><a href="#抗战胜利纪念日" class="headerlink" title="抗战胜利纪念日"></a>抗战胜利纪念日</h2><p>第二次世界大战过去离我们也就 70 年，70 年还没有一个普通人的寿命长，也就意味着那个年代出生的前辈，现在很多都还活着。</p><p><strong>1945 年 9 月 2 日</strong>，日本在停泊在东京湾的美国军舰上签署了投降书，标志着抗日战争的胜利结束，中国将每年的 9 月 3 日定为抗日战争胜利纪念日。因为日本是轴心国中最后一个投降的国家，所以这也标志着整个第二次世界大战的结束。</p><p>中国抗日战争是国际反法西斯战争的一个重要组成部分，是反法西斯战争的东方主战场，永远不能被忽视。网上一些信息总是说道抗日战争的胜利是靠着美国给日本本土投下原子弹才胜利的，这是实打实的谬论，美国加入第二次世界大战确实加速了战争的结束，但中国军民为此付出的努力和牺牲，永远都不应该被漠视和否定，如果没有中国在亚太战场上牵制日本军队，日本军队将快速占据土地和资源，并不断扩大战争。</p><p>9 月 3 日是一个不容易被记住的日子，但我们应该记住曾经的那些血与泪的日子，记住我们民族曾经遭受过的苦难，记住日本掌权者依然不愿承认历史，坦然道歉。历史可能会被篡改，可能会被教育抹掉，更可怕的是，这只需要一代人。</p><h2 id="九一八事变"><a href="#九一八事变" class="headerlink" title="九一八事变"></a>九一八事变</h2><p>九一八事变是日本军队在 <strong>1931 年 9 月 18 日</strong>，在中国东北发动的日本侵略战争，是日本帝国主义侵略中国的开始。</p><p>和很多故事一样，九一八事变也是写入中国历史教科书的重要历史事件。9 月 18 日，日本军队炸毁南满铁路部分路段，并谎称是中国军队所为，并开始炮轰沈阳，同时进攻其他几个东北城市。战争，都是需要借口的，重要的不是嘴上说的原因，重要的是日本对中国的土地和资源已经觊觎已久。</p><p>冲突发生后，当时的东北军领袖张学良听从蒋介石的命令，下令不抵抗，并撤军，让日本军队快速占领了东北，半年后，整个东北沦陷。当时，以蒋介石为首的中央国民政府正在忙着第一次国共内战，便下令对日本的入侵不抵抗，并寄希望于国际压力。蒋没有大局观，实际上那个时候就输了。</p><p>日本占领东北后，成立了伪满洲国，扶持当时的清政府残余势力，谋划通过政治隔离分裂中国。次后，东北发生了什么，成为了难以言表的悲剧，731、病毒实验、人体活体研究，日本露出了它的残忍兽性。这些让多少中国人以生命作为代价，产生的实验成果，战后被美国收走，并用于他们的生物武器研制。</p><p>客观来说，我们并不应该仇恨日本这个国家，而是仇恨日本民族中一部分极端民族主义者，如果让他们或相关势力掌权，日本这个国家就会变得危险。而且事实上，后来大多数时间，都处于这个状态。</p><p>对于整个中国来说，七七事变通常被看作是中国被侵略的开始，但对于整个东北地区和东北人民来说，九一八事变才是最初的国耻日，是真正的国耻日，是没有抵抗，被抛弃的国耻日！</p><h2 id="南京大屠杀遇难同胞悼念日"><a href="#南京大屠杀遇难同胞悼念日" class="headerlink" title="南京大屠杀遇难同胞悼念日"></a>南京大屠杀遇难同胞悼念日</h2><p>有些战争，是政体和政体之间的战争，而有些战争，是民族和民族的战争。政体之间的战争，随着政体的覆亡，也一并被历史淡忘了，但民族是跨越政体的存在，民族战争的记忆，永远不会被时间冲淡。</p><p>日本军队在侵华战争中，犯下过非常多的惨无人道的战争罪行。既然已经是战争了，为什么还要单独提罪行，因为国际法规定了战争行为不能触碰的红线，突破了红线，战争就是毫无人性的，就是突破了作为人这种动物，作为一种高智商生物的底线。</p><p>南京大屠杀是日本军队在众多迫害中国人民的事件中，最典型、影响最恶劣的一件。大屠杀<strong>从 1937 年 12 月 13 日开始，整整持续了六周</strong>，到底具体有多少人遇害，已经不可考证，但至少有 30 万无辜的平民百姓被日本兵杀害，其中几万民中国妇女被奸杀，南京城内三分之一的建筑被破坏烧毁。</p><p>那些天的南京，是人间地狱，魔鬼拿着刀枪，肆无忌惮。</p><p>日本军队在屠杀期间，组织杀人比赛；他们将婴儿抛在空中，再用刺刀串起来；他们将男女老少赶到江边，逼着他们跳河，也将他们活埋，南京码头尸体堆积如山；他们排着队轮奸妇女，当着受害女性家人的面，甚至强迫受害者乱伦；孕妇被刺刀刨腹，身上插满木棍，劈开脑袋；他们强奸几岁的女孩，甚至七旬的老人。</p><p>所有这一切，都是日本军官默许甚至鼓励的。这些人是野兽，并且他们一直还活着。</p><p>所有信息都是有据可考的，是真实发生的。战争结束后，有一些对中国幸存者和日本老兵的采访和记录，以及大屠杀发生时，国际记者在现场的拍摄照片和新闻内容，甚至也包括了日本国内媒体的报道。然而，日本直至目前为止，依然没有承认这件事情的严重性，也没有公开为之道歉，而且继续扭曲历史，妄图把这段历史从时间中抹去。</p><p>我之前去过一次南京，便抽时间去了一次南京大屠杀纪念馆。建议每一个中国人，如果第一次去南京，一定要去一次南京大屠杀纪念馆。</p><p>2014 年，中国将每年的 12 月 13 日，设立为南京大屠杀死难同胞国家公祭日。而且，在中国几千年历史中，南京大屠杀只是比较恶劣的一次大屠杀，它只是一个象征，象征着只有国家强大了，才能保护人民，只有人民团结一致，才能抵抗外敌。</p><hr><div class="note info simple"><p>封面图片为侵华日军南京大屠杀遇难同胞纪念馆入口，来自：作者 x li - <a href="https://commons.wikimedia.org/w/index.php?curid=14620108">入口</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="历史" scheme="https://p2tree.top/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++14 特性杂谈</title>
    <link href="https://p2tree.top/posts/41507ee5.html"/>
    <id>https://p2tree.top/posts/41507ee5.html</id>
    <published>2024-09-11T22:23:27.000Z</published>
    <updated>2025-03-25T13:24:58.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 标准从 C++11 开始，采用一个大版本后接一个小版本的更新思路，所以 C++14 是一个小版本更新的标准，它的主要目的是完善 C++11 标准。</p><p>一些 C++11 标准发布时还不稳定的特性，在 C++14 中被加入标准中。另外，这么做也是给编译器实现者们提供一个缓冲，在 C++11 标准实现之后的晚一些时间，提出一些小型的完善性的提案。</p><p>为了能完整的使用现代 C++ 特性，通常不会开启 C++11，而是会选择开启 C++14。</p><hr><p>本文是 C++ 特性杂谈系列文章的第二篇：</p><ol class="series-items"><li><a href="/posts/e40506ec.html" title="C++11 特性杂谈">C++11 特性杂谈</a></li><li><a href="/posts/41507ee5.html" title="C++14 特性杂谈">C++14 特性杂谈</a></li><li><a href="/posts/3d315b3e.html" title="C++17 特性杂谈">C++17 特性杂谈</a></li><li><a href="/posts/49819b87.html" title="C++20 特性杂谈">C++20 特性杂谈</a></li></ol><hr><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字分隔符是 C++14 中的一个小特性，但却引起了很大的讨论。讨论的根源在于，使用什么分隔符可以最大程度上既能有效表示分隔符的意义，同时还能兼容旧代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> num = <span class="number">1&#x27;234&#x27;456</span>s;  <span class="comment">// 1234456 秒</span></span><br></pre></td></tr></table></figure><p>最终选定的分隔符是 ‘ ，这在我看来并不是一个特别好的决定，’ 用来包裹字符，虽然从语义上讲，数字分隔符不可能出现在一串数字的最前边，所以不会与字符产生冲突，但依然容易让人有困扰。</p><p>只能说，感谢静态分析工具和语法高亮吧。</p><hr><h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><p>坦白说，我没有在哪里看到过这个特性的用途。它用于定义一个带有模板参数的变量（而不是函数），对定义的表达式做泛化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.14159</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">circular_area</span><span class="params">(T r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pi&lt;T&gt; * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用途可能比较少，不过在 C++20 中定义 concept 时开始变地常用。</p><hr><h2 id="函数返回值类型推导"><a href="#函数返回值类型推导" class="headerlink" title="函数返回值类型推导"></a>函数返回值类型推导</h2><p>C++11 中的 lambda 函数，可以不写返回值类型。编译器可以通过 return 位置的类型来推导返回值类型。这种技术显然也可以应用在普通函数中，所以 C++14 中增加了这个特性，函数的返回类型为 auto。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">size</span><span class="params">(<span class="type">const</span> T&amp; a)</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果多个不同的 return 位置推导出了不同的类型，编译时会报错。</p><p>但这种推导返回值的函数会产生一个限制：函数签名是不稳定的，它由它的定义所决定。所以在调用这种函数时，函数定义必须已经可见（不能只给声明）。</p><hr><h2 id="泛型-lambda-表达式"><a href="#泛型-lambda-表达式" class="headerlink" title="泛型 lambda 表达式"></a>泛型 lambda 表达式</h2><p>泛型的 lambda 表达式在 C++11 提出时就已经经过了广泛的讨论，但最后认为还没有准备好，故没有出现在 C++11 标准中。因为 lambda 表达式本质上也是一种对象类型，所以支持泛型是显然合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_size = [](<span class="keyword">auto</span> &amp;m) &#123; <span class="keyword">return</span> m.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>使用 auto 来作为标记，指出类型是通过推导得出的。</p><hr><h2 id="增强的-constexpr"><a href="#增强的-constexpr" class="headerlink" title="增强的 constexpr"></a>增强的 constexpr</h2><p>constexpr 特性是 C++ 编译期编程的基础。</p><p>C++11 中的 constexpr 函数是要求比较严格的，只允许对纯函数的表达式进行求值，后来有一些人对此提出新的要求。在 C++14 中，可以允许 constexpr 函数中包含局部变量和循环，前提是它们不会对函数外部产生副作用。这个改进让编写 constexpr 函数更加自由灵活。</p><p>这些局部变量仅对编译器可见，编译器在编译时就会对函数求值。</p><p>在后续的 C++ 标准中，constexpr 的用法被进一步放宽，这得益于编译器实现的完善。尽可能将更多的计算从运行期移动到编译期是 C++ 设计的其中一个倾向，也即在最大程度上保证 C++ 编译的程序在运行时的性能。</p><hr><h2 id="make-unique"><a href="#make-unique" class="headerlink" title="make_unique"></a>make_unique</h2><p>std::make_shared 是一个 C++11 标准接口，它可以使得在创建一个 shared_ptr 对象时，不需要显式的暴露出来 new 关键字。但可惜的是，make_unique 没有出现在 C++11 中，而在 C++14 中才被加入标准库。在 C++11 中，只能自己编写一个 make_unique。</p><p>对我自己来说，这是 C++14 中最常用的一个特性。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/719519481">C++14 特性杂谈 - 知乎 (zhihu.com)</a></p><p>封面图片是一只海鸥，来自：Photo by <a href="https://unsplash.com/@carl_newton?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Carl Newton</a> on <a href="https://unsplash.com/photos/white-and-black-bird-on-brown-grass-during-daytime-AWJpalN_0yE?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>我们存在，是所有我们与爱我们的情感的总和</title>
    <link href="https://p2tree.top/posts/c82ee02e.html"/>
    <id>https://p2tree.top/posts/c82ee02e.html</id>
    <published>2024-09-01T19:24:53.000Z</published>
    <updated>2024-09-01T19:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感官经验的观察与描述具有独特价值，只要拥有同一段记忆，便为同一个人。这也恰如其分地解释了为何现在的自己与过去的自己是一个连续的整体。</p><p>进一步深入理解，我们的存在乃是所有关于自身记忆的总和。这记忆不仅存于自己的大脑，也在所有认识我们的人的记忆之中。由此可见，情感成为另一个度量人存在的重要维度。</p><p>这与看完《寻梦环游记》后的感悟不谋而合。一个人去世并不意味着其不复存在，只有当现世中无人记得他时，才是这个人真正的消失。换言之，人的存在是他自身与所有关于他的记忆的总和。</p><p>反观自身，我们亦存在于那些爱我们的人的记忆里。所以，即便我们去世，也并未消失，而依旧存在。我们的存在，是所有我们和爱我们的情感的总和。</p><hr><p><img src="https://webp.p2tree.top/2024/09/01/WechatIMG157.jpeg" alt="Chapter.72"></p><hr><div class="note default flat"><p>封面图片是北京奥林匹克塔，来自：<a href="https://unsplash.com/photos/white-and-black-spiral-light-EnUiazG5ROw">White and black spiral light photo – Free Wallpapers Image on Unsplash</a></p></div><div class="note primary flat"><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s/33_DDzgybNwRii89ikYq8w">目的地</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活感悟" scheme="https://p2tree.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="哲学" scheme="https://p2tree.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
</feed>
