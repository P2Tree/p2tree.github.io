<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P2Tree&#39;s Mill</title>
  
  
  <link href="https://p2tree.top/atom.xml" rel="self"/>
  
  <link href="https://p2tree.top/"/>
  <updated>2024-09-01T11:46:12.734Z</updated>
  <id>https://p2tree.top/</id>
  
  <author>
    <name>P2Tree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我们存在，是所有我们与爱我们的情感的总和</title>
    <link href="https://p2tree.top/posts/c82ee02e.html"/>
    <id>https://p2tree.top/posts/c82ee02e.html</id>
    <published>2024-09-01T19:24:53.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>感官经验的观察与描述具有独特价值，只要拥有同一段记忆，便为同一个人。这也恰如其分地解释了为何现在的自己与过去的自己是一个连续的整体。</p><p>进一步深入理解，我们的存在乃是所有关于自身记忆的总和。这记忆不仅存于自己的大脑，也在所有认识我们的人的记忆之中。由此可见，情感成为另一个度量人存在的重要维度。</p><p>这与看完《寻梦环游记》后的感悟不谋而合。一个人去世并不意味着其不复存在，只有当现世中无人记得他时，才是这个人真正的消失。换言之，人的存在是他自身与所有关于他的记忆的总和。</p><p>反观自身，我们亦存在于那些爱我们的人的记忆里。所以，即便我们去世，也并未消失，而依旧存在。我们的存在，是所有我们和爱我们的情感的总和。</p><hr><p><img src="/img/20240901/WechatIMG157.jpeg" alt="Chapter.72"></p><hr><div class="note default flat"><p>封面图片是北京奥林匹克塔，来自：<a href="https://unsplash.com/photos/white-and-black-spiral-light-EnUiazG5ROw">White and black spiral light photo – Free Wallpapers Image on Unsplash</a></p></div><div class="note primary flat"><p>转载自我自己的微信公众号：<a href="https://mp.weixin.qq.com/s/33_DDzgybNwRii89ikYq8w">目的地</a>，欢迎关注。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;感官经验的观察与描述具有独特价值，只要拥有同一段记忆，便为同一个人。这也恰如其分地解释了为何现在的自己与过去的自己是一个连续的整体。&lt;/p&gt;
&lt;p&gt;进一步深入理解，我们的存在乃是所有关于自身记忆的总和。这记忆不仅存于自己的大脑，也在所有认识我们的人的记忆之中。由此可见，情感</summary>
      
    
    
    
    <category term="语录" scheme="https://p2tree.top/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="哲学" scheme="https://p2tree.top/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++11特性杂谈</title>
    <link href="https://p2tree.top/posts/e40506ec.html"/>
    <id>https://p2tree.top/posts/e40506ec.html</id>
    <published>2024-08-31T22:04:59.000Z</published>
    <updated>2024-09-01T11:46:12.730Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 就像是一个新的语言，它弥补了之前 C++ 中的很多问题，引入的大量新特性，使 C++ 变成了一个非常易用的计算机语言，这让很多新程序员开始学习 C++，也让 C++ 重新焕发生机。</p><p>可以说，C++11 代表着现代 C++，使用 C++11 标准编写 C++ 代码已经成为一个最基本的项目管理要求，下一个这样的分界线应该是 C++20 了。</p><p>然而，C++11 的推出实际上困难重重，它最初提案时的版本是 C++0x，因为就没打算在 2010 年之后推出。很多 C++11 的新特性，在 2000 年之前就已经被提出了，一些特性已经在 Boost 库中被实现。C++ 语言作为一种非集权的计算机语言，在推出新标准时，需要考虑非常多的问题，又因为有各种领域、行业、公司的人一起参与拟定和决策，让 C++ 标准的最终成型变得更为艰难。</p><p>另外，C++ 的教学和很多行业的接受度并没有那么积极，导致 C++11 在推出十几年后，很多软件和库依然没有得到全面的更新和替代。对于标准委员会、编译器厂商来说已经是过去的东西，但对大多数普通 C++ 用户来说，却是未来。结果就是，这么多年后，C++11 的一些内容依然没有得到普遍接受。我在面试时问到的一些面试者，他们的项目依然采用 C with class 的 C++ 编程风格。</p><p>我学习了 C++之父 Bjarne Stroustrup 编写的 HOPL4（History of Programming Languages），整理了以下一些笔记。<strong>每隔一段时间，就应该把这些东西拿出来看看，和自己的业务代码对比一下，看看哪些地方值得改进，不要让自己和团队永远地困惑下去。</strong></p><h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><p>如果你有充足的时间和英文阅读能力，推荐直接读：<a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf</a></p><p>如果你有充足的时间，但不想阅读原文，这是一些大佬翻译的中文版：<a href="https://github.com/Cpp-Club/Cxx_HOPL4_zh/tree/main">https://github.com/Cpp-Club/Cxx_HOPL4_zh&#x2F;tree&#x2F;main</a></p><p>如果你没有充足的时间，请看本文和后续我发布的几篇文章。我的笔记中不会详细介绍每个特性具体的内容，所以如果你看不懂其中部分内容，可能需要自行查找其他资料补充。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>C++11 中最重要的一块新功能就是引入了并发编程的接口，在这之前，使用 C++ 编写并发程序只能依赖操作系统提供的库工具完成，从而影响了软件的可移植性。2006 年左右是一个转折点，在那之后，CPU 处理器厂商意识到单核处理器随着频率提高，性能到达了天花板，而需要转向多核处理器设计来实现性能提升。利用好这种新的硬件结构非常重要，C++ 标准便及时地更新了这块的能力。</p><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>对于并发编程中，内存模型的重要性有时会被低估，由于我们在学习并发编程时，内存模型总是很靠后的一节内容。然而在 C++ 标准委员会订立这块特性时，内存模型却需要优先考虑。</p><p>内存模型是描述计算机系统内存布局和访问行为的一系列约定。在并发编程中，内存模型用于规定不同线程或处理器如何访问共享内存中的数据，从而在并发程序中能够有可遵循的读写操作可见性和顺序性，确保并发访问时程序的正确性。</p><p>C++ 的内存模型基本采用了先行发生关系（happens-before），既支持宽松的内存模型，也支持顺序一致模型。另外，C++ 也支持了原子类型和无锁编程。</p><p>C++ 订立内存模型要比其他高级语言复杂的多，因为 C++ 需要考虑多个不同硬件平台的应用厂商的需求，比如以 Intel 为代表的 x86 体系结构下的内存同步模型，以及以 IBM 为代表的 PowerPC 体系结构模型。因为这些难以忽视的差异，导致 C++ 的内存模型要复杂的多。</p><p>涉及到的内容，本文不展开，类似的介绍可以在其他书籍和网络资料中找到。主要的几个关键点有：</p><ul><li><strong>序列一致性</strong>：C++ 不要求严格的序列一致性，而是提供了松散的一致性保证，可以确保在一定程度上的有序执行。</li><li><strong>原子操作</strong>：当使用原子类型操作时，原子操作在并发层面上是不可细分的，避免了线程之间的竞争。</li><li><strong>内存序</strong>：不同的内存序可以配置序列执行顺序的不同约束。</li><li><strong>数据竞争</strong>：明确了数据竞争的条件和后果。</li></ul><h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><p>是并发编程中使用并发相对较差的一种并发模型，但使用简单，不容易出错。</p><p>相关的内容包括：</p><ul><li><strong>thread</strong>：系统级的线程对象，支持 join() 和 detach()</li><li><strong>mutex</strong>：系统级的互斥锁，支持 lock()、unlock() 和 RAII 实现的加锁解锁（unique_lock 和 lock_guard）</li><li><strong>condition_variable</strong>：系统级的条件变量</li><li><strong>thread_local</strong>：线程本地存储</li></ul><p>欠缺的一块内容是线程取消操作，即通过一个线程向正在运行的其他线程发送停止命令。在订立这块特性时，C 委员会的一些代表反对支持这块特性。C++20 中提供了一种机制来实现这个目的。</p><h3 id="Future-和-Promise"><a href="#Future-和-Promise" class="headerlink" title="Future 和 Promise"></a>Future 和 Promise</h3><p>我一直不知道这个特性应该怎么翻译。一种更现代的、高层次的并发编程模型。</p><p>相关的内容包括：</p><ul><li><strong>future</strong>：通过它可以从一个共享的缓冲区中获取 <code>.get()</code> 一个值，可能要等待 promise 将值提前放入缓冲区</li><li><strong>promise</strong>：通过它可以将一个值放入 <code>.put()</code> 到一个共享的缓冲区，并唤醒等待 future 的线程</li><li><strong>packaged_task</strong>：一个类，将一个函数和一个异步线程绑定，并由 future 来获取返回的结果</li><li><strong>async</strong>：一个函数，用来启动任务并在一个线程上执行，将任务包装在 packaged_task 中，并利用 future 和 promise 来实现数据传输</li></ul><h2 id="简化使用"><a href="#简化使用" class="headerlink" title="简化使用"></a>简化使用</h2><p>C++ 容易被人批评的一个缺点是，它写起来非常啰嗦，有不少冗余重复的键入。在 C++11 中，引入了一些特性来改善这种问题。</p><p>被程序员们快速接受的新特性是 auto、范围 for 循环和 lambda 表达式。</p><p>这些改进的新功能并没有改变之前的任何问题，或者是引入新的有用的功能，仅仅只是让代码写起来更简洁、清晰，但这也足够有意义。</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>很早之前，auto 被用于指明某个变量位于栈上，但这个属性是默认的，可以不指定。类似的，要求变量存在寄存器中的关键字 register 一直存在，当然用途也并不多。据 Bjarne Stroustrup 说，他在 1982 年就支持了这个特性，但因为和 C 的不兼容性问题，特性被搁置，最终在 C++11 中才再次拿了出来。</p><p>C++11 中的 <strong>auto</strong> 只能用于声明变量类型时使用，由编译器来根据给变量赋值的表达式的类型，来推导变量的类型。这大大简化了很多代码的录入，尤其是一些类型非常复杂，甚至无法写出类型（如 lambda 对象）的变量。</p><blockquote><p>NOTE：auto 用于变量声明时，并不是泛型，而是由编译器来推导的静态类型。</p></blockquote><p>C++ 使用指南中，建议使用 auto 来避免类型名称的多余重复。但在一些场合下，使用 auto 也会带来歧义，比如表达式返回类型不明确时，使用 auto 会让代码不易读：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto ret = function(x, 3);  // 不易读，看不出来 ret 是什么类型</span><br></pre></td></tr></table></figure><p>然而，C++11 中的 auto 依然做的很保守，它只能用于变量的自动推导。C++17 中支持了对函数返回值的 auto 类型和对 lambda 表达式的参数和返回值的 auto 类型；C++20 中才支持了函数参数的 auto 类型。</p><h3 id="范围-for-循环"><a href="#范围-for-循环" class="headerlink" title="范围 for 循环"></a>范围 for 循环</h3><p>大多数现代编程语言中都提供了 for each 的语法，C++ 也不会例外。</p><p>这种语法简化了循环，在不需要关心循环细节时，使用它可以避免一些常见的错误，比如边界判断、错误的索引变量等。</p><h3 id="移动语义和右值引用"><a href="#移动语义和右值引用" class="headerlink" title="移动语义和右值引用"></a>移动语义和右值引用</h3><p>在这个特性出现之前，从函数返回大数据时，为了避免复制数据带来的性能开销，只能通过在自由存储区中分配内存，并通过指针传递数据的引用，无论是从参数传入返回指针，还是将指针从返回值返回。这种写法确实能用，但却很难在运算符重载中应用在自定义类型，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix* <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp;, <span class="type">const</span> Matrix&amp;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">(<span class="type">const</span> Matrix&amp; m1, <span class="type">const</span> Matrtix&amp; m2, <span class="type">const</span> Matrix&amp; m3)</span> </span>&#123;</span><br><span class="line">  Matrix* mret = m1 + m2;  <span class="comment">// 这个可以用 (1)</span></span><br><span class="line">  <span class="comment">// Matrix* mret = m1 + m2 + m3;  // 这个做不了 (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动语义通过移动构造函数来实现，而移动构造函数为了要和复制构造函数区分，采用右值引用作为参数。右值引用作为对右值的引用，也刚好符合移动后，之前位置的所有权便不存在的这一语义。从移动构造函数内部视角来看，形参是右值引用，表示当前构造函数拥有该资源的唯一所有权，也符合 “移动到该函数内” 的定义。</p><blockquote><p>NOTE：符号 <code>&amp;&amp;</code> 用在模板参数时，被叫做引用转发（或完美转发），它用来保持左值引用或右值应用的实参类型，而不发生引用折叠。</p></blockquote><p>现在，STL 中的所有容器类都实现了移动语义，可以使得大型数据能够高效的移动。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11 中提供了 <strong>shared_ptr</strong> 和 <strong>unique_ptr</strong>，它们利用了 RAII 机制，实现了不需要手动 delete 资源的资源管理，也就是将资源 delete 和对象生命周期绑定，在对象析构时同时 delete 相关的资源。</p><p>shared_ptr 比 unique_ptr 出现更早一些，它利用引用计数来标记当前资源有多少个指针在引用，当计数为 0 时才 delete 资源。然而，在多线程程序中，这会导致同步带来的性能问题，所以并不建议滥用 shared_ptr。</p><p>也因此，标准中又提供了 unique_ptr，unique_ptr 是和裸指针一样高效的指针，没有额外开销，它有资源的独占所有权，也就是只实现了移动构造函数和移动赋值运算符，而删掉了拷贝构造函数和拷贝赋值运算符。它取代了之前的 auto_ptr。</p><p>虽然智能指针足够智能，但过分随意的使用依然会带来很严重的问题。前边提到的 shared_ptr 在多线程程序中的性能问题是其中之一，而没有理解 unique_ptr 的所有权性质便乱用，比如 unique_ptr &amp; 这种，无视了智能指针带来的优势。另外，项目中混合使用智能指针和裸指针的操作，也可能引入难以发现的 bug。</p><p>仅在必要时使用智能指针，大多数时候，使用局部变量和更好的类结构和移动语义来实现数据流动。</p><h3 id="统一初始化器"><a href="#统一初始化器" class="headerlink" title="统一初始化器"></a>统一初始化器</h3><p>在该特性之前，不同类型的初始化有不同的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x;      // 基本类型可以有默认初始化，这里给 x 初始化了 0</span><br><span class="line">int x = 7;  // 使用 = 来对值进行初始化</span><br><span class="line">int a[] = &#123; 1, 2 &#125;;  // 使用 &#123;&#125; 来对数组进行初始化，注意只能用于数组</span><br><span class="line">string s;            // 调用了默认构造函数做初始化</span><br><span class="line">vector&lt;int&gt; v(10);   // 使用 vector 的带有 int 参数的构造函数初始化</span><br><span class="line">// vector&lt;int&gt; v = &#123; 1, 2 &#125;;  // 非法操作</span><br></pre></td></tr></table></figure><p>不同的初始化方式带来了很多不确定性，尤其是另一个问题，既同样是列表类型，但自定义容器类型就不能使用 <code>&#123;&#125;</code> 来完成初始化。</p><p>这些需求驱动了 C++ 标准委员会为其拟定一套统一的初始化方式。</p><p>在新的初始化方式下，采用初始化器来初始化，同时允许对其中一些语法做省略：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = &#123;0&#125;;               // 也可写作 int x &#123;0&#125;;</span><br><span class="line">int a[] = &#123; 1, 2 &#125;;        // 也可写作 int a[] &#123;1, 2&#125;;</span><br><span class="line">vector&lt;int&gt; v = &#123; 1, 2 &#125;;  // 也可写作 vector&lt;int&gt; v &#123;1, 2&#125;;</span><br></pre></td></tr></table></figure><p>然而，这种语法的引入事实上为本就混乱的初始化语法带来了更多的混乱，很多人依然习惯于使用过去的写法，而另一些人使用了初始化器的写法。虽然 C++ 标准中保证了编译时不会带来歧义，但从阅读上来说，还是带来了新的负担，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1(10);          // 初始化 10 个值为 0 的元素</span><br><span class="line">vector&lt;int&gt; v2&#123;10, 20, 30&#125;;  // 初始化 3 个值为 10 20 30 的元素</span><br><span class="line">vector&lt;int&gt; v3&#123;10&#125;;          // 应该怎么理解？是 10 个值为 0 的元素，还是 1 个值为 10 的元素</span><br></pre></td></tr></table></figure><p>第三行就是容易引起歧义的用法。虽然 C++ 标准规定了这种写法属于 “1 个值为 10 的元素”，但对于语法表示上来说，确实不是那么清晰。然而，为了兼容旧代码，过去的写法不可能删除，这种问题大概率会一直保持下去。<strong>唯一能做的就是约束软件项目的编程规范（拟定项目的 C++ 标准子集），再通过人工或工具做 code review 来避免项目代码中出现类似的问题。</strong></p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>不需要过多解释的一个特性。它用于避免之前空指针和 0 值的混用，尤其是在类型推导时，一个值为 0 的空指针，既可以推导为指针类型，也可以推导为 int 类型。</p><p>之所以没有使用更简短的名称，原因是在拟定这个特性时，之前的旧代码中已经广泛的使用了如 null、nil 等名字。C++ 标准中引入一个关键词时需要考虑到向前兼容，不能破坏之前的代码，所以新的关键词可能都不会太简单。</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>使用 <strong>constexpr</strong> 修饰的函数，是在编译期就可以运算和求值的函数，将运行时行为提前到编译期，可以提高运行时效率。除此之外，还有一些场景用到 constexpr：</p><ul><li>编译期检查的类型安全计算</li><li>在嵌入式系统编程中减少代码内存占用</li><li>支持元编程</li></ul><p>虽然应用代码中能用到 constexpr 的地方并不多，但 STL 中却有非常多的用途。比如对一些数学计算的查表和固定换算。</p><p>C++11 中引入的 constexpr 特性还只是一部分，在之后的 C++20 中，这个特性才得到完善，并逐渐成为元编程的关键支持特性。</p><h3 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h3><p>对字面量做扩展，可以理解为自定义对字面量做处理的一种语法糖。</p><p>这个特性提供了程序员可以自定义任何符合规范的字面量后缀形式，而不仅限于语言提供的那些。这给一些特殊的场景提供了很大的便利性，比如对数字添加单位：<code>10m</code> 表示 10 米，<code>1.2i</code> 表示虚数 1.2。</p><p>定义方法是一个特殊的字面量运算符，比如虚数字面量的定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constexpr Imaginary operator&quot;&quot;i(long double x) &#123; return Imaginary(x); &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>operator””</code> 为字面量自定义函数，后边接一个标识符，表示后缀内容。</p><p>这个特性也比较小众，一般用不到。</p><p>值得提出的是，在 C++14 中，内建类型的一些字面量后缀才加入到标准库中，比如 <code>100ul</code> 表示 100 且类型是 unsigned long，<code>”10”s</code> 表示 <code>“10”</code> 且类型是 std::string。</p><h3 id="原始字符串字面量"><a href="#原始字符串字面量" class="headerlink" title="原始字符串字面量"></a>原始字符串字面量</h3><p>另外一个小细节。C++11 支持了 regex 特性，正则模式中，大量使用了 <code>\</code> 和 <code>&quot;</code> 这些符号，而 C++ 字符串中，这两个符号却需要转义才能表示其自身。</p><p>为了让正则模式字符串看起来更清晰，这个特性提供了原始字符串标记，使用 <code>R&quot; &quot;</code> 这种模式来标记其中的字符串字面量是原始字符串，不需要转义任何特殊字符。</p><p>这是一个小细节，但在特定的场景下非常实用。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是一些通过 <code>[[ ]]</code> 包含着的特定名词，用来向编译器传递一些信息。C++11 标准中支持的属性有：</p><ul><li><code>[[noreturn]]</code>：表示函数不会返回，比如一些终止程序的函数、和固定抛出异常的函数，编译器可以据此属性做优化，比如不用额外生成针对这种函数调用的上下文恢复的代码。</li><li><code>[[carries_dependency]]</code> ：用于指示一个操作具有依赖关系，通常用在多线程编程中，编译器可以参考这个属性，保证多线程代码的正确优化</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>C++11 不是最早引入泛型编程的版本，早在 C++98 之前，泛型编程已经得到了广泛的使用，然而，当时的语法比较拙劣，导致非常复杂的编码实现和出错信息显示，即使这样，很多程序员依然忍受着痛苦而继续使用泛型编程。人们对泛型编程的需求非常大，C++11 中提出了一些特性来改善泛型编程的使用体验。</p><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>lambda 表达式是 C++11 中提出的新概念，一经提出，便得到了广泛认可和使用。简单来说，lambda 表达式解决了这样的一些需求：</p><ul><li>在需要完整代码块的位置定义代码块（而不是在函数外边或类里边定义成员函数）</li><li>从代码块里访问代码的上下文（也就是闭包）</li><li>代码块是完整独立的封装，可以以统一方式引用</li></ul><p>lambda 表达式的语法并不复杂，但需要简单熟悉，捕获列表中的按引用捕获和按值捕获，以及能够指定捕获某个确定的上下文变量的能力，让 lambda 表达式非常灵活。</p><p>通常，编译器实现 lambda 表达式的方式是将其构建为一个函数对象，并传递这个函数对象。捕获的变量成为函数对象的数据成员，函数体成为函数对象的调用运算符函数（<code>operator()</code>）。<strong>这很可能成为一个有趣的面试题。</strong></p><p>在 C++14 中，进一步对 lambda 表达式支持了参数泛型和移动捕获，从而让它在泛型编程中更易于使用。</p><h3 id="变长模板参数"><a href="#变长模板参数" class="headerlink" title="变长模板参数"></a>变长模板参数</h3><p>这是一个必要的功能，它解决了两个问题：</p><ul><li>实例化包含任意长度的模板类或模板函数</li><li>不能以类型安全的方式传递变长参数</li></ul><p>其基本语法是 <code>...</code> ，通过在类型或模板类型后边添加 <code>...</code> 来表示这个类型或模板类型参数是变长参数。</p><p>在变长参数展开时，传统的做法是通过递归调用当前函数，每次递归中，处理变长参数的第一个参数。然后提供一个非变长参数的特化函数（变长参数的位置只是单独的参数类型）作为递归的出口。</p><p>这种写法实际上会带来一些问题，比如递归本身带来的调用栈空间开销，以及可能大量的模板实例化开销。</p><p>在C++17 中，增加了折叠表达式的特性，允许用简洁方便的语法展开变长模板参数。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>C 的别名机制使用 typedef 来实现，C++ 也支持这种语法。但众所周知，这种语法在某些表现下非常难以阅读，所以 C++11 中提出了 using 来代替 typedef。</p><p>它们的主要区别就是，using 把别名的名称放到了前边，用 <code>=</code> 来连接别名名称和要定义的类型模式。</p><p>在用于给复杂的模板类和模板函数定义起别名中，非常有用。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>tuple 是 C++11 引入的新功能，在这之前，pair 已经出现在标准中。C++ 委员会希望能引入一种可以不限制其中元素数量的打包对象。</p><p>最终，元组 tuple 以库的形式加入到 C++11，而不是以语言特性的形式。C++ 标准在添加新特性时，总是倾向于优先以库的形式增加特性，这样有一些优势：</p><ul><li>在测试时，测试库比测试语言特性更方便</li><li>库可以早于编译器支持新的语言特性之前便投入使用</li></ul><p>然而在我看来，tuple 和 pair 的设计并不是非常优雅，它们本身是未命名的对象集合，所以在传递后，其物理意义可能会被丢弃或被误解，从而降低代码的可读性。建议仅在明显具有打包形式的物理值中使用这种功能，而不是随意使用。比如描述颜色，RGB 三个值可以用 tuple 包装，但将普通参数和返回状态包装在一起就不是好的设计。</p><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>C++ 是静态类型语言，虽然支持泛型，但泛型不等于动态类型。静态类型有一些明显的好处：</p><ul><li>程序表现更清晰，无论是方便程序员理解代码还是梳理编程逻辑</li><li>编译器更容易检查出隐藏的程序问题</li><li>编译器可以生成更优化的程序</li></ul><p>将任何基础类型（int、string 等）都使用具有物理意义的自定义类型（PersonID、PersonName 等）取代，是一种好的编程实践。无论是直接阅读，还是在自定义类型中加入更多的类型合法性检查，都可以进一步加强代码的质量。</p><p>C++11 代码中应当使用以下具有类型安全的指导原则：</p><ul><li>不要再使用 Linux POSIX 和 Windows 提供的并发接口，既不安全，也缺少移植性。使用新的 thread 系列工具</li><li>如无必要（比如必须要获取下标），使用范围 for 循环遍历容器和数组类型</li><li>尽量少的使用指针，同时也不要混合使用指针和引用。使用移动语义时也需要考虑好所有权问题</li><li>放心的使用智能指针，自己实现资源管理类时也要有意识使用 RAII，不要混合使用普通指针和智能指针</li><li>为了避免混乱的初始化语法，使用 C++11 提供的统一初始化语法，同时使用 auto 类型</li><li>使用 constexpr 尽可能地代替宏用法，宏容易出错，出错后报错信息可能很复杂</li><li>用户自定义字面量可以改善字面值的表现力，也加强了类型安全</li><li>用 enum class 代替 enum，收益很大</li><li>在使用内置数组时，考虑用 std::array 替代</li></ul><p><strong>C++ 没有办法删除之前不合理的遗留设计，因为需要考虑兼容老代码。C++ 语言的这种顾虑，就像是 Windows 一样，把困难的东西留给自己，把便捷留给用户，才成就了 C++ 语言历久弥新的特质。</strong></p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>C++11 的标准库中增加了大量的新特性和接口，同时也提供了很多有利于开发标准库的实践方法。</p><h3 id="复杂的实现"><a href="#复杂的实现" class="headerlink" title="复杂的实现"></a>复杂的实现</h3><p>C++ 标准库的设计中，存在着很多复杂的实现，很多实现就像是 “黑魔法”，在可读性上简直就是灾难，但它们确实好用，在 C++20 之前，很多奇怪的用法在标准库的实现中不断出现和进化。</p><p>认为 C++ 比较复杂和难以学习的一个原因，便是标准库的实现，Bjarne Stroustrup 大佬直白的指出，<strong>C++ 的那些所谓“专家”，一股脑地涌入标准库中，去研究这些复杂的语言实现，并且是是而非的通过网络和演讲向其他人解释这些内容，以换取成就感和名望。</strong>在其他计算机语言中，这种复杂性通常被隐藏在编译器内部或者库源码中而不开放给普通用户学习。</p><p>比如有代表性的技巧是 SFINAE（Substitution Failure Is Not An Error），它在标准库代码中被大量使用，但单独拿出来理解时比较困难，它以奇怪的缩写而被广泛传播。这里不展开，有很多网络资料中介绍这个概念。</p><h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>另一个有意义的支持是元编程。C++11 之前，人们已经使用基础的模板和宏等语法特性实现了复杂的元编程，但这些实现非常糟糕，无论是编译时间，对计算机资源的浪费，还是可读性和出错后调试的难度。</p><p>C++11 中提供的大量新特性改善了 C++ 元编程的难度。比如 lambda 表达式、模板别名、constexpr、type trait 以及 enable_if 等内建函数。C++20 才引入的 concept，早在 C++11 中就被提案，但却遗憾的没有被采纳。</p><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>它用来指明一个函数不会抛出异常，编译器可以静态的检查代码中是否有错误的异常设计。</p><p>这在用户代码中用处并不大，但在库实现中用处很大。库的实现时，需要考虑到一些操作是否会抛出异常，从而以更无感的方式来处理异常。如果操作明确不会抛出异常，那么便不需要做任何可能的异常假设，这使得那些担心异常带来性能问题的人放心。</p><p>然而，不抛出异常不代表不需要处理程序错误，没有异常时，很可能需要通过添加其他逻辑代码来处理如返回值、errno 等状态，所以也可能带来工程的复杂化。</p><p>在是否使用 noexcept 的回答之前，需要先搞清楚，异常仅代表着一种处理程序故障的方式，尤其是一些非本地错误。<strong>虽然异常发生时并不是零开销的，但这里的 “零开销设计”，应该被理解为，当其他同样严重的错误出现时，和使用非异常的方式处理相比，没有额外的开销。</strong></p><h3 id="标准库组件"><a href="#标准库组件" class="headerlink" title="标准库组件"></a>标准库组件</h3><p>一些典型的新组件（不完整列表）：</p><ul><li><strong>unique_ptr</strong> 和 <strong>shared_ptr</strong>：依赖 RAII 实现的智能指针类型</li><li><strong>thread</strong>、<strong>mutex</strong>、<strong>condition_variable</strong>：支持多线程编程</li><li><strong>future</strong>、<strong>promise</strong>、<strong>packaged_task</strong>：支持更高级和现代的并发编程</li><li><strong>tuple</strong>：匿名复合类型</li><li><strong>regex</strong>：支持正则表达式</li><li><strong>chrono</strong>：支持和时间有关的操作</li><li><strong>random</strong>：支持不同类型随机数的产生</li><li><strong>unordered_map</strong> 和 <strong>unordered_set</strong>：无序的 map 和 set 容器，使用哈希表实现</li><li><strong>array</strong> 和 <strong>forward_list</strong>：更实用的列表类型</li><li><strong>类型特征</strong>，比如 is_copy_assignable 等，常用于元编程</li></ul><p>很多标准库组件来自于 Boost，一个非常重要的 C++ 三方库，它被用来预先验证 C++ 的功能，并在成熟后被引入 C++ 标准库。Boost 的优势是其非常活跃，有很多不同领域的 C++ 的大佬参与其中，促成了它的高质量和广泛性。</p><p>unordered_map 和 unordered_set 之所以没有被命名为更显然的 hash_map 和 hash_set，也是因为过去已经有一些项目中使用了这些名字（C++ 引入新名称变得越来越困难了），当然现在的名字也并不差，指明了这些容器的特性，不过，只是名字有点太长了。</p><p>chrono 是一个设计非常好且易用的库，用途很广泛。</p><p>除此之外，还有新的一些算法库被引入。</p><hr><p>文章已经很长了，本来没打算写这么多，阅读起来会挺累，为此也删了一些内容。奈何 C++11 中有趣的特性太多了，围绕着他们产生的故事也很多，值得说道说道。</p><p>封面图片是加拿大的 Kinney Lake，来自：<a href="https://unsplash.com/photos/a-lake-surrounded-by-mountains-with-a-sky-filled-with-clouds-_eW1bHhufBg">A lake surrounded by mountains with a sky filled with clouds photo – Free Kinney lake Image on Unsplash</a></p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/717474726">C++11 特性杂谈 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11 就像是一个新的语言，它弥补了之前 C++ 中的很多问题，引入的大量新特性，使 C++ 变成了一个非常易用的计算机语言，这让很多新程序员开始学习 C++，也让 C++ 重新焕发生机。&lt;/p&gt;
&lt;p&gt;可以说，C++11 代表着现代 C++，使用 C++11 标准编写</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>个人说明书 v2.2.2</title>
    <link href="https://p2tree.top/posts/b32e3378.html"/>
    <id>https://p2tree.top/posts/b32e3378.html</id>
    <published>2024-08-23T19:59:27.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是个人说明书"><a href="#什么是个人说明书" class="headerlink" title="什么是个人说明书"></a>什么是个人说明书</h1><p>很喜欢《纳瓦尔宝典》中的一个观点，“把自己当做产品，努力推销出去”。无论是面对雇主还是朋友，当我将自己视作一件产品时，首先想到的便是如何以最快、最全面的方式展示自己，就像一份精心编写的产品说明书，突出最重要、最有意思的部分，也就是你最感兴趣的东西。</p><p>当然，通过整理这样一份说明书，也让我更深入地认识自己，明确自己的优势和不足，理清生活的目标和未来的发展方向。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>当前版本号：<strong>2.2.2</strong></p><p>作为一个软件工程师，发布版本是再熟悉不过的事情了。将自己视为产品，自然也需要不断的更新和完善，所以就需要版本号。</p><p>我的版本号采用三段式，更新策略为：</p><ul><li>职业赛道发生变化时，更新 Major version</li><li>就职公司或岗位发生变化时，更新 Minor version</li><li>每个版本内的修改和完善，更新 Patch version</li></ul><h1 id="我的基本情况"><a href="#我的基本情况" class="headerlink" title="我的基本情况"></a>我的基本情况</h1><ul><li><strong>网名</strong>：<strong>P2Tree</strong></li><li><strong>职业方向</strong>：目前我专注于基础软件开发，也就是编译器、操作系统驱动软件、工具软件及嵌入式软件等方向</li><li><strong>职级</strong>：Senior Software Engineer</li><li><strong>性格特质</strong>：我的 16 型人格是 <strong>INTJ-A</strong><ul><li>个性是<strong>建筑师</strong>。他们是富有想象力和战略性的思想家，喜欢利用创造力和理性来完善生活</li><li>角色是<strong>分析师</strong>（不典型）。崇尚理性和公正，擅长智力辩论、科学和技术领域，思想独立、开放，意志坚强</li><li>执行策略是<strong>自信的个人主义</strong>。喜欢独立完成任务，知道自己适合和擅长什么，选择依靠自己的直觉和技能，而不是依靠他人</li></ul></li><li><strong>我倾向的环境</strong>：喜欢有条理有秩序、安静整洁的环境</li><li><strong>我的爱好</strong>：<ul><li>玩电脑游戏：一个好游戏，可以扩展我生命的宽度和广度</li><li>阅读好书：这是与跨越时空的智者沟通的唯一途径</li><li>养花：植物有生长与凋零，人生有潮起和潮落</li><li>医学常识：生命是大自然最精妙的设计</li></ul></li></ul><h1 id="我的行事方式"><a href="#我的行事方式" class="headerlink" title="我的行事方式"></a>我的行事方式</h1><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><ul><li>对于正式严谨的沟通和讨论，我更喜欢通过邮件或聊天工具交流，一方面可以方便整理思路，另一方面也便于回顾和总结</li><li>对于技术讨论和头脑风暴，我希望面对面拿着笔和白板聊，这样更有利于准确传递没有经过修饰的信息</li><li>非技术性的会议，我不喜欢讨论超过半小时，比如工作汇报。类似的沟通内容我更愿意落实到文字中</li></ul><h1 id="我的技术栈"><a href="#我的技术栈" class="headerlink" title="我的技术栈"></a>我的技术栈</h1><h2 id="我做过的项目"><a href="#我做过的项目" class="headerlink" title="我做过的项目"></a>我做过的项目</h2><h3 id="LLVM-后端入门实践教程"><a href="#LLVM-后端入门实践教程" class="headerlink" title="LLVM 后端入门实践教程"></a>LLVM 后端入门实践教程</h3><p>业余期间，整理完善了一份 LLVM 后端入门实践教程，原本是整理自己学习的笔记成文，结果发表出来后在网络上反响很好，于是便重新整理了全部内容，并提交了项目的代码。<br>这个教程采用相对通俗的语言，使用流程化的步骤编写，旨在指导以最轻松的方式接触 LLVM 后端开发的内容。<br>项目代码：<a href="https://github.com/P2Tree/LLVM_for_cpu0">P2Tree&#x2F;LLVM_for_cpu0 (github.com)</a></p><h3 id="蓝牙手套与腿部姿态捕捉设备"><a href="#蓝牙手套与腿部姿态捕捉设备" class="headerlink" title="蓝牙手套与腿部姿态捕捉设备"></a>蓝牙手套与腿部姿态捕捉设备</h3><h3 id="室内定位机器人"><a href="#室内定位机器人" class="headerlink" title="室内定位机器人"></a>室内定位机器人</h3><p><a href="https://github.com/P2Tree/movingCatchRobot">P2Tree&#x2F;movingCatchRobot (github.com)</a></p><h3 id="建筑材料分析测试仪"><a href="#建筑材料分析测试仪" class="headerlink" title="建筑材料分析测试仪"></a>建筑材料分析测试仪</h3><h2 id="我能解决的问题"><a href="#我能解决的问题" class="headerlink" title="我能解决的问题"></a>我能解决的问题</h2><ul><li>任何在 Linux 操作系统上的软件开发工作。很长一段时间我都在 Linux 上工作，曾经做嵌入式设备时，有一些平台部署了 RT Linux 系统，我也完成过一些驱动软件和应用软件的项目。即使我没做过，我也可以很快通过学习掌握相关技能。</li><li>任何在 LLVM 软件栈上的软件开发工作。我过去的工作都在 LLVM 项目上完成，无论是编译器，还是现在正在做的模拟器等工具。我对 LLVM 提供的软件库和工具都比较熟悉，可以快速搭建原型，也可以对老项目做维护和重构。</li><li>虽然很久没有做嵌入式的工作了，但我依然可以提供技术咨询的工作。过去大概有三四年的时间，我负责或参与了一些很有挑战性的嵌入式项目开发工作，积累了不少经验。另外我还有一些能力很强的朋友，可以提供咨询。</li><li>我很乐意做一些文档整理、格式排版、UI 设计的工作，虽然我并没有系统的学习过类似内容，但我也确实完成过一些反响不错的业余作品，我对此充满热情。</li></ul><h2 id="我不擅长的工作"><a href="#我不擅长的工作" class="headerlink" title="我不擅长的工作"></a>我不擅长的工作</h2><ul><li>通过说服对方来接受自己观点的工作</li><li>枯燥乏味且重复性强的工作</li><li>要求经验积累多于专业深度的工作</li></ul><h2 id="我期待的工作"><a href="#我期待的工作" class="headerlink" title="我期待的工作"></a>我期待的工作</h2><p>我特别希望能做一份和机器人相关的工作。我喜欢智能化控制的设备，也特别看好这个行业的发展，尤其是智能驾驶和自动化工业。我过去的履历中相关的工作非常少，所以大概率不会贸然切换到这个赛道，但我依然埋下这个种子，期待未来时机成熟时，能够迎接新的挑战。</p><h1 id="我的社交媒体"><a href="#我的社交媒体" class="headerlink" title="我的社交媒体"></a>我的社交媒体</h1><h2 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h2><p>我一直都有自己的网络博客，但早期并没有想要自己搭建博客，原因很多，最主要的原因还是维护成本高。最早我在 CSDN 博客建站，当时主要发一些和嵌入式开发有关系的教程和分享文章。转到编译工具链赛道后，我开始把内容输出转移到知乎，因为 CSDN 的商业化味道太严重，让我非常不喜欢。然而，现在我也对知乎失望了，想来想去，还是有个自己的博客比较好，干净、整洁，这就是我想要的网络生活空间。<br>现在和可预见的将来，我的博客域名是 <a href="https://p2tree.top/">https://p2tree.top</a></p><h2 id="个人生活公众号"><a href="#个人生活公众号" class="headerlink" title="个人生活公众号"></a>个人生活公众号</h2><p>疫情那段时间，被隔离了一个月，后来居家办公了一段时间，那段时间突然心血来潮，想学别人搞自媒体，发点自己的生活感悟和读书笔记，于是开了自己的公众号。但我当时并没有了解自媒体这个行业，也选错了平台。微信公众号在 16 年之后就开始走向没落，我在之后的运营中并不顺利，所以停更了三年。但现在我又续更了，我的心态变了，不应该被平台牵着走。<br>我的公众号名称是：<strong>二树说</strong></p><h2 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h2><p>从 CSDN 转到了知乎，虽然现在知乎也已经商业味很浓了，但当时刚来时，知乎还是非常专业，有不少大佬在上边活跃，很多回答都非常有质量，曾经也非常看好知乎。虽然我在知乎上活动不再积极了，但依然感谢知乎，它让我有了一个环境能接触到其他的牛人，也让我自己一定程度上在专业领域内露了脸。<br>你依然可以在知乎上和我联系，主页链接是：<a href="https://www.zhihu.com/people/p2tree">https://www.zhihu.com/people/p2tree</a></p><hr><blockquote><p>有关标题图片：这是人类拍摄到的第一张黑洞的照片，虽然非常模糊，但却是最接近真相的一张照片。在可预见的将来，我们会拍摄到更多更清晰的黑洞照片，这些照片见证着人类探索的脚步。</p></blockquote>]]></content>
    
    
    <summary type="html">这份个人说明书，记录着我的基本信息和所思所想，希望能以最快的方式介绍我自己</summary>
    
    
    
    <category term="自我介绍" scheme="https://p2tree.top/categories/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="个人发展" scheme="https://p2tree.top/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>如何展开可变参数模板的参数包</title>
    <link href="https://p2tree.top/posts/5afd8958.html"/>
    <id>https://p2tree.top/posts/5afd8958.html</id>
    <published>2024-08-15T22:08:39.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 引入可变参数模板（variadic template），可以接受任意数量的模板参数，这对模板的用法是一个很大的改进。然而，可变参数模板的使用也很复杂，在 C++11 中，模板参数包不能直接展开，需要使用递归或者逗号表达式的方式展开，写法比较繁琐。C++17 引入了折叠表达式的语法，用来对可变参数模板中的参数做展开。</p><p>本文介绍与之相关的内容，方便有需要的读者在自己的项目中实践可变参数模板特性。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="什么是可变参数模板"><a href="#什么是可变参数模板" class="headerlink" title="什么是可变参数模板"></a>什么是可变参数模板</h3><p>模板参数列表可变的模板，如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T arg)</span></span>;</span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T... args)</span></span>;</span><br></pre></td></tr></table></figure><p>注意其中的省略号用法，两个地方出现了省略号：</p><ul><li>在模板参数列表中，<code>...</code> 出现在 typename 后边，用来表示 <code>T</code> 是一个可变长的模板参数</li><li>在模板函数参数列表中，<code>...</code> 出现在模板参数类型 <code>T</code> 后边，用来表示 <code>args</code> 是一个模板参数包 我们在函数内部需要使用 <code>args</code> 时，要遵循模板参数包的使用规则。</li></ul><p>注意，参数的数量范围是 <code>[0, N)</code> ，包括 0，也就是说可以实例化没有参数的模板函数。</p><h3 id="不想展开参数包"><a href="#不想展开参数包" class="headerlink" title="不想展开参数包"></a>不想展开参数包</h3><p>有些时候，我们不需要展开参数包，那也是可以的，可以直接使用整个参数包，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取模板参数包的大小</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传递给另一个可变参数模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="type">void</span> <span class="title">another_f</span><span class="params">(T... args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">another_f</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些更复杂的用法，我在最后一节介绍。</p><h2 id="不同的包展开方式"><a href="#不同的包展开方式" class="headerlink" title="不同的包展开方式"></a>不同的包展开方式</h2><h3 id="递归展开"><a href="#递归展开" class="headerlink" title="递归展开"></a>递归展开</h3><p>通过递归展开的实现代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数存在是必要的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归展开可变参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的 print 函数是必要的，处理没参数的情况，也处理递归调用最后一层出口，因为我们上边提到，<code>Ts...</code> 是包括 0 个模板参数的。</p><h3 id="逗号表达式展开"><a href="#逗号表达式展开" class="headerlink" title="逗号表达式展开"></a>逗号表达式展开</h3><p>递归展开的方式需要引入递归，还得单独实现出口函数，比较啰嗦。可以使用逗号表达式展开，实现代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_item</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; (<span class="built_in">print_item</span>(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中逗号表达式中第一项，表示对逗号表达式按序求值（也就是调用 print_item），之后 <code>&#123; ... &#125;</code> 是利用初始化列表的语法，对一个 <code>(print_item(args), 0)</code> 的逗号表达式做大小为 <code>sizeof...(args)</code> 的初始化，大概等效于伪代码 <code>&#123; (print_item(args[1]), 0), (print_item(args[1]), 0), ..., (print_item(args[N]), 0)&#125;</code>。</p><p>0 在这里的用途只是让逗号表达式 <code>(print_item(args), 0)</code> 的类型是 int，从而避免编译器报错，int 类型赋给 <code>int arr[]</code> 是合法的，如果不写 0，<code>int arr[] = &#123; print_item(args)... &#125;;</code> ，编译器会报错无法把 void 类型绑定到 int 的 array 上。</p><p>展开后的形式为（伪代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>),</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="string">&quot;2&quot;</span>), <span class="number">0</span>),</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="number">3</span>), <span class="number">0</span>),</span><br><span class="line">        (<span class="built_in">print_item</span>(<span class="number">4</span>), <span class="number">0</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其叫逗号表达式的展开法，不如叫<strong>初始化列表的展开法</strong>，因为逗号表达式并不是必须的，而初始化列表却是必须的，进而，没有被调用的 <code>int arr[]</code> 也是必须存在的，或者你也可以真的需要它（见后文章节）。比如说，不使用逗号表达式的办法是让 print_item 返回 int 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_item</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="built_in">print_item</span>(args)... &#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以留意下 <code>...</code> 的位置，当它位于参数左边时，表示这个参数的类型是 <code>T...</code> 也就是变长类型 T 的类型，此时参数时折叠状态，比如 <code>T... args</code> 中的 args；当它位于参数（或表达式）右边时，表示将折叠参数展开，比如 <code>args...</code>，展开的参数列表并不是逗号表达式，而是用逗号分隔开的表达式列表，C++标准规定了可以接受的范围。</p><h3 id="折叠表达式展开（C-17）"><a href="#折叠表达式展开（C-17）" class="headerlink" title="折叠表达式展开（C++17）"></a>折叠表达式展开（C++17）</h3><p>折叠表达式展开的语法看起来更奇怪，但它符合一种约定的语法形式，具体的实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一元右折叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    ((std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot;, &quot;</span>), ...) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一元左折叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printL</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    (..., (std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot;, &quot;</span>)) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printR</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printL</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种折叠的展开形式等价于（伪代码）：</p><p>一元右折叠：<code>(std::cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot;, &quot;, (std::cout &lt;&lt; &quot;2&quot; &lt;&lt; &quot;, &quot;, (std::cout &lt;&lt; 3 &lt;&lt; &quot;, &quot;, std::cout &lt;&lt; 4 &lt;&lt; &quot;, &quot;)))</code></p><p>一元左折叠：<code>(((std::cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot;, &quot;, std::cout &lt;&lt; &quot;2&quot; &lt;&lt; &quot;, &quot;), std::cout &lt;&lt; 3 &lt;&lt; &quot;, &quot;), std::cout &lt;&lt; 4 &lt;&lt; &quot;, &quot;)</code></p><p>回归到折叠表达式的定义中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一元左折叠表达式</span><br><span class="line">(pack op ...)</span><br><span class="line">// 一元右折叠表达式</span><br><span class="line">(... op pack)</span><br><span class="line">// 二元左折叠表达式</span><br><span class="line">(pack op ... op init)</span><br><span class="line">// 二元右折叠表达式</span><br><span class="line">(init op ... op pack)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>op</code> 是运算符，支持多种运算符</li><li><code>pack</code> 是包含未展开参数包的表达式</li><li><code>init</code> 是顶层参数，是二元折叠展开的出口，是不包含未展开参数包的表达式</li><li><code>...</code> 是折叠标记</li><li>注意 <code>()</code> 不能省略。</li></ul><p>如果使用一元表达式实现二元表达式的目的，需要给定一个二元出口的特化版本（即空参数包），而直接使用二元表达式，可以用 <code>init</code> 来指定出口值。</p><p>再回头看前边的示例，其中 <code>((std::cout &lt;&lt; args &lt;&lt; &quot;, &quot;), ...)</code> 中，<code>pack</code> 是 <code>(std::cout &lt;&lt; args &lt;&lt; &quot;, &quot;)</code>, <code>op</code> 是 <code>,</code>，也就是逗号表达式的逗号运算符。</p><p>左折叠和右折叠的区别就是先展开左侧参数，还是先展开右侧参数，这在一些要求结合顺序的运算符连接时很重要，比如 <code>-</code> 和 <code>/</code>。</p><p>使用二元折叠表达式实现的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元右折叠表达式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    ((std::cout &lt;&lt; args), ... , <span class="built_in">void</span>()) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二元左折叠表达式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printL</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">void</span>(<span class="number">0</span>), ... , (std::cout &lt;&lt; args)) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们示例中逗号运算符是二元运算符，之所以可以使用一元折叠表达式而不需要指定特化版本，原因是有一些一元折叠表达式拥有默认的空参数包值，是 <code>void()</code>，另外还有 &amp;&amp; 的默认空参数值是 true，|| 的默认空参数值是 false，它们也不需要定义特化版本（只有这 3 个特例）。</p><p>我项目中用到的一个例子，更直观的展示一下折叠表达式在语义上的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(std::convertible_to&lt;<span class="type">int</span>&gt; <span class="keyword">auto</span> ... i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span> + ... + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>std::convertible_to&lt;&gt;</code> 是 C++20 引入的一种 concept，它用来约束 <code>i</code> 的类型必须满足可转换为特定类型的条件；auto 作为泛型参数的用法也是 C++20 中的特性，本质还是模板，这里可以忽略。</p><h3 id="折叠表达式和逗号表达式的对比"><a href="#折叠表达式和逗号表达式的对比" class="headerlink" title="折叠表达式和逗号表达式的对比"></a>折叠表达式和逗号表达式的对比</h3><p>折叠表达式 <code>(args op ...)</code> 和逗号表达式展开 <code>((args, 0)...)</code> 的区别是，折叠表达式更灵活，它将折叠参数按 op 连接，并返回连接之后的整体参数列表，op 可以是逗号，此时和逗号表达式的意义是一样的。</p><p>比如，C++11 中的 <code>args...</code> 的展开虽然是通过逗号分隔，但它并不是逗号表达式，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args...;   <span class="comment">// compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp; ...)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">pass</span>(args...);   <span class="comment">// compiler pass</span></span><br></pre></td></tr></table></figure><p>参数展开时处理参数的函数，如 <code>print</code> 必须提供一个无参的终止类型。 <code>args...</code> 参数包用逗号表达式展开时，没有明确的展开顺序，所以在展开且求值的过程中，顺序是随机的。如果想严格展开顺序，就只能使用折叠表达式，折叠表达式的左折叠和右折叠可以约束展开顺序。</p><h2 id="不展开参数包"><a href="#不展开参数包" class="headerlink" title="不展开参数包"></a>不展开参数包</h2><p>模板参数包可以以 <code>T...</code> 类型来传递，比如将可变长参数模板和完美转发结合起来，实现一个可以创建任意类型的模板工厂函数。</p><p>举例来说，假设我们的目标是通过定义函数 <code>createT</code> 来实现以下用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"><span class="built_in">MyType</span>(<span class="type">int</span>, <span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lvalue</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T1 = <span class="built_in">createT</span>&lt;<span class="type">int</span>&gt;();        <span class="comment">// 不带构造参数的 int 类型对象构造</span></span><br><span class="line"><span class="keyword">auto</span> T2 = <span class="built_in">createT</span>&lt;<span class="type">int</span>&gt;(<span class="number">2011</span>);   <span class="comment">// 带有 1 个右值的 int 类型对象构造</span></span><br><span class="line"><span class="keyword">auto</span> T3 = <span class="built_in">createT</span>&lt;<span class="type">int</span>&gt;(lvalue); <span class="comment">// 带有 1 个左值的 int 类型对象构造</span></span><br><span class="line"><span class="keyword">auto</span> T4 = <span class="built_in">createT</span>&lt;MyType&gt;(lvalue, <span class="number">2011</span>);  <span class="comment">// 带有左值和右值作为构造参数的自定义类型对象构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，但要注意语法，其中的 <code>Args &amp;&amp; ...</code> 是万能引用类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">createT</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库中 std::make_unique 等工厂函数就是这么实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们将 args 整个打包传递给了内部的 <code>std::forward</code>，注意其语法。</p><h3 id="可变长基类继承结构"><a href="#可变长基类继承结构" class="headerlink" title="可变长基类继承结构"></a>可变长基类继承结构</h3><p>还有一些有意思的用法，比如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Base&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base ... &#123;</span><br><span class="line">  <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">using</span> Base::func...;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它表示 Derived 可由模板类中模板参数指定的所有类型作为基类。</p><p>其中的 <code>using Base::func...</code> 可等价于 using 所有在模板参数列表中的基类类型中的 func 函数。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/714536540">如何展开可变参数模板的参数包 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11 引入可变参数模板（variadic template），可以接受任意数量的模板参数，这对模板的用法是一个很大的改进。然而，可变参数模板的使用也很复杂，在 C++11 中，模板参数包不能直接展开，需要使用递归或者逗号表达式的方式展开，写法比较繁琐。C++17 引入</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建笔记</title>
    <link href="https://p2tree.top/posts/6861d72c.html"/>
    <id>https://p2tree.top/posts/6861d72c.html</id>
    <published>2024-08-11T13:57:00.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h2><ul><li><input checked="" disabled="" type="checkbox"> 置顶文章</li><li><input disabled="" type="checkbox"> 站内搜索</li><li><input checked="" disabled="" type="checkbox"> 系列文章</li><li><input checked="" disabled="" type="checkbox"> feed 订阅中的中文乱码</li><li><input checked="" disabled="" type="checkbox"> 收藏链接</li><li><input checked="" disabled="" type="checkbox"> 域名</li><li><input checked="" disabled="" type="checkbox"> 首页轮播：hexo-butterfly-swiper</li><li><input checked="" disabled="" type="checkbox"> 永久链接</li><li><input checked="" disabled="" type="checkbox"> 页脚标签</li><li><input disabled="" type="checkbox"> 双列文章展示</li><li><input checked="" disabled="" type="checkbox"> 顶部加载条</li><li><input disabled="" type="checkbox"> CDN 加速访问，静态资源托管</li><li><input checked="" disabled="" type="checkbox"> 自动化部署（vercel）</li><li><input checked="" disabled="" type="checkbox"> 自动化部署（github action）取代 hexo-deploy-git 手动操作</li><li><input checked="" disabled="" type="checkbox"> 博客源码私有化</li><li><input disabled="" type="checkbox"> 更新评论系统为 Waline</li><li><input disabled="" type="checkbox"> SOE（谷歌和百度）<ul><li><input checked="" disabled="" type="checkbox"> 所有权验证</li><li><input disabled="" type="checkbox"> 站点地图</li></ul></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本博文为笔记性质的内容，全部内容来自于网络，有一些是官方描述，也有一些个人博客上的内容，另外我会把自己操作过程中遇到的问题记下来。<br>如果涉及到版权信息，请联系我删除。</p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>在文章的 front_matter 中增加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">sticky:</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="生成永久链接"><a href="#生成永久链接" class="headerlink" title="生成永久链接"></a>生成永久链接</h2><p>Hexo 中的博文 URL 链接默认是采用日期和文章题目组成，格式如：<code>:year/:month/:day/:title/</code>。这种格式，当文章的标题或日期发生变化后，原来的 URL 链接就会失效，这对于需要在其他地方保存博文链接来说非常不友好。</p><p>Hexo 的 <code>_config.yml</code> 文件中可以配置 permalink 参数来设置永久链接，或者也可以在每篇博文的 Front-matter 中指定 permalink 参数来为这篇博文指定永久链接。<br>具体可以参考这篇文章：<a href="https://hexo.io/zh-cn/docs/permalinks">永久链接（Permalinks） | Hexo</a></p><p>目前，我们可以使用 hexo-abbrlink 来为博文生成一个永久链接。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 hexo 全局 <code>_config.yml</code> 文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可选 permalink: abbrlink 短链接模式  </span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:abbrlink/</span> <span class="comment">#文章的永久链接 或者 permalink: posts/:abbrlink.html 如：http://localhost:4000/post/abaf7e89.html  </span></span><br><span class="line"><span class="comment"># abbrlink config  </span></span><br><span class="line"><span class="attr">abbrlink:</span>  </span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment">#算法: crc16(default) | crc32  </span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#进制: dec(default) | hex</span></span><br></pre></td></tr></table></figure><p>之后，需要重新清理工程文件 <code>hexo clean</code> 再生成一次 <code>hexo g</code>，博文链接就会被全部替换为永久链接，默认格式是：<code>/post/xxxxx.html</code>，这个后缀是通过算法计算出来的唯一值。</p><p>测试时，可能要清理一下浏览器缓存，让浏览器重新拉取新的链接。</p><h2 id="Feed-订阅服务"><a href="#Feed-订阅服务" class="headerlink" title="Feed 订阅服务"></a>Feed 订阅服务</h2><p>Feed 是伴随着个人博客的兴起而出现的。Feed 是一种能够将自己博客中的更新内容以一种约定的格式分享到外部，通过 RSS 的方式由其他客户端订阅和展示的技术。简单说 Feed 就是 RSS 的信源。虽然现在这个年代使用 RSS 已经不是主流了，但依然有一小部分网友热衷于逃脱这个个性化订阅的时代，而是把网络信息来源和内容把握在自己的手里。</p><p>尽管个人博客没落了，但 Feed 已经被各种内容平台广泛使用和发展，作为信息推送的重要环节。</p><p>Hexo 中，可以使用 hexo-generator-feed 来实现对自己的网站生成 Feed 信源。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>在 hexo 全局 <code>_config.yml</code> 文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span>  <span class="comment"># atom | rss2</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>type: RSS的类型(atom&#x2F;rss2)  </li><li>path: 文件路径，默认是 atom.xml&#x2F;rss2.xml  </li><li>limit: 展示文章的数量,使用 0 或则 false 代表展示全部  </li><li>hub: URL of the PubSubHubbub hubs (如果使用不到可以为空)  </li><li>content: （可选）设置 true 可以在 RSS 文件中包含文章全部内容，默认：false  </li><li>content_limit: （可选）摘要中使用的帖子内容的默认长度。 仅在内容设置为false且未显示自定义帖子描述时才使用。  </li><li>content_limit_delim: （可选）如果content_limit用于缩短post内容，则仅在此分隔符的最后一次出现时进行剪切，然后才达到字符限制。默认不使用。  </li><li>icon: （可选）自定义订阅图标，默认设置为主配置中指定的图标。  </li><li>order_by: 订阅内容的顺序。 (默认: -date)</li></ul><p>之后，重新生成一次静态文件：<code>hexo clean &amp;&amp; hexo g</code>，在 publish 路径下会出现 atom.xml 就可以了。在页面需要的地方，通过 <code>/atom.xml</code> 来引用这个文件。</p><h2 id="置顶轮播"><a href="#置顶轮播" class="headerlink" title="置顶轮播"></a>置顶轮播</h2><p>本来是打算支持置顶功能的，顺便搜索了一下，发现大家都在用置顶轮播的插件，样式也挺好看，而且折叠起来也节省空间。</p><p>使用 hexo-butterfly-swiper 插件来实现这个功能。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-swiper --save</span><br></pre></td></tr></table></figure><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>在博客全局 <code>_config.yml</code> 中或者主题的 <code>_config.yml</code> 中添加以下内容（我是在 <code>_config.butterfly.yml</code> 中加入的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-butterfly-swiper  </span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/8e1264d1/  </span></span><br><span class="line"><span class="attr">swiper:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关  </span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权  </span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面  </span></span><br><span class="line">  <span class="attr">timemode:</span> <span class="string">date</span> <span class="comment">#date/updated  </span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型  </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span>  </span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span>  </span><br><span class="line">  <span class="attr">default_descr:</span> <span class="string">再怎么看我也不知道怎么描述它的啦！</span>  </span><br><span class="line">  <span class="attr">swiper_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css</span> <span class="comment">#swiper css依赖  </span></span><br><span class="line">  <span class="attr">swiper_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js</span> <span class="comment">#swiper js依赖  </span></span><br><span class="line">  <span class="attr">custom_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css</span> <span class="comment"># 适配主题样式补丁  </span></span><br><span class="line">  <span class="attr">custom_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js</span> <span class="comment"># swiper初始化方法</span></span><br></pre></td></tr></table></figure><p>需要注意，插件官网（github）上的配置中，js 和 css 的 CDN 已经失效，请使用上边的链接。</p><p>然后，在你想要加入置顶的文章的 front_matter 中，加入一个段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">swiper_index:</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>这个数字是任意正整数，数字越大，越靠前。</p><p>配置之后，<code>hexo clean &amp;&amp; hexo g</code> 即可。</p><h2 id="页脚标签"><a href="#页脚标签" class="headerlink" title="页脚标签"></a>页脚标签</h2><p>一个纯美化的配置，可以在页面页脚处增加自定义的标签，也可增加 “本网站已运行 xxx 时间“ 的计时器。</p><p>使用 hexo-butterfly-footer-beautify 插件可以做到。</p><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-footer-beautify --save</span><br></pre></td></tr></table></figure><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># footer_beautify  </span></span><br><span class="line"><span class="comment"># 页脚计时器：[Native JS Timer](https://akilar.top/posts/b941af/)  </span></span><br><span class="line"><span class="comment"># 页脚徽标：[Add Github Badge](https://akilar.top/posts/e87ad7f8/)  </span></span><br><span class="line"><span class="attr">footer_beautify:</span>  </span><br><span class="line">  <span class="attr">enable:</span>  </span><br><span class="line">    <span class="attr">timer:</span> <span class="literal">true</span> <span class="comment"># 计时器开关  </span></span><br><span class="line">    <span class="attr">bdage:</span> <span class="literal">true</span> <span class="comment"># 徽标开关  </span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权  </span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面  </span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="comment">#屏蔽页面  </span></span><br><span class="line">    <span class="comment"># - /posts/  </span></span><br><span class="line">    <span class="comment"># - /about/  </span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型  </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">footer-wrap</span>  </span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span>  </span><br><span class="line">  <span class="comment"># 计时器部分配置项  </span></span><br><span class="line">  <span class="attr">runtime_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js</span>  </span><br><span class="line">  <span class="attr">runtime_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css</span>  </span><br><span class="line">  <span class="comment"># 徽标部分配置项  </span></span><br><span class="line">  <span class="attr">swiperpara:</span> <span class="number">3</span> <span class="comment">#若非0，则开启轮播功能，每行徽标个数  </span></span><br><span class="line">  <span class="attr">bdageitem:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://hexo.io/</span> <span class="comment">#徽标指向网站链接  </span></span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo</span> <span class="comment">#徽标API  </span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">博客框架为Hexo_v5.4.0</span> <span class="comment">#徽标提示语  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://butterfly.js.org/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">主题版本Butterfly_v3.8.2</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://www.jsdelivr.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站使用JsDelivr为静态资源提供CDN加速</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://vercel.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站采用双线部署，默认线路托管于Vercel</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://vercel.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站采用双线部署，联通线路托管于Coding</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">https://github.com/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站项目由Github托管</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">link:</span> <span class="string">http://creativecommons.org/licenses/by-nc-sa/4.0/</span>  </span><br><span class="line">      <span class="attr">shields:</span> <span class="string">https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris</span>  </span><br><span class="line">      <span class="attr">message:</span> <span class="string">本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可</span>  </span><br><span class="line">  <span class="attr">swiper_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css</span>  </span><br><span class="line">  <span class="attr">swiper_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js</span>  </span><br><span class="line">  <span class="attr">swiperbdage_init_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js</span></span><br></pre></td></tr></table></figure><p>之后 <code>hexo clean &amp;&amp; hexo g</code> 就可以了。</p><h2 id="顶部加载条"><a href="#顶部加载条" class="headerlink" title="顶部加载条"></a>顶部加载条</h2><p>引入 css 文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pace</span> &#123;</span><br><span class="line">-webkit-<span class="attribute">pointer-events</span>: none;</span><br><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line"></span><br><span class="line">-webkit-user-select: none;</span><br><span class="line">-moz-user-select: none;</span><br><span class="line">user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pace-inactive</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#06e1bf</span>;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">2000</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>_config.butterfly.yml</code> 文件中的 preloader 部分注入 css：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source</span></span><br><span class="line">  <span class="comment"># 1. fullpage-loading</span></span><br><span class="line">  <span class="comment"># 2. pace (progress bar)</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># pace theme (see https://codebyzach.github.io/pace/)</span></span><br><span class="line">  <span class="comment"># pace_css_url: https://cdn.jsdelivr.net/npm/pace-js@latest/themes/green/pace-theme-minimal.css</span></span><br><span class="line">  <span class="attr">pace_css_url:</span> <span class="string">/css/pace-theme-minimal.css</span></span><br></pre></td></tr></table></figure><p>重新加载 hexo 后生效。</p><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>我之前的博客发布流程离不开几个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其中 <code>hexo d</code> 是由插件 <code>hexo-deploy-git</code> 提供的功能，通过手动执行在本地对博客源码进行编译，然后自动把编译后的产物推送到部署服务器。</p><p>自动化部署是希望避免在本地手动编译源码，而是通过自动化的流程，和 git 操作绑定，在每一次 git push 之后，平台自动捕获推送动作，并拉取源码做一次构建和部署。</p><p>类似的工具有很多，其中我接触到的是 Vercel 平台和 Github 自带的 github action。</p><h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>这个平台是专门用于 web 托管的平台，我们借用它的功能是免费的。通过 github 账号在 vercel 上登录，并授权 vercel 访问 github 账号内的 repo。</p><p>之后，创建一个项目，并选中我们在 github 上托管的博客源码 repo。</p><p>就这么简单，之后，每一次 git push 操作，它都会拉取源码，做一次构建。然后它提供了一个域名，会把构建后的博客部署在这个域名上。这个域名在国内访问不到，可以绑定自己的域名来代替。</p><hr><div class="note info flat"><p>本文标题图片来源于 <a href="https://www.pinterest.jp/pin/466333736393779796">Pin page (pinterest.jp)</a>。<br>该图片仅用于非商业用途。如涉及版权问题，请及时与我联系，我将予以删除。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TODO-List&quot;&gt;&lt;a href=&quot;#TODO-List&quot; class=&quot;headerlink&quot; title=&quot;TODO List&quot;&gt;&lt;/a&gt;TODO List&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="博客" scheme="https://p2tree.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://p2tree.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>雨幕下的城市映像</title>
    <link href="https://p2tree.top/posts/22b58fab.html"/>
    <id>https://p2tree.top/posts/22b58fab.html</id>
    <published>2024-08-10T17:59:37.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>城市最美的时刻莫过于它在雨中的夜景。</p><p>朦胧的雨雾笼罩了城市往日的喧嚣，路上匆匆走过的行人，雨点沙沙落下的声音，伴随着梦幻般的光影，路灯、车灯和广告牌闪烁着的光，映射在光滑湿润的柏油路面，充满了未来感。</p><p>抬头望去，身边的高楼一支支高耸入雨幕之中，似乎有无数层高，云端隐约闪现的微光照亮了周围的一片朦胧，仿佛置身于梦幻世界中。</p><hr><p><img src="/img/20240810/WechatIMG140.jpg" alt="Chapter.413"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;城市最美的时刻莫过于它在雨中的夜景。&lt;/p&gt;
&lt;p&gt;朦胧的雨雾笼罩了城市往日的喧嚣，路上匆匆走过的行人，雨点沙沙落下的声音，伴随着梦幻般的光影，路灯、车灯和广告牌闪烁着的光，映射在光滑湿润的柏油路面，充满了未来感。&lt;/p&gt;
&lt;p&gt;抬头望去，身边的高楼一支支高耸入雨幕之中，似</summary>
      
    
    
    
    <category term="语录" scheme="https://p2tree.top/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="这个美丽的世界" scheme="https://p2tree.top/tags/%E8%BF%99%E4%B8%AA%E7%BE%8E%E4%B8%BD%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>寻找生活的意义，就是意义所在</title>
    <link href="https://p2tree.top/posts/eaf9e695.html"/>
    <id>https://p2tree.top/posts/eaf9e695.html</id>
    <published>2024-08-06T22:12:25.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>我们总是匆忙地过完每一天，以至于忽略了生活本身的宁静与美好。当追求目标成为我们心中的执念，它便可能转化为焦虑与不安，让我们无法全心投入于每一个当下。我们所追求的目标，就已经偏离了生活的真谛。</p><p>生活的意义，不是静态的终点，而是一段流动的旅程。它不应该是我们不断追问的谜题，而是我们生活过程中自然涌现的答案。若我们总是驻足于思考生活的意义，便可能错失了那些让生活有意义的瞬间。</p><p>生活的意义不是预设的标签，而是我们内心所向往的生活状态的映像。<strong>追求自己所满足的生活状态，本身就成为了生活的意义。</strong></p><hr><p><img src="/img/20240806/Chapter445.jpg" alt="Chapter.445"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们总是匆忙地过完每一天，以至于忽略了生活本身的宁静与美好。当追求目标成为我们心中的执念，它便可能转化为焦虑与不安，让我们无法全心投入于每一个当下。我们所追求的目标，就已经偏离了生活的真谛。&lt;/p&gt;
&lt;p&gt;生活的意义，不是静态的终点，而是一段流动的旅程。它不应该是我们不断追</summary>
      
    
    
    
    <category term="语录" scheme="https://p2tree.top/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="与生活妥协" scheme="https://p2tree.top/tags/%E4%B8%8E%E7%94%9F%E6%B4%BB%E5%A6%A5%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号 P2Tree</title>
    <link href="https://p2tree.top/posts/e8d522db.html"/>
    <id>https://p2tree.top/posts/e8d522db.html</id>
    <published>2024-08-05T22:50:32.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>我自己维护着一个微信公众号，公众号名字是 P2Tree。</p><p>公众号上会同步发布我自己写的一些非技术类文章，比如心得感悟，好书推荐等。为了节省亲爱的你的时间，公众号上的文章都会保证在 5 分钟内读完，这可能会让内容没那么有文采，但绝对压缩到全部是干货。</p><p>我曾经停更过一段时间，因为一度怀疑自己是不是不适合写东西，但最后又想开了，如果感兴趣，可以到公众号里翻翻。</p><p>公众号的文章也会同步发布在博客上。欢迎通过下边二维码关注，也可搜索 P2Tree，握握手～</p><p><img src="/img/20240805/WechatIMG111.webp" alt="公众号 P2Tree"></p>]]></content>
    
    
    <summary type="html">我维护的微信公众号，欢迎来交个朋友</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在飞逝的时光中，他们让未来有所期待</title>
    <link href="https://p2tree.top/posts/93ab5592.html"/>
    <id>https://p2tree.top/posts/93ab5592.html</id>
    <published>2024-07-02T13:06:24.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>在人的三四十岁时，某个瞬间，你可能会惊讶的发现：生命中那些最灿烂的时刻，似乎都已成为了过去，而眼前所剩下的，无非是日复一日的重复与不可避免的衰老。岁月如梭，时间悄然流逝。</p><p>然而，孩子的出现，却能打破这个对未来的枷锁，为生活注入新的活力与未知。他们带来烦恼，也带来牵挂；他们让你欢喜，也让你惊讶。</p><p>孩子让你重温童年的纯真，让你理解当年父母的心情，让你有机会去拥有那些曾经渴望却未曾得到的玩具。在痛苦与挑战面前，孩子让你变得更加坚强和冷静，让你看到童年时的自己，看到他的勇敢、好奇、不安与局促，从而更加深刻地理解并接纳自己。</p><p>父母养育了孩子，而孩子也以他们独特的方式陪伴着父母。在这个过程中，父母与孩子相互滋养，相互成就。<strong>在飞逝的时光中，他们让未来有所期待。</strong></p><hr><p><img src="/img/20240702/Chapter337.jpg" alt="Chapter.337"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在人的三四十岁时，某个瞬间，你可能会惊讶的发现：生命中那些最灿烂的时刻，似乎都已成为了过去，而眼前所剩下的，无非是日复一日的重复与不可避免的衰老。岁月如梭，时间悄然流逝。&lt;/p&gt;
&lt;p&gt;然而，孩子的出现，却能打破这个对未来的枷锁，为生活注入新的活力与未知。他们带来烦恼，也带</summary>
      
    
    
    
    <category term="语录" scheme="https://p2tree.top/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="育儿" scheme="https://p2tree.top/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>扑克昆特牌玩法设计</title>
    <link href="https://p2tree.top/posts/9f7f9c30.html"/>
    <id>https://p2tree.top/posts/9f7f9c30.html</id>
    <published>2024-06-19T10:00:00.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>这篇文章中，我将会介绍如何用扑克牌（一定程度上）复刻传统昆特牌游戏的玩法。其中会涉及到分析昆特牌游戏为什么如此受玩家欢迎的原因，《巫师 3：狂猎》又被称为 “昆特 3” 是有一定道理的 🐶</p><p>通过使用扑克牌复刻昆特牌游戏玩法，可以把昆特牌搬到线下和朋友一起玩，之所以不购买或自制现成的昆特牌桌游套件，是因为扑克牌更容易拿到，而且扑克牌玩昆特牌绕开了一些不重要而且浪费时间的话题讨论中（比如希瑞雅的战力应该给多少）。</p><p>在设计这套玩法之前，我玩了很久的昆特牌及其衍生作品，也研究了昆特牌模组的改进，吸取了其他网友的一些灵感。如果你对这个话题感兴趣，欢迎，我的朋友 👏</p><h2 id="昆特牌介绍"><a href="#昆特牌介绍" class="headerlink" title="昆特牌介绍"></a>昆特牌介绍</h2><p>本文所提到的昆特牌为《巫师 3：狂猎》游戏中的小游戏，也被称为 ”传统昆特牌“，并不是 CDPR 后续出的《巫师之昆特牌》与另外两款单机昆特牌游戏。</p><p>本文不会啰啰嗦嗦的介绍所有关于该游戏的细节，没必要重复，想阅读本文但不了解昆特牌游戏的读者请先移步：<a href="https://witcher.huijiwiki.com/wiki/%E6%98%86%E7%89%B9%E7%89%8C">昆特牌 - 猎魔人中文维基 | 獵魔士中文維基 | 巫师狩魔猎人攻略资料站 | The Witcher | Wiedźmin - 灰机wiki - 北京嘉闻杰诺网络科技有限公司 (huijiwiki.com)</a></p><h3 id="基本玩法"><a href="#基本玩法" class="headerlink" title="基本玩法"></a>基本玩法</h3><p>我会提及一些下文会用到的基本信息，不感兴趣可跳过。</p><p>比赛将与对手一对一，采用三局两胜制。</p><p>游戏开始前双方各自选取 5 个阵营中的其中一个进行游戏，并需要在比赛前整理一套合适的卡组与选择领袖牌。</p><p>牌桌由六排组成，分别是我方攻城排、远程排、近程排、对方近程排、远程排、攻城排。我方放牌至我方所在排，对方牌放置在对方所在排，不同手牌有基本固定的放置排。</p><p>卡牌分为战力牌、特殊牌和领袖牌：</p><ul><li>战力牌拥有一个战力点数，并指定它可以放置的排，部分牌拥有特殊效果，战力牌中有一类牌为英雄牌，不受特殊牌影响</li><li>特殊牌（天气牌）会对牌桌上战力牌战力产生影响</li><li>领袖牌和特殊牌一样，也会产生对战力牌的影响</li></ul><p>比赛开始双方随机抽取一定数量的牌，开始前双方有一次机会可以替换手牌中两张牌为牌组中随机牌的机会。</p><p>之后三局中不会再抽牌（北方领域特色除外）。</p><p>比赛过程中交替出牌，直到其中一方放弃出牌或空牌，另一方可以选择继续出牌。双方放弃出牌后，根据牌桌上双方战力排战力点数总额最高者，获得此局胜利。</p><p>当前局结束后，牌桌清牌（怪物和史凯利格特色除外）。</p><p>某一小局双方分值持平时，双方均不获胜（尼国特色除外）。</p><p>第一小局掷骰子决定哪方先出牌（松鼠党特色除外），之后每一小局出牌方为上一局获胜方。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>五个阵营各自特色为：</p><ul><li>北方领域：某一小局获胜后，允许从牌组中抽取一张牌</li><li>尼国：某一小局双方分值相同时，尼国获胜</li><li>松鼠党：比赛开始时，决定己方先出牌还是对方先出牌</li><li>怪物：每小局结束时，随机一张战力牌留在牌桌</li><li>史凯利格：在第三小局时，随机从己方前两局弃牌中抽取两张牌放入牌桌</li></ul><p>部分战力牌拥有特殊效果，战力牌特殊效果是我认为昆特牌中最复杂的玩法细节，虽然它们相比其他卡牌类游戏并不复杂，这些特殊效果有：</p><ul><li>烧灼：消灭牌桌上当前战力最高的牌（可多张），无论敌方还是我方。如果当前战力牌战力最高，将消灭当前牌</li><li>间谍：放置在对方排，为对方累积战力，但换取己方抽取两张牌</li><li>士气：所在排其他牌战力均 +1，即使是后续放置在该排的牌</li><li>号角：所在排其他牌战力均乘 2，即使是后续放置在该排的牌</li><li>医生：从弃牌中选择一张牌放入牌桌</li><li>同胞：相同牌放置时，每张牌战力乘当前牌桌同名牌的数量，即使是后续放置的相同牌</li><li>召唤：放置牌时召唤卡组中其他同名牌一同打出</li><li>狂战士：放置后如果被转化牌转化，会转化为另一张战力牌，否则保持现状</li><li>转化（玛德罗弥）：放置后对当前排中所有狂战士做转化</li><li>复仇：放置在牌桌，直到下一局自动转化为另一张战力牌并保留在下一局牌桌上</li><li>假人：一种特殊牌（无战力），用来将己方牌桌上的间谍换取到手牌中</li></ul><p>天气牌是非常有趣的一个设计，它作为可以同时影响一排战力牌的强力卡牌，却会对双方排均产生影响，这让使用天气牌时更需要技巧，同时猜测对方是否持有天气排，从而改变己方出牌策略。这些天气牌有：</p><ul><li>白霜：双方近战排所在牌战力降为 1</li><li>浓雾：双方远程排所有牌战力降为 1</li><li>暴雨：双方攻城排所有牌战力降为 1</li><li>晴天：移除场上所有天气牌效果</li><li>史凯利格风暴：将双方远程和攻城排所有牌战力降为 1</li></ul><h3 id="特点及泛化分析"><a href="#特点及泛化分析" class="headerlink" title="特点及泛化分析"></a>特点及泛化分析</h3><h4 id="玩法独特"><a href="#玩法独特" class="headerlink" title="玩法独特:"></a>玩法独特:</h4><p>昆特牌最独具一格的特色是一次性抽牌后三局两胜制玩法，也就是 ”田忌赛马“ 式比赛玩法。某一局的弱势方可以选择放弃当前局保留实力，并尽可能骗取对方放下高战力牌的方式，为自己下一局争取获胜概率。</p><p>独立游戏《巫师之昆特牌》在每小局结束后双方均可抽牌的设计，弱化了传统昆特牌最大的特色，是我认为它衍生决策中最大的败笔。</p><h4 id="入门简单"><a href="#入门简单" class="headerlink" title="入门简单:"></a>入门简单:</h4><p>作为游戏中的小游戏，它最初的设计就不能允许过于复杂。大多数卡牌游戏都过于复杂，不同卡牌有各自的技能，卡牌之间又有克制关系，无论是比赛前熟悉卡牌特性，还是比赛中阅读技能说明，都让整个游戏过程变得复杂，也提高了新玩家熟悉游戏的门槛。</p><p>我不否认卡牌游戏作为策略游戏的一种，应该足够复杂，以提高可玩性，但另一方面，确实也有不少牌类游戏，以简单灵活为特色，被很多人喜爱，典型的就是斗地主。传统昆特牌刚好做到了在简单通用和足够有趣之间找到一个平衡。</p><h4 id="集卡"><a href="#集卡" class="headerlink" title="集卡:"></a>集卡:</h4><p>人们都控制不了自己的收集欲，而昆特牌一定程度上展现了猎魔人世界观的一些背景知识，这让玩家无论是单纯的收集全套，还是收集过程中阅读卡牌描述和了解人物，都变得非常有趣。</p><h4 id="卡牌属性特色"><a href="#卡牌属性特色" class="headerlink" title="卡牌属性特色:"></a>卡牌属性特色:</h4><p>和 “炉石传说” 等卡牌游戏有区别的地方在于它几乎没有双方牌之间的直接战斗，也就是类似炉石中拿一张牌攻击对方牌的做法。这让比赛过程简化很多，只需要关注自己的手牌在什么时机放下牌桌即可。</p><p>另外，特殊牌（天气牌）会对双方牌某排所有牌产生影响。这为游戏带来更多变数，需要思考如何放下特殊牌来最大化己方的战力累积而对对方产生更多影响。间谍牌也是非常有趣的一个设计，通过给对方加战力来换取自己抽取两张新牌的机会，配合假人牌，又克制了间谍牌的强度。不过我认为间谍牌依然是很强力的类型牌。</p><h3 id="不足与改进建议"><a href="#不足与改进建议" class="headerlink" title="不足与改进建议"></a>不足与改进建议</h3><p>5个阵营的特色不明显，尼国和史凯利格比较强。可以突出每类阵营的特色的同时，巧妙的设计克制关系，让不同阵营之间更平衡（昆特牌 mod：redux gwent 有这方面的改进）。另外一个建议是，取消阵营设计，融合阵营特色，将所有卡牌整合到一起。</p><p>领袖牌的特殊能力缺乏特色，有不少领袖的能力和天气牌重复。领袖牌应该有全新的特殊能力设计，甚至突破现有规则，比如设计能攻击对方指定牌的能力。否则可以撤销领袖牌。</p><p>牌组设计必然导致有一些强势牌和弱势牌，这导致在游戏中没有积累到强势牌时，昆特牌比赛非常困难，而积累到强势牌后又非常简单。舍弃牌组准备，而将所有牌都洗入牌组是一个简单的策略，在保证公平的前提下也简化了比赛复杂度。</p><p>英雄牌设计过于强势，比赛时抽取到多张英雄牌基本就决定比赛结果。应当削减英雄牌能力，或者减少（甚至删除）英雄牌。</p><h2 id="扑克昆特牌设计"><a href="#扑克昆特牌设计" class="headerlink" title="扑克昆特牌设计"></a>扑克昆特牌设计</h2><h3 id="考虑细节"><a href="#考虑细节" class="headerlink" title="考虑细节"></a>考虑细节</h3><p>使用扑克牌实现昆特牌玩法，可以还原一部分特性，但必然需要舍弃很多特性。一方面是扑克牌的种类没有那么多，另一方面是实体牌计算分值比较困难。</p><h4 id="核分："><a href="#核分：" class="headerlink" title="核分："></a>核分：</h4><p>作为实体牌玩昆特牌，无论是使用昆特牌桌游卡牌，还是用扑克牌模拟，都会遇到棘手的问题，也就是核算分数。</p><p>进行比赛时，需要累积分值，分值在每一张牌落下时都会作为后续决策的重要参考，所以需要频繁的做计算，如果没有便捷的分值计算方法，游戏过程会变得枯燥。当然也许这是一个练习心算能力的机会 😂。最好能有一个方便的记分工具，一个白板、计算器或者记分骰子是不错的选择。</p><p>另外，作为实体牌进行比赛时，战力牌的特殊效果也对分值计算带来更多挑战，在游戏中，程序会自动计算新的分值，在实体牌中需要额外处理。建议去掉战力牌特殊效果，或者只保留少数。</p><h4 id="取消角色："><a href="#取消角色：" class="headerlink" title="取消角色："></a>取消角色：</h4><p>和昆特牌卡牌不同，扑克牌无法还原卡牌角色及信息，这是缺憾的地方。当然，它也带来了好处，就像我开头所说，我们不必再纠结于角色本身的著作背景与昆特牌战力、特殊效果之间的一致性。</p><p>当然，如果手里有昆特牌桌游卡牌来代替，也是非常幸运的事情。</p><h3 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h3><h4 id="牌桌："><a href="#牌桌：" class="headerlink" title="牌桌："></a>牌桌：</h4><p>将 3+3 排改为 2+2 排，这里和《巫师之昆特牌》的考虑相同，3 排和 2 牌并没有产生本质的区别，反而让牌桌过长（我希望宽一些更符合比赛环境），另外我们的特殊牌也很有限。</p><p>牌桌将包括我方远程牌、近程牌、对方近程牌、远程牌。</p><h4 id="牌组："><a href="#牌组：" class="headerlink" title="牌组："></a>牌组：</h4><p>取消牌组准备的工作，所有牌全部纳入牌组参与比赛。</p><p>双方各自持有红牌（红桃、方片）和黑牌（黑桃、梅花）进行游戏（大小王双方各一张），如果可以用两套扑克牌也可以各自一套牌，但意义不大，因为每次比赛能抽到的牌有限，适当的可猜牌机会也能提高趣味性（双方相同牌都有两张）。四种花色分别放置在四排中，可以任选不同花色。</p><p>比赛开始时摸 10 张牌，允许选择换牌 2 张，之后每局获胜方额外摸 1 张牌。</p><h4 id="阵营："><a href="#阵营：" class="headerlink" title="阵营："></a>阵营：</h4><p>取消多方阵营，将阵营特色融合在一起。</p><p>阵营特色保留某一局获胜方可抽取一张牌的效果。</p><h4 id="战力牌："><a href="#战力牌：" class="headerlink" title="战力牌："></a>战力牌：</h4><p>选择数字 A, 2, 3, 4, 5, 6, 7, 8, 9, 10 的所有花色牌作为战力牌，A 为 1 分牌，其他牌战力与数字一致。</p><p>扑克牌不能表现出所有战力牌的特殊效果，扑克牌的牌特征有限，同时也避免了实体牌计算分值的复杂度。我将保留一些特殊效果，保留的依据是：</p><ul><li>避免给分值计算带来负担</li><li>尽可能保留昆特牌特色</li><li>加强低分牌，所以越强势的特殊效果会赋予给越低的分值牌</li></ul><p>这些特殊效果为：</p><ul><li>烧灼：指定分值的牌可以烧灼，我选择 A，烧灼会直接将被烧灼牌弃牌，不会给计算分值带来困难，A 作为 1 分牌，加强其能力</li><li>间谍：这种重要的特殊效果不能被丢弃，但只能简化它的分值差异，我选择 3 作为间谍，即 3 只能打在对方排，并允许己方抽取两张牌，选择 3 的原因是平衡抽牌的强度</li><li>医生：不会对分值计算带来困难，同时它也是非常有意思的一个特殊效果，我选择 2，作为 2 分牌，加强其能力</li><li>假人：替换己方牌桌上的一张间谍牌到手牌中，我选择大王、小王两张牌（双方各一张）</li><li><del>士气、号角、同胞</del>被舍弃，因为他们会改变牌的战力，对计算分值带来了困难</li><li><del>召唤</del>被舍弃，舍弃的原因是放置时需要到牌组中找牌，对比赛节奏不友好</li><li><del>狂战士、转化和复仇</del>被舍弃，它们也会改变牌的战力，对计算分值不利，在原版游戏中它们对比赛的影响也很有限</li></ul><h4 id="特殊牌："><a href="#特殊牌：" class="headerlink" title="特殊牌："></a>特殊牌：</h4><p>为了减轻分值计算复杂度，我对天气牌做了一个小调整，放置天气牌不是将战力降为 1，而是直接降为 0。降为 1 或 0 对分值的累积没有明显影响，但会极大改善分值计算的难度。</p><p>另外，由于我们只有两排，所以设置的特殊牌为：</p><ul><li>冰霜：将双方近战排所有牌战力降为 0，我选择为 J 牌</li><li>浓雾：将双方远程排所有牌战力降为 0，我选择为 Q 牌</li><li>晴天：移除牌桌上所有天气牌，我选择为 K 牌</li><li><del>暴雨、史凯利格风暴</del>被移出，效果比较重复，而且没有必要用</li></ul><h4 id="领袖牌："><a href="#领袖牌：" class="headerlink" title="领袖牌："></a>领袖牌：</h4><p>领袖牌将会被取消。原版游戏的领袖牌特征，要不过于强势，要不过于弱势，再加上很多特殊效果在战力牌特殊效果中有重复，所以领袖牌的意义并不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我个人的一些建议，欢迎参考和调整，玩的愉快 😆</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开头叨叨&quot;&gt;&lt;a href=&quot;#开头叨叨&quot; class=&quot;headerlink&quot; title=&quot;开头叨叨&quot;&gt;&lt;/a&gt;开头叨叨&lt;/h2&gt;&lt;p&gt;这篇文章中，我将会介绍如何用扑克牌（一定程度上）复刻传统昆特牌游戏的玩法。其中会涉及到分析昆特牌游戏为什么如此受玩家欢迎的原</summary>
      
    
    
    
    <category term="游戏" scheme="https://p2tree.top/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="昆特牌" scheme="https://p2tree.top/tags/%E6%98%86%E7%89%B9%E7%89%8C/"/>
    
    <category term="游戏" scheme="https://p2tree.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>处理器 barrier 行为的仿真实现</title>
    <link href="https://p2tree.top/posts/29efb39b.html"/>
    <id>https://p2tree.top/posts/29efb39b.html</id>
    <published>2024-06-16T10:00:00.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>由于编译器指令重排以及 CPU 乱序执行的问题，处理器指令有可能在多线程执行时遇到一些问题，比如数据竞争，死锁，非预期的计算结果等。为了避免这类潜在的问题，引入了 barrier 的概念。编译器会主动插入 barrier 指令来降低直接调整指令调度环节的复杂性，而硬件的非预期行为也只能通过软件强行做同步来避免。</p><p>在处理器架构领域，barrier 是一种同步行为，它通常是指令或者指令 modifier，用来对程序流进行同步控制。在多处理器或多线程处理器中，当不同的程序流遇到 barrier 时，会等待其他程序流同时到达这个同步点，然后再执行后边的程序。</p><p>这种方式确保了所有的线程或处理器能够在程序的同一个位置重新对齐。</p><p>在一些硬件上，这种行为通过指令实现，比如 intel 的 FENCE 指令，ARM 的 DMB&#x2F;DSB 指令。大多数 barrier 指令都带有对内存操作的同步，也就是在 barrier 之前的读写内存操作必须在 barrier 点完成，以达到内存访存有序的目的，这通常也被称为 memory fence。概念上讲，fence 是 barrier 的一个特例，也就是说 barrier 并不会要求必须实现 fence 的功能，当然这取决于具体硬件。</p><p>本文中，我将会介绍一种对 barrier 指令行为的软件仿真实现。出于简化实现的目的，程序中不会实现 memory fence，只会对程序指令流的同步行为做仿真，也就是 instruction barrier。</p><p>我也会对应用场景做简化，多线程程序和多处理器程序的 barrier 在程序表现上是一致的，不一致的是 barrier 的指令实现，文章和代码介绍多线程程序下的 barrier 仿真，两者之间很容易互通。</p><p>适合看这篇文章的人可能并不多，如果你想进一步了解 barrier 的概念，可以查找其他文章。阅读本文和 demo 程序需要对 C++ 多线程编程有足够的知识，且对汇编程序设计和并行处理器有一些了解。</p><p>我在网络上并没有找到介绍 barrier 仿真的中文资料，所以希望写此文和提供可参考的 demo 程序，帮助有需要的朋友。</p><p>Demo 程序放在：<a href="https://github.com/P2Tree/barrier/tree/master">P2Tree&#x2F;barrier: A simulate demo for barrier behaviour in compute architecture (github.com)</a>，可以直接取用，有问题请反馈我处理。</p><h2 id="设计用例场景"><a href="#设计用例场景" class="headerlink" title="设计用例场景"></a>设计用例场景</h2><p>一个良好的软件工程实践是先梳理需求和应用场景，并编写一些测试用例。我梳理了几种常见的 instruction barrier 的应用场景（以下用汇编伪码介绍），这些场景会作为 UT 出现在代码中：</p><ol><li><p>最普通的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_insts</span><br><span class="line">barrier_sync_all_threads</span><br><span class="line">some_insts</span><br></pre></td></tr></table></figure><p>多线程程序多以这种 sync 所有线程的方式调用 barrier，线程程序中没有分支和跳转指令，所以每个线程都会执行到相同的代码。但由于线程调度和指令 latency，barrier 前后的时间会不同。</p></li><li><p>程序中存在多个 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_insts</span><br><span class="line">barrier_sync_all_threads_with_ID_0</span><br><span class="line">some_insts</span><br><span class="line">barrier_sync_all_threads_with_ID_1</span><br><span class="line">some_insts</span><br></pre></td></tr></table></figure><p>硬件并不会只提供一个 barrier，程序的复杂性会要求同时使用多个不同的 barrier。不同的 barrier 的仿真实现可能带来复杂的同步问题。这里额外说一句，barrier 是一种硬件资源，线程程序需要考虑到不要超出资源限制。同一个 barrier 可以在程序的多个指令中被访问，但需要满足适当的用法，否则会出现程序异常、hangup 等问题。</p></li><li><p>只 wait 部分线程的 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_insts</span><br><span class="line">barrier_sync_partof_threads(count)</span><br><span class="line">some_insts</span><br><span class="line">barrier_sync_all_threads</span><br><span class="line">some_insts</span><br></pre></td></tr></table></figure><p>除了提供对所有线程做同步的 barrier 外，也可能存在对部分线程做同步的 barrier。可能会有两种形式，第一种形式并不关心要同步哪些线程，只关心同步了多少数量的线程；第二种形式关心同步指定线程 ID 的线程。两种形式看似不同，但在仿真实现上基本类似。Demo 中以第一种形式来实现。同步部分线程指令需要带有额外的操作数来指定同步多少线程（或同步哪些线程），超出同步数量的线程（或没有在指定范围内的线程）会直接忽略这个 barrier。</p><p>在做这个测试时，我们适当增加一下线程程序的复杂性，让 barrier_sync_all 和 barrier_sync_partof 同时出现。</p></li><li><p>多个部分线程 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_insts</span><br><span class="line">barrier_sync_partof_threads(count)</span><br><span class="line">some_insts</span><br><span class="line">barrier_sync_partof_threads(count)</span><br><span class="line">some_insts</span><br></pre></td></tr></table></figure><p>这个用例看似和上边类似，但实则不同，实际实现时更复杂。比如两个 barrier 各自都等待 4 个线程，线程 0,1,2,3 在第一个 barrier 暂停，线程 4,5,6,7 会忽略第一个 barrier，而在第二个 barrier 等待。注意到，两个 barrier 指令实际使用了同一个 barrier ID，也就是同一个 barrier 资源。</p></li><li><p>生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread_produce:</span><br><span class="line">barrier_with_produce</span><br><span class="line"></span><br><span class="line">thread_consume:</span><br><span class="line">barrier_with_consume</span><br></pre></td></tr></table></figure><p>生产者-消费者模型是一种常见的数据同步设计。一部分线程生产数据，并由另一部分线程消费数据。生产者线程在数据队列满的情况下会暂停生产，消费者线程在数据队列空的情况下会暂停消费，两者通过 barrier 的一种特殊设计来实现同步。</p><p>为了简化硬件细节，我们采用在 barrier 中增加一个计数器来近似硬件表现出的行为（实际硬件的实现可能大相径庭），生产者对计数器累加，而消费者对计数器累减。</p><p>插句题外话，硬件对这种设计的一个常见的应用场景是，硬件有时会让一个线程发射计算指令，但计算结果会交给所有线程去做后处理。</p></li><li><p>复杂的生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread_produce:</span><br><span class="line">barrier_sync_partof_threads(count)</span><br><span class="line">some_insts</span><br><span class="line">barrier_with_produce</span><br><span class="line"></span><br><span class="line">thread_consume:</span><br><span class="line">barrier_sync_partof_threads(count)</span><br><span class="line">some_insts</span><br><span class="line">barrier_with_consume</span><br></pre></td></tr></table></figure><p>如果之前的 barrier 实现合理，这个混合了普通 barrier 和生产者-消费者 barrier 的程序流应该能够正常工作。而且我这里还需要做个假设，同一个 barrier ID 资源不能同时作为普通 barrier 和生产者-消费者 barrier，否则设计会复杂太多。</p></li></ol><p>以上这些应用场景在我提供的 demo 程序中都能够找到，我没有提供更复杂的测试用例，感觉应该都覆盖到了。</p><p>连续多次 barrier 指令的程序流，看似和一次 barrier 指令没区别，只是重复调用仿真指令就可以。但实际并非如此，两次甚至多次 barrier 之间的 barrier 状态有一些细节要处理，多次 barrier 如果使用相同的 barrier ID（同一个资源），需要考虑 barrier 之间的状态更新和重新初始化。另外，C++ 并发编程中，还需要严格留意临界区的处理，即使你能快速实现第一个 case 的仿真，但后边的 case 依然会引入很多复杂的设计。</p><p>如果你有时间，可以自己拿去玩一下，只留下 test.cpp，设计一个 Barrier 类，看看如何让这些用例都通过。</p><h2 id="程序设计介绍"><a href="#程序设计介绍" class="headerlink" title="程序设计介绍"></a>程序设计介绍</h2><p>我编写了一个 Barrier 类来实现 barrier 指令的所有细节，通过 barrier.h 来了解类结构。我这里对类中的数据成员做介绍：</p><ul><li><p>MutexLock 和 Cond，锁和条件变量，不展开，默认读者需要对它们的使用有充分的了解。</p></li><li><p>Expect，用来记录要同步的线程数量，对于 barrier_sync_all_threads 来说，就是所有线程，否则就是程序在指令中指定的线程数量。</p></li><li><p>Count，一个计数器，参与每一次 barrier 操作。不同线程的相同 PC 下的 barrier 被视为 “同一次” barrier 操作。彻底离开一次 barrier 操作后，这个计数器应该被清零。</p></li><li><p>Release，这个参数最初是没有的，而是为了解决复杂用例下的同步问题而引入，它在不同次 barrier 操作中都会累加，并且不会被清零，它用来弥补 Count 被清零时到下一次 barrier 操作之间的临界区。当然这样会带来累加溢出的问题，我们暂时先不考虑。</p></li><li><p>Actives 数组，用来支持 barrier_sync_partof_threads 的行为，当一次 barrier 操作已经满足全部线程后，其他延迟抵达的线程将会被忽略。为什么不使用 bool 来标记而是使用了 unsigned，感兴趣可以试一下，线程在连续多次 barrier 操作时，是没法处理一个二元状态的，比如第一次遇到 barrier 操作时将 false 改为 true，紧接着第二次遇到 barrier，true 的状态会让他继续 ignore barrier，这是我们不想看到的行为。</p></li></ul><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>完成对总线程数（Expect）和其他一些辅助成员的初始化。</p><h4 id="public-function"><a href="#public-function" class="headerlink" title="public function"></a>public function</h4><p>handleBarSync 用来执行一条普通 barrier，通过重载来区分 barrier_sync_all_threads 和 barrier_sync_partof_threads。前者通过 Barrier 对象来获取总线程数，后者会传入额外一个参数指定要 sync 的线程数量。</p><p>普通 barrier 指令的行为也就是 wait 行为，内部通过同步变量来实现 wait 和 awake。参数 PC 指出 barrier 指令在指令流中的位置；参数 TID 用来指定线程 ID，硬件指令中不需要作为操作数，但仿真时是必需的；参数 Expect 用于在实现 barrier_sync_partof_threads 时指定要 sync 的线程数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Barrier::handleBarSync</span><span class="params">(<span class="type">unsigned</span> PC, <span class="type">unsigned</span> TID)</span> &#123;</span><br><span class="line">    wait(this-&gt;Expect, PC, TID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Barrier::handleBarSync</span><span class="params">(<span class="type">unsigned</span> Expect, <span class="type">unsigned</span> PC, <span class="type">unsigned</span> TID)</span> &#123;</span><br><span class="line">    wait(Expect, PC, TID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleBarProduce 和 handleBarConsume 用来执行一条生产者或消费者 barrier，内部调用了对应的私有函数。</p><p>生产者 barrier 的指令只需要指定 Expect 和 PC，原因是我的模型中假设了只有一个线程作为生产者，如果你的场景中需要多个生产者，我想这个 Demo 还需要调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::handleBarProduce</span><span class="params">(<span class="type">unsigned</span> Expect, <span class="type">unsigned</span> PC)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">produce</span>(Expect, PC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 barrier 的指令不需要 Expect，是因为我的模型中假设所有线程（除了生产者线程）都将作为消费者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::handleBarConsume</span><span class="params">(<span class="type">unsigned</span> PC, <span class="type">unsigned</span> TID)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">consume</span>(PC, TID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private-function"><a href="#private-function" class="headerlink" title="private function"></a>private function</h4><p>私有函数 wait、produce 和 consume 是关键代码。</p><p>wait 函数用来实现普通的 barrier 行为，一个不考虑各种复杂场景下的最简单实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::wait</span><span class="params">(<span class="type">unsigned</span> Expect, <span class="type">unsigned</span> PC, <span class="type">unsigned</span> TID)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">Lock</span><span class="params">(MutexLock)</span></span>;</span><br><span class="line">    Count++;</span><br><span class="line">    <span class="keyword">if</span> (Count == Expect) &#123;</span><br><span class="line">        Count = <span class="number">0</span>;</span><br><span class="line">        Cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Cond.<span class="built_in">wait</span>(Lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以停下来想想这样的设计会带来什么问题？</p><p>它能实现带有 barrier_sync_all_threads 指令的指令流。但不能实现带有 barrier_sync_partof_threads 的指令流。我可以举个例子来说明，假设共 8 个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_insts</span><br><span class="line">barrier_sync_partof_threads(4)   # wait 4 threads</span><br></pre></td></tr></table></figure><p>当其中第 4 个线程的 barrier wait 进入 if 分支后，前 3 个线程在 else 分支中做 Cond.wait，第 4 个线程清零 Count 并会 awake 前 3 个线程。后边 4 个线程会再次进入 Count++ 行为。</p><p>直觉性的，我们需要在前边加个判断，判断当前这一次 barrier 操作已结束（后边的线程不要再处理）。如果复用 Count 来做判断，很容易就会发现，代码难以设计，Count 既需要清 0，又需要作为判断后续线程状态的值而不能及时清 0。</p><p>如果在最后一个线程再清 0 也不可行，原因是在程序流中存在多条 barrier_sync_partof_threads 时（如用例 4），先前释放的线程（前 4 个线程）进入了第二个（相同 barrier 资源）的 barrier handle，它们也需要操作 Counter，与第一个 barrier 还没跑完的线程（后 4 个线程）争夺 Counter 的访问权。</p><p>我们需要一个额外的状态位，这个状态位不能在两次 barrier 操作之间清零（否则就和 Counter 遇到一样的问题），所以我加入了 Release。我们也不能交替使用两个状态（Counter 和 Release），因为我们无法预测指令流中不同的线程会同时执行到几个 barrier 指令（现在例子中是 2 个，但完全可以更多）。</p><p>我们还需要一个标记某个线程是否已经到达一次 barrier 操作，使用 “线程没有达到 barrier 操作” 并且 ”barrier 操作已完成“ 的条件来决定哪些线程需要跳过 barrier 操作。前边已经解释了为什么这个标记（Actives）需要是和 Release 一样的 unsigned 类型，而不是 bool，这里不再重复。</p><p>Release 变量会在每次 barrier 操作完成时累加一次；Actives 中对应线程的位置会在每次 barrier 操作时累加一次，所以两者是同步的。barrier 操作没完成时，Release 和未执行的线程 Actives 是相同的，barrier 操作完成后，Release 累加一次，已执行的线程 Actives 累加一次，未执行的线程 Actives 和 Release 进行比较，就可以判断当前线程是否要 ignore barrier。</p><p>修改后的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::wait</span><span class="params">(<span class="type">unsigned</span> Expect, <span class="type">unsigned</span> PC, <span class="type">unsigned</span> TID)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">Lock</span><span class="params">(MutexLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (Actives[TID] != Release) &#123;</span><br><span class="line">        Actives[TID]++;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="meta"># ignore barrier</span></span><br><span class="line">    &#125;</span><br><span class="line">    Count++;</span><br><span class="line">    Actives[TID]++;</span><br><span class="line">    <span class="keyword">if</span> (Count == Expect) &#123;</span><br><span class="line">        Count = <span class="number">0</span>;</span><br><span class="line">        Release++;</span><br><span class="line">        Cond.<span class="built_in">notify_all</span>();  <span class="meta"># threads all arrived</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Cond.<span class="built_in">wait</span>(Lock);  <span class="meta"># part of threads arrive</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看另外两个函数，produce 和 consume。相比于 wait，这两个函数的实现却显得简单多了。作为 produce 的 barrier，并不会有额外行为，它唯一做的事情就是通知 consume barrier 可以 continue 了，而 consume barrier，只需要 wait 等待 produce 通知即可，这与 C++ 的条件变量的等待-唤醒模型基本吻合。</p><p>produce 的实现可以直接写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::produce</span><span class="params">(<span class="type">unsigned</span> Expect, <span class="type">unsigned</span> PC)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">Lock</span><span class="params">(MutexLock)</span></span>;</span><br><span class="line">    Count = Expect;</span><br><span class="line">    Cond.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>produce 需要明确有几个 consumer 来处理数据，所以这里需要每次都设定 Counter。</p><p>consume 的实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::consume</span><span class="params">(<span class="type">unsigned</span> PC, <span class="type">unsigned</span> TID)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">Lock</span><span class="params">(MutexLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (Count != <span class="number">0</span>) &#123;</span><br><span class="line">        Count--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Cond.<span class="built_in">wait</span>(Lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于 wait 函数，consume 需要对 Counter 做递减，因为 produce 时给它设置了正数的非零值，每个 consume 需要减掉属于自己的那一位。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多的代码细节可以参考我提交的 demo，我要阐述的细节已经完毕。</p><p>这个话题来源于我工作中的一部分，我已经剔除了和业务相关的部分，由于要贴近工作需要，所以一些场景设计可能并没有考虑到，从而目前的设计也可能没有很好的普适性。保存这块代码的一个目的，也是在将来能够有需要时，继续完善它。</p><p>在设计整个 demo 中，自己遇到了一些问题，也进一步夯实了有关 C++ 并发编程的知识。如果你熟悉 C++20，那么会很快发现这很类似 C++20 里边的 std::barrier 和 std::latch。事实上我在实现这套逻辑的过程中发现了，但由于我的项目没有依赖 C++20 开发，所以没办法直接使用现成的模型。另外，我也没有尝试去使用 boost::barrier，因为它的实现比较单一，而我实际业务场景中有很多需要定制的地方，索性自己实现一套。</p><p>如果你愿意参考一下标准实现，我认为是极好的，我 demo 中的 count 对应 boost 库实现中的 m_count，release 对应 m_generation。我也认为其中有很多值得优化的地方，欢迎交流，有空的时候，我会再看看 std::barrier 的实现。</p><p>另一方面，并发编程需要处理很多细节，一些极端的异常需要在非常苛刻的环境下才能复现，而且调试也非常困难，本文中列举的示例场景依然只是其中一部分。Demo 中的代码实现比文章中的要复杂一些，因为其中处理了一些并发的小问题，比如应对 wait 的虚假唤醒，感兴趣的朋友可以找网上其他资料了解，有很多文章介绍。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/703597874">处理器 barrier 行为的仿真实现 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开头叨叨&quot;&gt;&lt;a href=&quot;#开头叨叨&quot; class=&quot;headerlink&quot; title=&quot;开头叨叨&quot;&gt;&lt;/a&gt;开头叨叨&lt;/h2&gt;&lt;p&gt;由于编译器指令重排以及 CPU 乱序执行的问题，处理器指令有可能在多线程执行时遇到一些问题，比如数据竞争，死锁，非预期的计算</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="并发编程" scheme="https://p2tree.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="体系结构" scheme="https://p2tree.top/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="仿真" scheme="https://p2tree.top/tags/%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Vim 高效编辑技巧</title>
    <link href="https://p2tree.top/posts/73fc32a.html"/>
    <id>https://p2tree.top/posts/73fc32a.html</id>
    <published>2023-10-14T10:00:00.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>这篇文章围绕 Vim 展开。</p><p>很早前就想写一篇关于 Vim 的文章，但始终难以动笔，是因为担心自己的领悟还不够高。前几个月，得知 Vim 创始人和维护者 Bram Moolenaar 去世了，又重新翻阅了一些文章，就打算做一次 Vim 的传道师，给一些不了解这个软件和刚刚接触、或曾经接触过的朋友们做一些粗浅地介绍。</p><p>在知乎问答中，有很多对于 Vim 的讨论，也有一些非常不错的回答，作为一个爱好者和每天都离不开使用 Vim 的人，显然我阅读了其中大多数内容。本着不输出重复信息的原则，我在这篇文章中，会以另一种视角介绍 Vim，也就是从 Vim 的设计理念出发，介绍一些如何高效进行代码编辑的技巧。最后我也会谈谈我对一些话题的想法。</p><p>Vim 是 Vi 的增强版，诞生于那个计算机图形界面还未成熟的年代，所以当时鼠标这个外设也没有普及，文字录入工作还只依赖于键盘输入，所以很多同学讨论为什么 Vim 不支持丰富的光标操作，原因就在于此。虽然后来图形化已经替代了终端程序，成为消费级计算机主要的用户接口之一，但在一些特殊场合和应用场景下，非图形化的终端程序，依然充当着重要的功能。这其中就包括部分场景下的代码编辑工作。</p><p>大多数对 Vim 痴迷的计算机技术人员，据我了解，基本能囊括在以下几点，这也是 Vim 区别于其他文本编辑器的重要特点：</p><ul><li>快速，不依赖鼠标控制实现任何编辑操作（模态编辑）</li><li>灵活，扩展性极强，可以自由定制（Vimscript，插件系统）</li><li>启动快速，与系统软件契合较好（轻量级）</li><li>工作环境受限，只能使用 Vim(Vi) 工作（Mac、Linux 系统自带程序）</li><li>开源软件，社区维护，免费使用</li></ul><p>其中最有特色的就是第一点，以至于很多其他编辑软件中，也会提供 Vim 键位和扩展（甚至包括一些非文本编辑类软件，比如控制浏览器）。</p><p>任何一点单独拿出来，都有其他匹配的软件有相似的特性，但结合在一起，可能只有 Vim 能做到了。</p><h2 id="实践心得"><a href="#实践心得" class="headerlink" title="实践心得"></a>实践心得</h2><p>在进入主题之前，先介绍一下我自己的学习和使用 Vim 的心得。</p><p>首先要摆正一个观念，Vim 是一个自定义程度很强的软件，所以达到一个目的，可能有很多种方法，有些方法快速，有些方法复杂，但其差别可能也就是一次点击和多次点击，所以<strong>并不是要求必须学会了所有的操作，才能开始使用它</strong>。就像我们刚开始接触电脑时，还不了解文件系统，而是将所有材料都放在桌面上，也一样可以工作。之后我们了解更多了，就可以不断地改善工作链路，让整个系统更高效。</p><p>学习和使用 Vim 的过程，是不断重复这样一个闭环的过程：</p><ol><li>掌握一些用法，开始用它干活</li><li>发现一些操作很繁琐</li><li>思考这些操作，能否用更高效的操作替代</li><li>逐渐适应新的操作，取代旧的操作</li><li>新操作熟练掌握，形成肌肉记忆</li></ol><p>我已经使用 Vim 十年了，依然还在践行这样一个迭代的过程，不断学习新的东西，并让自己对这款软件的使用更高效。</p><p>其中提到 ”肌肉记忆“，我应该也说一下。对于 Vim 新手来说，到网上查到一些用法，操作时总要回忆和记忆键位，所以并没有提高输入的效率。但其实这个阶段，还没有走完一次闭环（此时还在第 4 步）。只有完成了肌肉记忆，才是对这个新操作的完全掌握，就像弹钢琴，想发出什么音，到怎么发出，之间是没有 “这个音在哪个键上，应该用哪个手指点击” 这样一个脑回路的。</p><h2 id="模态编辑"><a href="#模态编辑" class="headerlink" title="模态编辑"></a>模态编辑</h2><p>开始使用 Vim 时，首先一定要学习这个概念。Vim 只依赖键盘输入，包括输入文本内容和输入控制指令。为了能高效的输入控制指令，Vim 不同于其他程序采用 Ctrl 和 Alt 等键位连接字母区键位的组合键方式，而是重新利用键盘中易于触碰的部分按键实现大多数功能。组合键方式有一些键位比较难以点击，尤其是当需要多次点击时，这会打断输入流。</p><p>为了做到这一点，Vim 对键盘区做了多层的重新映射，在不同的模态（映射模式）下，点击相同的键，会有完全不同的行为。Vim 启动后，默认处于 Normal 模式，可以认为是 HOME 模式，依赖于一些按键，可以进入其他模式，在其他模式下，按 Esc 键，可以回到 Normal 模式。</p><p>Vim 支持几种不同的模态，常用的有：</p><ul><li>Normal 模式：控制光标移动和对文本内容的修改（删除、复制等），并可以做到大量其他模式的操作</li><li>Insert 模式：文本内容输入，和其他编辑器一样</li><li>Visual 模式：选择内容，属于 Normal 模式的扩展，和 Command 模式配合，可以做到很多操作</li><li>Command 模式：控制软件的行为，它也可以实现其他几种模式的功能</li><li>Block Visual 模式：块选内容，和 Visual 模式类似，但按类似鼠标框选的方式选择文本</li><li>Replace 模式：替换一个字符或连续替换字符</li><li>Search 模式：搜索和跳转等</li></ul><p><img src="/img/20231014/img1.png" alt="Vim 模态关系"></p><p>对 Vim 的学习主要围绕着 Normal 模式展开。入门 Vim 的第一次闭环，就是将怎么切换模态（至少是在 Normal 和 Insert 之间切换）形成肌肉记忆的过程。</p><p>Normal 模式下常用的操作一定要熟悉，Command 命令可以在脚本里映射到 key，所以不用刻意记，熟悉了之后就随意了。后文会介绍一些常用的操作。</p><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>Vim 提供了自己的一套配置脚本语言，我们可以利用这种编程范式，配置一些自定义的自动命令序列，比方说，我有一个自动命令，可以在每次保存时自动删除行末尾的空白字符。这种自定义的命令可以通过特定事件触发，也可以手动触发。另一个同样出色的编辑器，emacs，也因这种特性而同样被很多程序员们推崇。</p><p>在这种扩展性的基础上，衍生出了很多通用且优质的配置文件，进而发展成了插件系统。插件系统易于安装、扩展和分发，对于很多通用的扩展。很多朋友可能会说，其他现代编辑器，如 VSCode 也支持插件系统，没错，它们都是优秀的编辑器软件。</p><p>扩展性这个重要的特点，给予了使用者完全的自由，就像自己在设计属于自己的程序一样，这对于程序员这个群体来说，简直如鱼得水。</p><p>Vim 的一个 Fork 版，Neovim，放弃了维护 Vimscript 这个脚本语言，转而将一种更通用的语言，lua，作为另一种可以配置的脚本语言。由于 lua 相比于 Vimscript 来说，是一门更完善且易用的编程语言，更易于学习和阅读，所以得到大家的一致赞同，也成为了吸引新用户使用 Neovim 的重要亮点。目前，使用 lua 编写的配置文件和插件，如雨后春笋般涌现，Neovim 的开发社区也比 Vim 更活跃一些。</p><p>我并不想在本文介绍常用地插件和配置文件，如果有朋友感兴趣，我可以单独开一期，像其他介绍 Vim 的文章一样，分享一些我的 Vim 配置。</p><h2 id="一些实践技巧"><a href="#一些实践技巧" class="headerlink" title="一些实践技巧"></a>一些实践技巧</h2><p>下边我会介绍一些使用 Vim 所特有的技巧，如果你是初学者，可能还没有掌握其中一些操作。这没有任何问题，我保证我介绍的都是比较基础的技巧，你可以利用上边介绍的实践心得，逐步接触、学习直到掌握这些更优秀的实践技巧。</p><p>如果我不特意说明，以下的操作都是在 Normal 模式中完成，部分操作也支持 Visual 模式。</p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>很多人都知道说，新手使用 Vim 时，很难脱离方向键移动光标的习惯，这很正常。所以他们被建议禁用方向键。我个人认为这种做法有点太极端。最早的键盘里是没有方向键的，这才使得 Vim 在设计光标移动时采用了 <code>h</code> <code>j</code> <code>k</code> <code>l</code>  的键位，在当时这种键位设计也不是 Vim 独有的。但这并不代表着方向键不如 <code>h</code> <code>j</code> <code>k</code> <code>l</code> ，否则也无法解释为什么后来的键盘添加了这样的按键了。</p><p>我倾向于说，<code>h</code> <code>j</code> <code>k</code> <code>l</code>  的学习并不应该成为接触 Vim 的一个门槛，如果习惯用方向键，依然可以用。当然，<code>h</code> <code>j</code> <code>k</code> <code>l</code>  的使用效率确实比方向键高，可以利用前边的实践心得来逐步地适应这套键位。</p><p>另外，hjkl 在 Vim 中也依然是最低效的一类光标移动操作。本质上它只避免了右手向右下方方向键区的移动，行为和方向键依然是一样的。Vim 的一个独特之处就在于，它天生适合代码编辑环境，所以光标在代码中的移动，其实有很多种，比如说：</p><ul><li>使用 <code>Ctrl-d</code>，<code>Ctrl-u</code>，<code>Ctrl-f</code>，<code>Ctrl-b</code> 快速翻页</li><li><code>e</code> 到 下一个单词末尾，<code>b</code> 到上一个单词开头，<code>w</code> 到下一个单词开头等</li><li><code>gg</code> 和 <code>G</code> 到第一行或最后一行</li><li><code>-</code> 来搜索特定的单词，<code>n</code> 或 <code>N</code> 向下或向上跳转</li><li><code>/</code> 进入搜索模式，快速搜索任何支持正则匹配的字段</li><li><code>%</code> 跳转到匹配的括号</li><li><code>gd</code> 跳转函数定义，<code>Ctrl-o</code> 返回</li></ul><p>不再过多举例，这些也只是比较常见的快速移动操作，配合一些扩展，还能实现更复杂的快速移动。</p><h3 id="不要重复操作"><a href="#不要重复操作" class="headerlink" title="不要重复操作"></a>不要重复操作</h3><p>这一小节，我想探讨下使用各种更高效的方式替代通过按住一个键一段时间来完成目标的行为。</p><p>比如说，向下翻页，我们可能按住方向键下键一段时间，快要到达目的地时，多次短按下键，如果超出了目的行，还要短按上键。另一个例子是按住 <code>backspace</code> 键来删除一段文本。</p><p>这种操作就叫重复操作。不同于写文章，代码编辑中会更多的涉及到重复操作，比如复制粘贴，比如移动位置。</p><p>重复操作带来了更多的时间浪费，而且会占用我们宝贵的注意力，毕竟，脑子里都是代码逻辑的时候，抽出注意力去关注按住多久才要松手这种事，其实是潜在占用精力的。</p><p>Vim 的设计哲学中，非常在意避免重复操作，所以它原生支持大量的操作来替代重复操作，比如说：</p><ul><li><code>dd</code> 删除一行，<code>d$</code> 删除从当前光标到行尾，<code>df</code> 加任何一个字符，就是删除从当前光标到接下来搜索该行中出现的第一个这个字符的位置，把 <code>f</code> 换成 <code>F</code> 就是向前删到指定字符，换成 <code>t</code> 或 <code>T</code> 的行为类似，区别是保留搜索到的字符不删除（类似闭区间和开区间）</li><li><code>x</code> 删除当前字符，替代 <code>a + backspace + Esc</code></li><li><code>h</code> <code>j</code> <code>k</code> <code>l</code>  加一个数字，就是向左下上右移动对应距离</li><li><code>c</code> 是删除并插入， 替代 x + i，如果你经常使用 dwi 删除一个单词后进入插入模式，那么可以换成 cw</li></ul><p>这种技巧其实非常多。另外值得提一下的是强大的 dot 操作和宏操作。</p><p>dot 操作，就是 <code>.</code> 键，这个键可以重复上一次原子操作，比如 <code>cw</code> 就是一次原子操作，如果需要重复这个操作多次，那么就不必要 <code>cwcwcwcw</code> 这样输入，而是 <code>cw...</code> ，是不是会快很多。</p><p>宏操作也很类似，它允许你定义一段操作作为一个集合，然后重复执行这个集合，就可以快速完成重复操作。</p><p>比如举我工作中常见的一个应用。我有时需要将一个特别长的行，按一些规律换行成多行，比如换行成每行 32 个字符，每隔 32 行中间插个空行。如果字符特别多，这种操作就会比较费时。我可以利用宏，先录制对前 32 行 32 列字符的操作，之后就可以播放这个宏，即可一键完成所有数据的处理。</p><p>宏操作只需要记住两个动作：</p><ul><li>录制：<code>q</code> 加一个字符，这个字符在 Vim 中被叫做寄存器，用来缓存内容的空间，字母区和一些特殊字符都对应一个专门的寄存器</li><li>播放：<code>@</code> 加这个字符，播放这个字符对应寄存器中的操作</li></ul><p>dot 操作可以和宏操作结合起来用，实现更快速的操作。</p><p>学习如何避免重复操作，是使用 Vim 进阶必须要走的路。</p><p>在插入模式中避免重复的操作，就是 snippet 和自动补全机制，这些特性在其他代码编辑器中也存在，我就不展开了。</p><h3 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h3><p>很多进阶的 Vim 介绍文章和视频都会提到文本对象这个概念（text object），但其实不是什么很复杂的概念。</p><p>当我们拿到一个文本时，可以按不同性质将它切分，比如按段落，按行，按单词。Vim 中会增加更多的切分方式。比如，可以指定一个边界来切分，如 <code>&#123;</code> <code>&#125;</code> 中的内容，或者指定一个函数块或类块。这个东西就是文本对象。</p><p>文本对象是一种选择后执行逻辑，就是指定要选中哪些切分的内容，然后按指定方式执行。</p><p>为了区别要不要在选中内容时，同时也选中边界，Vim 提供了两个文本对象标记，<code>i</code> 和 <code>a</code>，<code>i</code> 表示 inside，指不包含边界，<code>a</code> 表示 around，指包含边界。需要配合一个对文本对象操作的动作一起执行。比如：</p><ul><li>删除一个 <code>&#123;</code> <code>&#125;</code> 包含的内容，不包括边界就是 <code>di&#123;</code>，包括边界就是 <code>da&#123;</code></li><li>选中一个段落，使用 <code>vip</code>，<code>v</code> 表示开始选中并进入 Visual 模式，<code>p</code> 表示段落</li></ul><p>具体动作 <code>d</code> 或 <code>v</code>，可以将它替换成其他类似的操作实现其他功能。</p><p>文本对象是一个很值得摸索和研究的话题。</p><h3 id="程序思维"><a href="#程序思维" class="headerlink" title="程序思维"></a>程序思维</h3><p>上边这几个小节中，其实已经体现出了在使用 Vim 过程中的程序思维。程序思维，就是可以非常自由的拼接一些操作，来实现更复杂的操作。<code>d</code> 表示删除，<code>i</code> 表示不包含边界，<code>&#123;</code> 表示边界字符是 <code>&#123;</code> <code>&#125;</code>，连接起来就是删除不包含 <code>&#123;</code> <code>&#125;</code> 边界的中间的文本对象。<code>y</code> 表示复制，<code>G</code> 表示光标到文档结尾，连接起来就是复制从当前光标位置开始到结尾的内容。</p><p>Vim 的灵活性在这里体现的淋漓尽致，就像自动化编程一样，你可以按一定规律随意组合一些操作，快速完成一些复杂操作。对于一些开始复杂化的操作，可以将它编写到 keymap 中，或者 autocmd 中，实现更方便的快速完成。</p><p>当然，这里我想再重复一下本文开头的一个说明，即使你不熟悉这些看起来复杂的操作，也依然可以使用 Vim，这些只是可能对你有帮助的扩展，如果能掌握一定是更好的。大多数使用 Vim 的用户，可能也只掌握了不到一半的特性，这不妨碍他们完成工作任务。</p><h3 id="肌肉记忆"><a href="#肌肉记忆" class="headerlink" title="肌肉记忆"></a>肌肉记忆</h3><p>我能想到的最后一个技巧，或者说不是技巧，而是概念，就是肌肉记忆。</p><p>就像开车一样，刚开始学习怎么开车时，我们需要思考哪里是油门刹车，怎么挂档位，但熟悉之后，这些操作就成为了一种习惯，不需要再刻意思考就可以完成，这就是肌肉记忆。</p><p>Vim 也同样如此，看似挺复杂的操作，比如 <code>h</code> <code>j</code> <code>k</code> <code>l</code>  这种不太符合常规的方向移动键，当你适应之后，就不会再有使用的困难了。我在将 <code>h</code> <code>j</code> <code>k</code> <code>l</code>  解释成 “左下上右” 时，还需要思考一下，但使用 Vim 中从来不用思考，这就是肌肉记忆优先于大脑记忆。</p><p>这种肌肉记忆需要练习，也就是我前边实践心得中的第 4-5 阶段，当完成第 5 阶段之后，这个操作技能就会被掌握，就会成为你使用 Vim 完成开发的得力助手。</p><p>当然还有个小话题，如果你还不会盲打，那么先练习盲打，肌肉记忆是手指的肌肉，而不是视觉和大脑的反馈。</p><h2 id="不做-IDE"><a href="#不做-IDE" class="headerlink" title="不做 IDE"></a>不做 IDE</h2><p>在网上越来越多的关于 Vim 的讨论都是关于 “怎么将 Vim 打造成一个强大的 IDE”，或者是拿 Vim 和 Visual Studio 这种 IDE 做比较。我的观点是，力气用错地方了。除非是享受 Vim 强大的扩展性，享受将它升级成各种强大软件的过程，除此之外，Vim 并不适合成为一个 IDE。</p><p>IDE 软件在 UI、稳定性、兼容性等方面做的都比较好，这是由于大多数成熟的 IDE 都有着强大的企业资源在支撑。而 Vim 只是一个开源软件，它依赖一种社区共识以及整体开发人员的水平和素质。Vim 确实是一个优秀软件，但将各种 IDE 的功能，如构建和调试、文件管理、发布和部署这些都集中起来，对 Vim 来说是有挑战性的，毕竟它最初的设计只是一个出色的代码编辑器。当然，Vim 及 Neovim 的配置和插件生态中，确实存在很多优秀的样本。</p><p>但这并不表示 Vim 相比 IDE 软件来说低人一等，Vim 有它独特的使用场景。比如说：</p><ul><li>Linux 运维人员，服务器在云端，远程访问机器</li><li>仅使用终端来开发和部署软件的工作</li></ul><p>注意，我这里说的是 Vim 相比 IDE 独特的场景，而不是 Vim 可以使用的场景。</p><p>之前我写过一篇介绍 Tmux 的文章，通常这种环境下工作的工程师，都会配合一个终端管理器或窗口管理器，为了就是能灵活的使用 Vim 和其他系统软件，而不会有很大的割裂感。</p><p>换句话说，<strong>和 IDE 做比较的，不应该是 Vim，而是基于 Vim 作为代码编辑器的操作系统环境</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概就说这些吧，如果看到有更好的 Vim 话题，我会继续更新。</p><p>以上内容仅代表我个人观点，我自己是非常喜欢倒腾 Vim 等工具的，Vim 和 Neovim 我自己搭建过类 IDE 环境，也用过很多种发行版（也就是别人搭好的环境），将它一步步改造成适合自己的软件，是很有成就感的。</p><p>但目前开始佛系，不再会向当初那样天天去社区看更新进展，茶余饭后去思考怎么在功能丰富性和性能方面去找平衡。可能是年纪大了吧，看到 Vim 的讨论依然这么热烈，Neovim 的生态也在蒸蒸日上，我是欣慰的。</p><p>工具终归是工具，就像争论什么是最好的编程语言一样，争论什么是最好的代码编辑工具，实际上都是没什么意义的，认清目标，适合自己的和适合项目的，就是最好的。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/661320417">Vim 高效编辑技巧 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
    <summary type="html">绝对是全网都没有的 Vim 使用硬干货经验</summary>
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Vim" scheme="https://p2tree.top/tags/Vim/"/>
    
    <category term="软件工具" scheme="https://p2tree.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    <category term="终端开发" scheme="https://p2tree.top/tags/%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="高效编程" scheme="https://p2tree.top/tags/%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LLVM 风格的 RTTI</title>
    <link href="https://p2tree.top/posts/801cd0f2.html"/>
    <id>https://p2tree.top/posts/801cd0f2.html</id>
    <published>2023-08-14T14:47:40.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>众所周知，LLVM project 没有开启 C++ 的 RTTI 特性。一个主要的原因是 LLVM project 认为 C++ RTTI 特性的实现需要使用到虚函数表，对性能并不友好。LLVM 自己实现了一种类似 RTTI 的行为。我们在开发 LLVM 代码时，尤其是需要自己搭建自定义的数据结构时，可能会想用到 RTTI，此时，学习在 LLVM 风格下如何创建类似的 API，就显得尤为重要。</p><h2 id="什么是-RTTI"><a href="#什么是-RTTI" class="headerlink" title="什么是 RTTI"></a>什么是 RTTI</h2><p>难度：⭐</p><p>RTTI 是运行时类型识别，全称 Runtime Type Identification，网上有很多介绍这个的资料，属于 C++ 程序员必须要熟悉的内容。</p><p>它的主要目的是为程序运行时提供一种对对象类型的获取、操作的方式。</p><p>对应到 C++ API 上，有三个 API 会用到 RTTI：</p><ul><li>dynamic_cast，用来将一个指向基类的指针转换为一个指向派生类的指针，如果转换失败，会返回 nullptr</li><li>typeid，用来返回对象类型的值</li><li>type_info，也就是 typeid 的返回类型，用来存储描述类型的信息</li></ul><p>如果不使用这三个 API，关闭 RTTI 不会影响代码行为。</p><p>需要注意的是，RTTI 只能用于包含了虚函数的类，也就是需要虚函数表来提供负责转换类型和提取真实类型的信息。</p><h2 id="LLVM-的-RTTI-替代方案"><a href="#LLVM-的-RTTI-替代方案" class="headerlink" title="LLVM 的 RTTI 替代方案"></a>LLVM 的 RTTI 替代方案</h2><blockquote><p>参考自：<a href="https://www.llvm.org/docs/ProgrammersManual.html#important-and-useful-llvm-apis">LLVM Programmer’s Manual — LLVM 18.0.0git documentation</a></p></blockquote><p>难度：⭐</p><p>回到主题，LLVM project 构建中，默认把 RTTI 关闭了，也就是使能了 <code>-fno-rtti</code> 编译选项。</p><p>LLVM 设计了另外一种方式来实现 RTTI，这种做法可以更高效且灵活的完成如继承结构向下类型转换和获取类型并判定的功能。</p><p>LLVM 提供了以下 API：</p><ul><li><code>dyn_cast</code>，作为 dynamic_cast 的替代，用来检查一个特定类型的对象，并将其转换为指定的派生类型。如果转换是非法的，会返回 nullptr。这个 API 不能用于引用（dynamic_cast 可以用于引用，非法转换会返回 bad_cast 异常）</li><li><code>isa</code>，类似于 java 的 instanceof，用来判定一个对象是否是某个类型。返回 bool 类型，可以判断指针或引用类型</li><li><code>cast</code>，和 dyn_cast 类型一样，但可以既接受指针又接受引用类型，之所以能接受引用类型，是由于它在非法转换时，会发生 assertion 失败。所以，这需要在使用前预先确认 cast 不会失败才行，也就是通常要和 isa 配合使用。</li></ul><p>另外，还有 <code>dyn_cast_or_null</code>，<code>isa_and_nonnull</code> 和 <code>cast_or_null</code> 等扩展接口，它们是对应的能接受 nullptr 作为参数的 API。需要注意，dyn_cast_or_null 和 cast_or_null 接口已经在新版 LLVM 中被标记为 deprecated，用来替代它们的 API 是 cast_if_present，有关于这些接口的使用和实现，可以参考 <code>include/llvm/Support/Casting.h</code> 文件。</p><p>我们在平时编码时，很容易遇到这些应用场景，比如当拿到一个 MI 指令时，需要通过判断这个指令是哪种类型，来决定要采取哪种操作，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取特定类型指令的 operand type</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> *Ld = <span class="built_in">dyn_cast</span>&lt;LoadInst&gt;(V))</span><br><span class="line">  Ty = <span class="built_in">cast</span>&lt;PointerType&gt;(Ld-&gt;<span class="built_in">getPointerOperandType</span>())-&gt;<span class="built_in">getElementType</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个 operand 是否是 Integer type</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isa</span>&lt;IntegerType&gt;(V-&gt;<span class="built_in">getType</span>()))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>要尽可能使用这种风格的代码实现，而不是使用 if-else 风格 get 具体 enum kind 的形式。</p><h2 id="设计自定义类继承结构的-RTTI-API"><a href="#设计自定义类继承结构的-RTTI-API" class="headerlink" title="设计自定义类继承结构的 RTTI API"></a>设计自定义类继承结构的 RTTI API</h2><blockquote><p>参考自：<a href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html#how-to-set-up-llvm-style-rtti-for-your-class-hierarchy">How to set up LLVM-style RTTI for your class hierarchy — LLVM 18.0.0git documentation</a></p></blockquote><p>难度：⭐⭐</p><p>如果只是使用 API，前边章节的内容已经足够了，但如果是需要设计自己的类型，那么学习 LLVM 如何做到这些，也是很有意义的。由于 LLVM 关闭了 RTTI，所以我们需要手动维护一套类型机制来标记类型信息，即我们不需要依赖虚函数表来实现 RTTI。</p><p>假设我们有这样一个类结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomMCInst</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CustomMCInst</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> MCOperand <span class="title">getDstOperand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALUMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LSAMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，我们需要 include 头文件：<code>#include “llvm/Support/Casting.h”</code>，这个头文件中描述了上述的 API 声明及实现。</p><p>然后，在 CustomMCInst 中，需要增加一个用来描述各种 Kind 的 enum，这些 Kind 将用来描述各个派生类的类型（加粗部分为新增代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomMCInst</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CustomMCInst</span>() &#123;&#125;</span><br><span class="line">  **<span class="built_in">CustomMCInst</span>(InstKind K) : <span class="built_in">Kind</span>(K) &#123;&#125;**</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> MCOperand <span class="title">getDstOperand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  **<span class="keyword">enum</span> <span class="title class_">InstKind</span> &#123;</span><br><span class="line">    IK_ALU,</span><br><span class="line">    IK_LSA</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">InstKind <span class="title">getKind</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Kind; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> InstKind Kind;**</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALUMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LSAMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">MCOperand <span class="title">getOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用 Kind，而不是 type 或 classes 等名词，是为了和 LLVM 中其他常见的关键词做区分。最好将 Kind 和 getKind() 都保持使用相同的名称。</p><p>之后，需要将所有派生自基类的子类型，都设置为对应的 Kind。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略基类代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALUMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  **<span class="built_in">ALUMCInst</span>() : <span class="built_in">CustomMCInst</span>(IK_ALU) &#123;&#125;**</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LSAMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  **<span class="built_in">LSAMCInst</span>() : <span class="built_in">CustomMCInst</span>(IK_LSA) &#123;&#125;**</span><br><span class="line">  <span class="function">MCOperand <span class="title">getOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，还需要实现 LLVM RTTI 的模版接口，用来能够提供给如 dyn_cast 和 isa 来决定类型的调用。实现方式是通过一个静态的成员函数 classof 来作为 dyn_cast 和 isa 的调用接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略基类代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALUMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ALUMCInst</span>() : <span class="built_in">CustomMCInst</span>(IK_ALU) &#123;&#125;</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  **<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() == IK_ALU;</span><br><span class="line">  &#125;**</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LSAMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LSAMCInst</span>() : <span class="built_in">CustomMCInst</span>(IK_LSA) &#123;&#125;</span><br><span class="line">  <span class="function">MCOperand <span class="title">getOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  **<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() == IK_LSA;</span><br><span class="line">  &#125;**</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 classof 这个接口，是必须要叫这个名字的，因为在 dyn_cast 和 isa 的实现中，最终是调用了一个类型的 <code>::classof</code> 接口。留意到，我们的抽象基类并没有提供 classof 接口，因为这是没有必要的，不必要给不能实现对象的类提供类型。</p><p>以上就是完整的实现步骤。当我们具体使用时（调用方），可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MCOperand <span class="title">getDstOp</span><span class="params">(CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> * IALU = <span class="built_in">dyn_cast</span>&lt;ALUMCInst&gt;(I)) &#123;</span><br><span class="line">    <span class="keyword">return</span> IALU-&gt;<span class="built_in">getDstOpernad</span>();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> * ILSA = <span class="built_in">dyn_cast</span>&lt;LSAMCInst&gt;(I)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ILSA-&gt;<span class="built_in">getOperand</span>();</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MCOperand</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，所有非抽象类，都应该实现 classof 接口，即使它不是叶子类型。另外，classof 的参数将始终应该是抽象类类型。</p><p>进一步扩展一下，我们的 classof 函数实现，并不一定要求一定是 <code>return i→getKind() == IK_A_KIND</code>，事实上，任何能够决定类型，且返回 bool 状态的内部实现，都可以用来实现 classof。这些在我们实现更复杂的类继承结构中会考虑用到。</p><h2 id="深层次继承结构"><a href="#深层次继承结构" class="headerlink" title="深层次继承结构"></a>深层次继承结构</h2><p>难度：⭐⭐</p><p>上边提到，当一个非抽象类型，并不是叶子类型（也就是它自身还有子类派生），我们也应该提供 classof 接口。这是因为任何非抽象类型都可以成为在运行时需要动态识别和转换类型的入参。</p><p>对于这种多层的继承结构，有一些额外的规则：</p><ul><li>非抽象类型都要提供 classof 接口</li><li>非叶子类型的 classof 实现，需要将其子类型包含在其中</li></ul><p>举例来说，我们对上边的代码做扩展，将 ALU 指令分为 ARITH 指令和 LOGIC 指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomMCInst</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CustomMCInst</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">CustomMCInst</span>(InstKind K) : <span class="built_in">Kind</span>(K) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> MCOperand <span class="title">getDstOperand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">InstKind</span> &#123;</span><br><span class="line">    IK_ALU,</span><br><span class="line">    **IK_ARITH,</span><br><span class="line">    IK_LOGIC,**</span><br><span class="line">    IK_LSA</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">InstKind <span class="title">getKind</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Kind; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> InstKind Kind;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALUMCInst</span> : <span class="keyword">public</span> CustomMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ALUMCInst</span>() : <span class="built_in">CustomMCInst</span>(IK_ALU) &#123;&#125;</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">    **<span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() &gt;= IK_ALU &amp;&amp; I-&gt;<span class="built_in">getKind</span>() &lt;= IK_LOGIC;**</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">**<span class="keyword">class</span> <span class="title class_">ALUArithMCInst</span> : <span class="keyword">public</span> ALUMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ALUArithMCInst</span>() : <span class="built_in">ALUMCInst</span>(IK_ARITH) &#123;&#125;</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() == IK_ARITH;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALULogicMCInst</span> : <span class="keyword">public</span> ALUMCInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ALULogicMCInst</span>() : <span class="built_in">ALUMCInst</span>(IK_LOGIC) &#123;&#125;</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() == IK_LOGIC;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;**</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略 LSAMCInst 代码</span></span><br></pre></td></tr></table></figure><p>我们扩展了 <code>ALUMCInst::classof</code>中的实现，使用范围 enum 来将所有是 ALU 类型及其子类型的 InstKind 都考虑进来。然后，我们实现子类型 ALUArithMCInst 和 ALULogicMCInst 如之前。</p><p>这种实现需要留意避免调整 enum 顺序时造成 bug，更常见的做法可能是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ALUMCInst::classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() == IK_ALU || I-&gt;<span class="built_in">getKind</span>() == IK_ARITH || I-&gt;<span class="built_in">getKind</span>() == IK_LOGIC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="潜在的-Bug"><a href="#潜在的-Bug" class="headerlink" title="潜在的 Bug"></a>潜在的 Bug</h2><p>难度：⭐⭐</p><p>应当仔细做到在这些非叶子类型非抽象类中，classof 总是能囊括所有的子类类型，在整个类继承结构完成之后，应该再次检查 classof 的正确性，以避免潜在 Bug。</p><p>LLVM 文档中提到可以借用假的 enum flag 来标记一类 Kind 的结束为止，从而让 classof 的维护没那么容易引入问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CustomMCInst</span>::InstKind &#123;</span><br><span class="line">  IK_ALU,</span><br><span class="line">  IK_ARITH,</span><br><span class="line">  IK_LOGIC,</span><br><span class="line">  **IK_ALU_END,**</span><br><span class="line">  IK_LSA</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ALUMCInst::classof</span><span class="params">(<span class="type">const</span> CustomMCInst *I)</span> </span>&#123;</span><br><span class="line">  **<span class="keyword">return</span> I-&gt;<span class="built_in">getKind</span>() &gt;= IK_ALU &amp;&amp; I-&gt;<span class="built_in">getKind</span>() &lt;= IK_ALU_END**; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾区间选择开区间还是闭区间并不重要，毕竟不会有一个类型是假的 IK_ALU_END，当然为了避免意外使用，选择闭区间的出错概率可能低一些。</p><p>之后，我们如果想继续扩展 ALU 类指令，就只需要在 <code>CustomMCInst::InstKind</code> 中的 IK_ALU 和 IK_ALU_END 之间加入新类型即可，而不需要再次调整 <code>ALUMCInst::classof</code> 的实现。</p><h2 id="开放的类继承结构"><a href="#开放的类继承结构" class="headerlink" title="开放的类继承结构"></a>开放的类继承结构</h2><p>难度：⭐⭐⭐</p><p>前边描述实现 LLVM RTTI 的这套方法，依赖一个大前提，即我们需要在实现整个代码前，已经设计好了完整的类结构。</p><p>但如果因为业务需要，我们无法在设计完成时确定类继承结构，即我们的类结构是开放形式时，应该怎么实现 LLVM RTTI 呢，LLVM 文档中为我们简单介绍了一下它提供的一种新的机制：ExtensibleRTTI。</p><p>开放的继承结构，以本文例子来说，就是我们设计了整套 CustomMCInst 的类结构，但依然需要在将来由其他用户对这个类结构做扩展，而其他用户无法帮我们继续维护之前的 InstKind 和 classof 实现。</p><p>这种新机制和前文的方案完全无关，可以在需要时再进一步了解。</p><p>LLVM 提供了两个类：<code>RTTIRoot</code> 和 <code>RTTIExtends</code>，前者用来实现 RTTI 检查，后者提供了一种机制，使当前类型能够继承自 RTTIRoot，它接受两个模版参数，分别是当前类型和 RTTIRoot。</p><p>所有自定义类型（抽象类和派生类）都需要继承自 RTTIExtends，真正的继承关系由 RTTIExtends 负责建立。并且，所有自定义类型，都需要提供一个名为 <code>ID</code> 的 static char 成员，用来让 RTTIExtends 管理特定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomMCInst</span> : **<span class="keyword">public</span> RTTIExtends&lt;CustomMCInst, RTTIRoot&gt;** &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CustomMCInst</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> MCOperand <span class="title">getDstOperand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  **<span class="type">static</span> <span class="type">char</span> ID;**</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALUMCInst</span> : **<span class="keyword">public</span> RTTIExtends&lt;ALUMCInst, CustomMCInst&gt;** &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">MCOperand <span class="title">getDstOperand</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  **<span class="type">static</span> <span class="type">char</span> ID;**</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> CustomMCInst::ID = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ALUMCInst::ID = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这种实现方案，不再需要手动管理各种 Kind 和 classof，唯一需要的就是将所有类型都设计在 RTTIExtends 之下。</p><p>LLVM 文档提到，这种方案只有在开放结构中用，在其他场景下，还是应该使用之前介绍的标准 LLVM RTTI 方式。</p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>难度：⭐⭐⭐</p><p><code>isa/cast/dyn_cast</code> 这些接口的底层实现是 <code>CastInfo</code>，CastInfo 提供了 4 个方法，<code>isPossible</code>，<code>doCast</code>，<code>castFailed</code>，<code>doCastIfPossible</code>。这些方法用来对应实现 isa，cast，dyn_cast。</p><p>我们可以通过自定义 CastInfo 类型，来对这些 RTTI API 做更细致更灵活的定制。CastInfo 继承自 <code>CastIsPossible</code>，后者内部的实现就是我们前边介绍的，利用 classof 来决定类型判断和转换行为。</p><p>早前的实现中没有 CastInfo 这一层，这次写文时才看到 LLVM 更新了文档，介绍了这部分内容，简单看了下实现，但目前还没有用到过，感兴趣小伙伴可以到 <a href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html#advanced-use-cases">How to set up LLVM-style RTTI for your class hierarchy — LLVM 18.0.0git documentation</a> 了解或者看源码 <code>include/llvm/Support/Casting.h</code> 学习，其中写了很多注释帮助理解。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/650022272">LLVM 风格的 RTTI - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开头叨叨&quot;&gt;&lt;a href=&quot;#开头叨叨&quot; class=&quot;headerlink&quot; title=&quot;开头叨叨&quot;&gt;&lt;/a&gt;开头叨叨&lt;/h2&gt;&lt;p&gt;众所周知，LLVM project 没有开启 C++ 的 RTTI 特性。一个主要的原因是 LLVM project 认为 </summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>为什么终端开发离不开 Tmux</title>
    <link href="https://p2tree.top/posts/3229e191.html"/>
    <id>https://p2tree.top/posts/3229e191.html</id>
    <published>2023-06-23T10:00:00.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>我在每天的软件开发工作中都离不开 tmux，它极大的提高了我的工作效率，我使用它优化我的工作流程，维护开发环境，并结合其他工具扩展软件开发的体验感。</p><p>如果你之前还没有听说过这个软件，我建议你花 20 分钟了解一下它。有非常多的程序员使用这个软件，尤其是需要连接到远程服务器进行开发的同学。但我发现目前中文网络上还很少有能系统的讲解 “为什么要使用 tmux” 的文章，大多数文章都是直接开门见山地罗列怎么配置 tmux，再拉个表格梳理难以记忆的快捷键清单。</p><p>在这篇文章中，我不会花大篇幅介绍怎么使用 tmux，而是告诉你为什么要用它，以及我自己实践很多年的使用技巧。</p><h2 id="三个-tmux-组件"><a href="#三个-tmux-组件" class="headerlink" title="三个 tmux 组件"></a>三个 tmux 组件</h2><p>在使用 tmux 之前，有三个重要的概念一定要了解，分别是 session，window 和 pane。简单介绍下。</p><ul><li>session 是会话，也就是和操作系统建立的一次通信状态，不过 tmux 中的 session 不同于直接用 shell 建立的 session，可以理解成一种虚拟 session；session 包含 window，默认启动 session 后会带有 1 个 window。</li><li>window 就是窗口，也就是展示在屏幕上能看到的全部内容，可以看做是窗口类软件的 tab；window 包含 pane，默认带有 1 个 pane。</li><li>pane 就是每一个分屏的窗格，tmux 允许对一个 window 做分屏，每个 “子屏“ 都叫做一个 pane。</li></ul><p>tmux 提供了各种快捷键来 create、rename、move、delete 这些组件，以及可以便捷的在这些组件之间切换。你可以任意使用这些组件搭建自己的工作环境。</p><h2 id="我的-tmux-工作流"><a href="#我的-tmux-工作流" class="headerlink" title="我的 tmux 工作流"></a>我的 tmux 工作流</h2><p>这里我介绍下我的环境，这是我工作中的一张截图：</p><p><img src="/img/20230623/img1.png" alt="Tmux工作截图"></p><p>tmux 体现在最下边一行，这一行叫做 tmux 状态栏。左下角是 当前聚焦的 session、window、pane 的 index，也就是光标所在的位置。这个单纯就是美观，实际工作中用处不大。</p><p>中间部分是当前 session 中所有 window 的 list，以及当前所在的 window。这个在切换 window 时可以参考。</p><p>右边只是一个日期和时间，用处也不是很大。</p><p>日常开发中，我的工作流是这样的：</p><ul><li>第一个窗口开发，第二个测试，第三个调试。可以随时开启临时窗口完成一些其他功能，用完后关闭。窗口之间切换使用 <code>shift + left</code> 和 <code>shift + right</code> ，操作和 window list 显示布局一致。非活跃窗口有消息时，状态栏会高亮提示。</li><li>每个窗口上的布局都不同，开发窗口左边用来编码，右边用来编译和 shell 操作。在编码时，会将左边 pane 全屏。pane 之间切换使用 <code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code> 和 <code>ctrl + l</code>，vim 癌晚期患者必备（vim 内部分屏切换也是这套按键，之后讲 vim 时我会提到怎么配置）。</li><li>以上所有布局都是同一个会话，这个会话用来做一件事情。当有其他更紧急的事情接手时，我会开启新的会话。经常有人找我验证一些其他问题，或者我手里同时有两三件事在推进，打工人都懂 😂。</li><li>下班后，直接关闭终端走人，第二天开终端后，我提前配好了 ssh 授信，所以可以自动连接并进入 tmux 环境。如果有多个 session，系统会询问我现在打算进入哪个 session。</li></ul><h2 id="最主要的功能点"><a href="#最主要的功能点" class="headerlink" title="最主要的功能点"></a>最主要的功能点</h2><p>那么，简单来说，tmux 有哪些很难被其他软件完美替代的功能呢？</p><ul><li><p>会话管理</p><p>  tmux 可以将会话和终端相分离。简单说就是我们使用终端运行任务，之后关闭终端或远程断开连接，都不影响任务的继续运行。这样我可以做到下班时断开 ssh 连接就好了，第二天上班建立 ssh 连接就可以恢复昨天的开发界面、窗口布局，以及查看昨晚编译和测试的结果。</p><p>  当程序员为了快速恢复环境而不关电脑，与公司为了省电要求下班关电脑之间产生冲突时，tmux 就是一个完美的解决方案 🐶。</p><p>  另外，你也不会希望遇到因为网络问题或电脑死机，导致 ssh 断连后，运行的程序和任务被 kill 掉的结果吧。</p><p>  另一个类似的软件是 screen，但 tmux 比 screen 要好用很多，建议使用 tmux。</p></li><li><p>分屏</p><p>  现在大多数终端软件都可以做到分屏，本地开发工作中， tmux 的分屏功能并不是必要的，甚至终端软件的分屏功能都不是必要的，完全可以使用 dwm 这种窗口管理器实现。</p><p>  但如果你是在远程服务器上开发，那么 tmux 的分屏还是很重要的，这意味着你不需要和服务器建立多个 ssh 连接。</p></li><li><p>自动化创建环境</p><p>  远程服务器并不常关机，所以启动 tmux 服务之后，一次配置好窗口布局和环境，可能很长时间都不需要再次配置了。</p><p>  但如果某一天你们 IT 突然发邮件说今晚 10 点停机维护，是不是就意味着我们的布局要重新配置了？</p><p>  其实不一定，tmux 的布局创建都是利用 tmux 指令来完成的，可以将创建布局的指令按类似 shell 脚本的原理配置好，每次需要配置时运行一次就好了。运行指令脚本需要 tmux 辅助工具，比如 tmuxp 来完成。</p></li><li><p>共享会话</p><p>  在远程开发工作中，我们可以将多个 host 端的终端连接到同一个 tmux session，这样可以实现一些需要多屏共享的需求。我自己不太用得到这个功能。</p></li></ul><h2 id="常用的几个命令"><a href="#常用的几个命令" class="headerlink" title="常用的几个命令"></a>常用的几个命令</h2><p>本着不给网络环境增加冗余信息的原则，怎么安装 tmux 我就不展开了。可以在这里了解：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>tmux 可以添加参数使用。以下是我常用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动新 session</span></span><br><span class="line">tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 session list</span></span><br><span class="line">tmux <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接入 session</span></span><br><span class="line">tmux attach -t &lt;session <span class="built_in">id</span>/name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 session</span></span><br><span class="line">tmux kill-session -t &lt;session-id/name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脱离 session</span></span><br><span class="line">tmux detach</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 session</span></span><br><span class="line">tmux switch -t &lt;session-id/name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名 session</span></span><br><span class="line">tmux rename-session -t &lt;session-id/name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><h2 id="我的使用技巧"><a href="#我的使用技巧" class="headerlink" title="我的使用技巧"></a>我的使用技巧</h2><p>看到这里，想必我应该介绍清楚 tmux 为什么是终端开发必备软件了。</p><p>说它是神器，可能过誉了，但说它必不可少，这反而是大实话。不过，应该有很多小伙伴会在使用 tmux 时，被它复杂难懂的配置脚本和快捷键劝退。这部分内容，我会介绍一下我在使用 tmux 这些年，总结出来的一些经验和使用技巧，方便你再一次尝试这个软件，或者——如果你已经在用了——改进你的工作流。</p><h3 id="1-tmux-版本"><a href="#1-tmux-版本" class="headerlink" title="1 tmux 版本"></a>1 tmux 版本</h3><p>如果你刚刚使用 tmux，并且被配置脚本困扰，也许你会去网上搜搜别人是怎么配置的，然后拿过来后，却发现并不一定起作用，那么你可能需要考虑看看自己的 tmux 版本。</p><p>tmux 目前的最新版本是 3.3a，但很多 Linux 发行版中内置的 tmux 却是很久前的 2.6 甚至 2.2 版本。很遗憾，tmux 在版本更新过程中多次调整了它的配置接口，所以你参考的网上的配置和你自己使用的 tmux 版本可能不匹配。更悲剧的是，大多数人并没有意识到这个问题，所以他们在上传自己配置时，并不会说清这套配置的版本号。</p><p>我自己的 tmux 配置中写明了版本号，这应该是大家都去注意的，一个完善的配置文件，应该写清楚它适用的软件版本、运行说明、注意事项等。</p><p>使用 <code>tmux -V</code> 可以查看 tmux 版本。</p><h3 id="2-修改键位"><a href="#2-修改键位" class="headerlink" title="2 修改键位"></a>2 修改键位</h3><p>tmux 的默认键位是很反人类的，不但很难记得住，而且点击起来也很别扭。prefix 键，也就是 tmux 前缀键，本来其实就是两个键（默认的 <code>ctrl + b</code>），然而有些功能，却还需要 <code>shift</code> 键参与，比如 <code>prefix + %</code> ，看着像是两个键，实际上是四个键参与（<code>ctrl + b</code>, <code>shift + 5</code> ）。</p><p>每个人都会有自己的使用习惯，但大家能统一意见的始终是用 tmux 一定要改键。我的一些键位修改供参考：</p><ul><li>prefix 键：<code>ctrl + a</code></li><li>水平分屏：<code>prefix + -</code></li><li>垂直分屏：<code>prefix + \\</code></li><li>pane 之间移动：<code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code>，<code>ctrl + l</code></li><li>window 之间移动：<code>shift + left</code>，<code>shift + right</code> （就是左右方向键）</li></ul><p>还有几个常用的按键没有改键：</p><ul><li>创建 window：<code>prefix + c</code></li><li>重命名 window：<code>prefix + ,</code></li><li>将当前 pane 全屏：<code>prefix + z</code></li></ul><h3 id="3-复制粘贴"><a href="#3-复制粘贴" class="headerlink" title="3 复制粘贴"></a>3 复制粘贴</h3><p>这个问题应该是网络上和 tmux 相关的问题中，搜索次数最多的问题了。同样的，在不同版本的 tmux 中，解决这个问题的方案并不相同。在最新的 3.3a 版本中，我认为复制粘贴的功能已经比较好用了。</p><ul><li><p>第一种情况，在本机使用 tmux。</p><p>  tmux 原生支持的方案是：使用 <code>prefix + [</code> 进入选择模式，控制光标到一段文字的开头，<code>space</code> 开始选择，继续移动光标选中需要复制的内容，<code>enter</code> 确认复制，并自动退出选择模式。这时内容就会被复制到剪切板。<code>prefix + ]</code> 来粘贴。如果 tmux 配置开启了鼠标增强模式，还可以用鼠标选取内容，右键弹出菜单操作。</p><p>  如果你的终端能支持适配 tmux，那么直接用鼠标选取内容，内容就会自动复制到系统剪切板中，右键粘贴或弹出右键菜单粘贴，比如 mac 上使用 iterm2 可以做到。</p></li><li><p>第二种情况，通过远程终端连接使用 tmux。</p><p>  tmux 无法解析出你在 host 端选取的文字，也就无法把它复制到剪切板中，所以不能依赖鼠标选择。你依然可以使用的是 tmux 原生方案，因为 tmux 会将内容复制到服务器那边系统的剪切板，那么在终端中再粘贴也就没有问题了。</p><p>  但是，如果希望将内容复制到 host 这边，这种办法就行不通了。可行的办法是直接利用当前终端的复制粘贴功能，直接鼠标选择文本来复制和粘贴。如果开启了鼠标增强模式，那么 tmux 会接管鼠标选择功能，绕开它的办法是按住 <code>shift</code> 键的同时来选择复制和粘贴。当然，这种方法自动滚屏就失效了。</p><p>  还有一种我听说的方案，是利用其他软件专门同步远程服务器的剪切板和 host 机器的剪切板，Github 上有类似的项目，感兴趣可以了解一下。</p></li></ul><p>如果我说的这些还不能满足你的需要，可能你得自己再摸索摸索了，远程访问模式本来对复制粘贴就不友好，也许最不会产生心智负担的方案就是文件传输吧 😆。</p><p>我自己不常使用复制粘贴的功能，粘贴代码这种行为，往外边粘，公司安全部门不同意，往里边粘，公司法务部门不开心。如果是粘贴报错信息或者运行日志，可能提炼关键点更有利于解决问题。</p><h3 id="4-美化"><a href="#4-美化" class="headerlink" title="4 美化"></a>4 美化</h3><p>有关于状态栏的美化就不说了，网络上很多类似的帖子。</p><p>我说几个不常见的：</p><ul><li><p>tmux 和 neovim 配合实现不同 mode 下变化光标样式：</p><p>  在 .tmux.conf 中配置这个命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-option -sa terminal-overrides &#x27;*:Ss=\\E[%p1%d q:Se=\\E[ q&#x27;</span><br></pre></td></tr></table></figure><p>  一定要注意一点，这个配置 是在 neovim 0.9 + zsh + tmux 3.3a 下才能生效。vim 需要配置一下也能实现相同的效果。你可能还需要考虑不同终端软件可能对光标样式做的主动更改。</p></li><li><p>斜体字体。如果终端能够显示斜体字，但打开 tmux 中却不显示，那么需要这么配置：</p><p>  在用户根目录下创建名为 <code>screen-256color.terminfo</code> 的文件，内容为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A screen-256color based TERMINFO that adds the escape sequences for italic.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Install:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   tic screen-256color.terminfo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   export TERM=screen-256color</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">screen-256color|screen with 256 colors and italic,</span><br><span class="line">        sitm=\\E[3m, ritm=\\E[23m,</span><br><span class="line">        use=screen-256color,</span><br></pre></td></tr></table></figure><p>  终端执行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tic screen-256color.terminfo</span><br></pre></td></tr></table></figure><p>  在 shell 脚本中配置这个环境变量并 source：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TERM=screen-256color</span><br></pre></td></tr></table></figure><p>  在 .tmux.conf 中加入以下配置：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">&quot;screen-256color&quot;</span></span><br></pre></td></tr></table></figure><p>  为了在 vim 中也能显示斜体字，还需要在 .vimrc 中加入以下配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &amp;t_ZH=&quot;\\e[3m&quot;</span><br><span class="line">let &amp;t_ZR=&quot;\\e[23m&quot;</span><br><span class="line"></span><br><span class="line"># 或者如果是 neovim，在 init.lua 中加入：</span><br><span class="line">vim.g.t_ZH = &quot;\\\\e[3m&quot;</span><br><span class="line">vim.g.t_ZR = &quot;\\\\e[23m&quot;</span><br></pre></td></tr></table></figure></li><li><p>支持真彩色</p><p>  真彩色是 24 位颜色，比 256-color（8 位）更艳丽，对于很多插件，尤其是终端和 vim 中的色彩主题，开启真彩色会显示更好的视觉效果。</p><p>  首先需要你的终端支持真彩色，新一些的终端都支持，可以使用这个脚本验证：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fL &lt;https://raw.githubusercontent.com/Beavan/tools/master/sh/24-bit-color.sh&gt; |bash</span><br></pre></td></tr></table></figure><p>  如果显示的颜色条没有明显的色彩块边界，那么就是真彩色了。</p><p>  在 .tmux.conf 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set -g default-terminal &quot;screen-256color&quot;</span><br><span class="line">set-option -ga terminal-overrides &quot;,*256col*:Tc&quot;</span><br></pre></td></tr></table></figure><p>  vim 中支持真彩色，还需要在 .vimrc 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set termguicolors</span><br><span class="line"></span><br><span class="line"># neovim 在 init.lua 中加入</span><br><span class="line">vim.opt.termguicolors = true</span><br></pre></td></tr></table></figure></li><li><p>实现当前 pane 的背景突出显示。</p><p>  iterm2 有这么个效果，当分屏后，当前光标所在屏幕会正常显示，而其他屏幕会变灰。tmux 也可以实现这种效果。</p><p>  在 .tmux.conf 中添加这个配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set -g window-style &#x27;fg=grey62,bg=grey19&#x27;</span><br><span class="line">set -g window-active-style &#x27;fg=terminal,bg=terminal&#x27;</span><br></pre></td></tr></table></figure><p>  颜色可以自己随意改，试了下是 256 color。效果不如 iterm2 好，但我感觉足够用了。</p></li><li><p>状态栏背景和终端样式保持一致。</p><p>  比如说我的终端是磨砂效果，我不想显示 tmux 的绿色大横条。那么可以配置 status bar 的 style：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在 3.2 及更新版本中</span><br><span class="line">set-option -g status-style bg=default</span><br><span class="line"></span><br><span class="line"># 在较旧的版本中</span><br><span class="line">set-option -g status-bg default</span><br></pre></td></tr></table></figure></li></ul><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这些内容零散的躺在我的笔记中很久了，终于有机会整理成文。</p><p>如果你之前没有使用过 tmux，看过这篇文章可能并不会帮你完全熟悉这个软件，任何软件的熟练使用都依赖于 “尝试” 和 “探索”。如果能吸引你 “入坑”， 或者其中有一些能值得你参考的内容，那我这篇文章就没白写。</p><p>有疑问和请求都可以给我留言，也请 feel free 指出文中的错误。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/639084118">为什么终端开发离不开 Tmux - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开头叨叨&quot;&gt;&lt;a href=&quot;#开头叨叨&quot; class=&quot;headerlink&quot; title=&quot;开头叨叨&quot;&gt;&lt;/a&gt;开头叨叨&lt;/h2&gt;&lt;p&gt;我在每天的软件开发工作中都离不开 tmux，它极大的提高了我的工作效率，我使用它优化我的工作流程，维护开发环境，并结合其他工</summary>
      
    
    
    
    <category term="软件工具" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="软件工具" scheme="https://p2tree.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    <category term="终端开发" scheme="https://p2tree.top/tags/%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Tmux" scheme="https://p2tree.top/tags/Tmux/"/>
    
    <category term="Terminal" scheme="https://p2tree.top/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>LLVM New Pass Manager</title>
    <link href="https://p2tree.top/posts/ab589331.html"/>
    <id>https://p2tree.top/posts/ab589331.html</id>
    <published>2022-12-03T17:29:47.000Z</published>
    <updated>2024-09-01T11:46:12.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇<strong>译文</strong>，主要介绍了 LLVM 中的 New Pass Manager 原文链接：<br><a href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/">https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/</a><br>by Arthur Eubanks（Mar 26, 2021）</p></blockquote><h2 id="Pass-Manager-的介绍"><a href="#Pass-Manager-的介绍" class="headerlink" title="Pass Manager 的介绍"></a>Pass Manager 的介绍</h2><p>Pass Manager 的主要用途是调度 Pass 在各 IR 层级按顺序运行。</p><p>Pass 分为 transformation pass 和 analyses pass，它们可以选择运行在 module、function 等各种 scope 下，甚至更加抽象地，比如 call graph 上的强连接组件（<code>SCC: strongly connected component</code>）或者 loop 上。</p><p>调度可以很简单，比如直接按顺序运行 pass list，或者按遇到的每一个 function 来调用。同时调度也可能很复杂，比如 SCC 在 call graph 中的顺序必须正确。</p><p>Pass Manager 还负责管理 analyses pass 的分析结果，比如说支配树（dominator tree）。为了更好的提高性能，分析结果可能会在 pass 之间共享，因为 pass 之间常会有依赖性，毕竟重复计算相同的结果开销太大。所以 Pass Manager 还需要缓存分析结果。当然，如果中间还经过了 transformation pass，还可能涉及到重新计算结果（之前的分析结果过期了）。</p><p>Pass Manager 支持添加一些测试 pass 来测试整个 pass list。但更简单的是使用预先构建好的 pass pipeline，比如使用 <code>clang -O2</code> 来运行 O2 优化下的所有 passes。</p><h2 id="New-Pass-Manager-的介绍"><a href="#New-Pass-Manager-的介绍" class="headerlink" title="New Pass Manager 的介绍"></a>New Pass Manager 的介绍</h2><p>LLVM 在几年前推出了一套新的 Pass Manager，所以目前有两套不同的 Pass Manager 共存：<code>legacy pass manager</code> 和 <code>new pass manager</code>。</p><p>legacy pass manager 在结构上，会丢失一些好的优化机会，尤其是在 <code>inliner</code> 中提取分析结果。比如内联函数希望从 callee 那里拿到一些 profile 信息，特别是对于延迟内联，想要在 inliner 拿到一些 warpper function。legacy pass manager 不支持在 CGSCC pass 中提取任意函数的分析信息（CGSCC 就是 call graph strongly connected component）。pass manager 会确保我们自底向上地遍历 SCC，从而可以在从 caller 中拿到更精确地信息来让 callee 的优化更充分。 LLVM 的 inliner 是一个 CGSCC pass，因为他是一个自底向上遍历的 inliner 实现。以这个例子可以说明，legacy pass manager 在提升一些优化时的能力不足。</p><p>目前， new pass manager 还只适用于 LLVM IR 上的中端 pass pipeline。后端的 codegen pass pipeline 还依然使用 legacy pass manager，主要原因是后端 pass 是基于 MIR 的，没有很多人有精力去给后端的 MIR 框架适配 new pass manager，况且还有那么多后端需要自己适配。另外，后端 pass 中几乎没有过程间优化 pass，所以使用 new pass manager 也并不会带来什么性能提升。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>在 legacy pass manager 中，每个 pass 都会预先声明它需要保留的分析信息，如果这些分析并没有在缓存或者缓存已失效，那么 pass manager 需要将这些分析作为 pass 来提前调度。提前声明的方式会带来不必要的 boilerplate（即一些重复冗余但又不可缺少的代码——译注），并且对于一个 pass，它也并不是在任何情况下都会使用所有的分析信息。</p><p>在 new pass manager 中，使用了另一种完全不同的方法，它将分析 pass 和常规 pass 完全分离开来。其中，所有的分析 pass 都由一个独立的 analysis manager 来管理（计算运行、缓存信息、决定失效）。普通 pass 可以向 analysis manager 请求分析信息，这包括惰性计算分析。为了能向普通 pass 通知哪些分析信息是有效的，analysis manager 可以向 pass 返回它目前获知的信息。pass manager 告诉 analysis manager 来处理失效的缓存信息。这种方式可以减少 boilerplate，能更清晰的区分普通 pass 和分析 pass。</p><p>因为 legacy pass manager 将分析工作也当做 pass 来调度，所以我们无法有效的为任意函数进行分析。对于函数级别的分析 pass，它能获得的信息只能是最后一次分析 pass 运行时对当前函数的信息。我们可以为其他函数手动创建新的分析代码，但它们的分析结果不会被缓存在任何地方，从而导致很多的冗余工作和编译成本开销。由于在 new pass manager 中，分析 pass 都统一由 analysis manager 来管理，所以 analysis manager 可以负责管理任意函数的任意信息。</p><p>为了支持 CGSCC 分析，我们需要一个索引来缓存分析结果。对于像函数和循环 block 这种代码，我们有持续性的数据结构作为索引。然而，legacy 的 CGSCC pass manager 只能存储内存中当前 SCC 中的函数，不能拿到一个持续性的 call graph 数据结构作为索引来缓存分析结果。所以我们需要将整个 graph 放在内存中作为索引。另外，如果我们使用这个 graph 作为索引，这还需要能时刻确保数据是有效的（避免有 pass 改变了数据结构，但没有更新分析结果）。为了避免过多的冗余操作来重新反复的生成大量但松散的 graph，我们就需要增量更新 graph。这就是在 new pass manager 中为什么 CGSCC 设计复杂的原因。</p><p>在一个 SCC 内部，一次 transform 操作可能会破坏 call graph cycle 导致切分 SCC。legacy CGSCC 实现中的一个问题是，它简单的将一个 SCC 中所有的 functions 都存放在当前 SCC 中的一个 array 中，然后按顺序遍历所有的 functions。比如下述代码中，一个 SCC 中有 2 个 functions：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会首先 visit foo 函数，然后 visit bar 函数，然后删除其中的 dead call。最后会 transform 成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们现在其实希望重新访问一次 foo 函数，因为我们有了更多的信息（调整后 foo 函数成为一个独立的 SCC）。legacy pass manager 的 CGSCC 只会移动到 call graph 的下一个部分。在 new pass manager 中，设计了增量式的 call graph 更新机制，如果一个 SCC 被切分，我们会确保自底向上地重新 visit 新切分的 SCC。这种机制可能会重复的 visit function，但这也给 pass 一个机会来发现更多潜在地更详细的信息。</p><p>当在 legacy pass manager 中新增一个 pass 时，不同 pass 类型之间的嵌套是隐式的。比如，在一个 module 级别的 pass 之后增加一个 function 级别的 pass，会在连续的 function pass list 之外隐式的增加一个 function pass manager。理论上说这样没问题，虽然看起来有点困惑。 一些 pipeline 可能希望在运行一个 CGSCC pass 时能独立的运行一个 function pass，而不是嵌套在 CGSCC 的 pass manager 中。new pass manager 中，它通过限制只允许相同类型的 pass 包含在同一个 pass manager 中的方式，将这种嵌套变得更加明显。比如，想在一个 function pass 中增加一个 loop pass，这个 loop pass 必须使用 loop-to-function 的 adaptor 来包装，将其转换为一个 function pass。 new pass manager 中的嵌套顺序是：module (→ CGSCC) → function →loop， CGSCC 嵌套是可选的。增加一个 CGSCC 嵌套其实是为了简化问题，但这带来的构建 call graph 的开销和额外的支持嵌套 function pass 的代码，反而也使得它有点复杂，所以它成为一个 optional 的部分。</p><p>legacy pass manager 的实现依赖于许多的全局标记和注册函数。这是由宏生成函数和变量来初始化 pass 的。而且 legacy pass manager 的用户需要确保调用一个函数来初始化这些 pass。但我们有时希望通过一些方法让 pass manager 意识到我们有些 pass 是用于测试目的的。在 new pass manager 中，这个问题的解决方法是通过将所有 pass 的定义传递给 pass manager builder，然后内部使用一个 pass ID 和 pass 构建函数的 mapping 来依次创建 pipeline 和新增 pass，这个过程中会解析文本的描述信息作为指导。 pass manager builder 的用户可以添加注册解析回调函数的插件来控制自定义的 out-of-tree pass。虽然这会产生全局函数，但并不会带来 mutable 的全局状态，因为每个 pass manager builder 都可以解析 pass pipeline，而不需要访问全局注册函数。其他可选功能，比如调试 pass manager 的运行，也是通过这种构建函数的方式，而不是通过全局标记。</p><p>最后，对于 LLVM pass 并行运行的呼声很高。虽然 pass manager 的结果并不是这个需求的唯一阻碍，但 legacy pass manager 也确实有不少阻碍并行运行的问题需要解决。比如在 call graph 级别，只有 sibling SCC 可以并行执行。按需创建 SCC 的方式让它很难找到 sibling SCC。new pass manager 是通过计算全局 call graph 的方式来运行的，所以可以方便的找出 sibling SCC，从而可以并行化 SCC pass。一些 pass 只会使用缓存的分析信息，所以并行化可能导致非确定性的问题，因为一个 module 分析 pass 并不一定会依赖其他并行的 pipeline 的需求而存在。 new pass manager 只允许 function 级别的 pass 访问缓存的 module 分析信息，但不允许运行它们。这样做的缺点是需要保证在运行低级别 pass 之前要先运行高级别的 pass，比如需要确保 GlobalsAA pass 必须优先于一个 function pass 执行。</p><h2 id="设置-new-pass-manager-为默认-pass-manager"><a href="#设置-new-pass-manager-为默认-pass-manager" class="headerlink" title="设置 new pass manager 为默认 pass manager"></a>设置 new pass manager 为默认 pass manager</h2><p>LLVM 的一些主要用户已经几年前就默认使用 new pass manager 了，在上游的努力开发下，目前 new pass manager 已经支持所有的用例。比如，好久前，所有的 Clang 用例就可以在 new pass manager 上运行了。然而，目前还有大量的 LLVM 的测试依然运行在 legacy pass manager 上。opt 工具，它是一个用于测试 pass 的软件，可以使用一些方法来运行 pass 到 legacy pass manager：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run in legacy pass manager</span></span><br><span class="line">opt -instcombine</span><br><span class="line"></span><br><span class="line"><span class="comment"># run in new pass manager opt -passes=instcombine  </span></span><br></pre></td></tr></table></figure><p>因为目前还有大量的 LLVM 的测试用例仍然使用 legacy pass manager，所以直接将默认改成 new pass manager 会带来大量用例无法通过的情况（虽然手动运行已经验证大多用例可以通过）。</p><p>为了能让用例通过 new pass manager，我们可以手动运行两次，一次运行 legacy pass manager，一次运行 new pass manager，或者也可以自动将运行命令做调整（不需要手动去修改命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># automatically translate legacy syntax to new syntax</span></span><br><span class="line">opt -enable-new-pm</span><br></pre></td></tr></table></figure><p>使用这个选项，我们可以探索两种 pass manager 的差异。仍然再次强调，本地打开这个功能，可能会让很多用例无法通过（因为它们还不支持 new pass manager）。目前只是将能在 new pass manager 上更有意义运行的用例做了移植，而对那些无关紧要的用例，仍然放到了 legacy pass manager 上运行。</p><p>一些使用 <code>-enable-new-pm</code> 无法覆盖的问题：</p><ul><li><p>如果函数标记为 <code>optnone</code> 属性，这可能并不会跳过所有的可选 pass。在现有的 pass 检测框架下（即运行 pass 之前和之后会调用回调，允许跳过 pass），这种实现是最简单的。然而，一些 pass 必须要运行来保证整体的正确性，所以我们仍然根据需要保留了一些必要的 pass。</p></li><li><p>Opt-bisect 在 new pass manager 中不被支持。它曾被用来分辨在 pipeline 中的哪个 pass 会导致编译错误，从而可以跳过这个 pass。在现在的 pass 检测框架下，也可以很方便的实现这个功能，所以它总被标记为必要的 pass。</p></li><li><p>大量目标相关的测试会失败。经过检查，一些期望在一些 pipeline（比如 O2）下运行的 pass 没有被运行。这是因为一些后端会向默认 pipeline 中增加一些自定义的 pass，而其中一些 pass 对于正确性是必须的，比如 lower 目标相关的 intrinsics。legacy pass manager 提供了一种方法可以向默认 pipeline 中注入 pass，即通过 <code>TargetMachine::adjustPassManager()</code> 来实现。在 new pass manager 中使用了一种等价的机制来实现将目标相关 pass 引入默认 pipeline 中。这不一定是个很麻烦的问题，因为目前 new pass manager 的主要用户是 x86 架构，而这个架构下并没有使用这个 legacy pass manager 的特性。</p></li><li><p>一些 coroutine 的用例在 CGSCC 框架上运行失败。原因是在 new pass manager CGSCC 框架下不支持将已有函数的部分提取到其他函数（又称为 outlining）。曾经有一些 hack 的处理来解决一些错误的 workaround，但却没有正确的更新 call graph，也没有处理好来自新的 outline function 的递归。最后，我们找到一种方法来适配当前的 CGSCC 框架，保持 call graph 的正确性，尽管这必须要适应特定于 coroutine 的 call graph 转换。</p></li></ul><h2 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h2><p>出于性能考虑，很多项目和公司多年前都已经在使用 new pass manager 了。另外，Chrome 最近开始使用 PGO 和 ThinLTO 来加速 Chrome 运行，两者都带来了不错的性能改善。将 new pass manager 设置为默认打开后，Chrome 很快也进行了更新，目前可以在 Linux 和 Windows 系统上运行 Speedometer 2.0 达到 3-4% 的性能提升，减少 8-9MB 空间占用。更好的使用 profile 信息以及更好的处理大文件 ThinLTO 的 call graph 可能会带来这些改进。</p><p>然而，一些小应用并不会因为切换到 new pass manager 带来多大的益处，因为 new pass manager 带来的改进更倾向于会对大型代码仓库产生影响。</p><p>除了面向用户的提升外，通过标准化使用其中一个 pass manager 改进代码，它也能帮助 LLVM 代码更健壮。虽然我们不能立即移除 legacy pass manager，但已经不建议使用它，尤其是在优化 pipeline 中。然后将来，我们也可能会移除一些和 legacy pass manager 相关的优化 pipeline。</p><h2 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h2><p>开始着手移除使用 legacy pass manager 的优化 pipeline，我们先要确保在 new pass manager 中都能有配套的替代。目前已知的模块：bugpoint，LLVM C API，GPU divergency analysis。</p><p>前边提到，后端 codegen pipeline 仍然工作在 legacy pass manager。虽然已经有一些后端切换到了 new pass manager，但离实用仍然有一段距离。这是改善 LLVM 代码很好的切入点，感兴趣可以与 llvm-dev 沟通。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/588822158">LLVM New Pass Manager - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是一篇&lt;strong&gt;译文&lt;/strong&gt;，主要介绍了 LLVM 中的 New Pass Manager 原文链接：&lt;br&gt;&lt;a href=&quot;https://blog.llvm.org/posts/2021-03-26-the-new-pass</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
    <category term="译文" scheme="https://p2tree.top/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 术语</title>
    <link href="https://p2tree.top/posts/350eef5c.html"/>
    <id>https://p2tree.top/posts/350eef5c.html</id>
    <published>2022-08-28T23:16:07.000Z</published>
    <updated>2024-09-01T11:46:12.730Z</updated>
    
    <content type="html"><![CDATA[<p>学习 CUDA 最重要的首先是理解 GPU 和 CUDA 中的各种术语，在不同的平台上，相同或类似的概念却有着不同的称呼，典型的就是在 CUDA 和 OpenCL 的系统中叫法之差异，以及和通用体系结构教材中的称呼。GPU 学习曲线陡峭的一个原因就是术语使用上还未完全统一。</p><h2 id="程序抽象类"><a href="#程序抽象类" class="headerlink" title="程序抽象类"></a>程序抽象类</h2><table><thead><tr><th>书中使用的一般性名称</th><th>非 GPU 术语</th><th>NVIDIA 和 CUDA 术语</th><th>AMD 和 OpenCL 术语</th><th>详细描述（其他术语标粗体）</th></tr></thead><tbody><tr><td>可向量化循环</td><td>可向量化循环</td><td>网格（Grid）</td><td>索引范围（NDRange）</td><td>在 GPU 上执行的可向量化循环，由一个或多个可以并行执行的线程块（向量化循环体）组成</td></tr><tr><td>向量化循环体</td><td>（条带挖掘后的）向量化循环体</td><td>线程块（Block）</td><td>工作组（WorkGroup）</td><td>可以在多线程 SIMD 处理器上执行的向量化循环，由一个或多个 SIMD 指令线程构成，可以通过局部存储器通信</td></tr><tr><td>SIMD 车道操作序列</td><td>标量循环的一次迭代</td><td>CUDA 线程（Thread）</td><td>工作项（WorkItem）</td><td>SIMD 指令线程的垂直抽取，对应于一个 SIMD 车道所执行的一个元素。根据遮罩和预测寄存器对结果进行存储</td></tr></tbody></table><p>OpenCL 通常通过 API 函数来得到与任务维度和索引相关的值：</p><ul><li>get_num_groups() ：描述 WorkGroup 的数量，即 Task 的 dimension</li><li>get_local_size() ：描述 WorkItem 的数量，即 WorkGroup 的 dimension</li><li>get_group_id() ：描述 WorkGroup 的索引下标</li><li>get_local_id() ：描述 WorkItem 在当前 WorkGroup 中的索引下标</li><li>get_global_id() ：描述 WorkItem 在 Task 中的索引下标</li></ul><p>CUDA 通常是提供全局的变量来指定与任务维度和索引相关的值：</p><ul><li>grid_dim ：同 OpenCL get_num_groups()</li><li>block_dim ：同 OpenCL get_local_size()</li><li>block_idx ：同 OpenCL get_group_id()</li><li>thread_idx ：同 OpenCL get_local_id()</li><li>CUDA 获取 CUDA 线程相对于 Task 的全局索引，需要手动计算</li></ul><p>NVIDIA 将 CUDA 编程模型定义为 SIMT（单指令多线程），用以与 SIMD 模型做区分。SIMT 优于 SIMD 是因为 SIMT 按线程做分支和控制流的机制与 SIMD 机器不同。</p><h2 id="机器对象"><a href="#机器对象" class="headerlink" title="机器对象"></a>机器对象</h2><table><thead><tr><th>书中使用的一般性名称</th><th>非 CUDA 术语（旧术语）</th><th>NVIDIA 和 CUDA 术语</th><th>AMD 和 OpenCL 术语</th><th>详细描述（其他术语标粗体）</th></tr></thead><tbody><tr><td>SIMD 指令线程</td><td>向量指令线程</td><td>Warp</td><td>波前（wave）</td><td>一种传统线程，但它仅包含在多线程 SIMD 处理器上执行的 SIMD 指令。根据每个元素的遮罩来存储结果</td></tr><tr><td>SIMD 指令</td><td>向量指令</td><td>PTX 指令</td><td>AMDIL&#x2F;FSAIL 指令</td><td>在多个 SIMD 车道上执行的单一 SIMD 指令</td></tr></tbody></table><p>注意区分 SIMD 指令线程（Warp）和 CUDA 线程。</p><ul><li>Warp 是硬件创建、管理、调度和执行的计算单元，它依赖硬件的并行执行单元来执行运算，也就是 CUDA 线程（车道操作序列），每个 Warp 有自己的 PC。</li><li>CUDA 线程只是硬件实现的最小计算单元，以及会暴露给程序抽象的一个概念（用来划分最小的独立计算数据）。</li></ul><p>之所以说是 SIMD 指令，是因为该指令会在同一个 Warp 下的多个 SIMD 车道上执行，其中每一个独立的 SIMD 车道都会处理不同的等量数据单位，满足标准 SIMD 指令的概念。同一个 Warp 下的不同 SIMD 车道一定会执行相同的 SIMD 指令。</p><p>每个 SIMD 指令线程（Warp）映射的 CUDA 线程（车道操作序列）数量依不同硬件配置而异，车道数量不一定等同于 SIMD 指令中的数据量（宽度）。比如在 Fermi 架构中，每个拥有 32 宽度的 SIMD 指令线程映射到 16 个物理 CUDA 线程，所以每个 SIMD 指令需要 2 个 cycle 才能完成计算。</p><h2 id="处理硬件"><a href="#处理硬件" class="headerlink" title="处理硬件"></a>处理硬件</h2><table><thead><tr><th>书中使用的一般性名称</th><th>非 CUDA 术语（旧术语）</th><th>NVIDIA 和 CUDA 术语</th><th>AMD 和 OpenCL 术语</th><th>详细描述（其他术语标粗体）</th></tr></thead><tbody><tr><td>多线程 SIMD 处理器</td><td>（多线程）向量处理器</td><td>流式多处理器 Stream Multi-processor（SM）</td><td>计算单元</td><td>多线程 SIMD 处理器执行 SIMD 指令线程，与其他 SIMD 处理器无关</td></tr><tr><td>线程块调度程序</td><td>标量处理器</td><td>Giga 线程引擎</td><td>超线程分派引擎</td><td>将多个线程块（向量化循环体）指定给多线程 SIMD 处理器</td></tr><tr><td>SIMD 线程调度程序</td><td>多线程 CPU 中的线程调度器</td><td>Warp 调度程序</td><td>工作组调度程序</td><td>当 SIMD 指令线程（Warp）做好执行准备之后，用于调度和发射这些线程的硬件；包括一个计分板，用于跟踪 SIMD 线程执行</td></tr><tr><td>SIMD 车道（lane）</td><td>向量车道</td><td>线程处理器</td><td>处理元素&#x2F;SIMD 车道</td><td>SIMD 车道执行一个 SIMD 指令线程中针对单个元素的操作。根据遮罩存储结果</td></tr></tbody></table><p>多线程 SIMD 处理器可以看作是完整的处理器，也可以说 GPU 是多核的多线程 SIMD 处理器。</p><p>GPU 上存在两种不同的调度：</p><ul><li>线程块调度：将线程块（向量化循环体）分配给多线程 SIMD 处理器；</li><li>SIMD 线程（Warp）调度：由它调度何时、在哪里运行 SIMD 线程；</li></ul><h2 id="存储器硬件"><a href="#存储器硬件" class="headerlink" title="存储器硬件"></a>存储器硬件</h2><table><thead><tr><th>书中使用的一般性名称</th><th>非 CUDA 术语（旧术语）</th><th>NVIDIA 和 CUDA 术语</th><th>AMD 和 OpenCL 术语</th><th>详细描述（其他术语标粗体）</th></tr></thead><tbody><tr><td>GPU 存储器</td><td>主存储器</td><td>全局存储器</td><td>全局存储器</td><td>可供 GPU 中所有多线程 SIMD 处理器访问的 DRAM 存储器</td></tr><tr><td>专用存储器</td><td>栈或线程局部存储（操作系统）</td><td>局部存储器</td><td>专用存储器</td><td>每个 SIMD 车道专用的 DRAM 存储器部分</td></tr><tr><td>局部存储器&#x2F;本地存储器</td><td>局部存储器</td><td>共享存储器</td><td>本地存储器&#x2F;组存储器</td><td>一个多线程 SIMD 处理器的快速本地 SRAM，不可供其他 SIMD 处理器使用</td></tr><tr><td>SIMD 车道寄存器</td><td>向量车道寄存器</td><td>线程处理器寄存器</td><td>寄存器</td><td>跨越完整线程块（向量化循环体）分配的单一 SIMD 车道中的寄存器</td></tr></tbody></table><p>层次结构是 全局存储器（Global，所有 SP 可访问）&gt; 局部共享存储器（Shared，单一 SP 内部使用）&gt; 局部存储器（local，单一 SIMD 车道私有）。</p><p>局部存储器常用来保存单个 SIMD 车道的栈帧、溢出寄存器和不能放到寄存器中的私有变量。为了提高性能，通常 GPU 会设计缓存来辅助加速数据访问和节省能量。</p><p>局部共享存储器通常用来做单个 SIMD 处理器内不同 SIMD 线程之间的数据交互和同步。</p><p>SIMD 车道寄存器是车道内的硬件资源，所以从 SIMD 指令处理器（SP）角度看，会拥有极其大量的寄存器数量（Fermi 架构中拥有 32768 个 32 位的寄存器）。</p><hr><div class="note info simple"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/558728158">CUDA 术语 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 CUDA 最重要的首先是理解 GPU 和 CUDA 中的各种术语，在不同的平台上，相同或类似的概念却有着不同的称呼，典型的就是在 CUDA 和 OpenCL 的系统中叫法之差异，以及和通用体系结构教材中的称呼。GPU 学习曲线陡峭的一个原因就是术语使用上还未完全统一。</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="并发编程" scheme="https://p2tree.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="体系结构" scheme="https://p2tree.top/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="CUDA" scheme="https://p2tree.top/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>GCC 和 Clang 的原子库支持</title>
    <link href="https://p2tree.top/posts/5807aaf4.html"/>
    <id>https://p2tree.top/posts/5807aaf4.html</id>
    <published>2021-11-29T09:29:59.000Z</published>
    <updated>2024-09-01T11:46:12.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首先介绍了标准库和运行时库在 GCC 和 clang 上的关系和区别。之后介绍各自编译器软件中对原子库的支持情况。 本文讨论的 GCC 的版本是 7.5.0，clang 的版本是 12.0.0。 本文提到的 GCC 和 clang 分别是对应的编译器系统，并不是 gcc&#x2F;Clang 编译器前端或编译器驱动软件。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="标准-C-库"><a href="#标准-C-库" class="headerlink" title="标准 C 库"></a>标准 C 库</h3><p>libc 是 Linux 下最早支持的标准 C 库。</p><p>后来逐步被 glibc 取代，glibc 是 GNU 版本的标准 C 库，是现在最流行的标准 C 库，在主流 Linux 操作系统中都是预装的。</p><p>glibc 实现了 Linux 系统中最底层的 API 库，主要是对系统调用的封装，比如 fopen。同时也提供了一些通用的数据类型和操作，如 string，malloc，signal 等。</p><p>除此之外，还有一些小众 C 库，比如用于嵌入式环境的 eglibc，还有轻量级的 glib 等。这些库在 Linux 系统中不是预装的。</p><h3 id="标准-C-库-1"><a href="#标准-C-库-1" class="headerlink" title="标准 C++ 库"></a>标准 C++ 库</h3><p>标准 C++ 库主要有两个，libc++ 和 libstdc++，看似名字相同，libstdc++ 是 gcc 编译器系统中的标准 C++ 库，libc++ 是 clang 编译器特别重写的标准 C++ 库，clang 重写的 libc++ 库比 libstdc++ 更充实，但两者不能兼容。</p><p>有趣的是，在大多数以 GCC 主导的操作系统中，clang 默认使用的是 gcc 的标准 C++ 库来编译程序，也就是 libstdc++，如果需要使用 libc++，要额外在编译参数中设置。这可能是处于兼容性的考虑。</p><p>libstdc++ 是和 gcc 绑定安装的，但 glibc 和 gcc 却没有绑定安装，这是因为 glibc 过于底层，在不同硬件上不能通用，所以绑定安装可能会导致危险的问题，而 libstdc++ 就显得没那么底层了。</p><h3 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h3><p>runtime 有三层意思，在不同语境下指的是不同的：</p><ol><li><p>指程序在运行中，即程序运行时生命周期。比如：” C++ 的运行时错误比编译时错误更隐蔽且难以 debug“；</p></li><li><p>指运行时库，也就是本节提到的概念。比如：”C++ 程序的编译需要一些运行时库的支持“；</p></li><li><p>指运行时系统，或运行时环境。比如：”Node.js 是 JavaScript 的一个运行时环境“；</p></li></ol><p>通俗来讲，运行时库提供的函数和功能是为了满足程序运行的所有辅助功能，也就是说，用户逻辑程序代码之外的程序，都可以看作运行时库。当然，狭义的说，只有支撑软件运行的基础功能所组成的软件库，被称作运行时库。</p><p>比如，在 C 运行时库中，有负责字符串的 string 库，负责内存管理的 stdlib 库，负责输入输出的 stdio 库等。</p><h3 id="运行时库和标准库的区别"><a href="#运行时库和标准库的区别" class="headerlink" title="运行时库和标准库的区别"></a>运行时库和标准库的区别</h3><p>运行时库包含标准库。</p><p>标准库是程序语言要求的基础功能集合，通常它是独立于不同硬件的，因为语言需要保证一定的可移植性，所以编程语言定出来的库规范，一定是能具有通用性的；但运行时库是需要保障软件在硬件上正常运行的，依据不同的硬件，运行时库的实现可能不同。运行时库对标准库做了扩展，支持软件能够在系统上正常运行。</p><p>所以，查看标准库规范应该到 C 标准委员会或 C++ 标准委员会的网站上查询，而查看运行时库，需要到对应编译器的手册或运行时库自己的手册中查询。</p><h3 id="GCC-和-clang-的运行时库"><a href="#GCC-和-clang-的运行时库" class="headerlink" title="GCC 和 clang 的运行时库"></a>GCC 和 clang 的运行时库</h3><p>GCC 的运行时库是 libgcc_s，clang 的运行时库是 runtime-rt。如上一节提到的，clang 在大多数 GCC 主导的操作系统中默认使用 GCC 的标准库，同时它也默认使用 GCC 的运行时库。如果需要切换使用 clang 的标准库，那么要额外指定使用 clang 的 runtime-rt 才可以。这需要在编译时给定一些配置参数。当然，你也可以选择把两个版本的运行时库都链接到程序中，但这样通常是冗余和浪费的。</p><p>GCC 的运行时库相比 clang 的 runtime-rt，会缺少一些 LLVM 依赖的接口实现。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作通常都是硬件强依赖的，所以通常都需要编译器的运行时库来提供支持。</p><p>以下以 <code>atomic_fetch_add</code> 为例，其他接口可能有更多约束和设计，出于突出重点的考虑不作提及，可参考手册。</p><h3 id="C-标准（C-11）对原子操作的规定"><a href="#C-标准（C-11）对原子操作的规定" class="headerlink" title="C++ 标准（C++11）对原子操作的规定"></a>C++ 标准（C++11）对原子操作的规定</h3><p>头文件在<code>&lt;atomic&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">std::atomic_fetch_add</span><span class="params">(std::atomic&lt;T&gt;* obj, <span class="keyword">typename</span> std::atomic&lt;T&gt;::difference_type arg)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">std::atomic_fetch_add</span><span class="params">(<span class="keyword">volatile</span> std::atomic&lt;T&gt;* obj, <span class="keyword">typename</span> std::atomic&lt;T&gt;::difference_type arg)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">std::atomic_fetch_add_explicit</span><span class="params">(std::atomic&lt;T&gt;* obj, <span class="keyword">typename</span> std::atomic&lt;T&gt;::difference_type arg, std::memory_order order)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">std::atomic_fetch_add_explicit</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">volatile</span> std::atomic&lt;T&gt;* obj, <span class="keyword">typename</span> std::atomic&lt;T&gt;::difference_type arg, std::memory_order order)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>注意，这里的标准是模板泛型实现对不同长度数据类型的支持。<code>atomic_fetch_add</code> 是 <code>atomic_fetch_add_explicit</code> 的宏替换，它会展开为 <code>atomic_fetch_add_explicit(obj, arg, memory_order_seq_cst)</code> ，这种 memory_order 是默认的常用类型。</p><p><code>obj</code> 是指定要修改的值，<code>arg</code> 是要 add 上去的值，返回值是 add 之前 <code>obj</code> 指向的值。</p><h3 id="GCC-对原子操作的支持"><a href="#GCC-对原子操作的支持" class="headerlink" title="GCC 对原子操作的支持"></a>GCC 对原子操作的支持</h3><p>GCC 的运行时库，libgcc_s 中，并没有提供一套原子操作的实现，它将其实现在 libstdc++ 中，即 GCC libatomic 库。当使用 libgcc_s 时，对原子操作的处理，会调用 GCC libatomic 的实现来完成。</p><p>在提标准库函数之前，先解释下 GCC 提供的 builtin 接口。</p><p>在 GCC 的原子操作的头文件 <code>&lt;stdatomic.h&gt;</code> 中，对 C++ 标准接口做了宏替换（注意是 GCC 的头文件，clang 有同名但内容不同的另一个头文件）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_fetch_add(PTR, VAL) __atomic_fetch_add ((PTR), (VAL), __ATOMIC_SEQ_CST)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_fetch_add_explicit(PTR, VAL, MO) __atomic_fetch_add ((PTR), (VAL), (MO))</span></span><br></pre></td></tr></table></figure><p>这样，就可以把 C++ 标准 与 GCC 中的实现对应起来了。能看到，C++ 标准中规定的函数名称前没有两个下划线，而 GCC 中为了表示区分，会添加两个下划线（clang 中也同理，下节展示）。</p><p>GCC 中提供的 builtin 接口是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type __atomic_fetch_add (type *ptr, type val, <span class="type">int</span> model)</span><br></pre></td></tr></table></figure><p>builtin 接口是泛型的，因为编译器在编译期间能够获取变量的类型。因为是 builtin 函数，所以使用这个接口不需要依赖 GCC 的标准库或运行时库。</p><p>在 GCC 的标准库中，另外提供了一些接口函数，对于 fetch_add 是指定数据长度的接口，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I1  __atomic_fetch_add_1  (I1 *mem, I1 val, <span class="type">int</span> model)</span><br><span class="line">I2  __atomic_fetch_add_2  (I2 *mem, I2 val, <span class="type">int</span> model)</span><br><span class="line">I4  __atomic_fetch_add_4  (I4 *mem, I4 val, <span class="type">int</span> model)</span><br><span class="line">I8  __atomic_fetch_add_8  (I8 *mem, I8 val, <span class="type">int</span> model)</span><br><span class="line">I16 __atomic_fetch_add_16 (I16 *mem, I16 val, <span class="type">int</span> model)</span><br></pre></td></tr></table></figure><p>对应对象长度的类型，在不同的硬件平台下可能有所不同，所以以符号来代替。使用这些接口时，必须给链接器指定标准库，如果出现链接错误，可以手动指定 <code>-latomic</code> 选项。</p><h3 id="clang-对原子操作的支持"><a href="#clang-对原子操作的支持" class="headerlink" title="clang 对原子操作的支持"></a>clang 对原子操作的支持</h3><p>clang 的原子操作是在运行时库 compiler-rt 中支持的。源代码位于 compiler-rt 中的 atomic.c 文件中。</p><p>在 clang 中，它首先会检查系统路径下是否已经有一套原子库的实现，如果有的话，就会使用系统的原子库实现。比如在 Linux 系统中，clang 的这种查询，可能会找到系统默认 gcc 编译器的标准库中的 atomic 实现；如果没有找到系统的 libatomic，则会生成编译器的 builtin 函数调用，即 <code>__c11_atomic_fetch_add</code> 系列函数。这在 clang 的 <code>&lt;stdatomic.h&gt;</code> 中能查找到细节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_HOSTED__ &amp;&amp; __has_include_next(<span class="string">&lt;stdatomic.h&gt;</span>)</span></span><br><span class="line">#include_next &lt;stdatomic.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_fetch_add(object, operand) __c11_atomic_fetch_add(object, operand, __ATOMIC_SEQ_CST)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_fetch_add_explicit __c11_atomic_fetch_add</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>生成 builtin 函数的目的，是为了提供给编译器后端去做一些更底层的指令替换，从而提高原子操作的可靠性。</p><p>这个细节很重要，如果你的系统中有 GCC 的原子库实现，你在代码中想使用 clang 的原子库实现，就会发现应用不了。</p><p>除了上文代码提到的 <code>__c11_atomic_fetch_add</code> 函数之外，clang 还提供了其他几个版本的 builtin 函数， 文档中的说明是：</p><blockquote><p>Note that Clang additionally provides GCC-compatible _<em>atomic</em>* builtins and OpenCL 2.0 _<em>opencl_atomic</em>* builtins</p></blockquote><p>即也提供和 GCC 兼容的 <code>__atomic_fetch_add</code> 接口和与 OpenCL 兼容的 <code>__opencl_atomic_fetch_add</code> 接口，可以在 Builtins.def 文件中查找到定义的细节，在 CGAtomic.cpp 文件中，builtin 函数被选择成 LLVM 指令 <code>llvm::AtomicRMWInst::Add</code>。</p><p>clang 提供的运行时库中对原子操作的接口与 GCC 的标准库中提供的函数基本类似。在 compiler-rt 中的 atomic.c 文件中可以查看到，clang 的运行时库对原子操作的实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_RMW(n, lockfree, type, opname, op)</span></span><br><span class="line">  type __atomic_fetch_#<span class="meta">#opname##_##n(type *ptr, type val, int model) &#123;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">lockfree</span>(ptr))</span><br><span class="line">          <span class="keyword">return</span> __c11_atomic_fetch_#<span class="meta">#opname((_Atomic(type) *)ptr, val, model);</span></span><br><span class="line">      Lock *l = <span class="built_in">lock_for_pointer</span>(ptr);</span><br><span class="line">      <span class="built_in">lock</span>(l);</span><br><span class="line">      type tmp = *ptr;</span><br><span class="line">      *ptr = tmp op val;</span><br><span class="line">      <span class="built_in">unlock</span>(l);</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>显然，它提供的接口中，会判断如果 lockfree 机制没有使能的话，仍然生成 <code>__c11</code> 系列函数；否则，会使用 lock 来完成原子操作，其他非算数逻辑运算的实现更复杂一些，但原理类似。</p><p>对应支持的数据长度会依赖于硬件对原子操作的限制。这里很明显这样做的目的是为了兼容 GCC 的指定数据长度的原子操作接口。但从源文件中能看到，当你需要调用这个接口时，需要提前对其进行一次声明，避免未找到函数声明的错误。可以参考 atomic_test.c 这个测试文件了解应用细节。</p><p>值得一提的是，如果想通过 clang 来调用 libgcc_s 运行时，需要使用原子操作时，clang 并不能够自动的查找到 GCC libatomic 库，而是需要手动指定链接器参数 <code>-latomic</code> 来配置。</p><p>还有一个特别要说明的是，无论是 GCC 的原子库，还是 clang 的原子库，都必须要求所有输入输出数据的数据长度要保持一致，第一个参数是指针类型，也需要要求指针类型指向的数据类型长度保持一致，否则会出现编译错误。</p><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>本文没有提到 GCC 旧版本的 <code>__sync__</code> 开头的原子操作，旧版本没有 memory model 的参数配置。clang 中对该接口也有支持。</p><p>本文没有提到如何处理原子操作的一些细节，比如 lock-free 机制和硬件原子指令，没有提到对 static 和 volatile 对象的原子操作，没有提到 atomic memory order 等参数细节。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><p><a href="https://www.zhihu.com/question/20607178">https://www.zhihu.com/question/20607178</a>，有关于运行时库的文章；</p></li><li><p><a href="https://www.cplusplus.com/reference/atomic/atomic_fetch_add/">https://www.cplusplus.com/reference/atomic/atomic_fetch_add&#x2F;</a>，C++ 标准库的规定；</p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html</a>，GCC 提供的 builtin 接口；</p></li><li><p><a href="https://gcc.gnu.org/wiki/Atomic/GCCMM/LIbrary">https://gcc.gnu.org/wiki/Atomic/GCCMM/LIbrary</a>，GCC 标准库中提供的接口；</p></li><li><p><a href="https://compiler-rt.llvm.org/">https://compiler-rt.llvm.org/</a>，clang 运行时库 compiler-rt 的说明；</p></li><li><p><a href="https://clang.llvm.org/docs/LanguageExtensions.html#c11-atomic-builtins">https://clang.llvm.org/docs/LanguageExtensions.html#c11-atomic-builtins</a>，提到了 clang 中支持的 builtin 接口；</p></li><li><p><a href="https://releases.llvm.org/8.0.1/docs/Atomics.html#libcalls-atomic">https://releases.llvm.org/8.0.1/docs/Atomics.html#libcalls-atomic</a>，提到了 clang 的运行时库中提供的接口；</p></li></ul><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/437343936">GCC 和 Clang 的原子库支持 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文首先介绍了标准库和运行时库在 GCC 和 clang 上的关系和区别。之后介绍各自编译器软件中对原子库的支持情况。 本文讨论的 GCC 的版本是 7.5.0，clang 的版本是 12.0.0。 本文提到的 GCC 和 clang 分别是对应的</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CPP" scheme="https://p2tree.top/tags/CPP/"/>
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</title>
    <link href="https://p2tree.top/posts/96dd94da.html"/>
    <id>https://p2tree.top/posts/96dd94da.html</id>
    <published>2021-09-10T17:12:50.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>最近家里事情比较多，拖了一段时间。这个笔记已经基本完成了，还剩下最后一章，使用 simulator 来验证我们开发的编译器，我将其放到附录里，是因为它不属于开发工作，只是辅助工具。我们的 Simulator 实现了 Cpu0 的指令功能，从而可以将 hex 格式的代码文件在之上运行，并能在终端中查看运行结果。</p><ol><li><a href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a></li><li><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a></li><li><a href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a></li><li><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a></li><li><a href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a></li><li><a href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a></li><li><a href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a></li><li><a href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a></li><li><a href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a></li><li><a href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a></li><li><a href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a></li><li><a href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></li></ol><hr><h3 id="A-1-运行-Simulator"><a href="#A-1-运行-Simulator" class="headerlink" title="A.1 运行 Simulator"></a>A.1 运行 Simulator</h3><h3 id="A-1-1-编译-Simulator"><a href="#A-1-1-编译-Simulator" class="headerlink" title="A.1.1 编译 Simulator"></a>A.1.1 编译 Simulator</h3><p>我们的 Simulator 使用 Verilog 语言实现，我借用了原作者提供的代码，代码文件是 cpu0.v，需要使用 verilog 编译器将其编译成可执行文件。</p><p>在我的 Mac 上，安装 iverilog 软件，它可以用来编译 verilog 代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install icarus-verilog</span><br></pre></td></tr></table></figure><p>安装后，编译的命令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iverilog -D TRACE -o cpu0Is cpu0.v</span><br><span class="line">iverilog -D TRACE -D CPU0II -o cpu0IIs cpu0.v</span><br></pre></td></tr></table></figure><p>通过传参编译出两种不同字节序的机器文件。<code>-D TRACE</code> 是定义一个 verilog 中的宏变量，用来表示需要追踪运行时寄存器和内存的值。</p><p>运行我们的代码不能只提供 main 函数，还需要提供一些启动引导代码和辅助函数，比如 print 一类。</p><p>我在示例代码中，将编译命令写在了 Makefile 中，可以直接在根目录下执行 make 来完成构建。</p><h3 id="A-1-2-启动引导文件"><a href="#A-1-2-启动引导文件" class="headerlink" title="A.1.2 启动引导文件"></a>A.1.2 启动引导文件</h3><p>这里要说明，因为我们没有链接器参与，所以需要手动将各段代码按照正常的方式排布，所以你会看到 include 一个 c 文件和汇编文件这种情况。包括在你的子函数中，如果需要多个文件的 c 代码，也需要手动将其编排到一起，并要保证声明顺序，同时还要注意跳转距离（不要写太复杂的程序就没事）。之后可以再做个链接器，让这些步骤更自然。</p><p>对于我们的编译器来看，以下的几段代码都存在一个完整的程序块中。</p><h4 id="1-start-h"><a href="#1-start-h" class="headerlink" title="(1) start.h"></a>(1) start.h</h4><p>用来在程序最开头插入一段汇编，用来初始化一些寄存器，比如 <code>$sw</code> 、<code>$fp</code> 和通用寄存器。</p><h4 id="2-boot-c"><a href="#2-boot-c" class="headerlink" title="(2) boot.c"></a>(2) boot.c</h4><p>紧接着 start.h 之后的代码，需要添加启动引导代码，逻辑就是：</p><ol><li><p>设置中断和异常的钩子符号，比如复位、错误、外部中断，因为我们目前没有这些需求，所以这里就定位到自身，做死循环，之后如果有需求再调整。</p></li><li><p>调整 <code>$gp</code> 和 <code>$lr</code> 寄存器。</p></li><li><p>调整栈指针寄存器 <code>$sp</code>。</p></li><li><p>设置一些系统寄存器，比如 <code>$mfc0</code>。</p></li><li><p>跳转到 main 入口，假设 main 入口就是紧随其后的代码，也可以选择跳转到标号 main。</p></li></ol><h4 id="3-print-h-c"><a href="#3-print-h-c" class="headerlink" title="(3) print.h&#x2F;c"></a>(3) print.h&#x2F;c</h4><p>编写打印输出到终端的函数，思路就是将字符串写入到一段内存，内存起始地址是 <code>OUT_MEM</code>，我们初始化为 0x80000，Simulator 的实现代码中会将这个地址当做与终端交互的 IO。</p><h4 id="4-run-c"><a href="#4-run-c" class="headerlink" title="(4) run.c"></a>(4) run.c</h4><p>驱动程序。我们将运行的代码都当做是子函数，使用这一个地方的 main 代码作为入口来调用。在我的示例代码中，先调用子函数，然后打印输出结果。</p><h3 id="A-1-3-构建-hex-文件脚本"><a href="#A-1-3-构建-hex-文件脚本" class="headerlink" title="A.1.3 构建 hex 文件脚本"></a>A.1.3 构建 hex 文件脚本</h3><p>我编写了一个构建脚本，自动化的调用各种构建工具，主要步骤为：</p><ol><li><p>使用 clang 生成 IR 文件。</p></li><li><p>使用 llc 生成目标文件。</p></li><li><p>使用 llvm-objdump 对目标文件做截取，提取 .text 段，并使用 awk 工具格式化输出。</p></li><li><p>使用 less 工具对 .text 段的文本做调整，只截取可执行的内容。</p></li></ol><p>最后我们就能得到能够执行的 hex 文件了。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash build.sh cpu032I be</span><br><span class="line">bash build.sh cpu032II be</span><br><span class="line">bash build.sh cpu032I le</span><br><span class="line">bash build.sh cpu032II le</span><br></pre></td></tr></table></figure><h3 id="A-1-4-执行-Simulator"><a href="#A-1-4-执行-Simulator" class="headerlink" title="A.1.4 执行 Simulator"></a>A.1.4 执行 Simulator</h3><p>在调用 Simulator 时，需要把生成的 hex 文件命名为 cpu0.hex 文件，并放到和 Simulator 同一个路径下。第 3 步中的脚本已经默认生成了 cpu0.hex 文件。</p><p>终端执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./cpu0IIs</span><br><span class="line">./cpu0Is</span><br></pre></td></tr></table></figure><p>选择二者之一，Simulator 就会打印出执行的每一步的信息。</p><p>最后会打印出 total cpu cycles，可以大致评价编译器和处理器的性能，这里只能看到 cpu 的 cycle，而无法查看 IO 的 cycle。理论上说 cpu0IIs 会比 cpu0Is 获得更好的执行性能，这个就体现了不同硬件的性能差异（主要是 <code>slt</code>, <code>beq</code> 指令等提升）。</p><p>Simulator 会先将代码加载到内存中，然后从 0 地址开始执行每一条指令。这个 Simulator 不支持流水线并行，如果能支持的话，性能应该会再翻好几倍。因为设计一个处理器也是很复杂的事情，我们这里的需求只是简单测试编译器的运行正确性，所以就不再展开去设计更完备的处理器了。</p><h3 id="A-2-结尾"><a href="#A-2-结尾" class="headerlink" title="A.2 结尾"></a>A.2 结尾</h3><p>这个系列笔记就到此结束了，我自己用了大概一年的时间去系统的学习了《Tutorial: Creating an LLVM Backend for the Cpu0 Architecture》，并实践了其中的过程，之后又花了半年时间将其内容整理成这份笔记，整理的同时又再一次实践，我自己收获特别多，也再次对原作者表示感谢。这个笔记某种程度上可以作为原作文档的概括和重述，我也鼓励需要接触 LLVM 系统的朋友可以像我一样，去做这样一个事情。</p><p>工作后不像在学校里了，没有丰富的时间去学习和探索，所以进展很慢，在此对于急切期待等我更新的朋友们说声抱歉，这个教程中我将几乎所有 C++ 的特性剥离了，是为了简化内容，目前依然没有补充 C++ 功能特性的想法，将来如果补充，可能也只是支持重载、多态和类这几个概念吧。</p><p>诚实的说，我在使用 Simulator 测试我们的程序时，有些是过不去的，表现为一个无限循环。因为时间原因，我没有一一去检查问题所在，但必须承认，这里边是存在问题的，这也告诉我自己，一个编译器是一个非常复杂的系统，虽然借助于 LLVM 这样优秀的软件框架，已经可以帮助我们完成很多复杂的任务，但如果想设计一个像商用编译器那样鲁棒性极强，又能兼顾扩展性和灵活性的软件系统，是非常困难的。</p><p>这个教程对我自己来说，也是学习、巩固和回顾的过程，在完成教程期间，我得到了很多朋友和网友的支持，谢谢你们，我也知道谦虚谨慎是学习进步必备的素养，所以后续有时间，我会继续完善这个系列的代码，解决已知 bug，测试更复杂的软件用例。</p><p>有网友私信问我如何学习熟悉 LLVM 的系统，我大概总结的回答是，不要想很快的掌握所有的东西，最有效的办法就是自己亲自动手，去做一个编译器，去解决实际遇到的问题，探索各种对自己有用的调试开发方法，再去追根溯源，阅读 LLVM 公开的源码，学习了解别人的设计思路，最后辅助以官方文档的解释就可以了。当然，对于完全没有概念的初学者，适当看一些中文教程，也是有帮助的。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/409067375">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近家里事情比较多，拖了一段时间。这个笔记已经基本完成了，还剩下最后一章，使用 simulator 来验证我们开发的编译器，我将其放到附录里，是因为它不属于开发工作，只是辅助工具。我们的 Simulator 实现了 Cpu0 的指令功能，从而可以将 hex 格式的代码文件在</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
    <category term="仿真" scheme="https://p2tree.top/tags/%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>LLVM 后端实践笔记 10：汇编</title>
    <link href="https://p2tree.top/posts/419cdb7c.html"/>
    <id>https://p2tree.top/posts/419cdb7c.html</id>
    <published>2021-08-07T23:15:39.000Z</published>
    <updated>2024-09-01T11:46:12.730Z</updated>
    
    <content type="html"><![CDATA[<p>这一章，我们来添加 Cpu0 的汇编功能，这包括独立汇编器和 C 语言内联汇编特性两个部分。</p><ol><li><a href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a></li><li><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a></li><li><a href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a></li><li><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a></li><li><a href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a></li><li><a href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a></li><li><a href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a></li><li><a href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a></li><li><a href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a></li><li><a href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a></li><li><a href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a></li><li><a href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></li></ol><hr><h2 id="10-1-汇编器"><a href="#10-1-汇编器" class="headerlink" title="10.1 汇编器"></a>10.1 汇编器</h2><p>独立汇编器可以理解为依赖于 LLVM 后端提供的接口实现的一个独立软件，因为 LLVM 和 gcc 在这个地方的实现逻辑不一样。</p><p>在 gcc 中，编译器和汇编器是两个独立的工具，编译器，也就是 cc，只能生成汇编代码，而汇编器 as，才用来将汇编代码翻译为二进制目标代码，gcc 驱动软件 gcc 将这些工具按顺序驱动起来（还包括预处理器、链接器等），最终实现从 C 语言到二进制目标代码的功能。但是，这样的设计有个缺点，每个工具都需要先对输入文件做 parse，然后再输出时写入文件，反复多次的磁盘读写一定程度影响了编译的效率。</p><p>而在 LLVM 中，编译器后端本身就可以将中间代码（对应 gcc 中 cc 的中间表示）翻译成二进制目标文件，而不需要发射汇编代码到文件中，再重新 parse 汇编文件。当然它也可以通过配置命令行参数指定将中间代码翻译成汇编代码，方便展示底层程序逻辑。</p><p>但我们目前已经实现的这些功能，却无法支持输入汇编代码，输出二进制目标文件，虽然通常情况下已经不再需要手工编写汇编代码，但在特殊情况下，比如引导程序、调试特殊功能、需要优化性能等场合下，还是需要编写汇编代码，所以一个汇编器依然是很重要的。</p><p>显然，我们之前的章节已经把和指令相关的汇编表示都在 TableGen 中实现了，这一节中，最核心的就是实现一个汇编器的 parser，并将其注册到 LLVM 后端框架中，并使能汇编功能。并且，汇编器的核心功能在 LLVM 中也已经实现了，原理其实就是一个语法制导的翻译，我们要做的只是重写其中部分和后端架构相关的接口。</p><p>我还实现了一个额外的特性。当我们仅使用汇编器时，编译器占用的寄存器 <code>$sw</code>，就可以被释放出来当做普通寄存器用了，所以我们重新定义一下 GPROut 这个寄存器类别，并将 <code>Cpu0.td</code> 拆分成两份，将它拆分为 <code>Cpu0Asm.td</code> 和 <code>Cpu0Other.td</code>，前者会在调用汇编器时被使用到，而后者保持和之前一样的设计。</p><p>因为 <code>$sw</code> 寄存器是编译器用来记录状态的，如果只编写汇编代码，我们认为程序员有义务去维护这个寄存器中的值什么时候是有效的，进而程序员就可以在认为这个寄存器中值无效时，把它当做普通寄存器来使用。我们的标量寄存器有很多，多这样一个寄存器的意义并不是很大，这里依然这么做，其实是想展示一下 TableGen 机制的灵活性。</p><p>在 Cpu0 的后端代码路径下，新建一个子目录 AsmParser，在这个路径下新建 Cpu0AsmParser.cpp 用来实现绝大多数功能。</p><h3 id="10-1-1-文件新增"><a href="#10-1-1-文件新增" class="headerlink" title="10.1.1 文件新增"></a>10.1.1 文件新增</h3><h4 id="1-AsmParser-Cpu0AsmParser-cpp"><a href="#1-AsmParser-Cpu0AsmParser-cpp" class="headerlink" title="(1) AsmParser&#x2F;Cpu0AsmParser.cpp"></a>(1) AsmParser&#x2F;Cpu0AsmParser.cpp</h4><p>作为一个独立的功能模块，使能它的 DEBUG 信息名称为 <code>cpu0-asm-parser</code>，声明一些新的 class： <code>Cpu0AsmParser</code> 作为核心类，用来处理所有汇编 parser 的工作，我们稍后介绍；<code>Cpu0AssemblerOptions</code> 这个类用来做汇编器参数的管理；<code>Cpu0Operand</code> 类用来解析指令操作数，因为指令操作数可能有各种不同的类型，所以将这部分单独抽出来实现。</p><p>在 class 声明之后，就是 class 中成员函数的实现代码。</p><p><code>Cpu0AsmParser</code> 类继承了基类 <code>MCTargetAsmParser</code>，并重写了部分接口，而有关于汇编 parser 的详细逻辑可以参考 AsmParser.cpp 中的实现。</p><p>两个比较重要的重写函数：<code>MatchAndEmitInstruction()</code>， <code>ParseInstruction()</code> 。</p><p>汇编器在做 parser 时，要先做 Parse，然后再对符合语法规范的指令做指令匹配，前者的关键函数就是第 2 个函数 <code>ParseInstruction()</code>，后者的关键函数就是第 1 个 <code>MatchAndEmitInstruction()</code>。</p><p>在 <code>ParseInstruction()</code> 中，根据传入的词法记号，解析指令助记符存入 Operands 容器中，然后在后边依次解析每个操作数，也存入 Operands 中。对于不满足语法规范的输入，比如操作数之间缺逗号等这种问题，直接报错并退出。在解析操作数时，调用了 <code>ParseOperand()</code> 接口，这也是一个很重要的接口，专用来解析操作数，我们也重写了这个接口以适应我们的类型，尤其是地址运算符。</p><p><code>ParseInstruction()</code> 执行完毕后会返回到 <code>AsmParser.cpp</code> 中的 <code>parseStatement</code> 方法中，并在做一些分析后，再调用到 <code>MatchAndEmitInstruction()</code> 方法。</p><p>在 <code>MatchAndEmitInstruction()</code> 函数中，将 Operands 容器对象传入。首先调用 <code>MatchInstructionImpl</code> 函数，这个函数是 TableGen 参考我们的指令 td 文件生成的 Cpu0GenAsmMatcher.inc 文件自动生成的。</p><p>匹配之后如果成功了，还需要做额外的处理，如果这个是伪指令，需要汇编器展开，这种指令我们设计了几条，在之后会提到，这种指令需要调用 <code>expandInstruction()</code> 函数来展开，后者根据对应指令调用对应的展开函数，如果不是伪指令，就调用 <code>EmitInstruction()</code> 接口来发射编码，这个函数与我们前边章节设计指令输出的接口是同一个，也就是说在汇编 parser 之后的代码，是复用了之前的代码。</p><p>匹配如果失败了，则做简单处理并返回，这里我们只实现了几种简单的情况，如果你的后端有一些 TableGen 支持不了的指令形式，也可以在这里做额外的处理，不过还是尽量去依赖 TableGen 的匹配表为好。</p><p>在 <code>ParseOperand()</code> 函数中，将前边 parse 出来的 Operands 容器对象传入。首先调用 <code>MatchOperandParserImpl()</code> 函数来 parse 操作数，这个函数也是 Cpu0GenAsmMatcher.inc 文件中定义好的。如果这个函数 parse 成功，就返回， 否则继续在下边完成一些自定义的 parse 动作，在一个 switch 分支中，根据词法 token 的类型来分别处理。其中，对于 Token，可能是一个寄存器，调用 <code>tryParseRegisterOperand()</code> 函数来处理，如果没有解析成功，则按照标识符处理；对于标识符、加减运算符和数字等 Token 的情况，统一调用 <code>parseExpression()</code> 来处理；对于百分号 Token，表示可能是一个重定位信息，比如 <code>%hi($r1)</code>，则调用 <code>parseRelocOperand()</code> 函数来处理。</p><p>其他函数就不一一说明了，其中包括很多在 parse 操作数时，不同的操作数下的特殊处理，还有伪指令的展开动作，重定位操作数的格式解析以及生成重定位表达式，寄存器、立即数的 parse，还有汇编宏指令的解析（比如 <code>.macro</code>, <code>.cpload</code> 这一类）。</p><p>在最后，这些代码都实现完毕后，需要调用 <code>RegisterMCAsmParser</code> 接口将汇编 parser 注册到 LLVM 中，这个步骤写入到 <code>LLVMInitializeCpu0AsmParser()</code> 函数中。</p><h4 id="2-AsmParser-CMakeLists-txt"><a href="#2-AsmParser-CMakeLists-txt" class="headerlink" title="(2) AsmParser&#x2F;CMakeLists.txt"></a>(2) AsmParser&#x2F;CMakeLists.txt</h4><p>新增加子路径下的编译配置文件。</p><h4 id="3-AsmParser-LLVMBuild-txt"><a href="#3-AsmParser-LLVMBuild-txt" class="headerlink" title="(3) AsmParser&#x2F;LLVMBuild.txt"></a>(3) AsmParser&#x2F;LLVMBuild.txt</h4><p>同上，添加 LLVM 构建编译配置。</p><h4 id="4-Cpu0RegisterInfoGPROutForAsm-td"><a href="#4-Cpu0RegisterInfoGPROutForAsm-td" class="headerlink" title="(4) Cpu0RegisterInfoGPROutForAsm.td"></a>(4) Cpu0RegisterInfoGPROutForAsm.td</h4><p>在这个文件中，我们定义的 GPROut 类别是支持完整的 CPURegs 的。</p><h4 id="5-Cpu0RegisterInfoGPROutForOther-td"><a href="#5-Cpu0RegisterInfoGPROutForOther-td" class="headerlink" title="(5) Cpu0RegisterInfoGPROutForOther.td"></a>(5) Cpu0RegisterInfoGPROutForOther.td</h4><p>在这个文件中，我们定义的 GPROut 类别不包含 <code>$sw</code> 寄存器。</p><h4 id="6-Cpu0Asm-td"><a href="#6-Cpu0Asm-td" class="headerlink" title="(6) Cpu0Asm.td"></a>(6) Cpu0Asm.td</h4><p>由 <code>Cpu0.td</code> 拆分出来的文件，和 <code>Cpu0Other.td</code> 对应，包含了文件 <code>Cpu0RegisterInfoGPROutForAsm.td</code>。</p><h4 id="7-Cpu0Other-td"><a href="#7-Cpu0Other-td" class="headerlink" title="(7) Cpu0Other.td"></a>(7) Cpu0Other.td</h4><p>由 <code>Cpu0.td</code> 拆分出来的文件，和 <code>Cpu0Asm.td</code> 对应，包含了文件 <code>Cpu0RegisterInfoGPROutForOther.td</code>。</p><h3 id="10-1-2-文件修改"><a href="#10-1-2-文件修改" class="headerlink" title="10.1.2 文件修改"></a>10.1.2 文件修改</h3><h4 id="1-CMakeLists-txt"><a href="#1-CMakeLists-txt" class="headerlink" title="(1) CMakeLists.txt"></a>(1) CMakeLists.txt</h4><p>添加子路径的配置。同时，还需要添加一个新的 tablegen 配置项，要求 TableGen 生成 Cpu0GenAsmMatcher.inc 文件用来做汇编指令匹配。</p><h4 id="2-LLVMBuild-txt"><a href="#2-LLVMBuild-txt" class="headerlink" title="(2) LLVMBuild.txt"></a>(2) LLVMBuild.txt</h4><p>同上。</p><h4 id="3-Cpu0-td"><a href="#3-Cpu0-td" class="headerlink" title="(3) Cpu0.td"></a>(3) Cpu0.td</h4><p>删掉 Target.td、Cpu0RegisterInfo.td 文件的包含。添加汇编器 parser 在 td 中的定义，并注册到 Cpu0 的属性中。这些都是常规操作。</p><h4 id="4-Cpu0InstrFormats-td"><a href="#4-Cpu0InstrFormats-td" class="headerlink" title="(4) Cpu0InstrFormats.td"></a>(4) Cpu0InstrFormats.td</h4><p>增加针对伪指令的描述性 class，继承自 <code>Cpu0Pseudo</code> 类。</p><h4 id="5-Cpu0InstrInfo-td"><a href="#5-Cpu0InstrInfo-td" class="headerlink" title="(5) Cpu0InstrInfo.td"></a>(5) Cpu0InstrInfo.td</h4><p>增加 Operand 操作数 class 中 <code>ParserMatchClass</code> 和 <code>ParserMethod</code> 属性的描述，只有这样，td 中的操作数才会支持汇编 parse。</p><p>定义伪指令 <code>LoadImm32Reg</code>, <code>LoadAddr32Reg</code>, <code>LoadAddr32Imm</code>，这几个指令会在 <code>Cpu0AsmParser.cpp</code> 中实现对应的展开函数 <code>expandLoadImm()</code>, <code>expandLoadAddressImm</code> 和 <code>expandLoadAddressReg</code>，这些函数统一放到 <code>expandInstruction()</code> 中管理，后者在 <code>MatchAndEmitInstruction()</code> 函数中被调用。</p><h4 id="6-Cpu0RegisterInfo-td"><a href="#6-Cpu0RegisterInfo-td" class="headerlink" title="(6) Cpu0RegisterInfo.td"></a>(6) Cpu0RegisterInfo.td</h4><p>将 GPROut 的定义移动到 <code>Cpu0RegisterInfoGPROutForAsm.td</code> 和 <code>Cpu0RegisterInfoGPROutForOther.td</code> 中。</p><h3 id="10-1-3-验证结果"><a href="#10-1-3-验证结果" class="headerlink" title="10.1.3 验证结果"></a><strong>10.1.3 验证结果</strong></h3><p>这些函数的部分调用关系如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. ParseInstruction() -&gt; ParseOperand() -&gt; MatchOperandParserImpl() -&gt; tryCustomParseOperand() -&gt; parseMemOperand() -&gt; parseMemOffset(), tryParseRegisterOperand()</span><br><span class="line">2. MatchAndEmitInstruction() -&gt; MatchInstructionImpl(), needsExpansion(), expandInstruction()</span><br><span class="line">3. parseMemOffset() -&gt; parseRelocOperand() -&gt; getVariantKind()</span><br><span class="line">4. tryParseRegisterOperand() -&gt; tryParseRegister() -&gt; matchRegisterName() -&gt; getReg(), matchRegisterByNumber()</span><br><span class="line">5. expandInstruction() -&gt;expandLoadImm(), expandLoadAddressImm(), expandLoadAddressReg() -&gt; EmitInstruction()</span><br><span class="line">6. ParseDirective() -&gt; parseDirectiveSet() -&gt; parseSetReorderDirective(), parseSetNoReorderDirective(), parseSetMacroDirective(), parseSetNoMacroDirective() -&gt; reportParseError()</span><br></pre></td></tr></table></figure><p>编译本章第一个 case ch10_1.s，这是一个汇编文件，LLVM 的独立汇编器软件名为 llvm-mc，mc 意指 MCInstr 表示格式，它是一种比 MI 格式更底层的一种中间表示，清除很多信息，在汇编器中使用。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llvm-mc -triple=cpu0 -filetype=obj ch10_1.s -o ch10_1.o</span><br></pre></td></tr></table></figure><p>如果没有出错，那就成功汇编了，使用 llvm-objdump 工具反汇编代码来查看结果。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llvm-objdump -d ch10_1.o</span><br></pre></td></tr></table></figure><h2 id="10-2-内联汇编"><a href="#10-2-内联汇编" class="headerlink" title="10.2 内联汇编"></a>10.2 内联汇编</h2><p>当 c 程序需要直接访问特殊寄存器、指令或内存时，就需要内联汇编的支持，内联汇编允许直接在 c 程序中嵌入汇编代码，来完成机器层次级别的操作。clang 支持内联汇编，但因为汇编是后端的概念，所以内联汇编也自然需要后端来配合支持。</p><h3 id="10-2-1-简要说明"><a href="#10-2-1-简要说明" class="headerlink" title="10.2.1 简要说明"></a>10.2.1 简要说明</h3><p>一个简单的内联汇编格式是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__ (&quot;addu %0, %1, %2&quot;</span><br><span class="line">                      : &quot;=r&quot; (a)</span><br><span class="line">                      : &quot;r&quot; (b), &quot;r&quot; (c));</span><br></pre></td></tr></table></figure><p>其中第一行的 <code>__asm__</code> 是必须要有的，用来指明后边是内联汇编表达式；<code>__volatile__</code> 用来告诉编译器不要对这段代码做调整和优化，可以选择加上。</p><p>括号中第一行是要添加的指令，可以多行加入多个这样的字符串，用来一次性添加多条指令，指令字符串末尾不带分号；除了<code>%</code> 开头的操作数以外，其他内容要与标准汇编格式一致，<code>%</code> 开头的操作数作为占位符，会在内联汇编中用于与 c 变量或内存做绑定；这种占位符形式与下边变量的绑定是按照数字顺序依次对应，比如本例中 <code>%0</code> 对应 <code>a</code> 变量，<code>%1</code> 对应 <code>b</code> 变量。除此之外，还有一种命名绑定法，不再详细介绍。</p><p>第一个 <code>:</code> 之后的内容是输出的定义，这里的输出，包括下边的输入和 clobber list，都是用来修饰整个内联汇编块的，如果有多条指令，这里也仅表示整个指令块的输出，而不是某一条指令的输出；后边第一个字符串是操作数约束 constraint，用来描述这个操作数的类型，具体类型有很多，可以参考 gcc 标准内联汇编的格式，LLVM 采用兼容 gcc 标准内联汇编的策略，绝大多数约束保持了一致；之后小括号中的内容是 c 语言代码中的变量名，表示要绑定的变量。</p><p>第二个 <code>:</code> 之后的内容是输入的定义，与输出定义表现方式一致。</p><p>其实还可能有第三个 <code>:</code>，用来表示特殊约束 clobber，不展开介绍。</p><p>这三个 <code>:</code> 之后的内容可以选择性省略，但不能省略 <code>:</code>。</p><p>虽然内联汇编的格式挺复杂，但庆幸的是这些 parse 的工作大部分都已经由 clang 和 LLVM 完成了，clang 不需要我们做修改，凡是字符串中的内容，都会直接传给后端，而显然内联汇编的格式也依照此策略方便的隔离了前后端（意思是字符串中的内容才和后端相关，非字符串的格式由前端处理）。</p><p>我们需要做的工作在后端，主要是对一些自定义的类型、操作方式和约束做定义，如果你的后端是一个很简单的后端，甚至在这里都不需要做什么工作，LLVM 本身已经支持了很多标准操作。</p><h3 id="10-2-1-修改文件"><a href="#10-2-1-修改文件" class="headerlink" title="10.2.1 修改文件"></a>10.2.1 修改文件</h3><h4 id="1-Cpu0AsmPrinter-h-cpp"><a href="#1-Cpu0AsmPrinter-h-cpp" class="headerlink" title="(1) Cpu0AsmPrinter.h&#x2F;.cpp"></a>(1) Cpu0AsmPrinter.h&#x2F;.cpp</h4><p>重写 <code>PrintAsmOperand()</code> 函数，该函数用来指定内联汇编表达式的自定义输出样式，比如当修饰符是 <code>z</code> 时，表示这个值是一个非负立即数，我们希望在立即数为 0 时，不输出 0 而是输出 <code>$0</code>，就在这里完成。如果没有匹配到，就会调用 LLVM 内建的 <code>AsmPrinter::PrintAsmOperand()</code> 函数完成默认处理。如果没有指定约束类型，则会走到 <code>printOperand()</code> 函数打印出可能的重定位形式的汇编代码。</p><p>重写<code>PrintAsmMemoryOperand()</code> 函数，与上边同理，这个函数只负责处理内存操作的操作数。我们额外定义了我们自己的汇编格式中对内存访问的表示形式，即 <code>10($2)</code> 这种样式。</p><h4 id="2-Cpu0ISelDAGToDAG-h-cpp"><a href="#2-Cpu0ISelDAGToDAG-h-cpp" class="headerlink" title="(2) Cpu0ISelDAGToDAG.h&#x2F;.cpp"></a>(2) Cpu0ISelDAGToDAG.h&#x2F;.cpp</h4><p>这里重写了一个函数<code>SelectInlineAsmMemoryOperand()</code>，该函数用来约定内存操作数在指令选择时的动作，对于内存操作，因为其表现是重定位字符串，所以不需要在编译器这里做处理，所以直接将 OP，就是对应的 node，保存下来并返回 false，告诉 LLVM 不需要对其进行下降。</p><h4 id="3-Cpu0ISelLowering-h-cpp"><a href="#3-Cpu0ISelLowering-h-cpp" class="headerlink" title="(3) Cpu0ISelLowering.h&#x2F;.cpp"></a>(3) Cpu0ISelLowering.h&#x2F;.cpp</h4><p>除了特殊的地址操作数之外，就剩下寄存器和立即数操作数了，立即数操作数会由 LLVM 自动的依据 Cpu0GenRegisterInfo.inc 中的信息做绑定，留下特殊的立即数操作数需要我们做处理。因为立即数编码是指令中的一部分，LLVM 公共环境并不知道我们可能支持哪些宽度的立即数，所以其代码需要手动添加。</p><p>我们重写了几个函数，其中关键的一个是 <code>LowerAsmOperandForConstraint()</code> ，这个函数对所有可能的自定义的约束做处理，处理完特殊情况之后，会转到 LLVM 公共的 <code>TargetLowering::LowerAsmOperandForConstraint()</code>。</p><p>其他几个函数用来配合寄存器约束的解析，具体可以参考代码中注释。</p><p>另外，内联汇编还支持将一个操作数约束成多个可能的类型，比如一个立即数，可以约束为几个不同有效编码范围的立即数类型。后端会使用 <code>getSingleConstraintMatchWeight()</code> 函数来决定一个权重，根据权重来选择最佳匹配的类型。</p><h4 id="4-Cpu0InstrInfo-cpp"><a href="#4-Cpu0InstrInfo-cpp" class="headerlink" title="(4) Cpu0InstrInfo.cpp"></a>(4) Cpu0InstrInfo.cpp</h4><p>增加计算内联汇编指令长度的计算代码。</p><p>LLVM 中处理内联汇编的主要逻辑在 <code>TargetLowering.cpp</code> 文件中，对于我们上边几个文件中重写的接口函数都有调用，而且因为核心逻辑是标准的，只要我们不在内联汇编的代码语法上做调整，就不需要修改到公共代码。至于如寄存器类型多而导致寄存器约束多（比如可能会自定义多种向量寄存器，新建如 <code>v</code>， <code>t</code> 等约束）， 或者立即数编码形式多、内存寻址方式多，都可以在后端的上述几个函数中做调整。</p><h3 id="10-2-3-检验成果"><a href="#10-2-3-检验成果" class="headerlink" title="10.2.3 检验成果"></a>10.2.3 检验成果</h3><p>运行 ch10_2.c 的代码，其中已经编写了几种简单的内联汇编的代码。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/clang -target mips-unknown-linux-gnu -c ch10_2.c -S -emit-llvm -o ch10_2.ll</span><br></pre></td></tr></table></figure><p>检查 IR 文件。LLVM IR 也有一种特殊的内联汇编表现样式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%1 = call i32 asm sideeffect &quot;addu $0, $1, $2&quot;, &quot;=r,r,r,~&#123;$1&#125;&quot;(i32 %0, i32 %1) #1, !srcloc !2</span><br></pre></td></tr></table></figure><p>它用 <code>asm</code> 作为一个特殊的操作节点，这个节点在后端会被当做内联汇编的块做 lowering。</p><p>编译为汇编代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=asm ch10_2.ll -o -</span><br></pre></td></tr></table></figure><p>检查汇编文件中，使用 <code>#APP</code> 和 <code>#NO_APP</code> 包含在中间的代码就是内联汇编代码。内联汇编默认的标识是 <code>#APP</code>，这个符号也可以修改。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/397262087">LLVM 后端实践笔记 10：汇编 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一章，我们来添加 Cpu0 的汇编功能，这包括独立汇编器和 C 语言内联汇编特性两个部分。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;/posts/4b2442c5.html&quot; title=&quot;LLVM 后端实践笔记 0：序&quot;&gt;LLVM 后端实践笔记 0：序&lt;/a&gt;&lt;/li</summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>LLVM 后端实践笔记 9：ELF文件支持</title>
    <link href="https://p2tree.top/posts/949c9f6a.html"/>
    <id>https://p2tree.top/posts/949c9f6a.html</id>
    <published>2021-07-31T23:04:26.000Z</published>
    <updated>2024-09-01T11:46:12.734Z</updated>
    
    <content type="html"><![CDATA[<p>虽然我们的 Cpu0 模拟器只需要输入 hex 格式的编码文件就可以执行，但这一章依然介绍如何生成 ELF 文件，ELF 文件是一种通用的可执行文件、目标文件和共享库与核心转储文件标准，最早是由 System V 应用二进制接口发布，之后成为一种标准，并很快被类 Unix 操作系统接受。几乎所有支持编译的后端平台都需要生成一种可执行文件格式来执行代码，现在主流的三种可执行文件分别是 Linux 系统及裸机系统支持的 ELF 文件、Windows 系统支持的 COFF 文件以及 MacOS 系统支持的 Mach-O 文件格式。我们让 Cpu0 后端生成 ELF 文件格式。</p><p>之前章节我们介绍了 Cpu0 后端生成各种指令编码的代码，所以有关于指令编码的行为，是由 td 文件中的描述来确定的，LLVM 的公共部分已经帮我们生成了指令编码的功能。但目前还没有定义生成 ELF 文件的头部、段组成、重定位信息等内容，这一章主要实现这部分内容。</p><p>这一章，我们会使用二进制解析工具来检查 ELF 文件，比如 objdump 和 readelf 文件。需要注意的是，因为他们是 gnu 工具集的软件，在 MacOS 系统上的 objdump 和 readelf 没有默认安装，需要手动安装，并且为了和 MacOS 自身的工具做区分，还需要简单的配置环境路径。</p><p>LLVM 中有类似于 objdump 的工具，默认生成名称为 <code>llvm-objdump</code>，基本使用和 objdump 一致，我们这一章也会试用这个工具。</p><ol><li><a href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a></li><li><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a></li><li><a href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a></li><li><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a></li><li><a href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a></li><li><a href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a></li><li><a href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a></li><li><a href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a></li><li><a href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a></li><li><a href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a></li><li><a href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a></li><li><a href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></li></ol><hr><h2 id="9-1-ELF-文件格式"><a href="#9-1-ELF-文件格式" class="headerlink" title="9.1 ELF 文件格式"></a>9.1 ELF 文件格式</h2><p>这一节只是简单介绍，有关于详细的学习材料，在网上可以找到很多。ELF 文件格式的支持是 LLVM 默认便已经完成的，不需要我们做更多的工作（少量工作在第 2 章中已经完成）。</p><p>ELF 文件格式有两种视图，分别是目标文件视图和可执行文件视图。</p><p>目标文件视图是为链接器服务的，它的划分标准是段（Section），不同的段有 <code>.text</code> 段存放代码内容、<code>.data</code> 段存放数据、<code>.rodata</code> 段存放只读数据等，这些段的索引保存在 ELF 文件末尾的段头部表（Section header table）中。链接器通过访问段头部表来检索到各段。</p><p>可执行文件视图是为执行服务的，它的划分标准是节（Segment），不同的节可能是多个段的组合，比如执行时，因为要关心数据的访问权限，<code>.text</code> 段和 <code>.rodata</code> 段会合并为一个只读数据的节。加载器会访问位于 ELF 文件开头文件头部表之后的节头部表（Segment header table），来访问各节。</p><p>链接器和加载器的实现不会在本教程中涉及。</p><p>ELF 文件开头的文件头部表是用来描述文件基本信息的，接下来我们通过工具查看文件头部表信息。</p><h3 id="9-1-1-读取-ELF-文件"><a href="#9-1-1-读取-ELF-文件" class="headerlink" title="9.1.1 读取 ELF 文件"></a>9.1.1 读取 ELF 文件</h3><p>工具 objdump 和 readelf 的功能类似，但我用起来觉得 objdump 更实用，大家也可以尝试；llvm-objdump 工具的用法与 objdump 工具类似。我们以 readelf 工具为例，读取 ELF 文件内容。</p><p>先编译生成一个目标文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=obj ch5.c -o ch5.o</span><br></pre></td></tr></table></figure><p>使用 readelf 工具解析 ELF 文件头部表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h ch5.o</span><br></pre></td></tr></table></figure><p>除了通用的内容，比如魔数、类型、版本等，其中标明机器类型的一项，显示的是 <code>&lt;unknown&gt;: 0x3e7</code>，这是因为 readelf 工具是通用工具，它会记录主流机器的唯一编码，而我们的 Cpu0 并不是一个主流机器，所以它无法识别。之后我们代码生成的 llvm-objdump 才可以识别 Cpu0 的机器。</p><p>然后继续读取它的节头部表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l ch5.o</span><br></pre></td></tr></table></figure><p>输出的内容是没有节头部表。这是正常的，因为我们当前生成的是目标文件，是给链接器用的，节头部表是链接器输出时在可执行文件中加入的内容。</p><p>然后我们看一下它的段头部表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S ch5.o</span><br></pre></td></tr></table></figure><p>输出的内容中，可以看到各个段的基本信息，包括大小、基址、偏移等。因为段还没有经过链接，所以地址是 0。</p><p>其他参数可以通过 <code>-h</code> 参数来查看，比如 <code>-t</code> 打印详细段信息，<code>-r</code> 打印出重定位信息。</p><p>打印重定位信息时，可以看到 <code>_gp_disp</code> 符号是需要重定位的，但在汇编代码中找不到这个符号，因为这个符号是在动态链接时用来指定全局变量表位置的，由加载器决定，而在汇编代码中，我们当时设计了 <code>.cpload</code> 伪指令，这条伪指令的展开代码中有 <code>_gp_disp</code> ，所以重定位信息中才会出现这个符号。如果按照 <code>-relocation-model=static</code> 来生成目标文件，就不会出现这个符号了。</p><h2 id="9-2-支持反汇编"><a href="#9-2-支持反汇编" class="headerlink" title="9.2 支持反汇编"></a>9.2 支持反汇编</h2><p>在执行反汇编命令时：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llvm-objdump -d ch5.o</span><br></pre></td></tr></table></figure><p>提示我们 cpu0 机器没有反汇编器。因为我们还没有实现反汇编，这一节我们来实现它。</p><h3 id="9-2-1-文件修改"><a href="#9-2-1-文件修改" class="headerlink" title="9.2.1 文件修改"></a>9.2.1 文件修改</h3><h4 id="1-CMakeLists-txt"><a href="#1-CMakeLists-txt" class="headerlink" title="(1) CMakeLists.txt"></a>(1) CMakeLists.txt</h4><p>需要新增反汇编代码的文件，所以在构建文件中需要增加说明。我们反汇编指令的大多数编码信息都是从 td 文件中解析的，这里指定基于 td 生成一个 inc 文件 Cpu0GenDisassemblerTables.inc，这个文件会在 Cpu0Disassembler.cpp 中用到。</p><h4 id="2-LLVMBuild-txt"><a href="#2-LLVMBuild-txt" class="headerlink" title="(2) LLVMBuild.txt"></a>(2) LLVMBuild.txt</h4><p>同理，增加一些说明，其中要说明我们的后端支持反汇编。</p><h4 id="3-Cpu0InstrInfo-td"><a href="#3-Cpu0InstrInfo-td" class="headerlink" title="(3) Cpu0InstrInfo.td"></a>(3) Cpu0InstrInfo.td</h4><p>对一些基本类添加反汇编函数的引用。这里添加了 JumpFR 类的引用。</p><h3 id="9-2-2-文件新增"><a href="#9-2-2-文件新增" class="headerlink" title="9.2.2 文件新增"></a>9.2.2 文件新增</h3><p>新增一个子目录，以及对应的文件。</p><h4 id="1-Disassembler-Cpu0Disassembler-cpp"><a href="#1-Disassembler-Cpu0Disassembler-cpp" class="headerlink" title="(1) Disassembler&#x2F;Cpu0Disassembler.cpp"></a>(1) Disassembler&#x2F;Cpu0Disassembler.cpp</h4><p>在这个反汇编文件中，实现了 td 文件中所有反汇编函数引用的函数，即 DecoderMethod 关键字指定的函数，尤其是对应一些特殊操作数的反汇编，比如内存引用的反汇编，因为这种特殊操作数格式是我们自定义的 td 类来定义的，所以也需要指定其反汇编方法。</p><h4 id="2-Disassembler-CMakeLists-txt-和-Disassembler-LLVMBuild-txt"><a href="#2-Disassembler-CMakeLists-txt-和-Disassembler-LLVMBuild-txt" class="headerlink" title="(2) Disassembler&#x2F;CMakeLists.txt 和 Disassembler&#x2F;LLVMBuild.txt"></a>(2) Disassembler&#x2F;CMakeLists.txt 和 Disassembler&#x2F;LLVMBuild.txt</h4><p>另外，该路径下的 CMakeLists.txt 和 LLVMBuild.txt 文件也要一并添加。</p><p>以上就是所有要修改和添加的文件，llvm-objdump 无法指定处理器类型，所以无法指定当前的可执行文件是要按 Cpu032I 还是 Cpu032II 来反汇编，所以需要指定默认值，我们在 Cpu0MCTargetDesc.cpp 中指定了当 cpu 型号为空时，按照 Cpu032II 来使用。Cpu032II 的指令集能够覆盖 Cpu032I，所以能够解析所有编码。</p><h3 id="9-2-3-验证结果"><a href="#9-2-3-验证结果" class="headerlink" title="9.2.3 验证结果"></a>9.2.3 验证结果</h3><p>最后测试一下，编译源码成功后，重新反汇编目标文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llvm-objdump -d ch5.o</span><br></pre></td></tr></table></figure><p>可以看到反汇编信息正常输出了。反汇编信息并不是我们后端按正常流程必须要有的一个功能，但它依然非常重要，核心的作用是辅助调试，会在如 <code>lldb</code> 和 <code>llvm-objdump</code> 这类工具中用到。</p><h2 id="9-3-总结"><a href="#9-3-总结" class="headerlink" title="9.3 总结"></a>9.3 总结</h2><p>以上就是本章的全部内容，这一章比较简单，LLVM 为我们实现了大部分的支持 ELF 文件格式输出的特性。下一章我们会支持汇编器功能。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a href="https://zhuanlan.zhihu.com/p/395013751">LLVM 后端实践笔记 9：ELF 文件支持 - 知乎 (zhihu.com)</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然我们的 Cpu0 模拟器只需要输入 hex 格式的编码文件就可以执行，但这一章依然介绍如何生成 ELF 文件，ELF 文件是一种通用的可执行文件、目标文件和共享库与核心转储文件标准，最早是由 System V 应用二进制接口发布，之后成为一种标准，并很快被类 Unix </summary>
      
    
    
    
    <category term="软件开发" scheme="https://p2tree.top/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编译器" scheme="https://p2tree.top/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="LLVM" scheme="https://p2tree.top/tags/LLVM/"/>
    
  </entry>
  
</feed>
