<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>扑克昆特牌玩法设计</title>
    <link href="/2024/06/19/%E6%89%91%E5%85%8B%E6%98%86%E7%89%B9%E7%89%8C%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/06/19/%E6%89%91%E5%85%8B%E6%98%86%E7%89%B9%E7%89%8C%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>这篇文章中，我将会介绍如何用扑克牌（一定程度上）复刻传统昆特牌游戏的玩法。其中会涉及到分析昆特牌游戏为什么如此受玩家欢迎的原因，《巫师 3：狂猎》又被称为 “昆特 3” 是有一定道理的 🐶</p><p>通过使用扑克牌复刻昆特牌游戏玩法，可以把昆特牌搬到线下和朋友一起玩，之所以不购买或自制现成的昆特牌桌游套件，是因为扑克牌更容易拿到，而且扑克牌玩昆特牌绕开了一些不重要而且浪费时间的话题讨论中（比如希瑞雅的战力应该给多少）。</p><p>在设计这套玩法之前，我玩了很久的昆特牌及其衍生作品，也研究了昆特牌模组的改进，吸取了其他网友的一些灵感。如果你对这个话题感兴趣，欢迎，我的朋友 👏</p><h2 id="昆特牌介绍"><a href="#昆特牌介绍" class="headerlink" title="昆特牌介绍"></a>昆特牌介绍</h2><p>本文所提到的昆特牌为《巫师 3：狂猎》游戏中的小游戏，也被称为 ”传统昆特牌“，并不是 CDPR 后续出的《巫师之昆特牌》与另外两款单机昆特牌游戏。</p><p>本文不会啰啰嗦嗦的介绍所有关于该游戏的细节，没必要重复，想阅读本文但不了解昆特牌游戏的读者请先移步：<a href="https://witcher.huijiwiki.com/wiki/%E6%98%86%E7%89%B9%E7%89%8C">昆特牌 - 猎魔人中文维基 | 獵魔士中文維基 | 巫师狩魔猎人攻略资料站 | The Witcher | Wiedźmin - 灰机wiki - 北京嘉闻杰诺网络科技有限公司 (huijiwiki.com)</a></p><h3 id="基本玩法"><a href="#基本玩法" class="headerlink" title="基本玩法"></a>基本玩法</h3><p>我会提及一些下文会用到的基本信息，不感兴趣可跳过。</p><p>比赛将与对手一对一，采用三局两胜制。</p><p>游戏开始前双方各自选取 5 个阵营中的其中一个进行游戏，并需要在比赛前整理一套合适的卡组与选择领袖牌。</p><p>牌桌由六排组成，分别是我方攻城排、远程排、近程排、对方近程排、远程排、攻城排。我方放牌至我方所在排，对方牌放置在对方所在排，不同手牌有基本固定的放置排。</p><p>卡牌分为战力牌、特殊牌和领袖牌：</p><ul><li>战力牌拥有一个战力点数，并指定它可以放置的排，部分牌拥有特殊效果，战力牌中有一类牌为英雄牌，不受特殊牌影响</li><li>特殊牌（天气牌）会对牌桌上战力牌战力产生影响</li><li>领袖牌和特殊牌一样，也会产生对战力牌的影响</li></ul><p>比赛开始双方随机抽取一定数量的牌，开始前双方有一次机会可以替换手牌中两张牌为牌组中随机牌的机会。</p><p>之后三局中不会再抽牌（北方领域特色除外）。</p><p>比赛过程中交替出牌，直到其中一方放弃出牌或空牌，另一方可以选择继续出牌。双方放弃出牌后，根据牌桌上双方战力排战力点数总额最高者，获得此局胜利。</p><p>当前局结束后，牌桌清牌（怪物和史凯利格特色除外）。</p><p>某一小局双方分值持平时，双方均不获胜（尼国特色除外）。</p><p>第一小局掷骰子决定哪方先出牌（松鼠党特色除外），之后每一小局出牌方为上一局获胜方。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>五个阵营各自特色为：</p><ul><li>北方领域：某一小局获胜后，允许从牌组中抽取一张牌</li><li>尼国：某一小局双方分值相同时，尼国获胜</li><li>松鼠党：比赛开始时，决定己方先出牌还是对方先出牌</li><li>怪物：每小局结束时，随机一张战力牌留在牌桌</li><li>史凯利格：在第三小局时，随机从己方前两局弃牌中抽取两张牌放入牌桌</li></ul><p>部分战力牌拥有特殊效果，战力牌特殊效果是我认为昆特牌中最复杂的玩法细节，虽然它们相比其他卡牌类游戏并不复杂，这些特殊效果有：</p><ul><li>烧灼：消灭牌桌上当前战力最高的牌（可多张），无论敌方还是我方。如果当前战力牌战力最高，将消灭当前牌</li><li>间谍：放置在对方排，为对方累积战力，但换取己方抽取两张牌</li><li>士气：所在排其他牌战力均 +1，即使是后续放置在该排的牌</li><li>号角：所在排其他牌战力均乘 2，即使是后续放置在该排的牌</li><li>医生：从弃牌中选择一张牌放入牌桌</li><li>同胞：相同牌放置时，每张牌战力乘当前牌桌同名牌的数量，即使是后续放置的相同牌</li><li>召唤：放置牌时召唤卡组中其他同名牌一同打出</li><li>狂战士：放置后如果被转化牌转化，会转化为另一张战力牌，否则保持现状</li><li>转化（玛德罗弥）：放置后对当前排中所有狂战士做转化</li><li>复仇：放置在牌桌，直到下一局自动转化为另一张战力牌并保留在下一局牌桌上</li><li>假人：一种特殊牌（无战力），用来将己方牌桌上的间谍换取到手牌中</li></ul><p>天气牌是非常有趣的一个设计，它作为可以同时影响一排战力牌的强力卡牌，却会对双方排均产生影响，这让使用天气牌时更需要技巧，同时猜测对方是否持有天气排，从而改变己方出牌策略。这些天气牌有：</p><ul><li>白霜：双方近战排所在牌战力降为 1</li><li>浓雾：双方远程排所有牌战力降为 1</li><li>暴雨：双方攻城排所有牌战力降为 1</li><li>晴天：移除场上所有天气牌效果</li><li>史凯利格风暴：将双方远程和攻城排所有牌战力降为 1</li></ul><h3 id="特点及泛化分析"><a href="#特点及泛化分析" class="headerlink" title="特点及泛化分析"></a>特点及泛化分析</h3><h4 id="玩法独特"><a href="#玩法独特" class="headerlink" title="玩法独特:"></a>玩法独特:</h4><p>昆特牌最独具一格的特色是一次性抽牌后三局两胜制玩法，也就是 ”田忌赛马“ 式比赛玩法。某一局的弱势方可以选择放弃当前局保留实力，并尽可能骗取对方放下高战力牌的方式，为自己下一局争取获胜概率。</p><p>独立游戏《巫师之昆特牌》在每小局结束后双方均可抽牌的设计，弱化了传统昆特牌最大的特色，是我认为它衍生决策中最大的败笔。</p><h4 id="入门简单"><a href="#入门简单" class="headerlink" title="入门简单:"></a>入门简单:</h4><p>作为游戏中的小游戏，它最初的设计就不能允许过于复杂。大多数卡牌游戏都过于复杂，不同卡牌有各自的技能，卡牌之间又有克制关系，无论是比赛前熟悉卡牌特性，还是比赛中阅读技能说明，都让整个游戏过程变得复杂，也提高了新玩家熟悉游戏的门槛。</p><p>我不否认卡牌游戏作为策略游戏的一种，应该足够复杂，以提高可玩性，但另一方面，确实也有不少牌类游戏，以简单灵活为特色，被很多人喜爱，典型的就是斗地主。传统昆特牌刚好做到了在简单通用和足够有趣之间找到一个平衡。</p><h4 id="集卡"><a href="#集卡" class="headerlink" title="集卡:"></a>集卡:</h4><p>人们都控制不了自己的收集欲，而昆特牌一定程度上展现了猎魔人世界观的一些背景知识，这让玩家无论是单纯的收集全套，还是收集过程中阅读卡牌描述和了解人物，都变得非常有趣。</p><h4 id="卡牌属性特色"><a href="#卡牌属性特色" class="headerlink" title="卡牌属性特色:"></a>卡牌属性特色:</h4><p>和 “炉石传说” 等卡牌游戏有区别的地方在于它几乎没有双方牌之间的直接战斗，也就是类似炉石中拿一张牌攻击对方牌的做法。这让比赛过程简化很多，只需要关注自己的手牌在什么时机放下牌桌即可。</p><p>另外，特殊牌（天气牌）会对双方牌某排所有牌产生影响。这为游戏带来更多变数，需要思考如何放下特殊牌来最大化己方的战力累积而对对方产生更多影响。间谍牌也是非常有趣的一个设计，通过给对方加战力来换取自己抽取两张新牌的机会，配合假人牌，又克制了间谍牌的强度。不过我认为间谍牌依然是很强力的类型牌。</p><h3 id="不足与改进建议"><a href="#不足与改进建议" class="headerlink" title="不足与改进建议"></a>不足与改进建议</h3><p>5个阵营的特色不明显，尼国和史凯利格比较强。可以突出每类阵营的特色的同时，巧妙的设计克制关系，让不同阵营之间更平衡（昆特牌 mod：redux gwent 有这方面的改进）。另外一个建议是，取消阵营设计，融合阵营特色，将所有卡牌整合到一起。</p><p>领袖牌的特殊能力缺乏特色，有不少领袖的能力和天气牌重复。领袖牌应该有全新的特殊能力设计，甚至突破现有规则，比如设计能攻击对方指定牌的能力。否则可以撤销领袖牌。</p><p>牌组设计必然导致有一些强势牌和弱势牌，这导致在游戏中没有积累到强势牌时，昆特牌比赛非常困难，而积累到强势牌后又非常简单。舍弃牌组准备，而将所有牌都洗入牌组是一个简单的策略，在保证公平的前提下也简化了比赛复杂度。</p><p>英雄牌设计过于强势，比赛时抽取到多张英雄牌基本就决定比赛结果。应当削减英雄牌能力，或者减少（甚至删除）英雄牌。</p><h2 id="扑克昆特牌设计"><a href="#扑克昆特牌设计" class="headerlink" title="扑克昆特牌设计"></a>扑克昆特牌设计</h2><h3 id="考虑细节"><a href="#考虑细节" class="headerlink" title="考虑细节"></a>考虑细节</h3><p>使用扑克牌实现昆特牌玩法，可以还原一部分特性，但必然需要舍弃很多特性。一方面是扑克牌的种类没有那么多，另一方面是实体牌计算分值比较困难。</p><h4 id="核分："><a href="#核分：" class="headerlink" title="核分："></a>核分：</h4><p>作为实体牌玩昆特牌，无论是使用昆特牌桌游卡牌，还是用扑克牌模拟，都会遇到棘手的问题，也就是核算分数。</p><p>进行比赛时，需要累积分值，分值在每一张牌落下时都会作为后续决策的重要参考，所以需要频繁的做计算，如果没有便捷的分值计算方法，游戏过程会变得枯燥。当然也许这是一个练习心算能力的机会 😂。最好能有一个方便的记分工具，一个白板、计算器或者记分骰子是不错的选择。</p><p>另外，作为实体牌进行比赛时，战力牌的特殊效果也对分值计算带来更多挑战，在游戏中，程序会自动计算新的分值，在实体牌中需要额外处理。建议去掉战力牌特殊效果，或者只保留少数。</p><h4 id="取消角色："><a href="#取消角色：" class="headerlink" title="取消角色："></a>取消角色：</h4><p>和昆特牌卡牌不同，扑克牌无法还原卡牌角色及信息，这是缺憾的地方。当然，它也带来了好处，就像我开头所说，我们不必再纠结于角色本身的著作背景与昆特牌战力、特殊效果之间的一致性。</p><p>当然，如果手里有昆特牌桌游卡牌来代替，也是非常幸运的事情。</p><h3 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h3><h4 id="牌桌："><a href="#牌桌：" class="headerlink" title="牌桌："></a>牌桌：</h4><p>将 3+3 排改为 2+2 排，这里和《巫师之昆特牌》的考虑相同，3 排和 2 牌并没有产生本质的区别，反而让牌桌过长（我希望宽一些更符合比赛环境），另外我们的特殊牌也很有限。</p><p>牌桌将包括我方远程牌、近程牌、对方近程牌、远程牌。</p><h4 id="牌组："><a href="#牌组：" class="headerlink" title="牌组："></a>牌组：</h4><p>取消牌组准备的工作，所有牌全部纳入牌组参与比赛。</p><p>双方各自持有红牌（红桃、方片）和黑牌（黑桃、梅花）进行游戏（大小王双方各一张），如果可以用两套扑克牌也可以各自一套牌，但意义不大，因为每次比赛能抽到的牌有限，适当的可猜牌机会也能提高趣味性（双方相同牌都有两张）。四种花色分别放置在四排中，可以任选不同花色。</p><p>比赛开始时摸 10 张牌，允许选择换牌 2 张，之后每局获胜方额外摸 1 张牌。</p><h4 id="阵营："><a href="#阵营：" class="headerlink" title="阵营："></a>阵营：</h4><p>取消多方阵营，将阵营特色融合在一起。</p><p>阵营特色保留某一局获胜方可抽取一张牌的效果。</p><h4 id="战力牌："><a href="#战力牌：" class="headerlink" title="战力牌："></a>战力牌：</h4><p>选择数字 A, 2, 3, 4, 5, 6, 7, 8, 9, 10 的所有花色牌作为战力牌，A 为 1 分牌，其他牌战力与数字一致。</p><p>扑克牌不能表现出所有战力牌的特殊效果，扑克牌的牌特征有限，同时也避免了实体牌计算分值的复杂度。我将保留一些特殊效果，保留的依据是：</p><ul><li>避免给分值计算带来负担</li><li>尽可能保留昆特牌特色</li><li>加强低分牌，所以越强势的特殊效果会赋予给越低的分值牌</li></ul><p>这些特殊效果为：</p><ul><li>烧灼：指定分值的牌可以烧灼，我选择 A，烧灼会直接将被烧灼牌弃牌，不会给计算分值带来困难，A 作为 1 分牌，加强其能力</li><li>间谍：这种重要的特殊效果不能被丢弃，但只能简化它的分值差异，我选择 3 作为间谍，即 3 只能打在对方排，并允许己方抽取两张牌，选择 3 的原因是平衡抽牌的强度</li><li>医生：不会对分值计算带来困难，同时它也是非常有意思的一个特殊效果，我选择 2，作为 2 分牌，加强其能力</li><li>假人：替换己方牌桌上的一张间谍牌到手牌中，我选择大王、小王两张牌（双方各一张）</li><li><del>士气、号角、同胞</del>被舍弃，因为他们会改变牌的战力，对计算分值带来了困难</li><li><del>召唤</del>被舍弃，舍弃的原因是放置时需要到牌组中找牌，对比赛节奏不友好</li><li><del>狂战士、转化和复仇</del>被舍弃，它们也会改变牌的战力，对计算分值不利，在原版游戏中它们对比赛的影响也很有限</li></ul><h4 id="特殊牌："><a href="#特殊牌：" class="headerlink" title="特殊牌："></a>特殊牌：</h4><p>为了减轻分值计算复杂度，我对天气牌做了一个小调整，放置天气牌不是将战力降为 1，而是直接降为 0。降为 1 或 0 对分值的累积没有明显影响，但会极大改善分值计算的难度。</p><p>另外，由于我们只有两排，所以设置的特殊牌为：</p><ul><li>冰霜：将双方近战排所有牌战力降为 0，我选择为 J 牌</li><li>浓雾：将双方远程排所有牌战力降为 0，我选择为 Q 牌</li><li>晴天：移除牌桌上所有天气牌，我选择为 K 牌</li><li><del>暴雨、史凯利格风暴</del>被移出，效果比较重复，而且没有必要用</li></ul><h4 id="领袖牌："><a href="#领袖牌：" class="headerlink" title="领袖牌："></a>领袖牌：</h4><p>领袖牌将会被取消。原版游戏的领袖牌特征，要不过于强势，要不过于弱势，再加上很多特殊效果在战力牌特殊效果中有重复，所以领袖牌的意义并不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我个人的一些建议，欢迎参考和调整，玩的愉快 😆</p>]]></content>
    
    
    
    <tags>
      
      <tag>昆特牌</tag>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>处理器 barrier 行为的仿真实现</title>
    <link href="/2024/06/16/%E5%A4%84%E7%90%86%E5%99%A8barrier%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/06/16/%E5%A4%84%E7%90%86%E5%99%A8barrier%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>由于编译器指令重排以及 CPU 乱序执行的问题，处理器指令有可能在多线程执行时遇到一些问题，比如数据竞争，死锁，非预期的计算结果等。为了避免这类潜在的问题，引入了 barrier 的概念。编译器会主动插入 barrier 指令来降低直接调整指令调度环节的复杂性，而硬件的非预期行为也只能通过软件强行做同步来避免。</p><p>在处理器架构领域，barrier 是一种同步行为，它通常是指令或者指令 modifier，用来对程序流进行同步控制。在多处理器或多线程处理器中，当不同的程序流遇到 barrier 时，会等待其他程序流同时到达这个同步点，然后再执行后边的程序。</p><p>这种方式确保了所有的线程或处理器能够在程序的同一个位置重新对齐。</p><p>在一些硬件上，这种行为通过指令实现，比如 intel 的 FENCE 指令，ARM 的 DMB&#x2F;DSB 指令。大多数 barrier 指令都带有对内存操作的同步，也就是在 barrier 之前的读写内存操作必须在 barrier 点完成，以达到内存访存有序的目的，这通常也被称为 memory fence。概念上讲，fence 是 barrier 的一个特例，也就是说 barrier 并不会要求必须实现 fence 的功能，当然这取决于具体硬件。</p><p>本文中，我将会介绍一种对 barrier 指令行为的软件仿真实现。出于简化实现的目的，程序中不会实现 memory fence，只会对程序指令流的同步行为做仿真，也就是 instruction barrier。</p><p>我也会对应用场景做简化，多线程程序和多处理器程序的 barrier 在程序表现上是一致的，不一致的是 barrier 的指令实现，文章和代码介绍多线程程序下的 barrier 仿真，两者之间很容易互通。</p><p>适合看这篇文章的人可能并不多，如果你想进一步了解 barrier 的概念，可以查找其他文章。阅读本文和 demo 程序需要对 C++ 多线程编程有足够的知识，且对汇编程序设计和并行处理器有一些了解。</p><p>我在网络上并没有找到介绍 barrier 仿真的中文资料，所以希望写此文和提供可参考的 demo 程序，帮助有需要的朋友。</p><p>Demo 程序放在：<a href="https://github.com/P2Tree/barrier/tree/master">P2Tree&#x2F;barrier: A simulate demo for barrier behaviour in compute architecture (github.com)</a>，可以直接取用，有问题请反馈我处理。</p><h2 id="设计用例场景"><a href="#设计用例场景" class="headerlink" title="设计用例场景"></a>设计用例场景</h2><p>一个良好的软件工程实践是先梳理需求和应用场景，并编写一些测试用例。我梳理了几种常见的 instruction barrier 的应用场景（以下用汇编伪码介绍），这些场景会作为 UT 出现在代码中：</p><ol><li><p>最普通的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">some_insts<br>barrier_sync_all_threads<br>some_insts<br></code></pre></td></tr></table></figure><p>多线程程序多以这种 sync 所有线程的方式调用 barrier，线程程序中没有分支和跳转指令，所以每个线程都会执行到相同的代码。但由于线程调度和指令 latency，barrier 前后的时间会不同。</p></li><li><p>程序中存在多个 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">some_insts<br>barrier_sync_all_threads_with_ID_0<br>some_insts<br>barrier_sync_all_threads_with_ID_1<br>some_insts<br></code></pre></td></tr></table></figure><p>硬件并不会只提供一个 barrier，程序的复杂性会要求同时使用多个不同的 barrier。不同的 barrier 的仿真实现可能带来复杂的同步问题。这里额外说一句，barrier 是一种硬件资源，线程程序需要考虑到不要超出资源限制。同一个 barrier 可以在程序的多个指令中被访问，但需要满足适当的用法，否则会出现程序异常、hangup 等问题。</p></li><li><p>只 wait 部分线程的 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_sync_all_threads<br>some_insts<br></code></pre></td></tr></table></figure><p>除了提供对所有线程做同步的 barrier 外，也可能存在对部分线程做同步的 barrier。可能会有两种形式，第一种形式并不关心要同步哪些线程，只关心同步了多少数量的线程；第二种形式关心同步指定线程 ID 的线程。两种形式看似不同，但在仿真实现上基本类似。Demo 中以第一种形式来实现。同步部分线程指令需要带有额外的操作数来指定同步多少线程（或同步哪些线程），超出同步数量的线程（或没有在指定范围内的线程）会直接忽略这个 barrier。</p><p>在做这个测试时，我们适当增加一下线程程序的复杂性，让 barrier_sync_all 和 barrier_sync_partof 同时出现。</p></li><li><p>多个部分线程 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br></code></pre></td></tr></table></figure><p>这个用例看似和上边类似，但实则不同，实际实现时更复杂。比如两个 barrier 各自都等待 4 个线程，线程 0,1,2,3 在第一个 barrier 暂停，线程 4,5,6,7 会忽略第一个 barrier，而在第二个 barrier 等待。注意到，两个 barrier 指令实际使用了同一个 barrier ID，也就是同一个 barrier 资源。</p></li><li><p>生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">thread_produce:<br>barrier_with_produce<br><br>thread_consume:<br>barrier_with_consume<br></code></pre></td></tr></table></figure><p>生产者-消费者模型是一种常见的数据同步设计。一部分线程生产数据，并由另一部分线程消费数据。生产者线程在数据队列满的情况下会暂停生产，消费者线程在数据队列空的情况下会暂停消费，两者通过 barrier 的一种特殊设计来实现同步。</p><p>为了简化硬件细节，我们采用在 barrier 中增加一个计数器来近似硬件表现出的行为（实际硬件的实现可能大相径庭），生产者对计数器累加，而消费者对计数器累减。</p><p>插句题外话，硬件对这种设计的一个常见的应用场景是，硬件有时会让一个线程发射计算指令，但计算结果会交给所有线程去做后处理。</p></li><li><p>复杂的生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">thread_produce:<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_with_produce<br><br>thread_consume:<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_with_consume<br></code></pre></td></tr></table></figure><p>如果之前的 barrier 实现合理，这个混合了普通 barrier 和生产者-消费者 barrier 的程序流应该能够正常工作。而且我这里还需要做个假设，同一个 barrier ID 资源不能同时作为普通 barrier 和生产者-消费者 barrier，否则设计会复杂太多。</p></li></ol><p>以上这些应用场景在我提供的 demo 程序中都能够找到，我没有提供更复杂的测试用例，感觉应该都覆盖到了。</p><p>连续多次 barrier 指令的程序流，看似和一次 barrier 指令没区别，只是重复调用仿真指令就可以。但实际并非如此，两次甚至多次 barrier 之间的 barrier 状态有一些细节要处理，多次 barrier 如果使用相同的 barrier ID（同一个资源），需要考虑 barrier 之间的状态更新和重新初始化。另外，C++ 并发编程中，还需要严格留意临界区的处理，即使你能快速实现第一个 case 的仿真，但后边的 case 依然会引入很多复杂的设计。</p><p>如果你有时间，可以自己拿去玩一下，只留下 test.cpp，设计一个 Barrier 类，看看如何让这些用例都通过。</p><h2 id="程序设计介绍"><a href="#程序设计介绍" class="headerlink" title="程序设计介绍"></a>程序设计介绍</h2><p>我编写了一个 Barrier 类来实现 barrier 指令的所有细节，通过 barrier.h 来了解类结构。我这里对类中的数据成员做介绍：</p><ul><li><p>MutexLock 和 Cond，锁和条件变量，不展开，默认读者需要对它们的使用有充分的了解。</p></li><li><p>Expect，用来记录要同步的线程数量，对于 barrier_sync_all_threads 来说，就是所有线程，否则就是程序在指令中指定的线程数量。</p></li><li><p>Count，一个计数器，参与每一次 barrier 操作。不同线程的相同 PC 下的 barrier 被视为 “同一次” barrier 操作。彻底离开一次 barrier 操作后，这个计数器应该被清零。</p></li><li><p>Release，这个参数最初是没有的，而是为了解决复杂用例下的同步问题而引入，它在不同次 barrier 操作中都会累加，并且不会被清零，它用来弥补 Count 被清零时到下一次 barrier 操作之间的临界区。当然这样会带来累加溢出的问题，我们暂时先不考虑。</p></li><li><p>Actives 数组，用来支持 barrier_sync_partof_threads 的行为，当一次 barrier 操作已经满足全部线程后，其他延迟抵达的线程将会被忽略。为什么不使用 bool 来标记而是使用了 unsigned，感兴趣可以试一下，线程在连续多次 barrier 操作时，是没法处理一个二元状态的，比如第一次遇到 barrier 操作时将 false 改为 true，紧接着第二次遇到 barrier，true 的状态会让他继续 ignore barrier，这是我们不想看到的行为。</p></li></ul><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>完成对总线程数（Expect）和其他一些辅助成员的初始化。</p><h4 id="public-function"><a href="#public-function" class="headerlink" title="public function"></a>public function</h4><p>handleBarSync 用来执行一条普通 barrier，通过重载来区分 barrier_sync_all_threads 和 barrier_sync_partof_threads。前者通过 Barrier 对象来获取总线程数，后者会传入额外一个参数指定要 sync 的线程数量。</p><p>普通 barrier 指令的行为也就是 wait 行为，内部通过同步变量来实现 wait 和 awake。参数 PC 指出 barrier 指令在指令流中的位置；参数 TID 用来指定线程 ID，硬件指令中不需要作为操作数，但仿真时是必需的；参数 Expect 用于在实现 barrier_sync_partof_threads 时指定要 sync 的线程数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Barrier::handleBarSync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> &#123;<br>    wait(this-&gt;Expect, PC, TID);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Barrier::handleBarSync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> &#123;<br>    wait(Expect, PC, TID);<br>&#125;<br></code></pre></td></tr></table></figure><p>handleBarProduce 和 handleBarConsume 用来执行一条生产者或消费者 barrier，内部调用了对应的私有函数。</p><p>生产者 barrier 的指令只需要指定 Expect 和 PC，原因是我的模型中假设了只有一个线程作为生产者，如果你的场景中需要多个生产者，我想这个 Demo 还需要调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::handleBarProduce</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC)</span> </span>&#123;<br>    <span class="hljs-built_in">produce</span>(Expect, PC);<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者 barrier 的指令不需要 Expect，是因为我的模型中假设所有线程（除了生产者线程）都将作为消费者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::handleBarConsume</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-built_in">consume</span>(PC, TID);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="private-function"><a href="#private-function" class="headerlink" title="private function"></a>private function</h4><p>私有函数 wait、produce 和 consume 是关键代码。</p><p>wait 函数用来实现普通的 barrier 行为，一个不考虑各种复杂场景下的最简单实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::wait</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    Count++;<br>    <span class="hljs-keyword">if</span> (Count == Expect) &#123;<br>        Count = <span class="hljs-number">0</span>;<br>        Cond.<span class="hljs-built_in">notify_all</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以停下来想想这样的设计会带来什么问题？</p><p>它能实现带有 barrier_sync_all_threads 指令的指令流。但不能实现带有 barrier_sync_partof_threads 的指令流。我可以举个例子来说明，假设共 8 个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(4)   # wait 4 threads<br></code></pre></td></tr></table></figure><p>当其中第 4 个线程的 barrier wait 进入 if 分支后，前 3 个线程在 else 分支中做 Cond.wait，第 4 个线程清零 Count 并会 awake 前 3 个线程。后边 4 个线程会再次进入 Count++ 行为。</p><p>直觉性的，我们需要在前边加个判断，判断当前这一次 barrier 操作已结束（后边的线程不要再处理）。如果复用 Count 来做判断，很容易就会发现，代码难以设计，Count 既需要清 0，又需要作为判断后续线程状态的值而不能及时清 0。</p><p>如果在最后一个线程再清 0 也不可行，原因是在程序流中存在多条 barrier_sync_partof_threads 时（如用例 4），先前释放的线程（前 4 个线程）进入了第二个（相同 barrier 资源）的 barrier handle，它们也需要操作 Counter，与第一个 barrier 还没跑完的线程（后 4 个线程）争夺 Counter 的访问权。</p><p>我们需要一个额外的状态位，这个状态位不能在两次 barrier 操作之间清零（否则就和 Counter 遇到一样的问题），所以我加入了 Release。我们也不能交替使用两个状态（Counter 和 Release），因为我们无法预测指令流中不同的线程会同时执行到几个 barrier 指令（现在例子中是 2 个，但完全可以更多）。</p><p>我们还需要一个标记某个线程是否已经到达一次 barrier 操作，使用 “线程没有达到 barrier 操作” 并且 ”barrier 操作已完成“ 的条件来决定哪些线程需要跳过 barrier 操作。前边已经解释了为什么这个标记（Actives）需要是和 Release 一样的 unsigned 类型，而不是 bool，这里不再重复。</p><p>Release 变量会在每次 barrier 操作完成时累加一次；Actives 中对应线程的位置会在每次 barrier 操作时累加一次，所以两者是同步的。barrier 操作没完成时，Release 和未执行的线程 Actives 是相同的，barrier 操作完成后，Release 累加一次，已执行的线程 Actives 累加一次，未执行的线程 Actives 和 Release 进行比较，就可以判断当前线程是否要 ignore barrier。</p><p>修改后的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::wait</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    <span class="hljs-keyword">if</span> (Actives[TID] != Release) &#123;<br>        Actives[TID]++;<br>        <span class="hljs-keyword">return</span>;    <span class="hljs-meta"># ignore barrier</span><br>    &#125;<br>    Count++;<br>    Actives[TID]++;<br>    <span class="hljs-keyword">if</span> (Count == Expect) &#123;<br>        Count = <span class="hljs-number">0</span>;<br>        Release++;<br>        Cond.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-meta"># threads all arrived</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);  <span class="hljs-meta"># part of threads arrive</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看看另外两个函数，produce 和 consume。相比于 wait，这两个函数的实现却显得简单多了。作为 produce 的 barrier，并不会有额外行为，它唯一做的事情就是通知 consume barrier 可以 continue 了，而 consume barrier，只需要 wait 等待 produce 通知即可，这与 C++ 的条件变量的等待-唤醒模型基本吻合。</p><p>produce 的实现可以直接写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::produce</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    Count = Expect;<br>    Cond.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>produce 需要明确有几个 consumer 来处理数据，所以这里需要每次都设定 Counter。</p><p>consume 的实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::consume</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    <span class="hljs-keyword">if</span> (Count != <span class="hljs-number">0</span>) &#123;<br>        Count--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同于 wait 函数，consume 需要对 Counter 做递减，因为 produce 时给它设置了正数的非零值，每个 consume 需要减掉属于自己的那一位。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多的代码细节可以参考我提交的 demo，我要阐述的细节已经完毕。</p><p>这个话题来源于我工作中的一部分，我已经剔除了和业务相关的部分，由于要贴近工作需要，所以一些场景设计可能并没有考虑到，从而目前的设计也可能没有很好的普适性。保存这块代码的一个目的，也是在将来能够有需要时，继续完善它。</p><p>在设计整个 demo 中，自己遇到了一些问题，也进一步夯实了有关 C++ 并发编程的知识。如果你熟悉 C++20，那么会很快发现这很类似 C++20 里边的 std::barrier 和 std::latch。事实上我在实现这套逻辑的过程中发现了，但由于我的项目没有依赖 C++20 开发，所以没办法直接使用现成的模型。另外，我也没有尝试去使用 boost::barrier，因为它的实现比较单一，而我实际业务场景中有很多需要定制的地方，索性自己实现一套。</p><p>如果你愿意参考一下标准实现，我认为是极好的，我 demo 中的 count 对应 boost 库实现中的 m_count，release 对应 m_generation。我也认为其中有很多值得优化的地方，欢迎交流，有空的时候，我会再看看 std::barrier 的实现。</p><p>另一方面，并发编程需要处理很多细节，一些极端的异常需要在非常苛刻的环境下才能复现，而且调试也非常困难，本文中列举的示例场景依然只是其中一部分。Demo 中的代码实现比文章中的要复杂一些，因为其中处理了一些并发的小问题，比如应对 wait 的虚假唤醒，感兴趣的朋友可以找网上其他资料了解，有很多文章介绍。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/703597874">https://zhuanlan.zhihu.com/p/703597874</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>barrier</tag>
      
      <tag>C++</tag>
      
      <tag>体系结构</tag>
      
      <tag>并发编程</tag>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么终端开发离不开 Tmux</title>
    <link href="/2023/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A6%BB%E4%B8%8D%E5%BC%80Tmux/"/>
    <url>/2023/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A6%BB%E4%B8%8D%E5%BC%80Tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>我在每天的软件开发工作中都离不开 tmux，它极大的提高了我的工作效率，我使用它优化我的工作流程，维护开发环境，并结合其他工具扩展软件开发的体验感。</p><p>如果你之前还没有听说过这个软件，我建议你花 20 分钟了解一下它。有非常多的程序员使用这个软件，尤其是需要连接到远程服务器进行开发的同学。但我发现目前中文网络上还很少有能系统的讲解 “为什么要使用 tmux” 的文章，大多数文章都是直接开门见山地罗列怎么配置 tmux，再拉个表格梳理难以记忆的快捷键清单。</p><p>在这篇文章中，我不会花大篇幅介绍怎么使用 tmux，而是告诉你为什么要用它，以及我自己实践很多年的使用技巧。</p><h2 id="三个-tmux-组件"><a href="#三个-tmux-组件" class="headerlink" title="三个 tmux 组件"></a>三个 tmux 组件</h2><p>在使用 tmux 之前，有三个重要的概念一定要了解，分别是 session，window 和 pane。简单介绍下。</p><ul><li>session 是会话，也就是和操作系统建立的一次通信状态，不过 tmux 中的 session 不同于直接用 shell 建立的 session，可以理解成一种虚拟 session；session 包含 window，默认启动 session 后会带有 1 个 window。</li><li>window 就是窗口，也就是展示在屏幕上能看到的全部内容，可以看做是窗口类软件的 tab；window 包含 pane，默认带有 1 个 pane。</li><li>pane 就是每一个分屏的窗格，tmux 允许对一个 window 做分屏，每个 “子屏“ 都叫做一个 pane。</li></ul><p>tmux 提供了各种快捷键来 create、rename、move、delete 这些组件，以及可以便捷的在这些组件之间切换。你可以任意使用这些组件搭建自己的工作环境。</p><h2 id="我的-tmux-工作流"><a href="#我的-tmux-工作流" class="headerlink" title="我的 tmux 工作流"></a>我的 tmux 工作流</h2><p>这里我介绍下我的环境，这是我工作中的一张截图：</p><p><img src="/img/20230623/img1.png" alt="Tmux工作截图"></p><p>tmux 体现在最下边一行，这一行叫做 tmux 状态栏。左下角是 当前聚焦的 session、window、pane 的 index，也就是光标所在的位置。这个单纯就是美观，实际工作中用处不大。</p><p>中间部分是当前 session 中所有 window 的 list，以及当前所在的 window。这个在切换 window 时可以参考。</p><p>右边只是一个日期和时间，用处也不是很大。</p><p>日常开发中，我的工作流是这样的：</p><ul><li>第一个窗口开发，第二个测试，第三个调试。可以随时开启临时窗口完成一些其他功能，用完后关闭。窗口之间切换使用 <code>shift + left</code> 和 <code>shift + right</code> ，操作和 window list 显示布局一致。非活跃窗口有消息时，状态栏会高亮提示。</li><li>每个窗口上的布局都不同，开发窗口左边用来编码，右边用来编译和 shell 操作。在编码时，会将左边 pane 全屏。pane 之间切换使用 <code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code> 和 <code>ctrl + l</code>，vim 癌晚期患者必备（vim 内部分屏切换也是这套按键，之后讲 vim 时我会提到怎么配置）。</li><li>以上所有布局都是同一个会话，这个会话用来做一件事情。当有其他更紧急的事情接手时，我会开启新的会话。经常有人找我验证一些其他问题，或者我手里同时有两三件事在推进，打工人都懂 😂。</li><li>下班后，直接关闭终端走人，第二天开终端后，我提前配好了 ssh 授信，所以可以自动连接并进入 tmux 环境。如果有多个 session，系统会询问我现在打算进入哪个 session。</li></ul><h2 id="最主要的功能点"><a href="#最主要的功能点" class="headerlink" title="最主要的功能点"></a>最主要的功能点</h2><p>那么，简单来说，tmux 有哪些很难被其他软件完美替代的功能呢？</p><ul><li><p>会话管理</p><p>  tmux 可以将会话和终端相分离。简单说就是我们使用终端运行任务，之后关闭终端或远程断开连接，都不影响任务的继续运行。这样我可以做到下班时断开 ssh 连接就好了，第二天上班建立 ssh 连接就可以恢复昨天的开发界面、窗口布局，以及查看昨晚编译和测试的结果。</p><p>  当程序员为了快速恢复环境而不关电脑，与公司为了省电要求下班关电脑之间产生冲突时，tmux 就是一个完美的解决方案 🐶。</p><p>  另外，你也不会希望遇到因为网络问题或电脑死机，导致 ssh 断连后，运行的程序和任务被 kill 掉的结果吧。</p><p>  另一个类似的软件是 screen，但 tmux 比 screen 要好用很多，建议使用 tmux。</p></li><li><p>分屏</p><p>  现在大多数终端软件都可以做到分屏，本地开发工作中， tmux 的分屏功能并不是必要的，甚至终端软件的分屏功能都不是必要的，完全可以使用 dwm 这种窗口管理器实现。</p><p>  但如果你是在远程服务器上开发，那么 tmux 的分屏还是很重要的，这意味着你不需要和服务器建立多个 ssh 连接。</p></li><li><p>自动化创建环境</p><p>  远程服务器并不常关机，所以启动 tmux 服务之后，一次配置好窗口布局和环境，可能很长时间都不需要再次配置了。</p><p>  但如果某一天你们 IT 突然发邮件说今晚 10 点停机维护，是不是就意味着我们的布局要重新配置了？</p><p>  其实不一定，tmux 的布局创建都是利用 tmux 指令来完成的，可以将创建布局的指令按类似 shell 脚本的原理配置好，每次需要配置时运行一次就好了。运行指令脚本需要 tmux 辅助工具，比如 tmuxp 来完成。</p></li><li><p>共享会话</p><p>  在远程开发工作中，我们可以将多个 host 端的终端连接到同一个 tmux session，这样可以实现一些需要多屏共享的需求。我自己不太用得到这个功能。</p></li></ul><h2 id="常用的几个命令"><a href="#常用的几个命令" class="headerlink" title="常用的几个命令"></a>常用的几个命令</h2><p>本着不给网络环境增加冗余信息的原则，怎么安装 tmux 我就不展开了。可以在这里了解：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>tmux 可以添加参数使用。以下是我常用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动新 session</span><br>tmux<br><br><span class="hljs-comment"># 查看 session list</span><br>tmux <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 接入 session</span><br>tmux attach -t &lt;session <span class="hljs-built_in">id</span>/name&gt;<br><br><span class="hljs-comment"># 关闭 session</span><br>tmux kill-session -t &lt;session-id/name&gt;<br><br><span class="hljs-comment"># 脱离 session</span><br>tmux detach<br><br><span class="hljs-comment"># 切换 session</span><br>tmux switch -t &lt;session-id/name&gt;<br><br><span class="hljs-comment"># 重命名 session</span><br>tmux rename-session -t &lt;session-id/name&gt; &lt;new-name&gt;<br></code></pre></td></tr></table></figure><h2 id="我的使用技巧"><a href="#我的使用技巧" class="headerlink" title="我的使用技巧"></a>我的使用技巧</h2><p>看到这里，想必我应该介绍清楚 tmux 为什么是终端开发必备软件了。</p><p>说它是神器，可能过誉了，但说它必不可少，这反而是大实话。不过，应该有很多小伙伴会在使用 tmux 时，被它复杂难懂的配置脚本和快捷键劝退。这部分内容，我会介绍一下我在使用 tmux 这些年，总结出来的一些经验和使用技巧，方便你再一次尝试这个软件，或者——如果你已经在用了——改进你的工作流。</p><h3 id="1-tmux-版本"><a href="#1-tmux-版本" class="headerlink" title="1 tmux 版本"></a>1 tmux 版本</h3><p>如果你刚刚使用 tmux，并且被配置脚本困扰，也许你会去网上搜搜别人是怎么配置的，然后拿过来后，却发现并不一定起作用，那么你可能需要考虑看看自己的 tmux 版本。</p><p>tmux 目前的最新版本是 3.3a，但很多 Linux 发行版中内置的 tmux 却是很久前的 2.6 甚至 2.2 版本。很遗憾，tmux 在版本更新过程中多次调整了它的配置接口，所以你参考的网上的配置和你自己使用的 tmux 版本可能不匹配。更悲剧的是，大多数人并没有意识到这个问题，所以他们在上传自己配置时，并不会说清这套配置的版本号。</p><p>我自己的 tmux 配置中写明了版本号，这应该是大家都去注意的，一个完善的配置文件，应该写清楚它适用的软件版本、运行说明、注意事项等。</p><p>使用 <code>tmux -V</code> 可以查看 tmux 版本。</p><h3 id="2-修改键位"><a href="#2-修改键位" class="headerlink" title="2 修改键位"></a>2 修改键位</h3><p>tmux 的默认键位是很反人类的，不但很难记得住，而且点击起来也很别扭。prefix 键，也就是 tmux 前缀键，本来其实就是两个键（默认的 <code>ctrl + b</code>），然而有些功能，却还需要 <code>shift</code> 键参与，比如 <code>prefix + %</code> ，看着像是两个键，实际上是四个键参与（<code>ctrl + b</code>, <code>shift + 5</code> ）。</p><p>每个人都会有自己的使用习惯，但大家能统一意见的始终是用 tmux 一定要改键。我的一些键位修改供参考：</p><ul><li>prefix 键：<code>ctrl + a</code></li><li>水平分屏：<code>prefix + -</code></li><li>垂直分屏：<code>prefix + \\</code></li><li>pane 之间移动：<code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code>，<code>ctrl + l</code></li><li>window 之间移动：<code>shift + left</code>，<code>shift + right</code> （就是左右方向键）</li></ul><p>还有几个常用的按键没有改键：</p><ul><li>创建 window：<code>prefix + c</code></li><li>重命名 window：<code>prefix + ,</code></li><li>将当前 pane 全屏：<code>prefix + z</code></li></ul><h3 id="3-复制粘贴"><a href="#3-复制粘贴" class="headerlink" title="3 复制粘贴"></a>3 复制粘贴</h3><p>这个问题应该是网络上和 tmux 相关的问题中，搜索次数最多的问题了。同样的，在不同版本的 tmux 中，解决这个问题的方案并不相同。在最新的 3.3a 版本中，我认为复制粘贴的功能已经比较好用了。</p><ul><li><p>第一种情况，在本机使用 tmux。</p><p>  tmux 原生支持的方案是：使用 <code>prefix + [</code> 进入选择模式，控制光标到一段文字的开头，<code>space</code> 开始选择，继续移动光标选中需要复制的内容，<code>enter</code> 确认复制，并自动退出选择模式。这时内容就会被复制到剪切板。<code>prefix + ]</code> 来粘贴。如果 tmux 配置开启了鼠标增强模式，还可以用鼠标选取内容，右键弹出菜单操作。</p><p>  如果你的终端能支持适配 tmux，那么直接用鼠标选取内容，内容就会自动复制到系统剪切板中，右键粘贴或弹出右键菜单粘贴，比如 mac 上使用 iterm2 可以做到。</p></li><li><p>第二种情况，通过远程终端连接使用 tmux。</p><p>  tmux 无法解析出你在 host 端选取的文字，也就无法把它复制到剪切板中，所以不能依赖鼠标选择。你依然可以使用的是 tmux 原生方案，因为 tmux 会将内容复制到服务器那边系统的剪切板，那么在终端中再粘贴也就没有问题了。</p><p>  但是，如果希望将内容复制到 host 这边，这种办法就行不通了。可行的办法是直接利用当前终端的复制粘贴功能，直接鼠标选择文本来复制和粘贴。如果开启了鼠标增强模式，那么 tmux 会接管鼠标选择功能，绕开它的办法是按住 <code>shift</code> 键的同时来选择复制和粘贴。当然，这种方法自动滚屏就失效了。</p><p>  还有一种我听说的方案，是利用其他软件专门同步远程服务器的剪切板和 host 机器的剪切板，Github 上有类似的项目，感兴趣可以了解一下。</p></li></ul><p>如果我说的这些还不能满足你的需要，可能你得自己再摸索摸索了，远程访问模式本来对复制粘贴就不友好，也许最不会产生心智负担的方案就是文件传输吧 😆。</p><p>我自己不常使用复制粘贴的功能，粘贴代码这种行为，往外边粘，公司安全部门不同意，往里边粘，公司法务部门不开心。如果是粘贴报错信息或者运行日志，可能提炼关键点更有利于解决问题。</p><h3 id="4-美化"><a href="#4-美化" class="headerlink" title="4 美化"></a>4 美化</h3><p>有关于状态栏的美化就不说了，网络上很多类似的帖子。</p><p>我说几个不常见的：</p><ul><li><p>tmux 和 neovim 配合实现不同 mode 下变化光标样式：</p><p>  在 .tmux.conf 中配置这个命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set-option -sa terminal-overrides &#x27;*:Ss=\\E[%p1%d q:Se=\\E[ q&#x27;<br></code></pre></td></tr></table></figure><p>  一定要注意一点，这个配置 是在 neovim 0.9 + zsh + tmux 3.3a 下才能生效。vim 需要配置一下也能实现相同的效果。你可能还需要考虑不同终端软件可能对光标样式做的主动更改。</p></li><li><p>斜体字体。如果终端能够显示斜体字，但打开 tmux 中却不显示，那么需要这么配置：</p><p>  在用户根目录下创建名为 <code>screen-256color.terminfo</code> 的文件，内容为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># A screen-256color based TERMINFO that adds the escape sequences for italic.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Install:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   tic screen-256color.terminfo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Usage:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   export TERM=screen-256color</span><br><span class="hljs-comment">#</span><br>screen-256color|screen with 256 colors and italic,<br>        sitm=\\E[3m, ritm=\\E[23m,<br>        use=screen-256color,<br></code></pre></td></tr></table></figure><p>  终端执行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tic screen-256color.terminfo<br></code></pre></td></tr></table></figure><p>  在 shell 脚本中配置这个环境变量并 source：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> TERM=screen-256color<br></code></pre></td></tr></table></figure><p>  在 .tmux.conf 中加入以下配置：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g default-terminal <span class="hljs-string">&quot;screen-256color&quot;</span><br></code></pre></td></tr></table></figure><p>  为了在 vim 中也能显示斜体字，还需要在 .vimrc 中加入以下配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vimrc">let &amp;t_ZH=&quot;\\e[3m&quot;<br>let &amp;t_ZR=&quot;\\e[23m&quot;<br><br># 或者如果是 neovim，在 init.lua 中加入：<br>vim.g.t_ZH = &quot;\\\\e[3m&quot;<br>vim.g.t_ZR = &quot;\\\\e[23m&quot;<br></code></pre></td></tr></table></figure></li><li><p>支持真彩色</p><p>  真彩色是 24 位颜色，比 256-color（8 位）更艳丽，对于很多插件，尤其是终端和 vim 中的色彩主题，开启真彩色会显示更好的视觉效果。</p><p>  首先需要你的终端支持真彩色，新一些的终端都支持，可以使用这个脚本验证：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fL &lt;https://raw.githubusercontent.com/Beavan/tools/master/sh/24-bit-color.sh&gt; |bash<br></code></pre></td></tr></table></figure><p>  如果显示的颜色条没有明显的色彩块边界，那么就是真彩色了。</p><p>  在 .tmux.conf 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set -g default-terminal &quot;screen-256color&quot;<br>set-option -ga terminal-overrides &quot;,*256col*:Tc&quot;<br></code></pre></td></tr></table></figure><p>  vim 中支持真彩色，还需要在 .vimrc 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set termguicolors<br><br># neovim 在 init.lua 中加入<br>vim.opt.termguicolors = true<br></code></pre></td></tr></table></figure></li><li><p>实现当前 pane 的背景突出显示。</p><p>  iterm2 有这么个效果，当分屏后，当前光标所在屏幕会正常显示，而其他屏幕会变灰。tmux 也可以实现这种效果。</p><p>  在 .tmux.conf 中添加这个配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set -g window-style &#x27;fg=grey62,bg=grey19&#x27;<br>set -g window-active-style &#x27;fg=terminal,bg=terminal&#x27;<br></code></pre></td></tr></table></figure><p>  颜色可以自己随意改，试了下是 256 color。效果不如 iterm2 好，但我感觉足够用了。</p></li><li><p>状态栏背景和终端样式保持一致。</p><p>  比如说我的终端是磨砂效果，我不想显示 tmux 的绿色大横条。那么可以配置 status bar 的 style：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tmux"># 在 3.2 及更新版本中<br>set-option -g status-style bg=default<br><br># 在较旧的版本中<br>set-option -g status-bg default<br></code></pre></td></tr></table></figure></li></ul><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这些内容零散的躺在我的笔记中很久了，终于有机会整理成文。</p><p>如果你之前没有使用过 tmux，看过这篇文章可能并不会帮你完全熟悉这个软件，任何软件的熟练使用都依赖于 “尝试” 和 “探索”。如果能吸引你 “入坑”， 或者其中有一些能值得你参考的内容，那我这篇文章就没白写。</p><p>有疑问和请求都可以给我留言，也请 feel free 指出文中的错误。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/639084118">https://zhuanlan.zhihu.com/p/639084118</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tmux</tag>
      
      <tag>终端开发</tag>
      
      <tag>Terminal</tag>
      
      <tag>软件工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
