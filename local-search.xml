<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>处理器 barrier 行为的仿真实现</title>
    <link href="/2024/06/16/%E5%A4%84%E7%90%86%E5%99%A8barrier%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/06/16/%E5%A4%84%E7%90%86%E5%99%A8barrier%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>由于编译器指令重排以及 CPU 乱序执行的问题，处理器指令有可能在多线程执行时遇到一些问题，比如数据竞争，死锁，非预期的计算结果等。为了避免这类潜在的问题，引入了 barrier 的概念。编译器会主动插入 barrier 指令来降低直接调整指令调度环节的复杂性，而硬件的非预期行为也只能通过软件强行做同步来避免。</p><p>在处理器架构领域，barrier 是一种同步行为，它通常是指令或者指令 modifier，用来对程序流进行同步控制。在多处理器或多线程处理器中，当不同的程序流遇到 barrier 时，会等待其他程序流同时到达这个同步点，然后再执行后边的程序。</p><p>这种方式确保了所有的线程或处理器能够在程序的同一个位置重新对齐。</p><p>在一些硬件上，这种行为通过指令实现，比如 intel 的 FENCE 指令，ARM 的 DMB&#x2F;DSB 指令。大多数 barrier 指令都带有对内存操作的同步，也就是在 barrier 之前的读写内存操作必须在 barrier 点完成，以达到内存访存有序的目的，这通常也被称为 memory fence。概念上讲，fence 是 barrier 的一个特例，也就是说 barrier 并不会要求必须实现 fence 的功能，当然这取决于具体硬件。</p><p>本文中，我将会介绍一种对 barrier 指令行为的软件仿真实现。出于简化实现的目的，程序中不会实现 memory fence，只会对程序指令流的同步行为做仿真，也就是 instruction barrier。</p><p>我也会对应用场景做简化，多线程程序和多处理器程序的 barrier 在程序表现上是一致的，不一致的是 barrier 的指令实现，文章和代码介绍多线程程序下的 barrier 仿真，两者之间很容易互通。</p><p>适合看这篇文章的人可能并不多，如果你想进一步了解 barrier 的概念，可以查找其他文章。阅读本文和 demo 程序需要对 C++ 多线程编程有足够的知识，且对汇编程序设计和并行处理器有一些了解。</p><p>我在网络上并没有找到介绍 barrier 仿真的中文资料，所以希望写此文和提供可参考的 demo 程序，帮助有需要的朋友。</p><p>Demo 程序放在：<a href="https://github.com/P2Tree/barrier/tree/master">P2Tree&#x2F;barrier: A simulate demo for barrier behaviour in compute architecture (github.com)</a>，可以直接取用，有问题请反馈我处理。</p><h2 id="设计用例场景"><a href="#设计用例场景" class="headerlink" title="设计用例场景"></a>设计用例场景</h2><p>一个良好的软件工程实践是先梳理需求和应用场景，并编写一些测试用例。我梳理了几种常见的 instruction barrier 的应用场景（以下用汇编伪码介绍），这些场景会作为 UT 出现在代码中：</p><ol><li><p>最普通的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">some_insts<br>barrier_sync_all_threads<br>some_insts<br></code></pre></td></tr></table></figure><p>多线程程序多以这种 sync 所有线程的方式调用 barrier，线程程序中没有分支和跳转指令，所以每个线程都会执行到相同的代码。但由于线程调度和指令 latency，barrier 前后的时间会不同。</p></li><li><p>程序中存在多个 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">some_insts<br>barrier_sync_all_threads_with_ID_0<br>some_insts<br>barrier_sync_all_threads_with_ID_1<br>some_insts<br></code></pre></td></tr></table></figure><p>硬件并不会只提供一个 barrier，程序的复杂性会要求同时使用多个不同的 barrier。不同的 barrier 的仿真实现可能带来复杂的同步问题。这里额外说一句，barrier 是一种硬件资源，线程程序需要考虑到不要超出资源限制。同一个 barrier 可以在程序的多个指令中被访问，但需要满足适当的用法，否则会出现程序异常、hangup 等问题。</p></li><li><p>只 wait 部分线程的 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_sync_all_threads<br>some_insts<br></code></pre></td></tr></table></figure><p>除了提供对所有线程做同步的 barrier 外，也可能存在对部分线程做同步的 barrier。可能会有两种形式，第一种形式并不关心要同步哪些线程，只关心同步了多少数量的线程；第二种形式关心同步指定线程 ID 的线程。两种形式看似不同，但在仿真实现上基本类似。Demo 中以第一种形式来实现。同步部分线程指令需要带有额外的操作数来指定同步多少线程（或同步哪些线程），超出同步数量的线程（或没有在指定范围内的线程）会直接忽略这个 barrier。</p><p>在做这个测试时，我们适当增加一下线程程序的复杂性，让 barrier_sync_all 和 barrier_sync_partof 同时出现。</p></li><li><p>多个部分线程 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br></code></pre></td></tr></table></figure><p>这个用例看似和上边类似，但实则不同，实际实现时更复杂。比如两个 barrier 各自都等待 4 个线程，线程 0,1,2,3 在第一个 barrier 暂停，线程 4,5,6,7 会忽略第一个 barrier，而在第二个 barrier 等待。注意到，两个 barrier 指令实际使用了同一个 barrier ID，也就是同一个 barrier 资源。</p></li><li><p>生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">thread_produce:<br>barrier_with_produce<br><br>thread_consume:<br>barrier_with_consume<br></code></pre></td></tr></table></figure><p>生产者-消费者模型是一种常见的数据同步设计。一部分线程生产数据，并由另一部分线程消费数据。生产者线程在数据队列满的情况下会暂停生产，消费者线程在数据队列空的情况下会暂停消费，两者通过 barrier 的一种特殊设计来实现同步。</p><p>为了简化硬件细节，我们采用在 barrier 中增加一个计数器来近似硬件表现出的行为（实际硬件的实现可能大相径庭），生产者对计数器累加，而消费者对计数器累减。</p><p>插句题外话，硬件对这种设计的一个常见的应用场景是，硬件有时会让一个线程发射计算指令，但计算结果会交给所有线程去做后处理。</p></li><li><p>复杂的生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">thread_produce:<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_with_produce<br><br>thread_consume:<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_with_consume<br></code></pre></td></tr></table></figure><p>如果之前的 barrier 实现合理，这个混合了普通 barrier 和生产者-消费者 barrier 的程序流应该能够正常工作。而且我这里还需要做个假设，同一个 barrier ID 资源不能同时作为普通 barrier 和生产者-消费者 barrier，否则设计会复杂太多。</p></li></ol><p>以上这些应用场景在我提供的 demo 程序中都能够找到，我没有提供更复杂的测试用例，感觉应该都覆盖到了。</p><p>连续多次 barrier 指令的程序流，看似和一次 barrier 指令没区别，只是重复调用仿真指令就可以。但实际并非如此，两次甚至多次 barrier 之间的 barrier 状态有一些细节要处理，多次 barrier 如果使用相同的 barrier ID（同一个资源），需要考虑 barrier 之间的状态更新和重新初始化。另外，C++ 并发编程中，还需要严格留意临界区的处理，即使你能快速实现第一个 case 的仿真，但后边的 case 依然会引入很多复杂的设计。</p><p>如果你有时间，可以自己拿去玩一下，只留下 test.cpp，设计一个 Barrier 类，看看如何让这些用例都通过。</p><h2 id="程序设计介绍"><a href="#程序设计介绍" class="headerlink" title="程序设计介绍"></a>程序设计介绍</h2><p>我编写了一个 Barrier 类来实现 barrier 指令的所有细节，通过 barrier.h 来了解类结构。我这里对类中的数据成员做介绍：</p><ul><li><p>MutexLock 和 Cond，锁和条件变量，不展开，默认读者需要对它们的使用有充分的了解。</p></li><li><p>Expect，用来记录要同步的线程数量，对于 barrier_sync_all_threads 来说，就是所有线程，否则就是程序在指令中指定的线程数量。</p></li><li><p>Count，一个计数器，参与每一次 barrier 操作。不同线程的相同 PC 下的 barrier 被视为 “同一次” barrier 操作。彻底离开一次 barrier 操作后，这个计数器应该被清零。</p></li><li><p>Release，这个参数最初是没有的，而是为了解决复杂用例下的同步问题而引入，它在不同次 barrier 操作中都会累加，并且不会被清零，它用来弥补 Count 被清零时到下一次 barrier 操作之间的临界区。当然这样会带来累加溢出的问题，我们暂时先不考虑。</p></li><li><p>Actives 数组，用来支持 barrier_sync_partof_threads 的行为，当一次 barrier 操作已经满足全部线程后，其他延迟抵达的线程将会被忽略。为什么不使用 bool 来标记而是使用了 unsigned，感兴趣可以试一下，线程在连续多次 barrier 操作时，是没法处理一个二元状态的，比如第一次遇到 barrier 操作时将 false 改为 true，紧接着第二次遇到 barrier，true 的状态会让他继续 ignore barrier，这是我们不想看到的行为。</p></li></ul><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>完成对总线程数（Expect）和其他一些辅助成员的初始化。</p><h4 id="public-function"><a href="#public-function" class="headerlink" title="public function"></a>public function</h4><p>handleBarSync 用来执行一条普通 barrier，通过重载来区分 barrier_sync_all_threads 和 barrier_sync_partof_threads。前者通过 Barrier 对象来获取总线程数，后者会传入额外一个参数指定要 sync 的线程数量。</p><p>普通 barrier 指令的行为也就是 wait 行为，内部通过同步变量来实现 wait 和 awake。参数 PC 指出 barrier 指令在指令流中的位置；参数 TID 用来指定线程 ID，硬件指令中不需要作为操作数，但仿真时是必需的；参数 Expect 用于在实现 barrier_sync_partof_threads 时指定要 sync 的线程数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Barrier::handleBarSync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> &#123;<br>    wait(this-&gt;Expect, PC, TID);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Barrier::handleBarSync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> &#123;<br>    wait(Expect, PC, TID);<br>&#125;<br></code></pre></td></tr></table></figure><p>handleBarProduce 和 handleBarConsume 用来执行一条生产者或消费者 barrier，内部调用了对应的私有函数。</p><p>生产者 barrier 的指令只需要指定 Expect 和 PC，原因是我的模型中假设了只有一个线程作为生产者，如果你的场景中需要多个生产者，我想这个 Demo 还需要调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::handleBarProduce</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC)</span> </span>&#123;<br>    <span class="hljs-built_in">produce</span>(Expect, PC);<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者 barrier 的指令不需要 Expect，是因为我的模型中假设所有线程（除了生产者线程）都将作为消费者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::handleBarConsume</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-built_in">consume</span>(PC, TID);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="private-function"><a href="#private-function" class="headerlink" title="private function"></a>private function</h4><p>私有函数 wait、produce 和 consume 是关键代码。</p><p>wait 函数用来实现普通的 barrier 行为，一个不考虑各种复杂场景下的最简单实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::wait</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    Count++;<br>    <span class="hljs-keyword">if</span> (Count == Expect) &#123;<br>        Count = <span class="hljs-number">0</span>;<br>        Cond.<span class="hljs-built_in">notify_all</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以停下来想想这样的设计会带来什么问题？</p><p>它能实现带有 barrier_sync_all_threads 指令的指令流。但不能实现带有 barrier_sync_partof_threads 的指令流。我可以举个例子来说明，假设共 8 个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(4)   # wait 4 threads<br></code></pre></td></tr></table></figure><p>当其中第 4 个线程的 barrier wait 进入 if 分支后，前 3 个线程在 else 分支中做 Cond.wait，第 4 个线程清零 Count 并会 awake 前 3 个线程。后边 4 个线程会再次进入 Count++ 行为。</p><p>直觉性的，我们需要在前边加个判断，判断当前这一次 barrier 操作已结束（后边的线程不要再处理）。如果复用 Count 来做判断，很容易就会发现，代码难以设计，Count 既需要清 0，又需要作为判断后续线程状态的值而不能及时清 0。</p><p>如果在最后一个线程再清 0 也不可行，原因是在程序流中存在多条 barrier_sync_partof_threads 时（如用例 4），先前释放的线程（前 4 个线程）进入了第二个（相同 barrier 资源）的 barrier handle，它们也需要操作 Counter，与第一个 barrier 还没跑完的线程（后 4 个线程）争夺 Counter 的访问权。</p><p>我们需要一个额外的状态位，这个状态位不能在两次 barrier 操作之间清零（否则就和 Counter 遇到一样的问题），所以我加入了 Release。我们也不能交替使用两个状态（Counter 和 Release），因为我们无法预测指令流中不同的线程会同时执行到几个 barrier 指令（现在例子中是 2 个，但完全可以更多）。</p><p>我们还需要一个标记某个线程是否已经到达一次 barrier 操作，使用 “线程没有达到 barrier 操作” 并且 ”barrier 操作已完成“ 的条件来决定哪些线程需要跳过 barrier 操作。前边已经解释了为什么这个标记（Actives）需要是和 Release 一样的 unsigned 类型，而不是 bool，这里不再重复。</p><p>Release 变量会在每次 barrier 操作完成时累加一次；Actives 中对应线程的位置会在每次 barrier 操作时累加一次，所以两者是同步的。barrier 操作没完成时，Release 和未执行的线程 Actives 是相同的，barrier 操作完成后，Release 累加一次，已执行的线程 Actives 累加一次，未执行的线程 Actives 和 Release 进行比较，就可以判断当前线程是否要 ignore barrier。</p><p>修改后的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::wait</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    <span class="hljs-keyword">if</span> (Actives[TID] != Release) &#123;<br>        Actives[TID]++;<br>        <span class="hljs-keyword">return</span>;    <span class="hljs-meta"># ignore barrier</span><br>    &#125;<br>    Count++;<br>    Actives[TID]++;<br>    <span class="hljs-keyword">if</span> (Count == Expect) &#123;<br>        Count = <span class="hljs-number">0</span>;<br>        Release++;<br>        Cond.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-meta"># threads all arrived</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);  <span class="hljs-meta"># part of threads arrive</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看看另外两个函数，produce 和 consume。相比于 wait，这两个函数的实现却显得简单多了。作为 produce 的 barrier，并不会有额外行为，它唯一做的事情就是通知 consume barrier 可以 continue 了，而 consume barrier，只需要 wait 等待 produce 通知即可，这与 C++ 的条件变量的等待-唤醒模型基本吻合。</p><p>produce 的实现可以直接写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::produce</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    Count = Expect;<br>    Cond.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>produce 需要明确有几个 consumer 来处理数据，所以这里需要每次都设定 Counter。</p><p>consume 的实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::consume</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    <span class="hljs-keyword">if</span> (Count != <span class="hljs-number">0</span>) &#123;<br>        Count--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同于 wait 函数，consume 需要对 Counter 做递减，因为 produce 时给它设置了正数的非零值，每个 consume 需要减掉属于自己的那一位。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多的代码细节可以参考我提交的 demo，我要阐述的细节已经完毕。</p><p>这个话题来源于我工作中的一部分，我已经剔除了和业务相关的部分，由于要贴近工作需要，所以一些场景设计可能并没有考虑到，从而目前的设计也可能没有很好的普适性。保存这块代码的一个目的，也是在将来能够有需要时，继续完善它。</p><p>在设计整个 demo 中，自己遇到了一些问题，也进一步夯实了有关 C++ 并发编程的知识。如果你熟悉 C++20，那么会很快发现这很类似 C++20 里边的 std::barrier 和 std::latch。事实上我在实现这套逻辑的过程中发现了，但由于我的项目没有依赖 C++20 开发，所以没办法直接使用现成的模型。另外，我也没有尝试去使用 boost::barrier，因为它的实现比较单一，而我实际业务场景中有很多需要定制的地方，索性自己实现一套。</p><p>如果你愿意参考一下标准实现，我认为是极好的，我 demo 中的 count 对应 boost 库实现中的 m_count，release 对应 m_generation。我也认为其中有很多值得优化的地方，欢迎交流，有空的时候，我会再看看 std::barrier 的实现。</p><p>另一方面，并发编程需要处理很多细节，一些极端的异常需要在非常苛刻的环境下才能复现，而且调试也非常困难，本文中列举的示例场景依然只是其中一部分。Demo 中的代码实现比文章中的要复杂一些，因为其中处理了一些并发的小问题，比如应对 wait 的虚假唤醒，感兴趣的朋友可以找网上其他资料了解，有很多文章介绍。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/703597874">https://zhuanlan.zhihu.com/p/703597874</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>barrier</tag>
      
      <tag>C++</tag>
      
      <tag>体系结构</tag>
      
      <tag>并发编程</tag>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么终端开发离不开 Tmux</title>
    <link href="/2023/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A6%BB%E4%B8%8D%E5%BC%80Tmux/"/>
    <url>/2023/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A6%BB%E4%B8%8D%E5%BC%80Tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>我在每天的软件开发工作中都离不开 tmux，它极大的提高了我的工作效率，我使用它优化我的工作流程，维护开发环境，并结合其他工具扩展软件开发的体验感。</p><p>如果你之前还没有听说过这个软件，我建议你花 20 分钟了解一下它。有非常多的程序员使用这个软件，尤其是需要连接到远程服务器进行开发的同学。但我发现目前中文网络上还很少有能系统的讲解 “为什么要使用 tmux” 的文章，大多数文章都是直接开门见山地罗列怎么配置 tmux，再拉个表格梳理难以记忆的快捷键清单。</p><p>在这篇文章中，我不会花大篇幅介绍怎么使用 tmux，而是告诉你为什么要用它，以及我自己实践很多年的使用技巧。</p><h2 id="三个-tmux-组件"><a href="#三个-tmux-组件" class="headerlink" title="三个 tmux 组件"></a>三个 tmux 组件</h2><p>在使用 tmux 之前，有三个重要的概念一定要了解，分别是 session，window 和 pane。简单介绍下。</p><ul><li>session 是会话，也就是和操作系统建立的一次通信状态，不过 tmux 中的 session 不同于直接用 shell 建立的 session，可以理解成一种虚拟 session；session 包含 window，默认启动 session 后会带有 1 个 window。</li><li>window 就是窗口，也就是展示在屏幕上能看到的全部内容，可以看做是窗口类软件的 tab；window 包含 pane，默认带有 1 个 pane。</li><li>pane 就是每一个分屏的窗格，tmux 允许对一个 window 做分屏，每个 “子屏“ 都叫做一个 pane。</li></ul><p>tmux 提供了各种快捷键来 create、rename、move、delete 这些组件，以及可以便捷的在这些组件之间切换。你可以任意使用这些组件搭建自己的工作环境。</p><h2 id="我的-tmux-工作流"><a href="#我的-tmux-工作流" class="headerlink" title="我的 tmux 工作流"></a>我的 tmux 工作流</h2><p>这里我介绍下我的环境，这是我工作中的一张截图：</p><p><img src="/img/20230623/img1.png" alt="Tmux工作截图"></p><p>tmux 体现在最下边一行，这一行叫做 tmux 状态栏。左下角是 当前聚焦的 session、window、pane 的 index，也就是光标所在的位置。这个单纯就是美观，实际工作中用处不大。</p><p>中间部分是当前 session 中所有 window 的 list，以及当前所在的 window。这个在切换 window 时可以参考。</p><p>右边只是一个日期和时间，用处也不是很大。</p><p>日常开发中，我的工作流是这样的：</p><ul><li>第一个窗口开发，第二个测试，第三个调试。可以随时开启临时窗口完成一些其他功能，用完后关闭。窗口之间切换使用 <code>shift + left</code> 和 <code>shift + right</code> ，操作和 window list 显示布局一致。非活跃窗口有消息时，状态栏会高亮提示。</li><li>每个窗口上的布局都不同，开发窗口左边用来编码，右边用来编译和 shell 操作。在编码时，会将左边 pane 全屏。pane 之间切换使用 <code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code> 和 <code>ctrl + l</code>，vim 癌晚期患者必备（vim 内部分屏切换也是这套按键，之后讲 vim 时我会提到怎么配置）。</li><li>以上所有布局都是同一个会话，这个会话用来做一件事情。当有其他更紧急的事情接手时，我会开启新的会话。经常有人找我验证一些其他问题，或者我手里同时有两三件事在推进，打工人都懂 😂。</li><li>下班后，直接关闭终端走人，第二天开终端后，我提前配好了 ssh 授信，所以可以自动连接并进入 tmux 环境。如果有多个 session，系统会询问我现在打算进入哪个 session。</li></ul><h2 id="最主要的功能点"><a href="#最主要的功能点" class="headerlink" title="最主要的功能点"></a>最主要的功能点</h2><p>那么，简单来说，tmux 有哪些很难被其他软件完美替代的功能呢？</p><ul><li><p>会话管理</p><p>  tmux 可以将会话和终端相分离。简单说就是我们使用终端运行任务，之后关闭终端或远程断开连接，都不影响任务的继续运行。这样我可以做到下班时断开 ssh 连接就好了，第二天上班建立 ssh 连接就可以恢复昨天的开发界面、窗口布局，以及查看昨晚编译和测试的结果。</p><p>  当程序员为了快速恢复环境而不关电脑，与公司为了省电要求下班关电脑之间产生冲突时，tmux 就是一个完美的解决方案 🐶。</p><p>  另外，你也不会希望遇到因为网络问题或电脑死机，导致 ssh 断连后，运行的程序和任务被 kill 掉的结果吧。</p><p>  另一个类似的软件是 screen，但 tmux 比 screen 要好用很多，建议使用 tmux。</p></li><li><p>分屏</p><p>  现在大多数终端软件都可以做到分屏，本地开发工作中， tmux 的分屏功能并不是必要的，甚至终端软件的分屏功能都不是必要的，完全可以使用 dwm 这种窗口管理器实现。</p><p>  但如果你是在远程服务器上开发，那么 tmux 的分屏还是很重要的，这意味着你不需要和服务器建立多个 ssh 连接。</p></li><li><p>自动化创建环境</p><p>  远程服务器并不常关机，所以启动 tmux 服务之后，一次配置好窗口布局和环境，可能很长时间都不需要再次配置了。</p><p>  但如果某一天你们 IT 突然发邮件说今晚 10 点停机维护，是不是就意味着我们的布局要重新配置了？</p><p>  其实不一定，tmux 的布局创建都是利用 tmux 指令来完成的，可以将创建布局的指令按类似 shell 脚本的原理配置好，每次需要配置时运行一次就好了。运行指令脚本需要 tmux 辅助工具，比如 tmuxp 来完成。</p></li><li><p>共享会话</p><p>  在远程开发工作中，我们可以将多个 host 端的终端连接到同一个 tmux session，这样可以实现一些需要多屏共享的需求。我自己不太用得到这个功能。</p></li></ul><h2 id="常用的几个命令"><a href="#常用的几个命令" class="headerlink" title="常用的几个命令"></a>常用的几个命令</h2><p>本着不给网络环境增加冗余信息的原则，怎么安装 tmux 我就不展开了。可以在这里了解：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>tmux 可以添加参数使用。以下是我常用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动新 session</span><br>tmux<br><br><span class="hljs-comment"># 查看 session list</span><br>tmux <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 接入 session</span><br>tmux attach -t &lt;session <span class="hljs-built_in">id</span>/name&gt;<br><br><span class="hljs-comment"># 关闭 session</span><br>tmux kill-session -t &lt;session-id/name&gt;<br><br><span class="hljs-comment"># 脱离 session</span><br>tmux detach<br><br><span class="hljs-comment"># 切换 session</span><br>tmux switch -t &lt;session-id/name&gt;<br><br><span class="hljs-comment"># 重命名 session</span><br>tmux rename-session -t &lt;session-id/name&gt; &lt;new-name&gt;<br></code></pre></td></tr></table></figure><h2 id="我的使用技巧"><a href="#我的使用技巧" class="headerlink" title="我的使用技巧"></a>我的使用技巧</h2><p>看到这里，想必我应该介绍清楚 tmux 为什么是终端开发必备软件了。</p><p>说它是神器，可能过誉了，但说它必不可少，这反而是大实话。不过，应该有很多小伙伴会在使用 tmux 时，被它复杂难懂的配置脚本和快捷键劝退。这部分内容，我会介绍一下我在使用 tmux 这些年，总结出来的一些经验和使用技巧，方便你再一次尝试这个软件，或者——如果你已经在用了——改进你的工作流。</p><h3 id="1-tmux-版本"><a href="#1-tmux-版本" class="headerlink" title="1 tmux 版本"></a>1 tmux 版本</h3><p>如果你刚刚使用 tmux，并且被配置脚本困扰，也许你会去网上搜搜别人是怎么配置的，然后拿过来后，却发现并不一定起作用，那么你可能需要考虑看看自己的 tmux 版本。</p><p>tmux 目前的最新版本是 3.3a，但很多 Linux 发行版中内置的 tmux 却是很久前的 2.6 甚至 2.2 版本。很遗憾，tmux 在版本更新过程中多次调整了它的配置接口，所以你参考的网上的配置和你自己使用的 tmux 版本可能不匹配。更悲剧的是，大多数人并没有意识到这个问题，所以他们在上传自己配置时，并不会说清这套配置的版本号。</p><p>我自己的 tmux 配置中写明了版本号，这应该是大家都去注意的，一个完善的配置文件，应该写清楚它适用的软件版本、运行说明、注意事项等。</p><p>使用 <code>tmux -V</code> 可以查看 tmux 版本。</p><h3 id="2-修改键位"><a href="#2-修改键位" class="headerlink" title="2 修改键位"></a>2 修改键位</h3><p>tmux 的默认键位是很反人类的，不但很难记得住，而且点击起来也很别扭。prefix 键，也就是 tmux 前缀键，本来其实就是两个键（默认的 <code>ctrl + b</code>），然而有些功能，却还需要 <code>shift</code> 键参与，比如 <code>prefix + %</code> ，看着像是两个键，实际上是四个键参与（<code>ctrl + b</code>, <code>shift + 5</code> ）。</p><p>每个人都会有自己的使用习惯，但大家能统一意见的始终是用 tmux 一定要改键。我的一些键位修改供参考：</p><ul><li>prefix 键：<code>ctrl + a</code></li><li>水平分屏：<code>prefix + -</code></li><li>垂直分屏：<code>prefix + \\</code></li><li>pane 之间移动：<code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code>，<code>ctrl + l</code></li><li>window 之间移动：<code>shift + left</code>，<code>shift + right</code> （就是左右方向键）</li></ul><p>还有几个常用的按键没有改键：</p><ul><li>创建 window：<code>prefix + c</code></li><li>重命名 window：<code>prefix + ,</code></li><li>将当前 pane 全屏：<code>prefix + z</code></li></ul><h3 id="3-复制粘贴"><a href="#3-复制粘贴" class="headerlink" title="3 复制粘贴"></a>3 复制粘贴</h3><p>这个问题应该是网络上和 tmux 相关的问题中，搜索次数最多的问题了。同样的，在不同版本的 tmux 中，解决这个问题的方案并不相同。在最新的 3.3a 版本中，我认为复制粘贴的功能已经比较好用了。</p><ul><li><p>第一种情况，在本机使用 tmux。</p><p>  tmux 原生支持的方案是：使用 <code>prefix + [</code> 进入选择模式，控制光标到一段文字的开头，<code>space</code> 开始选择，继续移动光标选中需要复制的内容，<code>enter</code> 确认复制，并自动退出选择模式。这时内容就会被复制到剪切板。<code>prefix + ]</code> 来粘贴。如果 tmux 配置开启了鼠标增强模式，还可以用鼠标选取内容，右键弹出菜单操作。</p><p>  如果你的终端能支持适配 tmux，那么直接用鼠标选取内容，内容就会自动复制到系统剪切板中，右键粘贴或弹出右键菜单粘贴，比如 mac 上使用 iterm2 可以做到。</p></li><li><p>第二种情况，通过远程终端连接使用 tmux。</p><p>  tmux 无法解析出你在 host 端选取的文字，也就无法把它复制到剪切板中，所以不能依赖鼠标选择。你依然可以使用的是 tmux 原生方案，因为 tmux 会将内容复制到服务器那边系统的剪切板，那么在终端中再粘贴也就没有问题了。</p><p>  但是，如果希望将内容复制到 host 这边，这种办法就行不通了。可行的办法是直接利用当前终端的复制粘贴功能，直接鼠标选择文本来复制和粘贴。如果开启了鼠标增强模式，那么 tmux 会接管鼠标选择功能，绕开它的办法是按住 <code>shift</code> 键的同时来选择复制和粘贴。当然，这种方法自动滚屏就失效了。</p><p>  还有一种我听说的方案，是利用其他软件专门同步远程服务器的剪切板和 host 机器的剪切板，Github 上有类似的项目，感兴趣可以了解一下。</p></li></ul><p>如果我说的这些还不能满足你的需要，可能你得自己再摸索摸索了，远程访问模式本来对复制粘贴就不友好，也许最不会产生心智负担的方案就是文件传输吧 😆。</p><p>我自己不常使用复制粘贴的功能，粘贴代码这种行为，往外边粘，公司安全部门不同意，往里边粘，公司法务部门不开心。如果是粘贴报错信息或者运行日志，可能提炼关键点更有利于解决问题。</p><h3 id="4-美化"><a href="#4-美化" class="headerlink" title="4 美化"></a>4 美化</h3><p>有关于状态栏的美化就不说了，网络上很多类似的帖子。</p><p>我说几个不常见的：</p><ul><li><p>tmux 和 neovim 配合实现不同 mode 下变化光标样式：</p><p>  在 .tmux.conf 中配置这个命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set-option -sa terminal-overrides &#x27;*:Ss=\\E[%p1%d q:Se=\\E[ q&#x27;<br></code></pre></td></tr></table></figure><p>  一定要注意一点，这个配置 是在 neovim 0.9 + zsh + tmux 3.3a 下才能生效。vim 需要配置一下也能实现相同的效果。你可能还需要考虑不同终端软件可能对光标样式做的主动更改。</p></li><li><p>斜体字体。如果终端能够显示斜体字，但打开 tmux 中却不显示，那么需要这么配置：</p><p>  在用户根目录下创建名为 <code>screen-256color.terminfo</code> 的文件，内容为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># A screen-256color based TERMINFO that adds the escape sequences for italic.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Install:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   tic screen-256color.terminfo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Usage:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   export TERM=screen-256color</span><br><span class="hljs-comment">#</span><br>screen-256color|screen with 256 colors and italic,<br>        sitm=\\E[3m, ritm=\\E[23m,<br>        use=screen-256color,<br></code></pre></td></tr></table></figure><p>  终端执行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tic screen-256color.terminfo<br></code></pre></td></tr></table></figure><p>  在 shell 脚本中配置这个环境变量并 source：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> TERM=screen-256color<br></code></pre></td></tr></table></figure><p>  在 .tmux.conf 中加入以下配置：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g default-terminal <span class="hljs-string">&quot;screen-256color&quot;</span><br></code></pre></td></tr></table></figure><p>  为了在 vim 中也能显示斜体字，还需要在 .vimrc 中加入以下配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vimrc">let &amp;t_ZH=&quot;\\e[3m&quot;<br>let &amp;t_ZR=&quot;\\e[23m&quot;<br><br># 或者如果是 neovim，在 init.lua 中加入：<br>vim.g.t_ZH = &quot;\\\\e[3m&quot;<br>vim.g.t_ZR = &quot;\\\\e[23m&quot;<br></code></pre></td></tr></table></figure></li><li><p>支持真彩色</p><p>  真彩色是 24 位颜色，比 256-color（8 位）更艳丽，对于很多插件，尤其是终端和 vim 中的色彩主题，开启真彩色会显示更好的视觉效果。</p><p>  首先需要你的终端支持真彩色，新一些的终端都支持，可以使用这个脚本验证：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fL &lt;https://raw.githubusercontent.com/Beavan/tools/master/sh/24-bit-color.sh&gt; |bash<br></code></pre></td></tr></table></figure><p>  如果显示的颜色条没有明显的色彩块边界，那么就是真彩色了。</p><p>  在 .tmux.conf 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set -g default-terminal &quot;screen-256color&quot;<br>set-option -ga terminal-overrides &quot;,*256col*:Tc&quot;<br></code></pre></td></tr></table></figure><p>  vim 中支持真彩色，还需要在 .vimrc 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set termguicolors<br><br># neovim 在 init.lua 中加入<br>vim.opt.termguicolors = true<br></code></pre></td></tr></table></figure></li><li><p>实现当前 pane 的背景突出显示。</p><p>  iterm2 有这么个效果，当分屏后，当前光标所在屏幕会正常显示，而其他屏幕会变灰。tmux 也可以实现这种效果。</p><p>  在 .tmux.conf 中添加这个配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set -g window-style &#x27;fg=grey62,bg=grey19&#x27;<br>set -g window-active-style &#x27;fg=terminal,bg=terminal&#x27;<br></code></pre></td></tr></table></figure><p>  颜色可以自己随意改，试了下是 256 color。效果不如 iterm2 好，但我感觉足够用了。</p></li><li><p>状态栏背景和终端样式保持一致。</p><p>  比如说我的终端是磨砂效果，我不想显示 tmux 的绿色大横条。那么可以配置 status bar 的 style：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tmux"># 在 3.2 及更新版本中<br>set-option -g status-style bg=default<br><br># 在较旧的版本中<br>set-option -g status-bg default<br></code></pre></td></tr></table></figure></li></ul><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这些内容零散的躺在我的笔记中很久了，终于有机会整理成文。</p><p>如果你之前没有使用过 tmux，看过这篇文章可能并不会帮你完全熟悉这个软件，任何软件的熟练使用都依赖于 “尝试” 和 “探索”。如果能吸引你 “入坑”， 或者其中有一些能值得你参考的内容，那我这篇文章就没白写。</p><p>有疑问和请求都可以给我留言，也请 feel free 指出文中的错误。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/639084118">https://zhuanlan.zhihu.com/p/639084118</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tmux</tag>
      
      <tag>终端开发</tag>
      
      <tag>Terminal</tag>
      
      <tag>软件工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
