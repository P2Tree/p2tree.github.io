<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在飞逝的时光中，他们让未来有所期待</title>
    <link href="/2024/07/13/%E5%9C%A8%E9%A3%9E%E9%80%9D%E7%9A%84%E6%97%B6%E5%85%89%E4%B8%AD%EF%BC%8C%E4%BB%96%E4%BB%AC%E8%AE%A9%E6%9C%AA%E6%9D%A5%E6%9C%89%E6%89%80%E6%9C%9F%E5%BE%85/"/>
    <url>/2024/07/13/%E5%9C%A8%E9%A3%9E%E9%80%9D%E7%9A%84%E6%97%B6%E5%85%89%E4%B8%AD%EF%BC%8C%E4%BB%96%E4%BB%AC%E8%AE%A9%E6%9C%AA%E6%9D%A5%E6%9C%89%E6%89%80%E6%9C%9F%E5%BE%85/</url>
    
    <content type="html"><![CDATA[<p>在人的三四十岁时，某个瞬间，你可能会惊讶的发现：生命中那些最灿烂的时刻，似乎都已成为了过去，而眼前所剩下的，无非是日复一日的重复与不可避免的衰老。岁月如梭，时间悄然流逝。</p><p>然而，孩子的出现，却能打破这个对未来的枷锁，为生活注入新的活力与未知。他们带来烦恼，也带来牵挂；他们让你欢喜，也让你惊讶。</p><p>孩子让你重温童年的纯真，让你理解当年父母的心情，让你有机会去拥有那些曾经渴望却未曾得到的玩具。在痛苦与挑战面前，孩子让你变得更加坚强和冷静，让你看到童年时的自己，看到他的勇敢、好奇、不安与局促，从而更加深刻地理解并接纳自己。</p><p>父母养育了孩子，而孩子也以他们独特的方式陪伴着父母。在这个过程中，父母与孩子相互滋养，相互成就。在飞逝的时光中，他们让未来有所期待。</p>]]></content>
    
    
    <categories>
      
      <category>语录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>育儿</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扑克昆特牌玩法设计</title>
    <link href="/2024/06/19/%E6%89%91%E5%85%8B%E6%98%86%E7%89%B9%E7%89%8C%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/06/19/%E6%89%91%E5%85%8B%E6%98%86%E7%89%B9%E7%89%8C%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>这篇文章中，我将会介绍如何用扑克牌（一定程度上）复刻传统昆特牌游戏的玩法。其中会涉及到分析昆特牌游戏为什么如此受玩家欢迎的原因，《巫师 3：狂猎》又被称为 “昆特 3” 是有一定道理的 🐶</p><p>通过使用扑克牌复刻昆特牌游戏玩法，可以把昆特牌搬到线下和朋友一起玩，之所以不购买或自制现成的昆特牌桌游套件，是因为扑克牌更容易拿到，而且扑克牌玩昆特牌绕开了一些不重要而且浪费时间的话题讨论中（比如希瑞雅的战力应该给多少）。</p><p>在设计这套玩法之前，我玩了很久的昆特牌及其衍生作品，也研究了昆特牌模组的改进，吸取了其他网友的一些灵感。如果你对这个话题感兴趣，欢迎，我的朋友 👏</p><h2 id="昆特牌介绍"><a href="#昆特牌介绍" class="headerlink" title="昆特牌介绍"></a>昆特牌介绍</h2><p>本文所提到的昆特牌为《巫师 3：狂猎》游戏中的小游戏，也被称为 ”传统昆特牌“，并不是 CDPR 后续出的《巫师之昆特牌》与另外两款单机昆特牌游戏。</p><p>本文不会啰啰嗦嗦的介绍所有关于该游戏的细节，没必要重复，想阅读本文但不了解昆特牌游戏的读者请先移步：<a href="https://witcher.huijiwiki.com/wiki/%E6%98%86%E7%89%B9%E7%89%8C">昆特牌 - 猎魔人中文维基 | 獵魔士中文維基 | 巫师狩魔猎人攻略资料站 | The Witcher | Wiedźmin - 灰机wiki - 北京嘉闻杰诺网络科技有限公司 (huijiwiki.com)</a></p><h3 id="基本玩法"><a href="#基本玩法" class="headerlink" title="基本玩法"></a>基本玩法</h3><p>我会提及一些下文会用到的基本信息，不感兴趣可跳过。</p><p>比赛将与对手一对一，采用三局两胜制。</p><p>游戏开始前双方各自选取 5 个阵营中的其中一个进行游戏，并需要在比赛前整理一套合适的卡组与选择领袖牌。</p><p>牌桌由六排组成，分别是我方攻城排、远程排、近程排、对方近程排、远程排、攻城排。我方放牌至我方所在排，对方牌放置在对方所在排，不同手牌有基本固定的放置排。</p><p>卡牌分为战力牌、特殊牌和领袖牌：</p><ul><li>战力牌拥有一个战力点数，并指定它可以放置的排，部分牌拥有特殊效果，战力牌中有一类牌为英雄牌，不受特殊牌影响</li><li>特殊牌（天气牌）会对牌桌上战力牌战力产生影响</li><li>领袖牌和特殊牌一样，也会产生对战力牌的影响</li></ul><p>比赛开始双方随机抽取一定数量的牌，开始前双方有一次机会可以替换手牌中两张牌为牌组中随机牌的机会。</p><p>之后三局中不会再抽牌（北方领域特色除外）。</p><p>比赛过程中交替出牌，直到其中一方放弃出牌或空牌，另一方可以选择继续出牌。双方放弃出牌后，根据牌桌上双方战力排战力点数总额最高者，获得此局胜利。</p><p>当前局结束后，牌桌清牌（怪物和史凯利格特色除外）。</p><p>某一小局双方分值持平时，双方均不获胜（尼国特色除外）。</p><p>第一小局掷骰子决定哪方先出牌（松鼠党特色除外），之后每一小局出牌方为上一局获胜方。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>五个阵营各自特色为：</p><ul><li>北方领域：某一小局获胜后，允许从牌组中抽取一张牌</li><li>尼国：某一小局双方分值相同时，尼国获胜</li><li>松鼠党：比赛开始时，决定己方先出牌还是对方先出牌</li><li>怪物：每小局结束时，随机一张战力牌留在牌桌</li><li>史凯利格：在第三小局时，随机从己方前两局弃牌中抽取两张牌放入牌桌</li></ul><p>部分战力牌拥有特殊效果，战力牌特殊效果是我认为昆特牌中最复杂的玩法细节，虽然它们相比其他卡牌类游戏并不复杂，这些特殊效果有：</p><ul><li>烧灼：消灭牌桌上当前战力最高的牌（可多张），无论敌方还是我方。如果当前战力牌战力最高，将消灭当前牌</li><li>间谍：放置在对方排，为对方累积战力，但换取己方抽取两张牌</li><li>士气：所在排其他牌战力均 +1，即使是后续放置在该排的牌</li><li>号角：所在排其他牌战力均乘 2，即使是后续放置在该排的牌</li><li>医生：从弃牌中选择一张牌放入牌桌</li><li>同胞：相同牌放置时，每张牌战力乘当前牌桌同名牌的数量，即使是后续放置的相同牌</li><li>召唤：放置牌时召唤卡组中其他同名牌一同打出</li><li>狂战士：放置后如果被转化牌转化，会转化为另一张战力牌，否则保持现状</li><li>转化（玛德罗弥）：放置后对当前排中所有狂战士做转化</li><li>复仇：放置在牌桌，直到下一局自动转化为另一张战力牌并保留在下一局牌桌上</li><li>假人：一种特殊牌（无战力），用来将己方牌桌上的间谍换取到手牌中</li></ul><p>天气牌是非常有趣的一个设计，它作为可以同时影响一排战力牌的强力卡牌，却会对双方排均产生影响，这让使用天气牌时更需要技巧，同时猜测对方是否持有天气排，从而改变己方出牌策略。这些天气牌有：</p><ul><li>白霜：双方近战排所在牌战力降为 1</li><li>浓雾：双方远程排所有牌战力降为 1</li><li>暴雨：双方攻城排所有牌战力降为 1</li><li>晴天：移除场上所有天气牌效果</li><li>史凯利格风暴：将双方远程和攻城排所有牌战力降为 1</li></ul><h3 id="特点及泛化分析"><a href="#特点及泛化分析" class="headerlink" title="特点及泛化分析"></a>特点及泛化分析</h3><h4 id="玩法独特"><a href="#玩法独特" class="headerlink" title="玩法独特:"></a>玩法独特:</h4><p>昆特牌最独具一格的特色是一次性抽牌后三局两胜制玩法，也就是 ”田忌赛马“ 式比赛玩法。某一局的弱势方可以选择放弃当前局保留实力，并尽可能骗取对方放下高战力牌的方式，为自己下一局争取获胜概率。</p><p>独立游戏《巫师之昆特牌》在每小局结束后双方均可抽牌的设计，弱化了传统昆特牌最大的特色，是我认为它衍生决策中最大的败笔。</p><h4 id="入门简单"><a href="#入门简单" class="headerlink" title="入门简单:"></a>入门简单:</h4><p>作为游戏中的小游戏，它最初的设计就不能允许过于复杂。大多数卡牌游戏都过于复杂，不同卡牌有各自的技能，卡牌之间又有克制关系，无论是比赛前熟悉卡牌特性，还是比赛中阅读技能说明，都让整个游戏过程变得复杂，也提高了新玩家熟悉游戏的门槛。</p><p>我不否认卡牌游戏作为策略游戏的一种，应该足够复杂，以提高可玩性，但另一方面，确实也有不少牌类游戏，以简单灵活为特色，被很多人喜爱，典型的就是斗地主。传统昆特牌刚好做到了在简单通用和足够有趣之间找到一个平衡。</p><h4 id="集卡"><a href="#集卡" class="headerlink" title="集卡:"></a>集卡:</h4><p>人们都控制不了自己的收集欲，而昆特牌一定程度上展现了猎魔人世界观的一些背景知识，这让玩家无论是单纯的收集全套，还是收集过程中阅读卡牌描述和了解人物，都变得非常有趣。</p><h4 id="卡牌属性特色"><a href="#卡牌属性特色" class="headerlink" title="卡牌属性特色:"></a>卡牌属性特色:</h4><p>和 “炉石传说” 等卡牌游戏有区别的地方在于它几乎没有双方牌之间的直接战斗，也就是类似炉石中拿一张牌攻击对方牌的做法。这让比赛过程简化很多，只需要关注自己的手牌在什么时机放下牌桌即可。</p><p>另外，特殊牌（天气牌）会对双方牌某排所有牌产生影响。这为游戏带来更多变数，需要思考如何放下特殊牌来最大化己方的战力累积而对对方产生更多影响。间谍牌也是非常有趣的一个设计，通过给对方加战力来换取自己抽取两张新牌的机会，配合假人牌，又克制了间谍牌的强度。不过我认为间谍牌依然是很强力的类型牌。</p><h3 id="不足与改进建议"><a href="#不足与改进建议" class="headerlink" title="不足与改进建议"></a>不足与改进建议</h3><p>5个阵营的特色不明显，尼国和史凯利格比较强。可以突出每类阵营的特色的同时，巧妙的设计克制关系，让不同阵营之间更平衡（昆特牌 mod：redux gwent 有这方面的改进）。另外一个建议是，取消阵营设计，融合阵营特色，将所有卡牌整合到一起。</p><p>领袖牌的特殊能力缺乏特色，有不少领袖的能力和天气牌重复。领袖牌应该有全新的特殊能力设计，甚至突破现有规则，比如设计能攻击对方指定牌的能力。否则可以撤销领袖牌。</p><p>牌组设计必然导致有一些强势牌和弱势牌，这导致在游戏中没有积累到强势牌时，昆特牌比赛非常困难，而积累到强势牌后又非常简单。舍弃牌组准备，而将所有牌都洗入牌组是一个简单的策略，在保证公平的前提下也简化了比赛复杂度。</p><p>英雄牌设计过于强势，比赛时抽取到多张英雄牌基本就决定比赛结果。应当削减英雄牌能力，或者减少（甚至删除）英雄牌。</p><h2 id="扑克昆特牌设计"><a href="#扑克昆特牌设计" class="headerlink" title="扑克昆特牌设计"></a>扑克昆特牌设计</h2><h3 id="考虑细节"><a href="#考虑细节" class="headerlink" title="考虑细节"></a>考虑细节</h3><p>使用扑克牌实现昆特牌玩法，可以还原一部分特性，但必然需要舍弃很多特性。一方面是扑克牌的种类没有那么多，另一方面是实体牌计算分值比较困难。</p><h4 id="核分："><a href="#核分：" class="headerlink" title="核分："></a>核分：</h4><p>作为实体牌玩昆特牌，无论是使用昆特牌桌游卡牌，还是用扑克牌模拟，都会遇到棘手的问题，也就是核算分数。</p><p>进行比赛时，需要累积分值，分值在每一张牌落下时都会作为后续决策的重要参考，所以需要频繁的做计算，如果没有便捷的分值计算方法，游戏过程会变得枯燥。当然也许这是一个练习心算能力的机会 😂。最好能有一个方便的记分工具，一个白板、计算器或者记分骰子是不错的选择。</p><p>另外，作为实体牌进行比赛时，战力牌的特殊效果也对分值计算带来更多挑战，在游戏中，程序会自动计算新的分值，在实体牌中需要额外处理。建议去掉战力牌特殊效果，或者只保留少数。</p><h4 id="取消角色："><a href="#取消角色：" class="headerlink" title="取消角色："></a>取消角色：</h4><p>和昆特牌卡牌不同，扑克牌无法还原卡牌角色及信息，这是缺憾的地方。当然，它也带来了好处，就像我开头所说，我们不必再纠结于角色本身的著作背景与昆特牌战力、特殊效果之间的一致性。</p><p>当然，如果手里有昆特牌桌游卡牌来代替，也是非常幸运的事情。</p><h3 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h3><h4 id="牌桌："><a href="#牌桌：" class="headerlink" title="牌桌："></a>牌桌：</h4><p>将 3+3 排改为 2+2 排，这里和《巫师之昆特牌》的考虑相同，3 排和 2 牌并没有产生本质的区别，反而让牌桌过长（我希望宽一些更符合比赛环境），另外我们的特殊牌也很有限。</p><p>牌桌将包括我方远程牌、近程牌、对方近程牌、远程牌。</p><h4 id="牌组："><a href="#牌组：" class="headerlink" title="牌组："></a>牌组：</h4><p>取消牌组准备的工作，所有牌全部纳入牌组参与比赛。</p><p>双方各自持有红牌（红桃、方片）和黑牌（黑桃、梅花）进行游戏（大小王双方各一张），如果可以用两套扑克牌也可以各自一套牌，但意义不大，因为每次比赛能抽到的牌有限，适当的可猜牌机会也能提高趣味性（双方相同牌都有两张）。四种花色分别放置在四排中，可以任选不同花色。</p><p>比赛开始时摸 10 张牌，允许选择换牌 2 张，之后每局获胜方额外摸 1 张牌。</p><h4 id="阵营："><a href="#阵营：" class="headerlink" title="阵营："></a>阵营：</h4><p>取消多方阵营，将阵营特色融合在一起。</p><p>阵营特色保留某一局获胜方可抽取一张牌的效果。</p><h4 id="战力牌："><a href="#战力牌：" class="headerlink" title="战力牌："></a>战力牌：</h4><p>选择数字 A, 2, 3, 4, 5, 6, 7, 8, 9, 10 的所有花色牌作为战力牌，A 为 1 分牌，其他牌战力与数字一致。</p><p>扑克牌不能表现出所有战力牌的特殊效果，扑克牌的牌特征有限，同时也避免了实体牌计算分值的复杂度。我将保留一些特殊效果，保留的依据是：</p><ul><li>避免给分值计算带来负担</li><li>尽可能保留昆特牌特色</li><li>加强低分牌，所以越强势的特殊效果会赋予给越低的分值牌</li></ul><p>这些特殊效果为：</p><ul><li>烧灼：指定分值的牌可以烧灼，我选择 A，烧灼会直接将被烧灼牌弃牌，不会给计算分值带来困难，A 作为 1 分牌，加强其能力</li><li>间谍：这种重要的特殊效果不能被丢弃，但只能简化它的分值差异，我选择 3 作为间谍，即 3 只能打在对方排，并允许己方抽取两张牌，选择 3 的原因是平衡抽牌的强度</li><li>医生：不会对分值计算带来困难，同时它也是非常有意思的一个特殊效果，我选择 2，作为 2 分牌，加强其能力</li><li>假人：替换己方牌桌上的一张间谍牌到手牌中，我选择大王、小王两张牌（双方各一张）</li><li><del>士气、号角、同胞</del>被舍弃，因为他们会改变牌的战力，对计算分值带来了困难</li><li><del>召唤</del>被舍弃，舍弃的原因是放置时需要到牌组中找牌，对比赛节奏不友好</li><li><del>狂战士、转化和复仇</del>被舍弃，它们也会改变牌的战力，对计算分值不利，在原版游戏中它们对比赛的影响也很有限</li></ul><h4 id="特殊牌："><a href="#特殊牌：" class="headerlink" title="特殊牌："></a>特殊牌：</h4><p>为了减轻分值计算复杂度，我对天气牌做了一个小调整，放置天气牌不是将战力降为 1，而是直接降为 0。降为 1 或 0 对分值的累积没有明显影响，但会极大改善分值计算的难度。</p><p>另外，由于我们只有两排，所以设置的特殊牌为：</p><ul><li>冰霜：将双方近战排所有牌战力降为 0，我选择为 J 牌</li><li>浓雾：将双方远程排所有牌战力降为 0，我选择为 Q 牌</li><li>晴天：移除牌桌上所有天气牌，我选择为 K 牌</li><li><del>暴雨、史凯利格风暴</del>被移出，效果比较重复，而且没有必要用</li></ul><h4 id="领袖牌："><a href="#领袖牌：" class="headerlink" title="领袖牌："></a>领袖牌：</h4><p>领袖牌将会被取消。原版游戏的领袖牌特征，要不过于强势，要不过于弱势，再加上很多特殊效果在战力牌特殊效果中有重复，所以领袖牌的意义并不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我个人的一些建议，欢迎参考和调整，玩的愉快 😆</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>昆特牌</tag>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>处理器 barrier 行为的仿真实现</title>
    <link href="/2024/06/16/%E5%A4%84%E7%90%86%E5%99%A8barrier%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/06/16/%E5%A4%84%E7%90%86%E5%99%A8barrier%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%BB%BF%E7%9C%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>由于编译器指令重排以及 CPU 乱序执行的问题，处理器指令有可能在多线程执行时遇到一些问题，比如数据竞争，死锁，非预期的计算结果等。为了避免这类潜在的问题，引入了 barrier 的概念。编译器会主动插入 barrier 指令来降低直接调整指令调度环节的复杂性，而硬件的非预期行为也只能通过软件强行做同步来避免。</p><p>在处理器架构领域，barrier 是一种同步行为，它通常是指令或者指令 modifier，用来对程序流进行同步控制。在多处理器或多线程处理器中，当不同的程序流遇到 barrier 时，会等待其他程序流同时到达这个同步点，然后再执行后边的程序。</p><p>这种方式确保了所有的线程或处理器能够在程序的同一个位置重新对齐。</p><p>在一些硬件上，这种行为通过指令实现，比如 intel 的 FENCE 指令，ARM 的 DMB&#x2F;DSB 指令。大多数 barrier 指令都带有对内存操作的同步，也就是在 barrier 之前的读写内存操作必须在 barrier 点完成，以达到内存访存有序的目的，这通常也被称为 memory fence。概念上讲，fence 是 barrier 的一个特例，也就是说 barrier 并不会要求必须实现 fence 的功能，当然这取决于具体硬件。</p><p>本文中，我将会介绍一种对 barrier 指令行为的软件仿真实现。出于简化实现的目的，程序中不会实现 memory fence，只会对程序指令流的同步行为做仿真，也就是 instruction barrier。</p><p>我也会对应用场景做简化，多线程程序和多处理器程序的 barrier 在程序表现上是一致的，不一致的是 barrier 的指令实现，文章和代码介绍多线程程序下的 barrier 仿真，两者之间很容易互通。</p><p>适合看这篇文章的人可能并不多，如果你想进一步了解 barrier 的概念，可以查找其他文章。阅读本文和 demo 程序需要对 C++ 多线程编程有足够的知识，且对汇编程序设计和并行处理器有一些了解。</p><p>我在网络上并没有找到介绍 barrier 仿真的中文资料，所以希望写此文和提供可参考的 demo 程序，帮助有需要的朋友。</p><p>Demo 程序放在：<a href="https://github.com/P2Tree/barrier/tree/master">P2Tree&#x2F;barrier: A simulate demo for barrier behaviour in compute architecture (github.com)</a>，可以直接取用，有问题请反馈我处理。</p><h2 id="设计用例场景"><a href="#设计用例场景" class="headerlink" title="设计用例场景"></a>设计用例场景</h2><p>一个良好的软件工程实践是先梳理需求和应用场景，并编写一些测试用例。我梳理了几种常见的 instruction barrier 的应用场景（以下用汇编伪码介绍），这些场景会作为 UT 出现在代码中：</p><ol><li><p>最普通的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">some_insts<br>barrier_sync_all_threads<br>some_insts<br></code></pre></td></tr></table></figure><p>多线程程序多以这种 sync 所有线程的方式调用 barrier，线程程序中没有分支和跳转指令，所以每个线程都会执行到相同的代码。但由于线程调度和指令 latency，barrier 前后的时间会不同。</p></li><li><p>程序中存在多个 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">some_insts<br>barrier_sync_all_threads_with_ID_0<br>some_insts<br>barrier_sync_all_threads_with_ID_1<br>some_insts<br></code></pre></td></tr></table></figure><p>硬件并不会只提供一个 barrier，程序的复杂性会要求同时使用多个不同的 barrier。不同的 barrier 的仿真实现可能带来复杂的同步问题。这里额外说一句，barrier 是一种硬件资源，线程程序需要考虑到不要超出资源限制。同一个 barrier 可以在程序的多个指令中被访问，但需要满足适当的用法，否则会出现程序异常、hangup 等问题。</p></li><li><p>只 wait 部分线程的 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_sync_all_threads<br>some_insts<br></code></pre></td></tr></table></figure><p>除了提供对所有线程做同步的 barrier 外，也可能存在对部分线程做同步的 barrier。可能会有两种形式，第一种形式并不关心要同步哪些线程，只关心同步了多少数量的线程；第二种形式关心同步指定线程 ID 的线程。两种形式看似不同，但在仿真实现上基本类似。Demo 中以第一种形式来实现。同步部分线程指令需要带有额外的操作数来指定同步多少线程（或同步哪些线程），超出同步数量的线程（或没有在指定范围内的线程）会直接忽略这个 barrier。</p><p>在做这个测试时，我们适当增加一下线程程序的复杂性，让 barrier_sync_all 和 barrier_sync_partof 同时出现。</p></li><li><p>多个部分线程 barrier：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_sync_partof_threads(count)<br>some_insts<br></code></pre></td></tr></table></figure><p>这个用例看似和上边类似，但实则不同，实际实现时更复杂。比如两个 barrier 各自都等待 4 个线程，线程 0,1,2,3 在第一个 barrier 暂停，线程 4,5,6,7 会忽略第一个 barrier，而在第二个 barrier 等待。注意到，两个 barrier 指令实际使用了同一个 barrier ID，也就是同一个 barrier 资源。</p></li><li><p>生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">thread_produce:<br>barrier_with_produce<br><br>thread_consume:<br>barrier_with_consume<br></code></pre></td></tr></table></figure><p>生产者-消费者模型是一种常见的数据同步设计。一部分线程生产数据，并由另一部分线程消费数据。生产者线程在数据队列满的情况下会暂停生产，消费者线程在数据队列空的情况下会暂停消费，两者通过 barrier 的一种特殊设计来实现同步。</p><p>为了简化硬件细节，我们采用在 barrier 中增加一个计数器来近似硬件表现出的行为（实际硬件的实现可能大相径庭），生产者对计数器累加，而消费者对计数器累减。</p><p>插句题外话，硬件对这种设计的一个常见的应用场景是，硬件有时会让一个线程发射计算指令，但计算结果会交给所有线程去做后处理。</p></li><li><p>复杂的生产者-消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">thread_produce:<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_with_produce<br><br>thread_consume:<br>barrier_sync_partof_threads(count)<br>some_insts<br>barrier_with_consume<br></code></pre></td></tr></table></figure><p>如果之前的 barrier 实现合理，这个混合了普通 barrier 和生产者-消费者 barrier 的程序流应该能够正常工作。而且我这里还需要做个假设，同一个 barrier ID 资源不能同时作为普通 barrier 和生产者-消费者 barrier，否则设计会复杂太多。</p></li></ol><p>以上这些应用场景在我提供的 demo 程序中都能够找到，我没有提供更复杂的测试用例，感觉应该都覆盖到了。</p><p>连续多次 barrier 指令的程序流，看似和一次 barrier 指令没区别，只是重复调用仿真指令就可以。但实际并非如此，两次甚至多次 barrier 之间的 barrier 状态有一些细节要处理，多次 barrier 如果使用相同的 barrier ID（同一个资源），需要考虑 barrier 之间的状态更新和重新初始化。另外，C++ 并发编程中，还需要严格留意临界区的处理，即使你能快速实现第一个 case 的仿真，但后边的 case 依然会引入很多复杂的设计。</p><p>如果你有时间，可以自己拿去玩一下，只留下 test.cpp，设计一个 Barrier 类，看看如何让这些用例都通过。</p><h2 id="程序设计介绍"><a href="#程序设计介绍" class="headerlink" title="程序设计介绍"></a>程序设计介绍</h2><p>我编写了一个 Barrier 类来实现 barrier 指令的所有细节，通过 barrier.h 来了解类结构。我这里对类中的数据成员做介绍：</p><ul><li><p>MutexLock 和 Cond，锁和条件变量，不展开，默认读者需要对它们的使用有充分的了解。</p></li><li><p>Expect，用来记录要同步的线程数量，对于 barrier_sync_all_threads 来说，就是所有线程，否则就是程序在指令中指定的线程数量。</p></li><li><p>Count，一个计数器，参与每一次 barrier 操作。不同线程的相同 PC 下的 barrier 被视为 “同一次” barrier 操作。彻底离开一次 barrier 操作后，这个计数器应该被清零。</p></li><li><p>Release，这个参数最初是没有的，而是为了解决复杂用例下的同步问题而引入，它在不同次 barrier 操作中都会累加，并且不会被清零，它用来弥补 Count 被清零时到下一次 barrier 操作之间的临界区。当然这样会带来累加溢出的问题，我们暂时先不考虑。</p></li><li><p>Actives 数组，用来支持 barrier_sync_partof_threads 的行为，当一次 barrier 操作已经满足全部线程后，其他延迟抵达的线程将会被忽略。为什么不使用 bool 来标记而是使用了 unsigned，感兴趣可以试一下，线程在连续多次 barrier 操作时，是没法处理一个二元状态的，比如第一次遇到 barrier 操作时将 false 改为 true，紧接着第二次遇到 barrier，true 的状态会让他继续 ignore barrier，这是我们不想看到的行为。</p></li></ul><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>完成对总线程数（Expect）和其他一些辅助成员的初始化。</p><h4 id="public-function"><a href="#public-function" class="headerlink" title="public function"></a>public function</h4><p>handleBarSync 用来执行一条普通 barrier，通过重载来区分 barrier_sync_all_threads 和 barrier_sync_partof_threads。前者通过 Barrier 对象来获取总线程数，后者会传入额外一个参数指定要 sync 的线程数量。</p><p>普通 barrier 指令的行为也就是 wait 行为，内部通过同步变量来实现 wait 和 awake。参数 PC 指出 barrier 指令在指令流中的位置；参数 TID 用来指定线程 ID，硬件指令中不需要作为操作数，但仿真时是必需的；参数 Expect 用于在实现 barrier_sync_partof_threads 时指定要 sync 的线程数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Barrier::handleBarSync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> &#123;<br>    wait(this-&gt;Expect, PC, TID);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Barrier::handleBarSync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> &#123;<br>    wait(Expect, PC, TID);<br>&#125;<br></code></pre></td></tr></table></figure><p>handleBarProduce 和 handleBarConsume 用来执行一条生产者或消费者 barrier，内部调用了对应的私有函数。</p><p>生产者 barrier 的指令只需要指定 Expect 和 PC，原因是我的模型中假设了只有一个线程作为生产者，如果你的场景中需要多个生产者，我想这个 Demo 还需要调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::handleBarProduce</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC)</span> </span>&#123;<br>    <span class="hljs-built_in">produce</span>(Expect, PC);<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者 barrier 的指令不需要 Expect，是因为我的模型中假设所有线程（除了生产者线程）都将作为消费者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::handleBarConsume</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-built_in">consume</span>(PC, TID);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="private-function"><a href="#private-function" class="headerlink" title="private function"></a>private function</h4><p>私有函数 wait、produce 和 consume 是关键代码。</p><p>wait 函数用来实现普通的 barrier 行为，一个不考虑各种复杂场景下的最简单实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::wait</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    Count++;<br>    <span class="hljs-keyword">if</span> (Count == Expect) &#123;<br>        Count = <span class="hljs-number">0</span>;<br>        Cond.<span class="hljs-built_in">notify_all</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以停下来想想这样的设计会带来什么问题？</p><p>它能实现带有 barrier_sync_all_threads 指令的指令流。但不能实现带有 barrier_sync_partof_threads 的指令流。我可以举个例子来说明，假设共 8 个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">some_insts<br>barrier_sync_partof_threads(4)   # wait 4 threads<br></code></pre></td></tr></table></figure><p>当其中第 4 个线程的 barrier wait 进入 if 分支后，前 3 个线程在 else 分支中做 Cond.wait，第 4 个线程清零 Count 并会 awake 前 3 个线程。后边 4 个线程会再次进入 Count++ 行为。</p><p>直觉性的，我们需要在前边加个判断，判断当前这一次 barrier 操作已结束（后边的线程不要再处理）。如果复用 Count 来做判断，很容易就会发现，代码难以设计，Count 既需要清 0，又需要作为判断后续线程状态的值而不能及时清 0。</p><p>如果在最后一个线程再清 0 也不可行，原因是在程序流中存在多条 barrier_sync_partof_threads 时（如用例 4），先前释放的线程（前 4 个线程）进入了第二个（相同 barrier 资源）的 barrier handle，它们也需要操作 Counter，与第一个 barrier 还没跑完的线程（后 4 个线程）争夺 Counter 的访问权。</p><p>我们需要一个额外的状态位，这个状态位不能在两次 barrier 操作之间清零（否则就和 Counter 遇到一样的问题），所以我加入了 Release。我们也不能交替使用两个状态（Counter 和 Release），因为我们无法预测指令流中不同的线程会同时执行到几个 barrier 指令（现在例子中是 2 个，但完全可以更多）。</p><p>我们还需要一个标记某个线程是否已经到达一次 barrier 操作，使用 “线程没有达到 barrier 操作” 并且 ”barrier 操作已完成“ 的条件来决定哪些线程需要跳过 barrier 操作。前边已经解释了为什么这个标记（Actives）需要是和 Release 一样的 unsigned 类型，而不是 bool，这里不再重复。</p><p>Release 变量会在每次 barrier 操作完成时累加一次；Actives 中对应线程的位置会在每次 barrier 操作时累加一次，所以两者是同步的。barrier 操作没完成时，Release 和未执行的线程 Actives 是相同的，barrier 操作完成后，Release 累加一次，已执行的线程 Actives 累加一次，未执行的线程 Actives 和 Release 进行比较，就可以判断当前线程是否要 ignore barrier。</p><p>修改后的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::wait</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    <span class="hljs-keyword">if</span> (Actives[TID] != Release) &#123;<br>        Actives[TID]++;<br>        <span class="hljs-keyword">return</span>;    <span class="hljs-meta"># ignore barrier</span><br>    &#125;<br>    Count++;<br>    Actives[TID]++;<br>    <span class="hljs-keyword">if</span> (Count == Expect) &#123;<br>        Count = <span class="hljs-number">0</span>;<br>        Release++;<br>        Cond.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-meta"># threads all arrived</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);  <span class="hljs-meta"># part of threads arrive</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看看另外两个函数，produce 和 consume。相比于 wait，这两个函数的实现却显得简单多了。作为 produce 的 barrier，并不会有额外行为，它唯一做的事情就是通知 consume barrier 可以 continue 了，而 consume barrier，只需要 wait 等待 produce 通知即可，这与 C++ 的条件变量的等待-唤醒模型基本吻合。</p><p>produce 的实现可以直接写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::produce</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> Expect, <span class="hljs-type">unsigned</span> PC)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    Count = Expect;<br>    Cond.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>produce 需要明确有几个 consumer 来处理数据，所以这里需要每次都设定 Counter。</p><p>consume 的实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barrier::consume</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> PC, <span class="hljs-type">unsigned</span> TID)</span> </span>&#123;<br>    <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">Lock</span><span class="hljs-params">(MutexLock)</span></span>;<br>    <span class="hljs-keyword">if</span> (Count != <span class="hljs-number">0</span>) &#123;<br>        Count--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Cond.<span class="hljs-built_in">wait</span>(Lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同于 wait 函数，consume 需要对 Counter 做递减，因为 produce 时给它设置了正数的非零值，每个 consume 需要减掉属于自己的那一位。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多的代码细节可以参考我提交的 demo，我要阐述的细节已经完毕。</p><p>这个话题来源于我工作中的一部分，我已经剔除了和业务相关的部分，由于要贴近工作需要，所以一些场景设计可能并没有考虑到，从而目前的设计也可能没有很好的普适性。保存这块代码的一个目的，也是在将来能够有需要时，继续完善它。</p><p>在设计整个 demo 中，自己遇到了一些问题，也进一步夯实了有关 C++ 并发编程的知识。如果你熟悉 C++20，那么会很快发现这很类似 C++20 里边的 std::barrier 和 std::latch。事实上我在实现这套逻辑的过程中发现了，但由于我的项目没有依赖 C++20 开发，所以没办法直接使用现成的模型。另外，我也没有尝试去使用 boost::barrier，因为它的实现比较单一，而我实际业务场景中有很多需要定制的地方，索性自己实现一套。</p><p>如果你愿意参考一下标准实现，我认为是极好的，我 demo 中的 count 对应 boost 库实现中的 m_count，release 对应 m_generation。我也认为其中有很多值得优化的地方，欢迎交流，有空的时候，我会再看看 std::barrier 的实现。</p><p>另一方面，并发编程需要处理很多细节，一些极端的异常需要在非常苛刻的环境下才能复现，而且调试也非常困难，本文中列举的示例场景依然只是其中一部分。Demo 中的代码实现比文章中的要复杂一些，因为其中处理了一些并发的小问题，比如应对 wait 的虚假唤醒，感兴趣的朋友可以找网上其他资料了解，有很多文章介绍。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/703597874">https://zhuanlan.zhihu.com/p/703597874</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>体系结构</tag>
      
      <tag>并发编程</tag>
      
      <tag>仿真</tag>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 高效编辑技巧</title>
    <link href="/2023/10/14/Vim%20%E9%AB%98%E6%95%88%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/10/14/Vim%20%E9%AB%98%E6%95%88%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>这篇文章围绕 Vim 展开。</p><p>很早前就想写一篇关于 Vim 的文章，但始终难以动笔，是因为担心自己的领悟还不够高。前几个月，得知 Vim 创始人和维护者 Bram Moolenaar 去世了，又重新翻阅了一些文章，就打算做一次 Vim 的传道师，给一些不了解这个软件和刚刚接触、或曾经接触过的朋友们做一些粗浅地介绍。</p><p>在知乎问答中，有很多对于 Vim 的讨论，也有一些非常不错的回答，作为一个爱好者和每天都离不开使用 Vim 的人，显然我阅读了其中大多数内容。本着不输出重复信息的原则，我在这篇文章中，会以另一种视角介绍 Vim，也就是从 Vim 的设计理念出发，介绍一些如何高效进行代码编辑的技巧。最后我也会谈谈我对一些话题的想法。</p><p>Vim 是 Vi 的增强版，诞生于那个计算机图形界面还未成熟的年代，所以当时鼠标这个外设也没有普及，文字录入工作还只依赖于键盘输入，所以很多同学讨论为什么 Vim 不支持丰富的光标操作，原因就在于此。虽然后来图形化已经替代了终端程序，成为消费级计算机主要的用户接口之一，但在一些特殊场合和应用场景下，非图形化的终端程序，依然充当着重要的功能。这其中就包括部分场景下的代码编辑工作。</p><p>大多数对 Vim 痴迷的计算机技术人员，据我了解，基本能囊括在以下几点，这也是 Vim 区别于其他文本编辑器的重要特点：</p><ul><li>快速，不依赖鼠标控制实现任何编辑操作（模态编辑）</li><li>灵活，扩展性极强，可以自由定制（Vimscript，插件系统）</li><li>启动快速，与系统软件契合较好（轻量级）</li><li>工作环境受限，只能使用 Vim(Vi) 工作（Mac、Linux 系统自带程序）</li><li>开源软件，社区维护，免费使用</li></ul><p>其中最有特色的就是第一点，以至于很多其他编辑软件中，也会提供 Vim 键位和扩展（甚至包括一些非文本编辑类软件，比如控制浏览器）。</p><p>任何一点单独拿出来，都有其他匹配的软件有相似的特性，但结合在一起，可能只有 Vim 能做到了。</p><h2 id="实践心得"><a href="#实践心得" class="headerlink" title="实践心得"></a>实践心得</h2><p>在进入主题之前，先介绍一下我自己的学习和使用 Vim 的心得。</p><p>首先要摆正一个观念，Vim 是一个自定义程度很强的软件，所以达到一个目的，可能有很多种方法，有些方法快速，有些方法复杂，但其差别可能也就是一次点击和多次点击，所以<strong>并不是要求必须学会了所有的操作，才能开始使用它</strong>。就像我们刚开始接触电脑时，还不了解文件系统，而是将所有材料都放在桌面上，也一样可以工作。之后我们了解更多了，就可以不断地改善工作链路，让整个系统更高效。</p><p>学习和使用 Vim 的过程，是不断重复这样一个闭环的过程：</p><ol><li>掌握一些用法，开始用它干活</li><li>发现一些操作很繁琐</li><li>思考这些操作，能否用更高效的操作替代</li><li>逐渐适应新的操作，取代旧的操作</li><li>新操作熟练掌握，形成肌肉记忆</li></ol><p>我已经使用 Vim 十年了，依然还在践行这样一个迭代的过程，不断学习新的东西，并让自己对这款软件的使用更高效。</p><p>其中提到 ”肌肉记忆“，我应该也说一下。对于 Vim 新手来说，到网上查到一些用法，操作时总要回忆和记忆键位，所以并没有提高输入的效率。但其实这个阶段，还没有走完一次闭环（此时还在第 4 步）。只有完成了肌肉记忆，才是对这个新操作的完全掌握，就像弹钢琴，想发出什么音，到怎么发出，之间是没有 “这个音在哪个键上，应该用哪个手指点击” 这样一个脑回路的。</p><h2 id="模态编辑"><a href="#模态编辑" class="headerlink" title="模态编辑"></a>模态编辑</h2><p>开始使用 Vim 时，首先一定要学习这个概念。Vim 只依赖键盘输入，包括输入文本内容和输入控制指令。为了能高效的输入控制指令，Vim 不同于其他程序采用 Ctrl 和 Alt 等键位连接字母区键位的组合键方式，而是重新利用键盘中易于触碰的部分按键实现大多数功能。组合键方式有一些键位比较难以点击，尤其是当需要多次点击时，这会打断输入流。</p><p>为了做到这一点，Vim 对键盘区做了多层的重新映射，在不同的模态（映射模式）下，点击相同的键，会有完全不同的行为。Vim 启动后，默认处于 Normal 模式，可以认为是 HOME 模式，依赖于一些按键，可以进入其他模式，在其他模式下，按 Esc 键，可以回到 Normal 模式。</p><p>Vim 支持几种不同的模态，常用的有：</p><ul><li>Normal 模式：控制光标移动和对文本内容的修改（删除、复制等），并可以做到大量其他模式的操作</li><li>Insert 模式：文本内容输入，和其他编辑器一样</li><li>Visual 模式：选择内容，属于 Normal 模式的扩展，和 Command 模式配合，可以做到很多操作</li><li>Command 模式：控制软件的行为，它也可以实现其他几种模式的功能</li><li>Block Visual 模式：块选内容，和 Visual 模式类似，但按类似鼠标框选的方式选择文本</li><li>Replace 模式：替换一个字符或连续替换字符</li><li>Search 模式：搜索和跳转等</li></ul><p><img src="/img/20231014/img1.png" alt="Vim 模态关系"></p><p>对 Vim 的学习主要围绕着 Normal 模式展开。入门 Vim 的第一次闭环，就是将怎么切换模态（至少是在 Normal 和 Insert 之间切换）形成肌肉记忆的过程。</p><p>Normal 模式下常用的操作一定要熟悉，Command 命令可以在脚本里映射到 key，所以不用刻意记，熟悉了之后就随意了。后文会介绍一些常用的操作。</p><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>Vim 提供了自己的一套配置脚本语言，我们可以利用这种编程范式，配置一些自定义的自动命令序列，比方说，我有一个自动命令，可以在每次保存时自动删除行末尾的空白字符。这种自定义的命令可以通过特定事件触发，也可以手动触发。另一个同样出色的编辑器，emacs，也因这种特性而同样被很多程序员们推崇。</p><p>在这种扩展性的基础上，衍生出了很多通用且优质的配置文件，进而发展成了插件系统。插件系统易于安装、扩展和分发，对于很多通用的扩展。很多朋友可能会说，其他现代编辑器，如 VSCode 也支持插件系统，没错，它们都是优秀的编辑器软件。</p><p>扩展性这个重要的特点，给予了使用者完全的自由，就像自己在设计属于自己的程序一样，这对于程序员这个群体来说，简直如鱼得水。</p><p>Vim 的一个 Fork 版，Neovim，放弃了维护 Vimscript 这个脚本语言，转而将一种更通用的语言，lua，作为另一种可以配置的脚本语言。由于 lua 相比于 Vimscript 来说，是一门更完善且易用的编程语言，更易于学习和阅读，所以得到大家的一致赞同，也成为了吸引新用户使用 Neovim 的重要亮点。目前，使用 lua 编写的配置文件和插件，如雨后春笋般涌现，Neovim 的开发社区也比 Vim 更活跃一些。</p><p>我并不想在本文介绍常用地插件和配置文件，如果有朋友感兴趣，我可以单独开一期，像其他介绍 Vim 的文章一样，分享一些我的 Vim 配置。</p><h2 id="一些实践技巧"><a href="#一些实践技巧" class="headerlink" title="一些实践技巧"></a>一些实践技巧</h2><p>下边我会介绍一些使用 Vim 所特有的技巧，如果你是初学者，可能还没有掌握其中一些操作。这没有任何问题，我保证我介绍的都是比较基础的技巧，你可以利用上边介绍的实践心得，逐步接触、学习直到掌握这些更优秀的实践技巧。</p><p>如果我不特意说明，以下的操作都是在 Normal 模式中完成，部分操作也支持 Visual 模式。</p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>很多人都知道说，新手使用 Vim 时，很难脱离方向键移动光标的习惯，这很正常。所以他们被建议禁用方向键。我个人认为这种做法有点太极端。最早的键盘里是没有方向键的，这才使得 Vim 在设计光标移动时采用了 <code>h</code> <code>j</code> <code>k</code> <code>l</code>  的键位，在当时这种键位设计也不是 Vim 独有的。但这并不代表着方向键不如 <code>h</code> <code>j</code> <code>k</code> <code>l</code> ，否则也无法解释为什么后来的键盘添加了这样的按键了。</p><p>我倾向于说，<code>h</code> <code>j</code> <code>k</code> <code>l</code>  的学习并不应该成为接触 Vim 的一个门槛，如果习惯用方向键，依然可以用。当然，<code>h</code> <code>j</code> <code>k</code> <code>l</code>  的使用效率确实比方向键高，可以利用前边的实践心得来逐步地适应这套键位。</p><p>另外，hjkl 在 Vim 中也依然是最低效的一类光标移动操作。本质上它只避免了右手向右下方方向键区的移动，行为和方向键依然是一样的。Vim 的一个独特之处就在于，它天生适合代码编辑环境，所以光标在代码中的移动，其实有很多种，比如说：</p><ul><li>使用 <code>Ctrl-d</code>，<code>Ctrl-u</code>，<code>Ctrl-f</code>，<code>Ctrl-b</code> 快速翻页</li><li><code>e</code> 到 下一个单词末尾，<code>b</code> 到上一个单词开头，<code>w</code> 到下一个单词开头等</li><li><code>gg</code> 和 <code>G</code> 到第一行或最后一行</li><li><code>-</code> 来搜索特定的单词，<code>n</code> 或 <code>N</code> 向下或向上跳转</li><li><code>/</code> 进入搜索模式，快速搜索任何支持正则匹配的字段</li><li><code>%</code> 跳转到匹配的括号</li><li><code>gd</code> 跳转函数定义，<code>Ctrl-o</code> 返回</li></ul><p>不再过多举例，这些也只是比较常见的快速移动操作，配合一些扩展，还能实现更复杂的快速移动。</p><h3 id="不要重复操作"><a href="#不要重复操作" class="headerlink" title="不要重复操作"></a>不要重复操作</h3><p>这一小节，我想探讨下使用各种更高效的方式替代通过按住一个键一段时间来完成目标的行为。</p><p>比如说，向下翻页，我们可能按住方向键下键一段时间，快要到达目的地时，多次短按下键，如果超出了目的行，还要短按上键。另一个例子是按住 <code>backspace</code> 键来删除一段文本。</p><p>这种操作就叫重复操作。不同于写文章，代码编辑中会更多的涉及到重复操作，比如复制粘贴，比如移动位置。</p><p>重复操作带来了更多的时间浪费，而且会占用我们宝贵的注意力，毕竟，脑子里都是代码逻辑的时候，抽出注意力去关注按住多久才要松手这种事，其实是潜在占用精力的。</p><p>Vim 的设计哲学中，非常在意避免重复操作，所以它原生支持大量的操作来替代重复操作，比如说：</p><ul><li><code>dd</code> 删除一行，<code>d$</code> 删除从当前光标到行尾，<code>df</code> 加任何一个字符，就是删除从当前光标到接下来搜索该行中出现的第一个这个字符的位置，把 <code>f</code> 换成 <code>F</code> 就是向前删到指定字符，换成 <code>t</code> 或 <code>T</code> 的行为类似，区别是保留搜索到的字符不删除（类似闭区间和开区间）</li><li><code>x</code> 删除当前字符，替代 <code>a + backspace + Esc</code></li><li><code>h</code> <code>j</code> <code>k</code> <code>l</code>  加一个数字，就是向左下上右移动对应距离</li><li><code>c</code> 是删除并插入， 替代 x + i，如果你经常使用 dwi 删除一个单词后进入插入模式，那么可以换成 cw</li></ul><p>这种技巧其实非常多。另外值得提一下的是强大的 dot 操作和宏操作。</p><p>dot 操作，就是 <code>.</code> 键，这个键可以重复上一次原子操作，比如 <code>cw</code> 就是一次原子操作，如果需要重复这个操作多次，那么就不必要 <code>cwcwcwcw</code> 这样输入，而是 <code>cw...</code> ，是不是会快很多。</p><p>宏操作也很类似，它允许你定义一段操作作为一个集合，然后重复执行这个集合，就可以快速完成重复操作。</p><p>比如举我工作中常见的一个应用。我有时需要将一个特别长的行，按一些规律换行成多行，比如换行成每行 32 个字符，每隔 32 行中间插个空行。如果字符特别多，这种操作就会比较费时。我可以利用宏，先录制对前 32 行 32 列字符的操作，之后就可以播放这个宏，即可一键完成所有数据的处理。</p><p>宏操作只需要记住两个动作：</p><ul><li>录制：<code>q</code> 加一个字符，这个字符在 Vim 中被叫做寄存器，用来缓存内容的空间，字母区和一些特殊字符都对应一个专门的寄存器</li><li>播放：<code>@</code> 加这个字符，播放这个字符对应寄存器中的操作</li></ul><p>dot 操作可以和宏操作结合起来用，实现更快速的操作。</p><p>学习如何避免重复操作，是使用 Vim 进阶必须要走的路。</p><p>在插入模式中避免重复的操作，就是 snippet 和自动补全机制，这些特性在其他代码编辑器中也存在，我就不展开了。</p><h3 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h3><p>很多进阶的 Vim 介绍文章和视频都会提到文本对象这个概念（text object），但其实不是什么很复杂的概念。</p><p>当我们拿到一个文本时，可以按不同性质将它切分，比如按段落，按行，按单词。Vim 中会增加更多的切分方式。比如，可以指定一个边界来切分，如 <code>&#123;</code> <code>&#125;</code> 中的内容，或者指定一个函数块或类块。这个东西就是文本对象。</p><p>文本对象是一种选择后执行逻辑，就是指定要选中哪些切分的内容，然后按指定方式执行。</p><p>为了区别要不要在选中内容时，同时也选中边界，Vim 提供了两个文本对象标记，<code>i</code> 和 <code>a</code>，<code>i</code> 表示 inside，指不包含边界，<code>a</code> 表示 around，指包含边界。需要配合一个对文本对象操作的动作一起执行。比如：</p><ul><li>删除一个 <code>&#123;</code> <code>&#125;</code> 包含的内容，不包括边界就是 <code>di&#123;</code>，包括边界就是 <code>da&#123;</code></li><li>选中一个段落，使用 <code>vip</code>，<code>v</code> 表示开始选中并进入 Visual 模式，<code>p</code> 表示段落</li></ul><p>具体动作 <code>d</code> 或 <code>v</code>，可以将它替换成其他类似的操作实现其他功能。</p><p>文本对象是一个很值得摸索和研究的话题。</p><h3 id="程序思维"><a href="#程序思维" class="headerlink" title="程序思维"></a>程序思维</h3><p>上边这几个小节中，其实已经体现出了在使用 Vim 过程中的程序思维。程序思维，就是可以非常自由的拼接一些操作，来实现更复杂的操作。<code>d</code> 表示删除，<code>i</code> 表示不包含边界，<code>&#123;</code> 表示边界字符是 <code>&#123;</code> <code>&#125;</code>，连接起来就是删除不包含 <code>&#123;</code> <code>&#125;</code> 边界的中间的文本对象。<code>y</code> 表示复制，<code>G</code> 表示光标到文档结尾，连接起来就是复制从当前光标位置开始到结尾的内容。</p><p>Vim 的灵活性在这里体现的淋漓尽致，就像自动化编程一样，你可以按一定规律随意组合一些操作，快速完成一些复杂操作。对于一些开始复杂化的操作，可以将它编写到 keymap 中，或者 autocmd 中，实现更方便的快速完成。</p><p>当然，这里我想再重复一下本文开头的一个说明，即使你不熟悉这些看起来复杂的操作，也依然可以使用 Vim，这些只是可能对你有帮助的扩展，如果能掌握一定是更好的。大多数使用 Vim 的用户，可能也只掌握了不到一半的特性，这不妨碍他们完成工作任务。</p><h3 id="肌肉记忆"><a href="#肌肉记忆" class="headerlink" title="肌肉记忆"></a>肌肉记忆</h3><p>我能想到的最后一个技巧，或者说不是技巧，而是概念，就是肌肉记忆。</p><p>就像开车一样，刚开始学习怎么开车时，我们需要思考哪里是油门刹车，怎么挂档位，但熟悉之后，这些操作就成为了一种习惯，不需要再刻意思考就可以完成，这就是肌肉记忆。</p><p>Vim 也同样如此，看似挺复杂的操作，比如 <code>h</code> <code>j</code> <code>k</code> <code>l</code>  这种不太符合常规的方向移动键，当你适应之后，就不会再有使用的困难了。我在将 <code>h</code> <code>j</code> <code>k</code> <code>l</code>  解释成 “左下上右” 时，还需要思考一下，但使用 Vim 中从来不用思考，这就是肌肉记忆优先于大脑记忆。</p><p>这种肌肉记忆需要练习，也就是我前边实践心得中的第 4-5 阶段，当完成第 5 阶段之后，这个操作技能就会被掌握，就会成为你使用 Vim 完成开发的得力助手。</p><p>当然还有个小话题，如果你还不会盲打，那么先练习盲打，肌肉记忆是手指的肌肉，而不是视觉和大脑的反馈。</p><h2 id="不做-IDE"><a href="#不做-IDE" class="headerlink" title="不做 IDE"></a>不做 IDE</h2><p>在网上越来越多的关于 Vim 的讨论都是关于 “怎么将 Vim 打造成一个强大的 IDE”，或者是拿 Vim 和 Visual Studio 这种 IDE 做比较。我的观点是，力气用错地方了。除非是享受 Vim 强大的扩展性，享受将它升级成各种强大软件的过程，除此之外，Vim 并不适合成为一个 IDE。</p><p>IDE 软件在 UI、稳定性、兼容性等方面做的都比较好，这是由于大多数成熟的 IDE 都有着强大的企业资源在支撑。而 Vim 只是一个开源软件，它依赖一种社区共识以及整体开发人员的水平和素质。Vim 确实是一个优秀软件，但将各种 IDE 的功能，如构建和调试、文件管理、发布和部署这些都集中起来，对 Vim 来说是有挑战性的，毕竟它最初的设计只是一个出色的代码编辑器。当然，Vim 及 Neovim 的配置和插件生态中，确实存在很多优秀的样本。</p><p>但这并不表示 Vim 相比 IDE 软件来说低人一等，Vim 有它独特的使用场景。比如说：</p><ul><li>Linux 运维人员，服务器在云端，远程访问机器</li><li>仅使用终端来开发和部署软件的工作</li></ul><p>注意，我这里说的是 Vim 相比 IDE 独特的场景，而不是 Vim 可以使用的场景。</p><p>之前我写过一篇介绍 Tmux 的文章，通常这种环境下工作的工程师，都会配合一个终端管理器或窗口管理器，为了就是能灵活的使用 Vim 和其他系统软件，而不会有很大的割裂感。</p><p>换句话说，<strong>和 IDE 做比较的，不应该是 Vim，而是基于 Vim 作为代码编辑器的操作系统环境</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概就说这些吧，如果看到有更好的 Vim 话题，我会继续更新。</p><p>以上内容仅代表我个人观点，我自己是非常喜欢倒腾 Vim 等工具的，Vim 和 Neovim 我自己搭建过类 IDE 环境，也用过很多种发行版（也就是别人搭好的环境），将它一步步改造成适合自己的软件，是很有成就感的。</p><p>但目前开始佛系，不再会向当初那样天天去社区看更新进展，茶余饭后去思考怎么在功能丰富性和性能方面去找平衡。可能是年纪大了吧，看到 Vim 的讨论依然这么热烈，Neovim 的生态也在蒸蒸日上，我是欣慰的。</p><p>工具终归是工具，就像争论什么是最好的编程语言一样，争论什么是最好的代码编辑工具，实际上都是没什么意义的，认清目标，适合自己的和适合项目的，就是最好的。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/661320417">Vim 高效编辑技巧 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>软件工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>终端开发</tag>
      
      <tag>软件工具</tag>
      
      <tag>Vim</tag>
      
      <tag>高效编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLVM风格的RTTI</title>
    <link href="/2023/08/14/LLVM%E9%A3%8E%E6%A0%BC%E7%9A%84RTTI/"/>
    <url>/2023/08/14/LLVM%E9%A3%8E%E6%A0%BC%E7%9A%84RTTI/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>众所周知，LLVM project 没有开启 C++ 的 RTTI 特性。一个主要的原因是 LLVM project 认为 C++ RTTI 特性的实现需要使用到虚函数表，对性能并不友好。LLVM 自己实现了一种类似 RTTI 的行为。我们在开发 LLVM 代码时，尤其是需要自己搭建自定义的数据结构时，可能会想用到 RTTI，此时，学习在 LLVM 风格下如何创建类似的 API，就显得尤为重要。</p><h2 id="什么是-RTTI"><a href="#什么是-RTTI" class="headerlink" title="什么是 RTTI"></a>什么是 RTTI</h2><p>难度：⭐</p><p>RTTI 是运行时类型识别，全称 Runtime Type Identification，网上有很多介绍这个的资料，属于 C++ 程序员必须要熟悉的内容。</p><p>它的主要目的是为程序运行时提供一种对对象类型的获取、操作的方式。</p><p>对应到 C++ API 上，有三个 API 会用到 RTTI：</p><ul><li>dynamic_cast，用来将一个指向基类的指针转换为一个指向派生类的指针，如果转换失败，会返回 nullptr</li><li>typeid，用来返回对象类型的值</li><li>type_info，也就是 typeid 的返回类型，用来存储描述类型的信息</li></ul><p>如果不使用这三个 API，关闭 RTTI 不会影响代码行为。</p><p>需要注意的是，RTTI 只能用于包含了虚函数的类，也就是需要虚函数表来提供负责转换类型和提取真实类型的信息。</p><h2 id="LLVM-的-RTTI-替代方案"><a href="#LLVM-的-RTTI-替代方案" class="headerlink" title="LLVM 的 RTTI 替代方案"></a>LLVM 的 RTTI 替代方案</h2><blockquote><p>参考自：<a href="https://www.llvm.org/docs/ProgrammersManual.html#important-and-useful-llvm-apis">LLVM Programmer’s Manual — LLVM 18.0.0git documentation</a></p></blockquote><p>难度：⭐</p><p>回到主题，LLVM project 构建中，默认把 RTTI 关闭了，也就是使能了 <code>-fno-rtti</code> 编译选项。</p><p>LLVM 设计了另外一种方式来实现 RTTI，这种做法可以更高效且灵活的完成如继承结构向下类型转换和获取类型并判定的功能。</p><p>LLVM 提供了以下 API：</p><ul><li><code>dyn_cast</code>，作为 dynamic_cast 的替代，用来检查一个特定类型的对象，并将其转换为指定的派生类型。如果转换是非法的，会返回 nullptr。这个 API 不能用于引用（dynamic_cast 可以用于引用，非法转换会返回 bad_cast 异常）</li><li><code>isa</code>，类似于 java 的 instanceof，用来判定一个对象是否是某个类型。返回 bool 类型，可以判断指针或引用类型</li><li><code>cast</code>，和 dyn_cast 类型一样，但可以既接受指针又接受引用类型，之所以能接受引用类型，是由于它在非法转换时，会发生 assertion 失败。所以，这需要在使用前预先确认 cast 不会失败才行，也就是通常要和 isa 配合使用。</li></ul><p>另外，还有 <code>dyn_cast_or_null</code>，<code>isa_and_nonnull</code> 和 <code>cast_or_null</code> 等扩展接口，它们是对应的能接受 nullptr 作为参数的 API。需要注意，dyn_cast_or_null 和 cast_or_null 接口已经在新版 LLVM 中被标记为 deprecated，用来替代它们的 API 是 cast_if_present，有关于这些接口的使用和实现，可以参考 <code>include/llvm/Support/Casting.h</code> 文件。</p><p>我们在平时编码时，很容易遇到这些应用场景，比如当拿到一个 MI 指令时，需要通过判断这个指令是哪种类型，来决定要采取哪种操作，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取特定类型指令的 operand type</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> *Ld = <span class="hljs-built_in">dyn_cast</span>&lt;LoadInst&gt;(V))<br>  Ty = <span class="hljs-built_in">cast</span>&lt;PointerType&gt;(Ld-&gt;<span class="hljs-built_in">getPointerOperandType</span>())-&gt;<span class="hljs-built_in">getElementType</span>();<br><br><span class="hljs-comment">// 判断一个 operand 是否是 Integer type</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isa</span>&lt;IntegerType&gt;(V-&gt;<span class="hljs-built_in">getType</span>()))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>要尽可能使用这种风格的代码实现，而不是使用 if-else 风格 get 具体 enum kind 的形式。</p><h2 id="设计自定义类继承结构的-RTTI-API"><a href="#设计自定义类继承结构的-RTTI-API" class="headerlink" title="设计自定义类继承结构的 RTTI API"></a>设计自定义类继承结构的 RTTI API</h2><blockquote><p>参考自：<a href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html#how-to-set-up-llvm-style-rtti-for-your-class-hierarchy">How to set up LLVM-style RTTI for your class hierarchy — LLVM 18.0.0git documentation</a></p></blockquote><p>难度：⭐⭐</p><p>如果只是使用 API，前边章节的内容已经足够了，但如果是需要设计自己的类型，那么学习 LLVM 如何做到这些，也是很有意义的。由于 LLVM 关闭了 RTTI，所以我们需要手动维护一套类型机制来标记类型信息，即我们不需要依赖虚函数表来实现 RTTI。</p><p>假设我们有这样一个类结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMCInst</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CustomMCInst</span>() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSAMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先，我们需要 include 头文件：<code>#include “llvm/Support/Casting.h”</code>，这个头文件中描述了上述的 API 声明及实现。</p><p>然后，在 CustomMCInst 中，需要增加一个用来描述各种 Kind 的 enum，这些 Kind 将用来描述各个派生类的类型（加粗部分为新增代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMCInst</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CustomMCInst</span>() &#123;&#125;<br>  **<span class="hljs-built_in">CustomMCInst</span>(InstKind K) : <span class="hljs-built_in">Kind</span>(K) &#123;&#125;**<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  **<span class="hljs-keyword">enum</span> <span class="hljs-title class_">InstKind</span> &#123;<br>    IK_ALU,<br>    IK_LSA<br>  &#125;;<br>  <span class="hljs-function">InstKind <span class="hljs-title">getKind</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Kind; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> InstKind Kind;**<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSAMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里使用 Kind，而不是 type 或 classes 等名词，是为了和 LLVM 中其他常见的关键词做区分。最好将 Kind 和 getKind() 都保持使用相同的名称。</p><p>之后，需要将所有派生自基类的子类型，都设置为对应的 Kind。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ... 省略基类代码</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  **<span class="hljs-built_in">ALUMCInst</span>() : <span class="hljs-built_in">CustomMCInst</span>(IK_ALU) &#123;&#125;**<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSAMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  **<span class="hljs-built_in">LSAMCInst</span>() : <span class="hljs-built_in">CustomMCInst</span>(IK_LSA) &#123;&#125;**<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后，还需要实现 LLVM RTTI 的模版接口，用来能够提供给如 dyn_cast 和 isa 来决定类型的调用。实现方式是通过一个静态的成员函数 classof 来作为 dyn_cast 和 isa 的调用接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ... 省略基类代码</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ALUMCInst</span>() : <span class="hljs-built_in">CustomMCInst</span>(IK_ALU) &#123;&#125;<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  **<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() == IK_ALU;<br>  &#125;**<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSAMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LSAMCInst</span>() : <span class="hljs-built_in">CustomMCInst</span>(IK_LSA) &#123;&#125;<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <br>  **<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() == IK_LSA;<br>  &#125;**<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里 classof 这个接口，是必须要叫这个名字的，因为在 dyn_cast 和 isa 的实现中，最终是调用了一个类型的 <code>::classof</code> 接口。留意到，我们的抽象基类并没有提供 classof 接口，因为这是没有必要的，不必要给不能实现对象的类提供类型。</p><p>以上就是完整的实现步骤。当我们具体使用时（调用方），可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MCOperand <span class="hljs-title">getDstOp</span><span class="hljs-params">(CustomMCInst *I)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> * IALU = <span class="hljs-built_in">dyn_cast</span>&lt;ALUMCInst&gt;(I)) &#123;<br>    <span class="hljs-keyword">return</span> IALU-&gt;<span class="hljs-built_in">getDstOpernad</span>();<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> * ILSA = <span class="hljs-built_in">dyn_cast</span>&lt;LSAMCInst&gt;(I)) &#123;<br>    <span class="hljs-keyword">return</span> ILSA-&gt;<span class="hljs-built_in">getOperand</span>();<br>  <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">MCOperand</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意，所有非抽象类，都应该实现 classof 接口，即使它不是叶子类型。另外，classof 的参数将始终应该是抽象类类型。</p><p>进一步扩展一下，我们的 classof 函数实现，并不一定要求一定是 <code>return i→getKind() == IK_A_KIND</code>，事实上，任何能够决定类型，且返回 bool 状态的内部实现，都可以用来实现 classof。这些在我们实现更复杂的类继承结构中会考虑用到。</p><h2 id="深层次继承结构"><a href="#深层次继承结构" class="headerlink" title="深层次继承结构"></a>深层次继承结构</h2><p>难度：⭐⭐</p><p>上边提到，当一个非抽象类型，并不是叶子类型（也就是它自身还有子类派生），我们也应该提供 classof 接口。这是因为任何非抽象类型都可以成为在运行时需要动态识别和转换类型的入参。</p><p>对于这种多层的继承结构，有一些额外的规则：</p><ul><li>非抽象类型都要提供 classof 接口</li><li>非叶子类型的 classof 实现，需要将其子类型包含在其中</li></ul><p>举例来说，我们对上边的代码做扩展，将 ALU 指令分为 ARITH 指令和 LOGIC 指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMCInst</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CustomMCInst</span>() &#123;&#125;<br>  <span class="hljs-built_in">CustomMCInst</span>(InstKind K) : <span class="hljs-built_in">Kind</span>(K) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">InstKind</span> &#123;<br>    IK_ALU,<br>    **IK_ARITH,<br>    IK_LOGIC,**<br>    IK_LSA<br>  &#125;;<br>  <span class="hljs-function">InstKind <span class="hljs-title">getKind</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Kind; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> InstKind Kind;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUMCInst</span> : <span class="hljs-keyword">public</span> CustomMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ALUMCInst</span>() : <span class="hljs-built_in">CustomMCInst</span>(IK_ALU) &#123;&#125;<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>    **<span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() &gt;= IK_ALU &amp;&amp; I-&gt;<span class="hljs-built_in">getKind</span>() &lt;= IK_LOGIC;**<br>  &#125;<br>&#125;;<br>**<span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUArithMCInst</span> : <span class="hljs-keyword">public</span> ALUMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ALUArithMCInst</span>() : <span class="hljs-built_in">ALUMCInst</span>(IK_ARITH) &#123;&#125;<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() == IK_ARITH;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALULogicMCInst</span> : <span class="hljs-keyword">public</span> ALUMCInst &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ALULogicMCInst</span>() : <span class="hljs-built_in">ALUMCInst</span>(IK_LOGIC) &#123;&#125;<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() == IK_LOGIC;<br>  &#125;<br>&#125;;**<br><br><span class="hljs-comment">// ... 省略 LSAMCInst 代码</span><br></code></pre></td></tr></table></figure><p>我们扩展了 <code>ALUMCInst::classof</code>中的实现，使用范围 enum 来将所有是 ALU 类型及其子类型的 InstKind 都考虑进来。然后，我们实现子类型 ALUArithMCInst 和 ALULogicMCInst 如之前。</p><p>这种实现需要留意避免调整 enum 顺序时造成 bug，更常见的做法可能是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ALUMCInst::classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() == IK_ALU || I-&gt;<span class="hljs-built_in">getKind</span>() == IK_ARITH || I-&gt;<span class="hljs-built_in">getKind</span>() == IK_LOGIC;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="潜在的-Bug"><a href="#潜在的-Bug" class="headerlink" title="潜在的 Bug"></a>潜在的 Bug</h2><p>难度：⭐⭐</p><p>应当仔细做到在这些非叶子类型非抽象类中，classof 总是能囊括所有的子类类型，在整个类继承结构完成之后，应该再次检查 classof 的正确性，以避免潜在 Bug。</p><p>LLVM 文档中提到可以借用假的 enum flag 来标记一类 Kind 的结束为止，从而让 classof 的维护没那么容易引入问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CustomMCInst</span>::InstKind &#123;<br>  IK_ALU,<br>  IK_ARITH,<br>  IK_LOGIC,<br>  **IK_ALU_END,**<br>  IK_LSA<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ALUMCInst::classof</span><span class="hljs-params">(<span class="hljs-type">const</span> CustomMCInst *I)</span> </span>&#123;<br>  **<span class="hljs-keyword">return</span> I-&gt;<span class="hljs-built_in">getKind</span>() &gt;= IK_ALU &amp;&amp; I-&gt;<span class="hljs-built_in">getKind</span>() &lt;= IK_ALU_END**; <br>&#125;<br></code></pre></td></tr></table></figure><p>尾区间选择开区间还是闭区间并不重要，毕竟不会有一个类型是假的 IK_ALU_END，当然为了避免意外使用，选择闭区间的出错概率可能低一些。</p><p>之后，我们如果想继续扩展 ALU 类指令，就只需要在 <code>CustomMCInst::InstKind</code> 中的 IK_ALU 和 IK_ALU_END 之间加入新类型即可，而不需要再次调整 <code>ALUMCInst::classof</code> 的实现。</p><h2 id="开放的类继承结构"><a href="#开放的类继承结构" class="headerlink" title="开放的类继承结构"></a>开放的类继承结构</h2><p>难度：⭐⭐⭐</p><p>前边描述实现 LLVM RTTI 的这套方法，依赖一个大前提，即我们需要在实现整个代码前，已经设计好了完整的类结构。</p><p>但如果因为业务需要，我们无法在设计完成时确定类继承结构，即我们的类结构是开放形式时，应该怎么实现 LLVM RTTI 呢，LLVM 文档中为我们简单介绍了一下它提供的一种新的机制：ExtensibleRTTI。</p><p>开放的继承结构，以本文例子来说，就是我们设计了整套 CustomMCInst 的类结构，但依然需要在将来由其他用户对这个类结构做扩展，而其他用户无法帮我们继续维护之前的 InstKind 和 classof 实现。</p><p>这种新机制和前文的方案完全无关，可以在需要时再进一步了解。</p><p>LLVM 提供了两个类：<code>RTTIRoot</code> 和 <code>RTTIExtends</code>，前者用来实现 RTTI 检查，后者提供了一种机制，使当前类型能够继承自 RTTIRoot，它接受两个模版参数，分别是当前类型和 RTTIRoot。</p><p>所有自定义类型（抽象类和派生类）都需要继承自 RTTIExtends，真正的继承关系由 RTTIExtends 负责建立。并且，所有自定义类型，都需要提供一个名为 <code>ID</code> 的 static char 成员，用来让 RTTIExtends 管理特定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMCInst</span> : **<span class="hljs-keyword">public</span> RTTIExtends&lt;CustomMCInst, RTTIRoot&gt;** &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CustomMCInst</span>() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  **<span class="hljs-type">static</span> <span class="hljs-type">char</span> ID;**<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ALUMCInst</span> : **<span class="hljs-keyword">public</span> RTTIExtends&lt;ALUMCInst, CustomMCInst&gt;** &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">MCOperand <span class="hljs-title">getDstOperand</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  **<span class="hljs-type">static</span> <span class="hljs-type">char</span> ID;**<br>&#125;;<br><br><span class="hljs-type">char</span> CustomMCInst::ID = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> ALUMCInst::ID = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这种实现方案，不再需要手动管理各种 Kind 和 classof，唯一需要的就是将所有类型都设计在 RTTIExtends 之下。</p><p>LLVM 文档提到，这种方案只有在开放结构中用，在其他场景下，还是应该使用之前介绍的标准 LLVM RTTI 方式。</p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>难度：⭐⭐⭐</p><p><code>isa/cast/dyn_cast</code> 这些接口的底层实现是 <code>CastInfo</code>，CastInfo 提供了 4 个方法，<code>isPossible</code>，<code>doCast</code>，<code>castFailed</code>，<code>doCastIfPossible</code>。这些方法用来对应实现 isa，cast，dyn_cast。</p><p>我们可以通过自定义 CastInfo 类型，来对这些 RTTI API 做更细致更灵活的定制。CastInfo 继承自 <code>CastIsPossible</code>，后者内部的实现就是我们前边介绍的，利用 classof 来决定类型判断和转换行为。</p><p>早前的实现中没有 CastInfo 这一层，这次写文时才看到 LLVM 更新了文档，介绍了这部分内容，简单看了下实现，但目前还没有用到过，感兴趣小伙伴可以到 <a href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html#advanced-use-cases">How to set up LLVM-style RTTI for your class hierarchy — LLVM 18.0.0git documentation</a> 了解或者看源码 <code>include/llvm/Support/Casting.h</code> 学习，其中写了很多注释帮助理解。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/650022272">LLVM 风格的 RTTI - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>LLVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么终端开发离不开 Tmux</title>
    <link href="/2023/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A6%BB%E4%B8%8D%E5%BC%80Tmux/"/>
    <url>/2023/06/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%88%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A6%BB%E4%B8%8D%E5%BC%80Tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="开头叨叨"><a href="#开头叨叨" class="headerlink" title="开头叨叨"></a>开头叨叨</h2><p>我在每天的软件开发工作中都离不开 tmux，它极大的提高了我的工作效率，我使用它优化我的工作流程，维护开发环境，并结合其他工具扩展软件开发的体验感。</p><p>如果你之前还没有听说过这个软件，我建议你花 20 分钟了解一下它。有非常多的程序员使用这个软件，尤其是需要连接到远程服务器进行开发的同学。但我发现目前中文网络上还很少有能系统的讲解 “为什么要使用 tmux” 的文章，大多数文章都是直接开门见山地罗列怎么配置 tmux，再拉个表格梳理难以记忆的快捷键清单。</p><p>在这篇文章中，我不会花大篇幅介绍怎么使用 tmux，而是告诉你为什么要用它，以及我自己实践很多年的使用技巧。</p><h2 id="三个-tmux-组件"><a href="#三个-tmux-组件" class="headerlink" title="三个 tmux 组件"></a>三个 tmux 组件</h2><p>在使用 tmux 之前，有三个重要的概念一定要了解，分别是 session，window 和 pane。简单介绍下。</p><ul><li>session 是会话，也就是和操作系统建立的一次通信状态，不过 tmux 中的 session 不同于直接用 shell 建立的 session，可以理解成一种虚拟 session；session 包含 window，默认启动 session 后会带有 1 个 window。</li><li>window 就是窗口，也就是展示在屏幕上能看到的全部内容，可以看做是窗口类软件的 tab；window 包含 pane，默认带有 1 个 pane。</li><li>pane 就是每一个分屏的窗格，tmux 允许对一个 window 做分屏，每个 “子屏“ 都叫做一个 pane。</li></ul><p>tmux 提供了各种快捷键来 create、rename、move、delete 这些组件，以及可以便捷的在这些组件之间切换。你可以任意使用这些组件搭建自己的工作环境。</p><h2 id="我的-tmux-工作流"><a href="#我的-tmux-工作流" class="headerlink" title="我的 tmux 工作流"></a>我的 tmux 工作流</h2><p>这里我介绍下我的环境，这是我工作中的一张截图：</p><p><img src="/img/20230623/img1.png" alt="Tmux工作截图"></p><p>tmux 体现在最下边一行，这一行叫做 tmux 状态栏。左下角是 当前聚焦的 session、window、pane 的 index，也就是光标所在的位置。这个单纯就是美观，实际工作中用处不大。</p><p>中间部分是当前 session 中所有 window 的 list，以及当前所在的 window。这个在切换 window 时可以参考。</p><p>右边只是一个日期和时间，用处也不是很大。</p><p>日常开发中，我的工作流是这样的：</p><ul><li>第一个窗口开发，第二个测试，第三个调试。可以随时开启临时窗口完成一些其他功能，用完后关闭。窗口之间切换使用 <code>shift + left</code> 和 <code>shift + right</code> ，操作和 window list 显示布局一致。非活跃窗口有消息时，状态栏会高亮提示。</li><li>每个窗口上的布局都不同，开发窗口左边用来编码，右边用来编译和 shell 操作。在编码时，会将左边 pane 全屏。pane 之间切换使用 <code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code> 和 <code>ctrl + l</code>，vim 癌晚期患者必备（vim 内部分屏切换也是这套按键，之后讲 vim 时我会提到怎么配置）。</li><li>以上所有布局都是同一个会话，这个会话用来做一件事情。当有其他更紧急的事情接手时，我会开启新的会话。经常有人找我验证一些其他问题，或者我手里同时有两三件事在推进，打工人都懂 😂。</li><li>下班后，直接关闭终端走人，第二天开终端后，我提前配好了 ssh 授信，所以可以自动连接并进入 tmux 环境。如果有多个 session，系统会询问我现在打算进入哪个 session。</li></ul><h2 id="最主要的功能点"><a href="#最主要的功能点" class="headerlink" title="最主要的功能点"></a>最主要的功能点</h2><p>那么，简单来说，tmux 有哪些很难被其他软件完美替代的功能呢？</p><ul><li><p>会话管理</p><p>  tmux 可以将会话和终端相分离。简单说就是我们使用终端运行任务，之后关闭终端或远程断开连接，都不影响任务的继续运行。这样我可以做到下班时断开 ssh 连接就好了，第二天上班建立 ssh 连接就可以恢复昨天的开发界面、窗口布局，以及查看昨晚编译和测试的结果。</p><p>  当程序员为了快速恢复环境而不关电脑，与公司为了省电要求下班关电脑之间产生冲突时，tmux 就是一个完美的解决方案 🐶。</p><p>  另外，你也不会希望遇到因为网络问题或电脑死机，导致 ssh 断连后，运行的程序和任务被 kill 掉的结果吧。</p><p>  另一个类似的软件是 screen，但 tmux 比 screen 要好用很多，建议使用 tmux。</p></li><li><p>分屏</p><p>  现在大多数终端软件都可以做到分屏，本地开发工作中， tmux 的分屏功能并不是必要的，甚至终端软件的分屏功能都不是必要的，完全可以使用 dwm 这种窗口管理器实现。</p><p>  但如果你是在远程服务器上开发，那么 tmux 的分屏还是很重要的，这意味着你不需要和服务器建立多个 ssh 连接。</p></li><li><p>自动化创建环境</p><p>  远程服务器并不常关机，所以启动 tmux 服务之后，一次配置好窗口布局和环境，可能很长时间都不需要再次配置了。</p><p>  但如果某一天你们 IT 突然发邮件说今晚 10 点停机维护，是不是就意味着我们的布局要重新配置了？</p><p>  其实不一定，tmux 的布局创建都是利用 tmux 指令来完成的，可以将创建布局的指令按类似 shell 脚本的原理配置好，每次需要配置时运行一次就好了。运行指令脚本需要 tmux 辅助工具，比如 tmuxp 来完成。</p></li><li><p>共享会话</p><p>  在远程开发工作中，我们可以将多个 host 端的终端连接到同一个 tmux session，这样可以实现一些需要多屏共享的需求。我自己不太用得到这个功能。</p></li></ul><h2 id="常用的几个命令"><a href="#常用的几个命令" class="headerlink" title="常用的几个命令"></a>常用的几个命令</h2><p>本着不给网络环境增加冗余信息的原则，怎么安装 tmux 我就不展开了。可以在这里了解：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>tmux 可以添加参数使用。以下是我常用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动新 session</span><br>tmux<br><br><span class="hljs-comment"># 查看 session list</span><br>tmux <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 接入 session</span><br>tmux attach -t &lt;session <span class="hljs-built_in">id</span>/name&gt;<br><br><span class="hljs-comment"># 关闭 session</span><br>tmux kill-session -t &lt;session-id/name&gt;<br><br><span class="hljs-comment"># 脱离 session</span><br>tmux detach<br><br><span class="hljs-comment"># 切换 session</span><br>tmux switch -t &lt;session-id/name&gt;<br><br><span class="hljs-comment"># 重命名 session</span><br>tmux rename-session -t &lt;session-id/name&gt; &lt;new-name&gt;<br></code></pre></td></tr></table></figure><h2 id="我的使用技巧"><a href="#我的使用技巧" class="headerlink" title="我的使用技巧"></a>我的使用技巧</h2><p>看到这里，想必我应该介绍清楚 tmux 为什么是终端开发必备软件了。</p><p>说它是神器，可能过誉了，但说它必不可少，这反而是大实话。不过，应该有很多小伙伴会在使用 tmux 时，被它复杂难懂的配置脚本和快捷键劝退。这部分内容，我会介绍一下我在使用 tmux 这些年，总结出来的一些经验和使用技巧，方便你再一次尝试这个软件，或者——如果你已经在用了——改进你的工作流。</p><h3 id="1-tmux-版本"><a href="#1-tmux-版本" class="headerlink" title="1 tmux 版本"></a>1 tmux 版本</h3><p>如果你刚刚使用 tmux，并且被配置脚本困扰，也许你会去网上搜搜别人是怎么配置的，然后拿过来后，却发现并不一定起作用，那么你可能需要考虑看看自己的 tmux 版本。</p><p>tmux 目前的最新版本是 3.3a，但很多 Linux 发行版中内置的 tmux 却是很久前的 2.6 甚至 2.2 版本。很遗憾，tmux 在版本更新过程中多次调整了它的配置接口，所以你参考的网上的配置和你自己使用的 tmux 版本可能不匹配。更悲剧的是，大多数人并没有意识到这个问题，所以他们在上传自己配置时，并不会说清这套配置的版本号。</p><p>我自己的 tmux 配置中写明了版本号，这应该是大家都去注意的，一个完善的配置文件，应该写清楚它适用的软件版本、运行说明、注意事项等。</p><p>使用 <code>tmux -V</code> 可以查看 tmux 版本。</p><h3 id="2-修改键位"><a href="#2-修改键位" class="headerlink" title="2 修改键位"></a>2 修改键位</h3><p>tmux 的默认键位是很反人类的，不但很难记得住，而且点击起来也很别扭。prefix 键，也就是 tmux 前缀键，本来其实就是两个键（默认的 <code>ctrl + b</code>），然而有些功能，却还需要 <code>shift</code> 键参与，比如 <code>prefix + %</code> ，看着像是两个键，实际上是四个键参与（<code>ctrl + b</code>, <code>shift + 5</code> ）。</p><p>每个人都会有自己的使用习惯，但大家能统一意见的始终是用 tmux 一定要改键。我的一些键位修改供参考：</p><ul><li>prefix 键：<code>ctrl + a</code></li><li>水平分屏：<code>prefix + -</code></li><li>垂直分屏：<code>prefix + \\</code></li><li>pane 之间移动：<code>ctrl + h</code>，<code>ctrl + j</code>，<code>ctrl + k</code>，<code>ctrl + l</code></li><li>window 之间移动：<code>shift + left</code>，<code>shift + right</code> （就是左右方向键）</li></ul><p>还有几个常用的按键没有改键：</p><ul><li>创建 window：<code>prefix + c</code></li><li>重命名 window：<code>prefix + ,</code></li><li>将当前 pane 全屏：<code>prefix + z</code></li></ul><h3 id="3-复制粘贴"><a href="#3-复制粘贴" class="headerlink" title="3 复制粘贴"></a>3 复制粘贴</h3><p>这个问题应该是网络上和 tmux 相关的问题中，搜索次数最多的问题了。同样的，在不同版本的 tmux 中，解决这个问题的方案并不相同。在最新的 3.3a 版本中，我认为复制粘贴的功能已经比较好用了。</p><ul><li><p>第一种情况，在本机使用 tmux。</p><p>  tmux 原生支持的方案是：使用 <code>prefix + [</code> 进入选择模式，控制光标到一段文字的开头，<code>space</code> 开始选择，继续移动光标选中需要复制的内容，<code>enter</code> 确认复制，并自动退出选择模式。这时内容就会被复制到剪切板。<code>prefix + ]</code> 来粘贴。如果 tmux 配置开启了鼠标增强模式，还可以用鼠标选取内容，右键弹出菜单操作。</p><p>  如果你的终端能支持适配 tmux，那么直接用鼠标选取内容，内容就会自动复制到系统剪切板中，右键粘贴或弹出右键菜单粘贴，比如 mac 上使用 iterm2 可以做到。</p></li><li><p>第二种情况，通过远程终端连接使用 tmux。</p><p>  tmux 无法解析出你在 host 端选取的文字，也就无法把它复制到剪切板中，所以不能依赖鼠标选择。你依然可以使用的是 tmux 原生方案，因为 tmux 会将内容复制到服务器那边系统的剪切板，那么在终端中再粘贴也就没有问题了。</p><p>  但是，如果希望将内容复制到 host 这边，这种办法就行不通了。可行的办法是直接利用当前终端的复制粘贴功能，直接鼠标选择文本来复制和粘贴。如果开启了鼠标增强模式，那么 tmux 会接管鼠标选择功能，绕开它的办法是按住 <code>shift</code> 键的同时来选择复制和粘贴。当然，这种方法自动滚屏就失效了。</p><p>  还有一种我听说的方案，是利用其他软件专门同步远程服务器的剪切板和 host 机器的剪切板，Github 上有类似的项目，感兴趣可以了解一下。</p></li></ul><p>如果我说的这些还不能满足你的需要，可能你得自己再摸索摸索了，远程访问模式本来对复制粘贴就不友好，也许最不会产生心智负担的方案就是文件传输吧 😆。</p><p>我自己不常使用复制粘贴的功能，粘贴代码这种行为，往外边粘，公司安全部门不同意，往里边粘，公司法务部门不开心。如果是粘贴报错信息或者运行日志，可能提炼关键点更有利于解决问题。</p><h3 id="4-美化"><a href="#4-美化" class="headerlink" title="4 美化"></a>4 美化</h3><p>有关于状态栏的美化就不说了，网络上很多类似的帖子。</p><p>我说几个不常见的：</p><ul><li><p>tmux 和 neovim 配合实现不同 mode 下变化光标样式：</p><p>  在 .tmux.conf 中配置这个命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set-option -sa terminal-overrides &#x27;*:Ss=\\E[%p1%d q:Se=\\E[ q&#x27;<br></code></pre></td></tr></table></figure><p>  一定要注意一点，这个配置 是在 neovim 0.9 + zsh + tmux 3.3a 下才能生效。vim 需要配置一下也能实现相同的效果。你可能还需要考虑不同终端软件可能对光标样式做的主动更改。</p></li><li><p>斜体字体。如果终端能够显示斜体字，但打开 tmux 中却不显示，那么需要这么配置：</p><p>  在用户根目录下创建名为 <code>screen-256color.terminfo</code> 的文件，内容为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># A screen-256color based TERMINFO that adds the escape sequences for italic.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Install:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   tic screen-256color.terminfo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Usage:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   export TERM=screen-256color</span><br><span class="hljs-comment">#</span><br>screen-256color|screen with 256 colors and italic,<br>        sitm=\\E[3m, ritm=\\E[23m,<br>        use=screen-256color,<br></code></pre></td></tr></table></figure><p>  终端执行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tic screen-256color.terminfo<br></code></pre></td></tr></table></figure><p>  在 shell 脚本中配置这个环境变量并 source：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> TERM=screen-256color<br></code></pre></td></tr></table></figure><p>  在 .tmux.conf 中加入以下配置：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g default-terminal <span class="hljs-string">&quot;screen-256color&quot;</span><br></code></pre></td></tr></table></figure><p>  为了在 vim 中也能显示斜体字，还需要在 .vimrc 中加入以下配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vimrc">let &amp;t_ZH=&quot;\\e[3m&quot;<br>let &amp;t_ZR=&quot;\\e[23m&quot;<br><br># 或者如果是 neovim，在 init.lua 中加入：<br>vim.g.t_ZH = &quot;\\\\e[3m&quot;<br>vim.g.t_ZR = &quot;\\\\e[23m&quot;<br></code></pre></td></tr></table></figure></li><li><p>支持真彩色</p><p>  真彩色是 24 位颜色，比 256-color（8 位）更艳丽，对于很多插件，尤其是终端和 vim 中的色彩主题，开启真彩色会显示更好的视觉效果。</p><p>  首先需要你的终端支持真彩色，新一些的终端都支持，可以使用这个脚本验证：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fL &lt;https://raw.githubusercontent.com/Beavan/tools/master/sh/24-bit-color.sh&gt; |bash<br></code></pre></td></tr></table></figure><p>  如果显示的颜色条没有明显的色彩块边界，那么就是真彩色了。</p><p>  在 .tmux.conf 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set -g default-terminal &quot;screen-256color&quot;<br>set-option -ga terminal-overrides &quot;,*256col*:Tc&quot;<br></code></pre></td></tr></table></figure><p>  vim 中支持真彩色，还需要在 .vimrc 中加入：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set termguicolors<br><br># neovim 在 init.lua 中加入<br>vim.opt.termguicolors = true<br></code></pre></td></tr></table></figure></li><li><p>实现当前 pane 的背景突出显示。</p><p>  iterm2 有这么个效果，当分屏后，当前光标所在屏幕会正常显示，而其他屏幕会变灰。tmux 也可以实现这种效果。</p><p>  在 .tmux.conf 中添加这个配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tmux">set -g window-style &#x27;fg=grey62,bg=grey19&#x27;<br>set -g window-active-style &#x27;fg=terminal,bg=terminal&#x27;<br></code></pre></td></tr></table></figure><p>  颜色可以自己随意改，试了下是 256 color。效果不如 iterm2 好，但我感觉足够用了。</p></li><li><p>状态栏背景和终端样式保持一致。</p><p>  比如说我的终端是磨砂效果，我不想显示 tmux 的绿色大横条。那么可以配置 status bar 的 style：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tmux"># 在 3.2 及更新版本中<br>set-option -g status-style bg=default<br><br># 在较旧的版本中<br>set-option -g status-bg default<br></code></pre></td></tr></table></figure></li></ul><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这些内容零散的躺在我的笔记中很久了，终于有机会整理成文。</p><p>如果你之前没有使用过 tmux，看过这篇文章可能并不会帮你完全熟悉这个软件，任何软件的熟练使用都依赖于 “尝试” 和 “探索”。如果能吸引你 “入坑”， 或者其中有一些能值得你参考的内容，那我这篇文章就没白写。</p><p>有疑问和请求都可以给我留言，也请 feel free 指出文中的错误。</p><h2 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h2><p>本文同步发布在知乎账号下 <a href="https://zhuanlan.zhihu.com/p/639084118">https://zhuanlan.zhihu.com/p/639084118</a></p>]]></content>
    
    
    <categories>
      
      <category>软件工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tmux</tag>
      
      <tag>终端开发</tag>
      
      <tag>Terminal</tag>
      
      <tag>软件工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
