<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>LLVM 后端实践笔记 3：算术和逻辑指令 | P2Tree's Mill</title><meta name="author" content="P2Tree"><meta name="copyright" content="P2Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这一章首先增加了更多的 Cpu0 算术运算指令和逻辑运算指令，这些在各个优化步骤中存在的 DAG 转换过程可以使用 Graphviz 来图形化显示，展示出更多的有效信息。不同于上一章，在这一章中，你应该专注于 C 代码的操作和 llvm IR 之间的映射以及如何在 td 文件中描述更复杂的 IR 与指令。这一章定义了另外一些寄存器类，你需要了解为什么需要它们，如果有些设计没有看懂，可能是对 Cpu"><meta property="og:type" content="article"><meta property="og:title" content="LLVM 后端实践笔记 3：算术和逻辑指令"><meta property="og:url" content="https://p2tree.top/posts/1268381.html"><meta property="og:site_name" content="P2Tree&#39;s Mill"><meta property="og:description" content="这一章首先增加了更多的 Cpu0 算术运算指令和逻辑运算指令，这些在各个优化步骤中存在的 DAG 转换过程可以使用 Graphviz 来图形化显示，展示出更多的有效信息。不同于上一章，在这一章中，你应该专注于 C 代码的操作和 llvm IR 之间的映射以及如何在 td 文件中描述更复杂的 IR 与指令。这一章定义了另外一些寄存器类，你需要了解为什么需要它们，如果有些设计没有看懂，可能是对 Cpu"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.p2tree.top/2021/04/05/index.webp"><meta property="article:published_time" content="2021-04-05T23:24:42.000Z"><meta property="article:modified_time" content="2021-04-05T23:24:42.000Z"><meta property="article:author" content="P2Tree"><meta property="article:tag" content="编译器"><meta property="article:tag" content="LLVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.p2tree.top/2021/04/05/index.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LLVM 后端实践笔记 3：算术和逻辑指令",
  "url": "https://p2tree.top/posts/1268381.html",
  "image": "https://img.p2tree.top/2021/04/05/index.webp",
  "datePublished": "2021-04-05T23:24:42.000Z",
  "dateModified": "2021-04-05T23:24:42.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "P2Tree",
      "url": "https://p2tree.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://img.p2tree.top/avatar.webp"><link rel="canonical" href="https://p2tree.top/posts/1268381.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=5.5.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.29/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",()=>{void 0===t.get("theme")&&(e.matches?o():a())})}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-2M9BYWL9WW"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2M9BYWL9WW"),btf.addGlobalFn("pjaxComplete",()=>{gtag("config","G-2M9BYWL9WW",{page_path:window.location.pathname})},"google_analytics")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"D6LVAK5RKB",apiKey:"f6946a241b05432428a3e4fc6e7ba9e7",indexName:"my-hexo-blog",hitsPerPage:6,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!0,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:500,languages:{author:"作者: P2Tree",link:"链接: ",source:"来源: P2Tree's Mill",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"LLVM 后端实践笔记 3：算术和逻辑指令",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="baidu-site-verification" content="codeva-Watq1Co2vC"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4649427_nfzovmtn6c.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/hexo-butterfly-footer-marcus/lib/footer.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="P2Tree's Mill" type="application/atom+xml">
</head><body><script>window.paceOptions={restartOnPushState:!1},btf.addGlobalFn("pjaxSend",()=>{Pace.restart()},"pace_restart")</script><link rel="stylesheet" href="/css/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://img.p2tree.top/avatar.webp" onerror='this.onerror=null,this.src="/img/404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pen-to-square"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文踪</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.p2tree.top/2021/04/05/index.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">P2Tree's Mill</span></a><a class="nav-page-title" href="/"><span class="site-name">LLVM 后端实践笔记 3：算术和逻辑指令</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pen-to-square"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文踪</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">LLVM 后端实践笔记 3：算术和逻辑指令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-05T23:24:42.000Z" title="发表于 2021-04-05 23:24:42">2021-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-05T23:24:42.000Z" title="更新于 2021-04-05 23:24:42">2021-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:1000,&quot;messagePrev&quot;:&quot;距离上次更新已过去&quot;,&quot;messageNext&quot;:&quot;天，文章中的部分内容可能已经过时，请酌情参考～&quot;,&quot;postUpdate&quot;:&quot;2021-04-05 23:24:42&quot;}" hidden></div><p>这一章首先增加了更多的 Cpu0 算术运算指令和逻辑运算指令，这些在各个优化步骤中存在的 DAG 转换过程可以使用 Graphviz 来图形化显示，展示出更多的有效信息。不同于上一章，在这一章中，你应该专注于 C 代码的操作和 llvm IR 之间的映射以及如何在 td 文件中描述更复杂的 IR 与指令。这一章定义了另外一些寄存器类，你需要了解为什么需要它们，如果有些设计没有看懂，可能是对 Cpu0 的硬件不够熟悉，可以结合硬件来理解。</p><ol class="series-items"><li><a href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a></li><li><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a></li><li><a href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a></li><li><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a></li><li><a href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a></li><li><a href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a></li><li><a href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a></li><li><a href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a></li><li><a href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a></li><li><a href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a></li><li><a href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a></li><li><a href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></li></ol><hr><h2 id="3-1-算术运算"><a href="#3-1-算术运算" class="headerlink" title="3.1 算术运算"></a>3.1 算术运算</h2><h3 id="3-1-1-简要说明"><a href="#3-1-1-简要说明" class="headerlink" title="3.1.1 简要说明"></a>3.1.1 简要说明</h3><h4 id="1-乘法和移位运算"><a href="#1-乘法和移位运算" class="headerlink" title="(1) 乘法和移位运算"></a>(1) 乘法和移位运算</h4><p>C 语言中的加法（<code>+</code>）、减法（<code>-</code>）和乘法（<code>*</code>）运算符通过 <code>add</code>，<code>addu</code>，<code>sub</code>，<code>subu</code> 和 <code>mul</code> 指令来实现，左移（&lt;&lt;） 和右移（&gt;&gt;） 运算符通过 <code>shl</code>， <code>shlv</code>， <code>sra</code>， <code>srav</code>， <code>shr</code>， <code>shrv</code> 指令来实现。C 语言中右移负数位数操作的原语（比如右移 -1 位）是基于实现的，大多数编译器会将其翻译为算术右移。</p><p>对应到 llvm IR 中的指令分别是 <code>add</code>，<code>sub</code>，<code>mul</code>，<code>shl</code>，<code>ashr</code>，<code>lshr</code> 等，<code>ashr</code> 表示算术右移，或者说是符号扩展右移；<code>lshr</code> 表示逻辑右移，或者说是零扩展右移。不过，在 DAG node 中，使用 <code>sra</code> 表示 <code>ashr</code> 的 IR 指令，使用 <code>srl</code> 表示 <code>lshr</code> 的 IR 指令，看起来不是很直观，可能是历史设计的问题。</p><p>右移操作在不同的阶段的符号表示对应如：</p><table><thead><tr><th>描述</th><th>零扩展移位</th><th>符号扩展移位</th></tr></thead><tbody><tr><td>LLVM IR 中指令（.bc）</td><td>lshr</td><td>ashr</td></tr><tr><td>DAG node 中符号</td><td>srl</td><td>sra</td></tr><tr><td>Mips 指令</td><td>srl</td><td>sra</td></tr><tr><td>Cpu0 指令</td><td>shr</td><td>sra</td></tr></tbody></table><p>如果我们认为右移 1 位等效于对右移数字除以 2，在逻辑右移中，对于一些有符号数，结果有可能是错的；在算术右移中，对于一些无符号数，结果也是错的。同理，对于左移操作，也不能单纯的用乘除法取代。比如，有符号数 <code>0xfffffffe</code>（-2）做逻辑右移，得到 <code>0x7fffffff</code>（2G-1），我们期望得到 -1，却得到一个大数；无符号数 <code>0xfffffffe</code>（4G-2）做算术右移，得到 <code>0xffffffff</code>（4G-1），我们期望得到 2G-1，却得到 4G-1；有符号的 <code>0x40000000</code>（1G）做逻辑左移，是 <code>0x80000000</code>（-2G），我们期望的应该是 2G 却得到了 -2G。所以我们不能用乘除法指令来替代移位指令，必须要设计专用的硬件移位指令。</p><h4 id="2-除法和求余运算"><a href="#2-除法和求余运算" class="headerlink" title="(2) 除法和求余运算"></a>(2) 除法和求余运算</h4><p>llvm IR 中的除法是 <code>sdiv</code> 和 <code>udiv</code> 指令，不必多言。求余是 <code>srem</code> 和 <code>urem</code> 指令，这个指令接受一个整型值作为操作数（也可以是整形值元素的向量），它返回一个除法操作的余数。通常情况下数学上有多种对余数的定义，比如最接近 0 的那个余数，或者最接近负无穷大的那个余数，这里的余数定义是与被除数（第一个操作数）一致符号的余数（或能整除时为 0）。<code>srem</code> 是有符号数的求余，<code>urem</code> 是无符号数的求余指令。</p><p>除 0 后的余数是未定义行为，除法溢出也是未定义行为，和硬件实现相关。</p><p>LLVM 默认会把 <strong>带立即数的</strong> 除法和求余操作通过一个算法转换为利用有符号高位乘法 <code>mulhs</code> 来实现，但我们目前没有 <code>mulhs</code>，所以这个通路有问题。（LLVM 这么做的原因是，乘法操作在硬件上通常比除法操作更省资源，所以会尽量把除法转换成乘法来做）</p><p>为了支持 <code>mulhs</code> 这种操作，Mips 的做法是用 <code>mult</code> 指令（硬件指令）来将乘法运算结果的高 32 位放到 HI 寄存器，将低 32 位结果放到 LO 寄存器。然后使用 <code>mfhi</code> 和 <code>mflo</code> 硬件指令来将两部分结果移动到通用寄存器中。 我们的 Cpu0 也在这块采用这种实现方式。</p><p>llvm DAG node 中定义了 <code>mulhs</code> 和 <code>mulhu</code>，我们需要在 DAGToDAG 指令选择期间，将其转换为 <code>mult + mfhi</code> 的动作，这就是接下来实现 <code>selectMULT()</code> 函数的一部分功能。只有将 llvm IR 期间的 <code>mulhs</code> &#x2F; <code>mulhu</code> 替换为 Cpu0 硬件支持的操作，才不会在后续报错（另外，如果我们的后端能够直接支持 <code>mulh</code> 指令是最好的，但 Cpu0 没有支持）。</p><p>然后，我们来讨论一下如果求余操作的操作数不是立即数的情况。这时，LLVM 就会乖乖的生成除法求余的 node 了，这个 node 是 <code>ISD::SDIVREM</code> 和 <code>ISD::UDIVREM</code>，是除法和求余操作统一的 node。刚好我们的 Cpu0 支持一个 <code>div</code> 指令，这个指令的功能是将一个除法操作的商放到 LO 寄存器，将余数（满足我们上边说的那种规则的余数）放到 HI 寄存器。我们只需要使用 <code>mfhi</code> 和 <code>mflo</code> 指令将这两部分按需求取出来就好。</p><p>求余操作在不同阶段的符号表示如：</p><table><thead><tr><th>阶段</th><th>符号</th><th>相关函数</th></tr></thead><tbody><tr><td>llvm IR 指令</td><td>srem</td><td></td></tr><tr><td>DAG 指令选择的合法化阶段</td><td>sdivrem</td><td>setOperandAction(ISD::SREM, MVT::i32, Expand)</td></tr><tr><td>DAG 指令选择的优化合法化阶段</td><td>Cpu0ISD::DivRem, CopyFromReg xx, Hi, Cpu0ISD::DivRem</td><td>setTargetDAGCombine(ISD::SDIVREM)</td></tr><tr><td>指令模式匹配</td><td>div, mfhi</td><td>Cpu0InstrInfo.td 中的 SDIV, MFLO</td></tr></tbody></table><p>在<code>Cpu0ISelLowering.cpp</code> 中，注册了 <code>setOperationAction(ISD::SREM, MVT::i32, Expand)</code> 等操作，将 <code>ISD::SREM</code> lowering 到 <code>ISD::SDIVREM</code>（有关于 Expand 的参考资料，可以查看 <a target="_blank" rel="noopener" href="http://llvm.org/docs/WritingAnLLVMBackend.html#expand">http://llvm.org/docs/WritingAnLLVMBackend.html#expand</a>）。然后实现了 <code>PerformDAGCombine()</code> 函数，将 <code>ISD::SDIVREM</code> 根据它是除法还是求余（通过 <code>SDNode-&gt;hasAnyUseOfValue(0)</code> 来判断）操作，选择生成 <code>div + mflo / mfhi</code> 的 机器相关的 DAG，进而指令选择到机器汇编指令。</p><h3 id="3-1-2-文件修改"><a href="#3-1-2-文件修改" class="headerlink" title="3.1.2 文件修改"></a>3.1.2 文件修改</h3><h4 id="1-Cpu0Subtarget-cpp"><a href="#1-Cpu0Subtarget-cpp" class="headerlink" title="(1) Cpu0Subtarget.cpp"></a>(1) Cpu0Subtarget.cpp</h4><p>这个文件中新增了一个控制溢出处理方式的命令行选项：<code>-cpu0-enable-overflow</code>，默认是 false，如果在调用 llc 时的命令行中使用这个选项，则为 true。false 时，表示当算术运算出现溢出时，会触发 overflow 异常，true 时，表示算术运算出现溢出时，会截断运算结果。我们将 <code>add</code> 和 <code>sub</code> 指令设计为溢出时触发 overflow 异常，把 <code>addu</code> 和 <code>subu</code> 设计为不会触发异常，而是截断结果。</p><p>在 subtarget 中，将命令行选项的结果传入 EnableOverflow 类属性。</p><h4 id="2-Cpu0InstrInfo-td"><a href="#2-Cpu0InstrInfo-td" class="headerlink" title="(2) Cpu0InstrInfo.td"></a>(2) Cpu0InstrInfo.td</h4><p>新增了不少指令和节点的描述。</p><p>四则运算指令 <code>subu</code>，<code>add</code>，<code>sub</code>，<code>mul</code>，<code>mult</code>，<code>multu</code>，<code>div</code>，<code>divu</code>，其中 <code>mult</code> 和 <code>mul</code> 的区别是，<code>mult</code> 可以处理 64 位运算结果，为了能保存 64 位结果，Cpu0 引入两个寄存器 Hi 和 Lo，专用于保存 <code>mult</code> 的高 32 位和低 32 位运算结果（当然它还可以保存 <code>div</code> 的商和余数）。<code>mult</code> 和 <code>multu</code> 表示对符号扩展的值和对零扩展的值分别处理。</p><p>移位指令 <code>rol</code>， <code>ror</code>，<code>sra</code>，<code>shr</code>，<code>srav</code>，<code>shlv</code>，<code>shrv</code>，<code>rolv</code>，<code>rorv</code>，因为移位需要考虑是否是循环移位、逻辑移位还是算术移位等问题，所以衍生出多个指令，带 v 结尾的指令表示移位值存在寄存器中作为操作数。</p><p>其他辅助指令 <code>mfhi</code>，<code>mflo</code>，<code>mthi</code>，<code>mtlo</code>，<code>mfc0</code>，<code>mtc0</code>，<code>c0mov</code>，为了能将乘除法的结果返回到寄存器，需要提供 Hi 和 Lo 寄存器与通用寄存器之间的 move。C0 是一个协处理寄存器，目前还没有用途，一并实现。</p><h4 id="3-Cpu0ISelLowering-h-cpp"><a href="#3-Cpu0ISelLowering-h-cpp" class="headerlink" title="(3) Cpu0ISelLowering.h&#x2F;.cpp"></a>(3) Cpu0ISelLowering.h&#x2F;.cpp</h4><p>在这里特殊处理除法和求余运算的 lowering 操作，实现了一个 <code>performDivRemCombine</code> 动作，这是因为在 DAG 中，除法和求余的节点是同一个节点，叫 <code>ISD::SDIVREM</code>，节点中有个值来表示这个节点是计算商还是计算余数，虽然 Cpu0 后端本身并不关心要计算哪个值，因为都是通过 div 来计算的，但 DAG 一级还是会根据 C 代码的逻辑来区分的。当然我们的输出也需要考虑把哪个值（Hi 或 Lo）返回。<code>div</code> 运算会将商放到 Lo 寄存器，将余数放到 Hi 寄存器。</p><p>这里还设计了类型合法化的声明，使用 <code>setOperationAction</code> 函数，指定将 <code>div</code> 和 <code>rem</code> 在对 i32 类型下的操作做 expand，其实是指定使用 LLVM 内置的函数来展开他们的实现（位于 <code>TargetLowering.cpp</code> 中）。</p><h4 id="4-Cpu0RegisterInfo-td"><a href="#4-Cpu0RegisterInfo-td" class="headerlink" title="(4) Cpu0RegisterInfo.td"></a>(4) Cpu0RegisterInfo.td</h4><p>实现了 Hi 和 Lo 寄存器，以及 HILO 寄存器组。</p><h4 id="5-Cpu0Schedule-td"><a href="#5-Cpu0Schedule-td" class="headerlink" title="(5) Cpu0Schedule.td"></a>(5) Cpu0Schedule.td</h4><p>实现了乘除法和 HILO 操作的指令行程类。</p><h4 id="6-Cpu0SEISelDAGToDAG-h-cpp"><a href="#6-Cpu0SEISelDAGToDAG-h-cpp" class="headerlink" title="(6) Cpu0SEISelDAGToDAG.h&#x2F;.cpp"></a>(6) Cpu0SEISelDAGToDAG.h&#x2F;.cpp</h4><p>实现了 <code>selectMULT()</code> 函数，用来处理乘法的高低位运算。在 ISD 中的乘法是区分 MUL 和 MULH 的，也就是用两个不同的 Node 来分别处理乘法返回低 32 位和高 32 位。</p><p><code>selectMULT()</code> 会放到 <code>trySelect()</code> 接口函数中，专用来处理 MULH 的特殊情况，并将 Hi 作为返回值创建新的 Node。</p><h4 id="7-Cpu0SEInstrInfo-h-cpp"><a href="#7-Cpu0SEInstrInfo-h-cpp" class="headerlink" title="(7) Cpu0SEInstrInfo.h&#x2F;.cpp"></a>(7) Cpu0SEInstrInfo.h&#x2F;.cpp</h4><p>实现了 <code>copyPhysReg()</code> 函数，用来生成一些寄存器 move 的操作，会根据要移动的寄存器类型，生成不同的指令来处理。这个函数是基类的虚函数，直接覆盖实现，不需要考虑调用问题。</p><p>如果目的寄存器和源寄存器都是通用寄存器，会使用 <code>addu</code> 来完成，这是一种通用做法。如果源寄存器是 Hi 或 Lo，会选择生成 <code>mfhi</code> 或 <code>mflo</code> 来处理。反之，如果目的寄存器是 Hi 或 Lo，会选择生成 <code>mthi</code> 和 <code>mtlo</code> 来处理。</p><p>这里作为最后的指令选择阶段，会使用 BuildMI 直接生成 MI 结构。</p><h3 id="3-1-3-检验成果"><a href="#3-1-3-检验成果" class="headerlink" title="3.1.3 检验成果"></a>3.1.3 检验成果</h3><p>构建编译器之后。执行（test.ll 换成具体文件名）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -target mips-unknown-linux-gnu test.c -emit-llvm -S -o test.ll</span><br></pre></td></tr></table></figure><p>观察 llvm IR 的结果。执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -march=cpu0 -relocation-model=pic -filetype=asm test.ll -o test.s</span><br></pre></td></tr></table></figure><p>观察输出汇编的结果。</p><h4 id="1-乘法和移位操作"><a href="#1-乘法和移位操作" class="headerlink" title="(1) 乘法和移位操作"></a>(1) 乘法和移位操作</h4><p>我提供了一个 ch3_1_math.c 的例子，可以查看加减乘除法和移位运算符的输出结果。</p><p>对于将变量移位一个字面常量的位数的操作（如 <code>a &gt;&gt; 2</code>），会 lowering 为带立即数操作数的移位操作；对于将字面常量移位一个变量指定的位数的操作，（如 <code>1 &lt;&lt; b</code>），会 lowering 为带寄存器操作数的移位操作，并将字面常量通过 <code>addi</code> 移入要移位的寄存器中。</p><p>还记得我们的 <code>-cpu0-enable-overflow</code> 编译选项吧，它可以让编译器生成 <code>addu</code> 和 <code>subu</code>指令（这两个指令是会截断加减法结果的）或者 <code>add</code> 和 <code>sub</code>（这两个指令是会抛出溢出错误的）。</p><p>使用 ch3_1_addsuboverflow.c 示例，不加该选项（默认是 false），可以查看汇编代码中，是否生成了 <code>addu</code> 和 <code>subu</code> 指令。然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -march=cpu0 -relocation-model=pic -filetype=asm -cpu0-enable-overflow=true ch3_1_addsuboverflow.ll -o ch3_1_addsuboverflow.s</span><br></pre></td></tr></table></figure><p>再次查看汇编输出，发现生成了 <code>add</code> 和 <code>sub</code> 来替代 <code>addu</code> 和 <code>subu</code>。</p><p>现代 CPU 中的习惯做法是使用截断上溢的加减法。不过，我们提供了这个选项，就可以允许程序员生成需要抛出溢出异常的加减法，这可能有助于调试程序和修复 bug。</p><p>编译 ch3_1_rotate.c 这个例子，我们的 clang 会将某种 c 语言的组合解析为循环移位（如 <code>(a &lt;&lt; 30) | (a &gt;&gt; 2)</code> 这种）。最后的汇编代码中会生成 <code>rol</code> 指令。</p><p>不过，对于 <code>rolv</code> 和 <code>rorv</code> 这两个指令，因为它们依赖于逻辑运算 <code>or</code> 指令来做后续的数值运算，所以当前还无法测试，也就是说，移位操作是寄存器的逻辑代码（如 <code>(a &lt;&lt; n) | (a &gt;&gt; (32 - n))</code>），还无法正常输出汇编指令。实现了下一小节内容之后，可以再回来测试这块功能。</p><h4 id="2-除法和求余操作"><a href="#2-除法和求余操作" class="headerlink" title="(2) 除法和求余操作"></a>(2) 除法和求余操作</h4><p>我们先执行一下 ch3_1_mult_mod.c 这个例子，这个例子中是个求余操作，但因为我们上边叙述的，LLVM 对待字面常量的输入做求余时，会转换成乘法来执行，所以这个例子的汇编输出将会是 <code>mult</code> 和 <code>mul</code> 来实现的求余动作。</p><p>然后再看一下 ch3_1_mod.c 这个例子，我将字面常量替换成一个变量，查看汇编输出，会发现使用了 <code>div</code> 来实现求余动作。需要注意的是，编译器在开优化的情况下，会做常量传播优化，将我们的变量直接替换为立即数，并再次通过 <code>mult</code> 和 <code>mul</code> 来实现。可以使用 volatile 来修饰变量，从而避免编译器优化。</p><p>同理可以再试一下 ch3_1_mult_div.c 和 ch3_1_div.c 这两个例子，可以得到类似的结果。</p><h2 id="3-2-逻辑运算"><a href="#3-2-逻辑运算" class="headerlink" title="3.2 逻辑运算"></a>3.2 逻辑运算</h2><p>这一小节新增一些逻辑运算，比如位运算 <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>!</code> 和比较运算 <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>。实现部分并不复杂。</p><h3 id="3-2-1-简要说明"><a href="#3-2-1-简要说明" class="headerlink" title="3.2.1 简要说明"></a>3.2.1 简要说明</h3><p>需要说明的一个设计是，在 cpu032I 中使用 <code>cmp</code> 指令完成比较操作，但在 cpu032II 中使用 <code>slt</code> 指令作为替代，<code>slt</code> 指令比 <code>cmp</code> 指令有优势，它使用通用寄存器来代替 <code>$sw</code> 寄存器，能够使用更少的指令来完成比较运算，我们在第 1 章中叙述过这个话题。</p><p>比较运算 <code>cmp</code> 指令返回的值是 <code>$sw</code> 寄存器编码值，所以要针对我们的需要做一次转换，比如说我们要计算 <code>a &lt; b</code>，指令中是 <code>cmp $sw, a, b</code>，我们要将 <code>$sw</code> 中的值分析出来，并最终将比较结果放到一个新的寄存器中。</p><p>虽然 <code>slt</code> 指令返回一个普通寄存器的值，但因为它计算的是小于的结果，所以如果我们需要计算 <code>a &gt;= b</code>，那就要对其结果做取反的运算。这种操作会在下边详细叙述。</p><p>以下是比较运算的 LLVM IR、DAG node 和汇编的两种实现：</p><p>1.等于 <code>==</code></p><p>LLVM IR：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = icmp eq i32 %0, %1</span><br><span class="line">%conv = zext i1 %cmp to i32</span><br></pre></td></tr></table></figure><p>DAG node:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = (setcc %0, %1, seteq)</span><br><span class="line">and %cmp, 1</span><br></pre></td></tr></table></figure><p>汇编:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// cpu032I</span><br><span class="line">cmp $sw, $3, $2</span><br><span class="line">andi $2, $sw, 2</span><br><span class="line">shr $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br><span class="line">// cpu032II</span><br><span class="line">xor $2, $3, $2</span><br><span class="line">sltiu $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br></pre></td></tr></table></figure><p>2.不等于 <code>!=</code></p><p>LLVM IR:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = icmp ne i32 %0, %1</span><br><span class="line">%conv = zext i1 %cmp to i32</span><br></pre></td></tr></table></figure><p>DAG node:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = (setcc %0, %1, setne)</span><br><span class="line">and %cmp, 1</span><br></pre></td></tr></table></figure><p>汇编:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// cpu032I</span><br><span class="line">cmp %sw, $3, $2</span><br><span class="line">andi $2, $sw, 2</span><br><span class="line">shr $2, $2, 1</span><br><span class="line">xori $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br><span class="line">// cpu032II</span><br><span class="line">xor $2, $3, $2</span><br><span class="line">sltu $2, $zero, $2</span><br><span class="line">andi $2, $2, 1</span><br></pre></td></tr></table></figure><p>3.小于 <code>&lt;</code></p><p>LLVM IR:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = icmp lt i32 %0, %1</span><br><span class="line">%conv = zext i1 %cmp to i32</span><br></pre></td></tr></table></figure><p>DAG node:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = (setcc %0, %1, setlt)</span><br><span class="line">and %cmp, 1</span><br></pre></td></tr></table></figure><p>汇编:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// cpu032I</span><br><span class="line">cmp $sw, $3, $2</span><br><span class="line">andi $2, $sw, 1</span><br><span class="line">andi $2, $2, 1</span><br><span class="line">// cpu032II</span><br><span class="line">slt $2, $3, $2</span><br><span class="line">andi $2, $2, 1</span><br></pre></td></tr></table></figure><p>4.小于等于 <code>&lt;=</code></p><p>LLVM IR:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = icmp le i32 %0, %1</span><br><span class="line">%conv = zext i1 %cmp to i32</span><br></pre></td></tr></table></figure><p>DAG node:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = (setcc %0, %1, setle)</span><br><span class="line">and %cmp, 1</span><br></pre></td></tr></table></figure><p>汇编:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// cpu032I</span><br><span class="line">cmp $sw, $2, $3</span><br><span class="line">andi $2, $sw, 1</span><br><span class="line">xori $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br><span class="line">// cpu032II</span><br><span class="line">slt $2, $3, $2</span><br><span class="line">xori $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br></pre></td></tr></table></figure><p>5.大于 <code>&gt;</code></p><p>LLVM IR:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = icmp gt i32 %0, %1</span><br><span class="line">%conv = zext i1 %cmp to i32</span><br></pre></td></tr></table></figure><p>DAG node:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = (setcc %0, %1, setgt)</span><br><span class="line">and %cmp, 1</span><br></pre></td></tr></table></figure><p>汇编:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// cpu032I</span><br><span class="line">cmp $sw, $2, $3</span><br><span class="line">andi $2, $sw, 1</span><br><span class="line">andi $2, $2, 1</span><br><span class="line">// cpu032II</span><br><span class="line">slt $2, $3, $2</span><br><span class="line">andi $2, $2, 1</span><br></pre></td></tr></table></figure><p>6.大于等于 <code>&gt;=</code></p><p>LLVM IR:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = icmp ge i32 %0, %1</span><br><span class="line">%conv = zext i1 %cmp to i32</span><br></pre></td></tr></table></figure><p>DAG node:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%cmp = (setcc %0, %1, setle)</span><br><span class="line">and %cmp, 1</span><br></pre></td></tr></table></figure><p>汇编:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// cpu032I</span><br><span class="line">cmp $sw, $3, $2</span><br><span class="line">andi $2, $sw, 1</span><br><span class="line">xori $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br><span class="line">// cpu032II</span><br><span class="line">slt $2, $3, $2</span><br><span class="line">xori $2, $2, 1</span><br><span class="line">andi $2, $2, 1</span><br></pre></td></tr></table></figure><h3 id="3-2-2-文件修改"><a href="#3-2-2-文件修改" class="headerlink" title="3.2.2 文件修改"></a>3.2.2 文件修改</h3><h4 id="1-Cpu0InstrInfo-td"><a href="#1-Cpu0InstrInfo-td" class="headerlink" title="(1) Cpu0InstrInfo.td"></a>(1) Cpu0InstrInfo.td</h4><p>针对这些逻辑运算设计它们的 pattern 等信息。</p><p>这里反复使用了一个 Pat 类，这个类用来将一个 node 操作和一个或一组指令关联起来（通常用于窥孔优化）。</p><p>我们特殊处理的比较操作，会对应到一组指令中。举个例子，使用 cmp 来计算 <code>a == b</code>，那么首先，使用 <code>cmp $sw, a, b</code> 将比较结果的 flag 放到 <code>$sw</code> 寄存器中，<code>$sw</code> 寄存器的最低两位分别是 Z (bit 1)和 N (bit 0)，如果 a 与 b 相等，那么 Z &#x3D; 1, N &#x3D; 0，如果 a 与 b 不相等，那么 Z &#x3D; 1, N 可为 0 或 1。这样，我们后边只需要对 <code>$sw</code> 寄存器做与 <code>0b10</code> 的与运算，提取这两位，然后右移 1 位拿到 Z 的值，它的值赋给另一个寄存器，这便是 <code>a == b</code> 的结果。</p><p>再举个 <code>slt</code> 的例子，使用 <code>slt</code> 计算 <code>a &lt;= b</code>，因为 <code>slt</code> 返回的结果是 <code>a &lt; b</code> 的结果，所以我们将两个操作数交换，先使用 <code>slt res, b, a</code> 计算 <code>b &lt; a</code>，将结果 res 再做一次与 0b1 的异或操作，结果调转，就得到了 <code>a &lt;= b</code> 的结果。</p><p>将两种比较的方式都实现，并在 def 时使用 <code>HasSlt</code> 和 <code>HasCmp</code> 来选择定义。</p><p>Cpu032II 中是同时包含有 <code>slt</code> 和 <code>cmp</code> 指令的，但默认是优先选择 <code>slt</code> 指令。其小于运算不需要做这种映射，因为 <code>slt</code> 指令本身就是计算小于结果的。</p><h4 id="2-Cpu0ISelLowering-cpp"><a href="#2-Cpu0ISelLowering-cpp" class="headerlink" title="(2) Cpu0ISelLowering.cpp"></a>(2) Cpu0ISelLowering.cpp</h4><p>声明了类型合法化的方案，Cpu0 无法处理 <code>sext_inreg</code>，将其替换为 <code>shl/sra</code> 操作。</p><h3 id="3-2-3-检验成果"><a href="#3-2-3-检验成果" class="headerlink" title="3.2.3 检验成果"></a>3.2.3 检验成果</h3><p>首先是逻辑运算，使用示例程序 ch3_2_logic.c 进行编译，检查汇编输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/bin/clang -target mips-unknown-linux-gnu -c ch4_2_logic.cpp -emit-llvm -o ch4_2_logic.bc</span><br><span class="line">build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=asm ch4_2_logic.bc -o -</span><br></pre></td></tr></table></figure><p>当指定 <code>-mcpu=cpu032I</code> 时，汇编输出的内容中，实现比较操作的是 <code>cmp</code> 指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -mcpu=cpu032II -relocation-model=pic -filetype=asm ch4_2_logic.bc -o -</span><br></pre></td></tr></table></figure><h2 id="3-3-本章总结"><a href="#3-3-本章总结" class="headerlink" title="3.3 本章总结"></a>3.3 本章总结</h2><p>这一章我们增加了 20 多条算术和逻辑运算指令，增加了大概几百行代码。</p><p>下一章我们尝试生成二进制文件。</p><p>另外，有朋友反映我的代码仓库中的代码有些提交和章节不符的内容，在此深保歉意，因为我是一边写代码一边写文章，有时代码已经码到后边几章了，但文章依然拖延不写，可能导致一些错误，我会尽快重新调整代码。还有，我其实也发现原文中的宏开关还是挺好用的了，可能后续也会补上。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362363094">LLVM 后端实践笔记 3：算术和逻辑指令 - 知乎 (zhihu.com)</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://p2tree.top">P2Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://p2tree.top/posts/1268381.html">https://p2tree.top/posts/1268381.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://p2tree.top" target="_blank">P2Tree's Mill</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/LLVM/">LLVM</a></div><div class="post-share"><div class="social-share" data-image="https://img.p2tree.top/2021/04/05/index.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件"><img class="cover" src="https://img.p2tree.top/2021/05/11/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">LLVM 后端实践笔记 4：生成目标文件</div></div><div class="info-2"><div class="info-item-1">之前的章节只介绍了汇编代码生成的内容，这一章，我们将介绍对 ELF 目标格式文件的支持以及如何使用 objdump 工具来验证生成的目标文件。在 LLVM 代码框架下，只需要增加少量的代码，Cpu0 后端就可以生成支持大端或小端编码的目标文件。目标注册机制以及它的结构也在本章介绍。 LLVM 后端实践笔记 0：序LLVM 后端实践笔记 1：新后端初始化和软件编译LLVM 后端实践笔记 2：后端结构LLVM 后端实践笔记 3：算术和逻辑指令LLVM 后端实践笔记 4：生成目标文件LLVM 后端实践笔记 5：全局变量LLVM 后端实践笔记 6：更多数据类型LLVM 后端实践笔记 7：控制流LLVM 后端实践笔记 8：函数调用LLVM 后端实践笔记 9：ELF文件支持LLVM 后端实践笔记 10：汇编LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器 4.1 简要说明4.1.1 编码当 llc 指定 -filetype=obj 时，编译器会生成目标文件（而不是汇编文件），此时，AsmPrinter::OutStreamer 所引用的是 MCObjectStream...</div></div></div></a><a class="pagination-related" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构"><img class="cover" src="https://img.p2tree.top/2021/03/13/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LLVM 后端实践笔记 2：后端结构</div></div><div class="info-2"><div class="info-item-1">这一章介绍LLVM后端代码的组成结构，并分别实现这些结构下的类。这一章结束时，我们的后端就能够正常生成简单代码的汇编码了。这一章会增加不少代码，Cpu0 的后端代码主要参考 Mips 后端的代码，建议直接复制拿去用，然后根据实际情况修改。 这一章需要留意一下类关系。还需要知道指令选择、寄存器分配等概念。到调整栈帧的时候，可能会有点难，但只要对计算机体系结构比较清楚，相对会好理解。 （内容有点多，建议收藏后分多次阅读。本来打算分开的，但感觉分开之后章节关系变得太松散了，便作罢） LLVM 后端实践笔记 0：序LLVM 后端实践笔记 1：新后端初始化和软件编译LLVM 后端实践笔记 2：后端结构LLVM 后端实践笔记 3：算术和逻辑指令LLVM 后端实践笔记 4：生成目标文件LLVM 后端实践笔记 5：全局变量LLVM 后端实践笔记 6：更多数据类型LLVM 后端实践笔记 7：控制流LLVM 后端实践笔记 8：函数调用LLVM 后端实践笔记 9：ELF文件支持LLVM 后端实践笔记 10：汇编LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器 2.1 目标机器架...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet"><img class="cover" src="https://img.p2tree.top/2025/4/27/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">学习LLVM数据结构：SmallSet</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本系列文章以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 在现代编程语言开发中，集合（Set）是一种非常有用的数据结构，它可以高效存储唯一元素。本文介绍一种更轻量级的集合实现：SmallSet。它非常适合存储少量元素，同时保持出色的性能和内存效率。 基本介绍SmallSet 是一种小型集合类型，它实现了基本的集合操作，比如插入、删除和查找等。它的设计目标是优化在存储小规模数据时的性能和内存占用，它结合了小对象优化和动态内存调节技术，非常适合频繁访问的小集合场景。如果你已经对 SmallVector 有了解，那么 SmallSet 和它有着类似的实现思路。 llvm::SmallSet 定义在...</div></div></div></a><a class="pagination-related" href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef"><img class="cover" src="https://img.p2tree.top/2025/3/25/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="info-item-2">学习LLVM数据结构：StringRef</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 基本介绍llvm::StringRef 定义在 llvm/ADT/StringRef.h 头文件中。 它的声明为： 1class StringRef; 和 ArrayRef 类似，StringRef 是一种轻量级的字符串引用类型，它用于实现高效地表示和操作字符串数据，尤其是在一些高频处理字符串，但同时不希望维护实际内存开销地场景下。 它是不可变引用，主要用于向函数内传递字符串同时避免深拷贝。它只包含了指向字符串的指针和字符串的长度信息，从而使得对它的操作直接而高效。 特点 轻量级：只存储一个指向字符串的指针和字符串的长度，不存储实际的数...</div></div></div></a><a class="pagination-related" href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector"><img class="cover" src="https://img.p2tree.top/2025/3/9/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">学习LLVM数据结构：SmallVector</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 基本介绍llvm::SmallVector 定义在 llvm/ADT/SmallVector.h 头文件中。它的声明为： 12template&lt;typename T, unsigned N = CalculateSmallVectorDefaultInlinedElements&lt;T&gt;::value&gt; class SmallVector; llvm::SmallVector 是一个可变长数组，类似于 std::vector，同时它对较小长度的数组做了优化。它的内存管理方式采用局部缓存的设计思路，在对象内部预留一小块...</div></div></div></a><a class="pagination-related" href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef"><img class="cover" src="https://img.p2tree.top/2025/2/25/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-25</div><div class="info-item-2">学习LLVM数据结构：ArrayRef</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 基本介绍llvm::ArrayRef 定义在 llvm/ADT/ArrayRef.h 头文件中。它的声明为： 1template&lt;typename T&gt; class ArrayRef; llvm::ArrayRef 是一个轻量级的只读容器，主要用于引用一段连续的内存区域。它的设计目标是提供高效的数据访问，而不需要拥有底层数据的所有权。这使得 ArrayRef 特别适合在函数参数中实用，从而避免了不必要的内存拷贝。 特点 只读：ArrayRef 不能修改其引用的数据，也不能添加新元素（另一个容器 MutableArrayR...</div></div></div></a><a class="pagination-related" href="/posts/801cd0f2.html" title="LLVM 风格的 RTTI"><img class="cover" src="https://img.p2tree.top/2023/08/14/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="info-item-2">LLVM 风格的 RTTI</div></div><div class="info-2"><div class="info-item-1">开头叨叨众所周知，LLVM project 没有开启 C++ 的 RTTI 特性。一个主要的原因是 LLVM project 认为 C++ RTTI 特性的实现需要使用到虚函数表，对性能并不友好。LLVM 自己实现了一种类似 RTTI 的行为。我们在开发 LLVM 代码时，尤其是需要自己搭建自定义的数据结构时，可能会想用到 RTTI，此时，学习在 LLVM 风格下如何创建类似的 API，就显得尤为重要。 什么是 RTTI难度：⭐ RTTI 是运行时类型识别，全称 Runtime Type Identification，网上有很多介绍这个的资料，属于 C++ 程序员必须要熟悉的内容。 它的主要目的是为程序运行时提供一种对对象类型的获取、操作的方式。 对应到 C++ API 上，有三个 API 会用到 RTTI： dynamic_cast，用来将一个指向基类的指针转换为一个指向派生类的指针，如果转换失败，会返回 nullptr typeid，用来返回对象类型的值 type_info，也就是 typeid 的返回类型，用来存储描述类型的信息 如果不使用这三个 API，关闭 RTTI...</div></div></div></a><a class="pagination-related" href="/posts/ab589331.html" title="LLVM New Pass Manager"><img class="cover" src="https://img.p2tree.top/2022/12/03/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">LLVM New Pass Manager</div></div><div class="info-2"><div class="info-item-1">这是一篇译文，主要介绍了 LLVM 中的 New Pass Manager 原文链接：https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/by Arthur Eubanks（Mar 26, 2021） Pass Manager 的介绍Pass Manager 的主要用途是调度 Pass 在各 IR 层级按顺序运行。 Pass 分为 transformation pass 和 analyses pass，它们可以选择运行在 module、function 等各种 scope 下，甚至更加抽象地，比如 call graph 上的强连接组件（SCC: strongly connected component）或者 loop 上。 调度可以很简单，比如直接按顺序运行 pass list，或者按遇到的每一个 function 来调用。同时调度也可能很复杂，比如 SCC 在 call graph 中的顺序必须正确。 Pass Manager 还负责管理 analyses pass 的分析结果，比如说支配树（dominat...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://img.p2tree.top/avatar.webp" onerror='this.onerror=null,this.src="/img/404.gif"' alt="avatar"></div><div class="author-info-name">P2Tree</div><div class="author-info-description">基础软件研发工程师</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/p2tree" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:public@p2tree.top" target="_blank" title="Email"><i class="iconfont icon-mail"></i></a><a class="social-icon" href="https://zhihu.com/people/p2tree" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu"></i></a><a class="social-icon" href="/2024/08/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-P2Tree/" target="_blank" title="Weixin"><i class="iconfont icon-wechat"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="Feed"><i class="iconfont icon-feed"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问我的个人站点，这里会发布我的学习笔记和生活感悟。<br>可以通过选择分类或标签来阅读你感兴趣的文章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text">3.1 算术运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">3.1.1 简要说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B9%98%E6%B3%95%E5%92%8C%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">(1) 乘法和移位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%99%A4%E6%B3%95%E5%92%8C%E6%B1%82%E4%BD%99%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">(2) 除法和求余运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">1.2.</span> <span class="toc-text">3.1.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0Subtarget-cpp"><span class="toc-number">1.2.1.</span> <span class="toc-text">(1) Cpu0Subtarget.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0InstrInfo-td"><span class="toc-number">1.2.2.</span> <span class="toc-text">(2) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0ISelLowering-h-cpp"><span class="toc-number">1.2.3.</span> <span class="toc-text">(3) Cpu0ISelLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0RegisterInfo-td"><span class="toc-number">1.2.4.</span> <span class="toc-text">(4) Cpu0RegisterInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0Schedule-td"><span class="toc-number">1.2.5.</span> <span class="toc-text">(5) Cpu0Schedule.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Cpu0SEISelDAGToDAG-h-cpp"><span class="toc-number">1.2.6.</span> <span class="toc-text">(6) Cpu0SEISelDAGToDAG.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Cpu0SEInstrInfo-h-cpp"><span class="toc-number">1.2.7.</span> <span class="toc-text">(7) Cpu0SEInstrInfo.h&#x2F;.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">1.3.</span> <span class="toc-text">3.1.3 检验成果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B9%98%E6%B3%95%E5%92%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.</span> <span class="toc-text">(1) 乘法和移位操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%99%A4%E6%B3%95%E5%92%8C%E6%B1%82%E4%BD%99%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.</span> <span class="toc-text">(2) 除法和求余操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">3.2 逻辑运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">3.2.1 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">2.2.</span> <span class="toc-text">3.2.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0InstrInfo-td"><span class="toc-number">2.2.1.</span> <span class="toc-text">(1) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0ISelLowering-cpp"><span class="toc-number">2.2.2.</span> <span class="toc-text">(2) Cpu0ISelLowering.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">2.3.</span> <span class="toc-text">3.2.3 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">3.3 本章总结</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器"><img src="https://img.p2tree.top/2021/09/10/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器"></a><div class="content"><a class="title" href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a><time datetime="2021-09-10T17:12:50.000Z" title="发表于 2021-09-10 17:12:50">2021-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编"><img src="https://img.p2tree.top/2021/08/07/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 10：汇编"></a><div class="content"><a class="title" href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a><time datetime="2021-08-07T23:15:39.000Z" title="发表于 2021-08-07 23:15:39">2021-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持"><img src="https://img.p2tree.top/2021/07/31/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 9：ELF文件支持"></a><div class="content"><a class="title" href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a><time datetime="2021-07-31T23:04:26.000Z" title="发表于 2021-07-31 23:04:26">2021-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用"><img src="https://img.p2tree.top/2021/07/24/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 8：函数调用"></a><div class="content"><a class="title" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a><time datetime="2021-07-24T23:01:27.000Z" title="发表于 2021-07-24 23:01:27">2021-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流"><img src="https://img.p2tree.top/2021/07/04/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 7：控制流"></a><div class="content"><a class="title" href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a><time datetime="2021-07-04T22:09:23.000Z" title="发表于 2021-07-04 22:09:23">2021-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型"><img src="https://img.p2tree.top/2021/06/19/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 6：更多数据类型"></a><div class="content"><a class="title" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a><time datetime="2021-06-19T17:15:17.000Z" title="发表于 2021-06-19 17:15:17">2021-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量"><img src="https://img.p2tree.top/2021/06/06/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 5：全局变量"></a><div class="content"><a class="title" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a><time datetime="2021-06-06T21:38:10.000Z" title="发表于 2021-06-06 21:38:10">2021-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件"><img src="https://img.p2tree.top/2021/05/11/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 4：生成目标文件"></a><div class="content"><a class="title" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a><time datetime="2021-05-11T22:18:35.000Z" title="发表于 2021-05-11 22:18:35">2021-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令"><img src="https://img.p2tree.top/2021/04/05/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 3：算术和逻辑指令"></a><div class="content"><a class="title" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a><time datetime="2021-04-05T23:24:42.000Z" title="发表于 2021-04-05 23:24:42">2021-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构"><img src="https://img.p2tree.top/2021/03/13/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 2：后端结构"></a><div class="content"><a class="title" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a><time datetime="2021-03-13T07:47:31.000Z" title="发表于 2021-03-13 07:47:31">2021-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译"><img src="https://img.p2tree.top/2021/02/24/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 1：新后端初始化和软件编译"></a><div class="content"><a class="title" href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a><time datetime="2021-02-24T22:53:00.000Z" title="发表于 2021-02-24 22:53:00">2021-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序"><img src="https://img.p2tree.top/2021/02/22/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 0：序"></a><div class="content"><a class="title" href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a><time datetime="2021-02-22T23:14:05.000Z" title="发表于 2021-02-22 23:14:05">2021-02-22</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1e952ac7.html" title="读书推荐：南京大屠杀"><img src="https://img.p2tree.top/2025/4/26/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：南京大屠杀"></a><div class="content"><a class="title" href="/posts/1e952ac7.html" title="读书推荐：南京大屠杀">读书推荐：南京大屠杀</a><time datetime="2025-10-27T15:00:31.517Z" title="更新于 2025-10-27 15:00:31">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dc0bdc19.html" title="读书推荐：活着"><img src="https://img.p2tree.top/2024/12/15/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：活着"></a><div class="content"><a class="title" href="/posts/dc0bdc19.html" title="读书推荐：活着">读书推荐：活着</a><time datetime="2025-10-27T15:00:31.517Z" title="更新于 2025-10-27 15:00:31">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2626ad0e.html" title="读书推荐：宝贵的人生建议"><img src="https://img.p2tree.top/2024/10/27/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：宝贵的人生建议"></a><div class="content"><a class="title" href="/posts/2626ad0e.html" title="读书推荐：宝贵的人生建议">读书推荐：宝贵的人生建议</a><time datetime="2025-10-27T15:00:31.517Z" title="更新于 2025-10-27 15:00:31">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4fefbc0d.html" title="跟随一条指令来看LLVM的基本结构"><img src="https://img.p2tree.top/2020/01/04/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跟随一条指令来看LLVM的基本结构"></a><div class="content"><a class="title" href="/posts/4fefbc0d.html" title="跟随一条指令来看LLVM的基本结构">跟随一条指令来看LLVM的基本结构</a><time datetime="2025-10-27T15:00:31.517Z" title="更新于 2025-10-27 15:00:31">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet"><img src="https://img.p2tree.top/2025/4/27/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="学习LLVM数据结构：SmallSet"></a><div class="content"><a class="title" href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a><time datetime="2025-10-27T15:00:31.516Z" title="更新于 2025-10-27 15:00:31">2025-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://img.p2tree.top/default.webp)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2025 By P2Tree</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.0"></script><script src="/js/main.js?v=5.5.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.29/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const o="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t=(t=document,e=location.pathname)=>{twikoo.init({el:t.querySelector("#twikoo-wrap"),envId:"https://twikoo.p2tree.top/",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))},path:e}),o&&(window.shuoshuoComment.destroyTwikoo=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})},e=(o,e)=>{"object"==typeof twikoo?setTimeout(()=>t(o,e),0):btf.getScript("https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js").then(()=>t(o,e))};o?window.shuoshuoComment={loadComment:e}:e()})()</script></div><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3JR7r5l5JW5Miut3",ck:"3JR7r5l5JW5Miut3",autoTrack:!0})</script><script src="/js/mourning.js"></script><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div id="algolia-search-input"><div class="ais-SearchBox"><form class="ais-SearchBox-form" action="" role="search" novalidate><input class="ais-SearchBox-input" type="search" placeholder="搜索文章" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" maxlength="512" aria-label="Search"><button class="ais-SearchBox-submit" type="submit" title="Submit the search query" style="display:none"><svg class="ais-SearchBox-submitIcon" width="10" height="10" viewBox="0 0 40 40" aria-hidden="true"><path d="M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z"></path></svg></button></form></div><hr><div id="algolia-search-results"><div id="algolia-hits"><div id="algolia-hits-empty" style="display:none"></div><div class="ais-Hits" style="display:none"><ol class="ais-Hits-list"></ol></div></div><div class="ais-Pagination" id="algolia-pagination" style="display:none"><ul class="ais-Pagination-list"></ul></div><div id="algolia-info"><span class="ais-Stats-text"></span><a class="algolia-poweredBy" href="https://www.algolia.com/?utm_source=algoliasearch.js&amp;utm_medium=website&amp;utm_content=localhost&amp;utm_campaign=poweredby" target="_blank" aria-label="Search by Algolia" rel="noopener noreferrer"><svg class="ais-PoweredBy-logo" height="1.2em" viewBox="0 0 572 64" style="width:auto"><path fill="#36395A" d="M16 48.3c-3.4 0-6.3-.6-8.7-1.7A12.4 12.4 0 0 1 1.9 42C.6 40 0 38 0 35.4h6.5a6.7 6.7 0 0 0 3.9 6c1.4.7 3.3 1.1 5.6 1.1 2.2 0 4-.3 5.4-1a7 7 0 0 0 3-2.4 6 6 0 0 0 1-3.4c0-1.5-.6-2.8-1.9-3.7-1.3-1-3.3-1.6-5.9-1.8l-4-.4c-3.7-.3-6.6-1.4-8.8-3.4a10 10 0 0 1-3.3-7.9c0-2.4.6-4.6 1.8-6.4a12 12 0 0 1 5-4.3c2.2-1 4.7-1.6 7.5-1.6s5.5.5 7.6 1.6a12 12 0 0 1 5 4.4c1.2 1.8 1.8 4 1.8 6.7h-6.5a6.4 6.4 0 0 0-3.5-5.9c-1-.6-2.6-1-4.4-1s-3.2.3-4.4 1c-1.1.6-2 1.4-2.6 2.4-.5 1-.8 2-.8 3.1a5 5 0 0 0 1.5 3.6c1 1 2.6 1.7 4.7 1.9l4 .3c2.8.2 5.2.8 7.2 1.8 2.1 1 3.7 2.2 4.9 3.8a9.7 9.7 0 0 1 1.7 5.8c0 2.5-.7 4.7-2 6.6a13 13 0 0 1-5.6 4.4c-2.4 1-5.2 1.6-8.4 1.6Zm35.6 0c-2.6 0-4.8-.4-6.7-1.3a13 13 0 0 1-4.7-3.5 17.1 17.1 0 0 1-3.6-10.4v-1c0-2 .3-3.8 1-5.6a13 13 0 0 1 7.3-8.3 15 15 0 0 1 6.3-1.4A13.2 13.2 0 0 1 64 24.3c1 2.2 1.6 4.6 1.6 7.2V34H39.4v-4.3h21.8l-1.8 2.2c0-2-.3-3.7-.9-5.1a7.3 7.3 0 0 0-2.7-3.4c-1.2-.7-2.7-1.1-4.6-1.1s-3.4.4-4.7 1.3a8 8 0 0 0-2.9 3.6c-.6 1.5-.9 3.3-.9 5.4 0 2 .3 3.7 1 5.3a7.9 7.9 0 0 0 2.8 3.7c1.3.8 3 1.3 5 1.3s3.8-.5 5.1-1.3c1.3-1 2.1-2 2.4-3.2h6a11.8 11.8 0 0 1-7 8.7 16 16 0 0 1-6.4 1.2ZM80 48c-2.2 0-4-.3-5.7-1a8.4 8.4 0 0 1-3.7-3.3 9.7 9.7 0 0 1-1.3-5.2c0-2 .5-3.8 1.5-5.2a9 9 0 0 1 4.3-3.1c1.8-.7 4-1 6.7-1H89v4.1h-7.5c-2 0-3.4.5-4.4 1.4-1 1-1.6 2.1-1.6 3.6s.5 2.7 1.6 3.6c1 1 2.5 1.4 4.4 1.4 1.1 0 2.2-.2 3.2-.7 1-.4 1.9-1 2.6-2 .6-1 1-2.4 1-4.2l1.7 2.1c-.2 2-.7 3.8-1.5 5.2a9 9 0 0 1-3.4 3.3 12 12 0 0 1-5.3 1Zm9.5-.7v-8.8h-1v-10c0-1.8-.5-3.2-1.4-4.1-1-1-2.4-1.4-4.2-1.4a142.9 142.9 0 0 0-10.2.4v-5.6a74.8 74.8 0 0 1 8.6-.4c3 0 5.5.4 7.5 1.2s3.4 2 4.4 3.6c1 1.7 1.4 4 1.4 6.7v18.4h-5Zm12.9 0V17.8h5v12.3h-.2c0-4.2 1-7.4 2.8-9.5a11 11 0 0 1 8.3-3.1h1v5.6h-2a9 9 0 0 0-6.3 2.2c-1.5 1.5-2.2 3.6-2.2 6.4v15.6h-6.4Zm34.4 1a15 15 0 0 1-6.6-1.3c-1.9-.9-3.4-2-4.7-3.5a15.5 15.5 0 0 1-2.7-5c-.6-1.7-1-3.6-1-5.4v-1c0-2 .4-3.8 1-5.6a15 15 0 0 1 2.8-4.9c1.3-1.5 2.8-2.6 4.6-3.5a16.4 16.4 0 0 1 13.3.2c2 1 3.5 2.3 4.8 4a12 12 0 0 1 2 6H144c-.2-1.6-1-3-2.2-4.1a7.5 7.5 0 0 0-5.2-1.7 8 8 0 0 0-4.7 1.3 8 8 0 0 0-2.8 3.6 13.8 13.8 0 0 0 0 10.3c.6 1.5 1.5 2.7 2.8 3.6s2.8 1.3 4.8 1.3c1.5 0 2.7-.2 3.8-.8a7 7 0 0 0 2.6-2c.7-1 1-2 1.2-3.2h6.2a11 11 0 0 1-2 6.2 15.1 15.1 0 0 1-11.8 5.5Zm19.7-1v-40h6.4V31h-1.3c0-3 .4-5.5 1.1-7.6a9.7 9.7 0 0 1 3.5-4.8A9.9 9.9 0 0 1 172 17h.3c3.5 0 6 1.1 7.9 3.5 1.7 2.3 2.6 5.7 2.6 10v16.8h-6.4V29.6c0-2.1-.6-3.8-1.8-5a6.4 6.4 0 0 0-4.8-1.8c-2 0-3.7.7-5 2a7.8 7.8 0 0 0-1.9 5.5v17h-6.4Zm63.8 1a12.2 12.2 0 0 1-10.9-6.2 19 19 0 0 1-1.8-7.3h1.4v12.5h-5.1v-40h6.4v19.8l-2 3.5c.2-3.1.8-5.7 1.9-7.7a11 11 0 0 1 4.4-4.5c1.8-1 3.9-1.5 6.1-1.5a13.4 13.4 0 0 1 12.8 9.1c.7 1.9 1 3.8 1 6v1c0 2.2-.3 4.1-1 6a13.6 13.6 0 0 1-13.2 9.4Zm-1.2-5.5a8.4 8.4 0 0 0 7.9-5c.7-1.5 1.1-3.3 1.1-5.3s-.4-3.8-1.1-5.3a8.7 8.7 0 0 0-3.2-3.6 9.6 9.6 0 0 0-9.2-.2 8.5 8.5 0 0 0-3.3 3.2c-.8 1.4-1.3 3-1.3 5v2.3a9 9 0 0 0 1.3 4.8 9 9 0 0 0 3.4 3c1.4.7 2.8 1 4.4 1Zm27.3 3.9-10-28.9h6.5l9.5 28.9h-6Zm-7.5 12.2v-5.7h4.9c1 0 2-.1 2.9-.4a4 4 0 0 0 2-1.4c.4-.7.9-1.6 1.2-2.7l8.6-30.9h6.2l-9.3 32.4a14 14 0 0 1-2.5 5 8.9 8.9 0 0 1-4 2.8c-1.5.6-3.4.9-5.6.9h-4.4Zm9-12.2v-5.2h6.4v5.2H248Z"></path><path fill="#003DFF" d="M534.4 9.1H528a.8.8 0 0 1-.7-.7V1.8c0-.4.2-.7.6-.8l6.5-1c.4 0 .8.2.9.6v7.8c0 .4-.4.7-.8.7zM428 35.2V.8c0-.5-.3-.8-.7-.8h-.2l-6.4 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.5 0 .8-.4.8-.8V43c0-.4-.3-.7-.6-.8-4.5-.5-4.5-6-4.5-7zm106.5-21.8H528c-.4 0-.7.4-.7.8v34c0 .4.3.8.7.8h6.5c.4 0 .8-.4.8-.8v-34c0-.5-.4-.8-.8-.8zm-17.7 21.8V.8c0-.5-.3-.8-.8-.8l-6.5 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.4 0 .8-.4.8-.8V43c0-.4-.3-.7-.7-.8-4.4-.5-4.4-6-4.4-7zm-22.2-20.6a16.5 16.5 0 0 1 8.6 9.3c.8 2.2 1.3 4.8 1.3 7.5a19.4 19.4 0 0 1-4.6 12.6 14.8 14.8 0 0 1-5.2 3.6c-2 .9-5.2 1.4-6.8 1.4a21 21 0 0 1-6.7-1.4 15.4 15.4 0 0 1-8.6-9.3 21.3 21.3 0 0 1 0-14.4 15.2 15.2 0 0 1 8.6-9.3c2-.8 4.3-1.2 6.7-1.2s4.6.4 6.7 1.2zm-6.7 27.6c2.7 0 4.7-1 6.2-3s2.2-4.3 2.2-7.8-.7-6.3-2.2-8.3-3.5-3-6.2-3-4.7 1-6.1 3c-1.5 2-2.2 4.8-2.2 8.3s.7 5.8 2.2 7.8 3.5 3 6.2 3zm-88.8-28.8c-6.2 0-11.7 3.3-14.8 8.2a18.6 18.6 0 0 0 4.8 25.2c1.8 1.2 4 1.8 6.2 1.7s.1 0 .1 0h.9c4.2-.7 8-4 9.1-8.1v7.4c0 .4.3.7.8.7h6.4a.7.7 0 0 0 .7-.7V14.2c0-.5-.3-.8-.7-.8h-13.5zm6.3 26.5a9.8 9.8 0 0 1-5.7 2h-.5a10 10 0 0 1-9.2-14c1.4-3.7 5-6.3 9-6.3h6.4v18.3zm152.3-26.5h13.5c.5 0 .8.3.8.7v33.7c0 .4-.3.7-.8.7h-6.4a.7.7 0 0 1-.8-.7v-7.4c-1.2 4-4.8 7.4-9 8h-.1a4.2 4.2 0 0 1-.5.1h-.9a10.3 10.3 0 0 1-7-2.6c-4-3.3-6.5-8.4-6.5-14.2 0-3.7 1-7.2 3-10 3-5 8.5-8.3 14.7-8.3zm.6 28.4c2.2-.1 4.2-.6 5.7-2V21.7h-6.3a9.8 9.8 0 0 0-9 6.4 10.2 10.2 0 0 0 9.1 13.9h.5zM452.8 13.4c-6.2 0-11.7 3.3-14.8 8.2a18.5 18.5 0 0 0 3.6 24.3 10.4 10.4 0 0 0 13 .6c2.2-1.5 3.8-3.7 4.5-6.1v7.8c0 2.8-.8 5-2.2 6.3-1.5 1.5-4 2.2-7.5 2.2l-6-.3c-.3 0-.7.2-.8.5l-1.6 5.5c-.1.4.1.8.5 1h.1c2.8.4 5.5.6 7 .6 6.3 0 11-1.4 14-4.1 2.7-2.5 4.2-6.3 4.5-11.4V14.2c0-.5-.4-.8-.8-.8h-13.5zm6.3 8.2v18.3a9.6 9.6 0 0 1-5.6 2h-1a10.3 10.3 0 0 1-8.8-14c1.4-3.7 5-6.3 9-6.3h6.4zM291 31.5A32 32 0 0 1 322.8 0h30.8c.6 0 1.2.5 1.2 1.2v61.5c0 1.1-1.3 1.7-2.2 1l-19.2-17a18 18 0 0 1-11 3.4 18.1 18.1 0 1 1 18.2-14.8c-.1.4-.5.7-.9.6-.1 0-.3 0-.4-.2l-3.8-3.4c-.4-.3-.6-.8-.7-1.4a12 12 0 1 0-2.4 8.3c.4-.4 1-.5 1.6-.2l14.7 13.1v-46H323a26 26 0 1 0 10 49.7c.8-.4 1.6-.2 2.3.3l3 2.7c.3.2.3.7 0 1l-.2.2a32 32 0 0 1-47.2-28.6z"></path></svg></a></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@5.37.0/dist/lite/builds/browser.umd.min.js"></script><script src="/js/search/algolia.js?v=5.5.0"></script></div></div><script data-pjax>function butterfly_footer_beautify_injector_config(){var e=document.getElementById("footer");console.log("已挂载butterfly_footer_beautify"),e.innerHTML='<footer id="footer" style="background: transparent"><div id="footer-bottom"><div class="footer-bottom-content"><div class="footer-bottom-left"><span class="copyright">&copy;2024 - 2025 By <a target="_blank" rel="noopener" href="https://p2tree.top/" title="点击访问&quot;P2Tree&quot;的主页" style="margin-left:5px">P2Tree</a></span><div></div></div><div class="footer-bottom-right"><div><a class="footer-bottom-link" target="_blank" href="https://icp.hentioe.dev/sites/20255550" rel="noopener external nofollow" title="喵ICP备20255550号">喵ICP备20255550号</a><a class="footer-bottom-link" target="_blank" href="https://hexo.io/zh-cn/" rel="noopener external nofollow" title="博客框架">Hexo</a><a class="footer-bottom-link" target="_blank" href="https://butterfly.js.org/" rel="noopener external nofollow" title="主题">Butterfly</a><a class="footer-bottom-link" target="_blank" href="https://vercel.com/" rel="noopener external nofollow" title="undefined">Vercel</a><a class="footer-bottom-link" target="_blank" href="https://cloudflare.com/" rel="noopener external nofollow" title="undefined">CloudFlare</a><a class="footer-bottom-link" target="_blank" href="https://v6.51.la/land/3JR7r5l5JW5Miut3" rel="noopener external nofollow" title="undefined">51LA</a><a class="footer-bottom-link" target="_blank" href="https://stat.p2tree.top/" rel="noopener external nofollow" title="undefined">UptimeFlare</a></div></div></div></div></footer>'}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script defer src="https://cdn1.tianli0.top/npm/hexo-butterfly-footer-marcus/lib/footer.min.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var t=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/73fc32a.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2023/10/14/index.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-14</span><a class="blog-slider__title" href="posts/73fc32a.html" alt="">Vim 高效编辑技巧</a><div class="blog-slider__text">绝对是全网都没有的 Vim 使用硬干货经验</div><a class="blog-slider__button" href="posts/73fc32a.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4b2442c5.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2021/02/22/index.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-02-22</span><a class="blog-slider__title" href="posts/4b2442c5.html" alt="">LLVM 后端实践笔记 0：序</a><div class="blog-slider__text">LLVM 后端学习的系列教程，这是第一集，必读起跑线</div><a class="blog-slider__button" href="posts/4b2442c5.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/e8d522db.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2024/08/05/wechat_logo.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-05</span><a class="blog-slider__title" href="posts/e8d522db.html" alt="">微信公众号 P2Tree</a><div class="blog-slider__text">我维护的微信公众号，欢迎来交个朋友</div><a class="blog-slider__button" href="posts/e8d522db.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/b32e3378.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2024/08/23/index.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="posts/b32e3378.html" alt="">个人说明书 v2.2.4</a><div class="blog-slider__text">这份个人说明书，记录着我的基本信息和所思所想，希望能以最快的方式介绍我自己</div><a class="blog-slider__button" href="posts/b32e3378.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="/about/,/tags/,/categories/,/draft/".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>