<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>LLVM 后端实践笔记 7：控制流 | P2Tree's Mill</title><meta name="author" content="P2Tree"><meta name="copyright" content="P2Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这一章会介绍与控制流有关的功能实现，比如 if、else、while 和 for 等，还会介绍如何将控制流的 IR 表示转换为机器指令；之后会引入几个后端优化，处理一些跳转需求引入的问题，同时来说明如何编写后端优化的 pass。在条件指令小节中，会介绍 LLVM IR 中的特殊指令 select 和 select_cc，以及如何处理这种指令，从而来支持更细节的控制流支持实现。 LLVM 后端实践笔"><meta property="og:type" content="article"><meta property="og:title" content="LLVM 后端实践笔记 7：控制流"><meta property="og:url" content="https://p2tree.top/posts/8908debe.html"><meta property="og:site_name" content="P2Tree&#39;s Mill"><meta property="og:description" content="这一章会介绍与控制流有关的功能实现，比如 if、else、while 和 for 等，还会介绍如何将控制流的 IR 表示转换为机器指令；之后会引入几个后端优化，处理一些跳转需求引入的问题，同时来说明如何编写后端优化的 pass。在条件指令小节中，会介绍 LLVM IR 中的特殊指令 select 和 select_cc，以及如何处理这种指令，从而来支持更细节的控制流支持实现。 LLVM 后端实践笔"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.p2tree.top/2021/07/04/index.webp"><meta property="article:published_time" content="2021-07-04T22:09:23.000Z"><meta property="article:modified_time" content="2021-07-04T22:09:23.000Z"><meta property="article:author" content="P2Tree"><meta property="article:tag" content="编译器"><meta property="article:tag" content="LLVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.p2tree.top/2021/07/04/index.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LLVM 后端实践笔记 7：控制流",
  "url": "https://p2tree.top/posts/8908debe.html",
  "image": "https://img.p2tree.top/2021/07/04/index.webp",
  "datePublished": "2021-07-04T22:09:23.000Z",
  "dateModified": "2021-07-04T22:09:23.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "P2Tree",
      "url": "https://p2tree.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://img.p2tree.top/avatar.webp"><link rel="canonical" href="https://p2tree.top/posts/8908debe.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=5.5.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.29/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",()=>{void 0===t.get("theme")&&(e.matches?o():a())})}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-2M9BYWL9WW"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2M9BYWL9WW"),btf.addGlobalFn("pjaxComplete",()=>{gtag("config","G-2M9BYWL9WW",{page_path:window.location.pathname})},"google_analytics")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"D6LVAK5RKB",apiKey:"f6946a241b05432428a3e4fc6e7ba9e7",indexName:"my-hexo-blog",hitsPerPage:6,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!0,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:500,languages:{author:"作者: P2Tree",link:"链接: ",source:"来源: P2Tree's Mill",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"LLVM 后端实践笔记 7：控制流",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="baidu-site-verification" content="codeva-Watq1Co2vC"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4649427_nfzovmtn6c.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/hexo-butterfly-footer-marcus/lib/footer.min.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="P2Tree's Mill" type="application/atom+xml">
</head><body><script>window.paceOptions={restartOnPushState:!1},btf.addGlobalFn("pjaxSend",()=>{Pace.restart()},"pace_restart")</script><link rel="stylesheet" href="/css/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://img.p2tree.top/avatar.webp" onerror='this.onerror=null,this.src="/img/404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pen-to-square"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文踪</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.p2tree.top/2021/07/04/index.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">P2Tree's Mill</span></a><a class="nav-page-title" href="/"><span class="site-name">LLVM 后端实践笔记 7：控制流</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pen-to-square"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文踪</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">LLVM 后端实践笔记 7：控制流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-04T22:09:23.000Z" title="发表于 2021-07-04 22:09:23">2021-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-04T22:09:23.000Z" title="更新于 2021-07-04 22:09:23">2021-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:1000,&quot;messagePrev&quot;:&quot;距离上次更新已过去&quot;,&quot;messageNext&quot;:&quot;天，文章中的部分内容可能已经过时，请酌情参考～&quot;,&quot;postUpdate&quot;:&quot;2021-07-04 22:09:23&quot;}" hidden></div><p>这一章会介绍与控制流有关的功能实现，比如 if、else、while 和 for 等，还会介绍如何将控制流的 IR 表示转换为机器指令；之后会引入几个后端优化，处理一些跳转需求引入的问题，同时来说明如何编写后端优化的 pass。在条件指令小节中，会介绍 LLVM IR 中的特殊指令 select 和 select_cc，以及如何处理这种指令，从而来支持更细节的控制流支持实现。</p><ol class="series-items"><li><a href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a></li><li><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a></li><li><a href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a></li><li><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a></li><li><a href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a></li><li><a href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a></li><li><a href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a></li><li><a href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a></li><li><a href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a></li><li><a href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a></li><li><a href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a></li><li><a href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></li></ol><hr><h2 id="7-1-控制流语句"><a href="#7-1-控制流语句" class="headerlink" title="7.1 控制流语句"></a>7.1 控制流语句</h2><h3 id="7-1-1-简要说明"><a href="#7-1-1-简要说明" class="headerlink" title="7.1.1 简要说明"></a>7.1.1 简要说明</h3><p>从机器层面上来看，所有的跳转只分为无条件跳转和有条件跳转，从跳转方式上来分，又分为直接跳转（绝对地址）和间接跳转（相对偏移），所以我们只需要将 LLVM IR 的跳转 node 成功下降到机器跳转指令，并维护好跳转的范围、跳转的重定位信息即可。</p><p>Cpu032I 型机器支持 J 类型的跳转指令，比如无条件跳转 JMP，有条件跳转 JEQ、JNE、JLT、JGT、JLE、JGE，这部分指令是需要通过检查 condition code （SW 寄存器）来决定跳转条件的；Cpu032II 型机器除了支持 J 类型跳转指令之外，还支持 B 类型的跳转指令，比如 BEQ 和 BNE，这两个是通过直接比较操作数值关系来决定跳转条件的。相比较，后者的跳转依赖的资源少，指令效率更高。</p><p>SelectionDAG 中的 node，无条件跳转是 <code>ISD::br</code>，有条件跳转是 <code>ISD::brcond</code>，我们需要在 tablegen 中通过指定指令选择 pattern 来对这些 node 做映射。</p><p>另外，J 类型指令依赖的 condition code 是通过比较指令（比如 CMP）的结果来设置的，我们在之前的章节已经完成了比较指令，LLVM IR 的 <code>setcc</code> node 通常会被翻译为 <code>addiu reg1, zero, const + cmp reg1, reg2</code> 指令。</p><h3 id="7-1-2-文件修改"><a href="#7-1-2-文件修改" class="headerlink" title="7.1.2 文件修改"></a>7.1.2 文件修改</h3><h4 id="1-Cpu0ISelLowering-cpp"><a href="#1-Cpu0ISelLowering-cpp" class="headerlink" title="(1) Cpu0ISelLowering.cpp"></a>(1) Cpu0ISelLowering.cpp</h4><p>设置本章需要的几个 node 为 custom 的 lowering 类型，即我们会通过自定义的 lowering 操作来处理它们，这包括 <code>BlockAddress</code>，<code>JumpTable</code> 和 <code>BRCOND</code>。这分别对应 <code>lowerBlockAddress()</code>，<code>lowerJumpTable()</code> 和 <code>lowerBRCOND()</code> 函数，具体实现可参见代码，其中 <code>getAddrLocal()</code> 和 <code>getAddrNonPIC()</code> 是我们前边章节已经实现的自定义 node 生成函数。<code>BRCOND</code> 是条件跳转节点（包括 condition 的 op 和 condition 为 true 时 跳转的 block 的地址），<code>BlockAddress</code> 字面可知是 BasicBlock 的起始地址类型的节点，<code>JumpTable</code> 是跳转表类型的节点。后两者是叶子节点类型。</p><p>另外，设置 <code>SETCC</code> 在 i1 类型时做 Promote。增加了几行代码来说明额外的一些 ISD 的 node 需要做 Expand，有关于 Expand 我们在之前的章节介绍过，就是采用 LLVM 内部提供的一些展开方式来展开这些我们不支持的操作。这些操作包括：<code>BR_JT</code>，<code>BR_CC</code>，<code>CTPOP</code>，<code>CTTZ</code>，<code>CTTZ_ZERO_UNDEF</code>，<code>CTLZ_ZERO_UNDEF</code>。其中 <code>BR_JT</code> 操作的其中一个 op 是 <code>JumpTable</code> 类型的节点（保存 <code>JumpTable</code> 中的一个 index）。<code>BR_CC</code> 操作和 <code>SELECT_CC</code> 操作类似，区别是它保存有两个 op，通过比较相对大小来选择不同的分支。</p><h4 id="2-Cpu0InstrInfo-td"><a href="#2-Cpu0InstrInfo-td" class="headerlink" title="(2) Cpu0InstrInfo.td"></a>(2) Cpu0InstrInfo.td</h4><p>增加两个和跳转有关的操作数类型：<code>brtarget16</code> 和 <code>brtarget24</code>，前者是 16 位偏移的编码，将用于 <code>BEQ</code>、<code>BNE</code> 一类的指令，这一类指令是属于 Cpu032II 型号中特有；后者是 24 位偏移的编码，将用于 <code>JEQ</code>、<code>JNE</code> 一类的指令。两个操作数均指定了编码函数和解码函数的名称。还定义了 <code>jmptarget</code> 操作数类型，用来作为无条件跳转 <code>JMP</code> 的操作数。</p><p>之后便是定义这几条跳转指令，包括它们的匹配 pattern 和编码。</p><p>无条件跳转 <code>JMP</code> 的匹配 pattern 直接指明到了 <code>[(br bb::$addr)]</code>，很好理解。</p><p>然后我们做一些优化来定义 比较+跳转指令选择 Pattern，也就是将 <code>brcond + seteq/setueq/setne/setune/setlt/setult/setgt/setugt/setle/setule/setge/setuge</code> 系列模式转换为机器指令的比较+跳转指令组合。对于 J 系列的跳转指令，实际上会转换为 <code>Jxx + CMP</code> 模式，而对于 B 系列的跳转指令，则直接转换成指令本身。</p><p>比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def : Pat&lt;(brcond (i32 (setne RC:$lhs, RC:$rhs)), bb:$dst), (JNEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)&gt;;</span><br><span class="line">def : Pat&lt;(brcond (i32 (setne RC:$lhs, RC:$rhs)), bb:$dst), (BNEOp RC:$lhs, RC:$rhs, bb:$dst)&gt;;</span><br></pre></td></tr></table></figure><p>需要留意的一个是，我们无法从 C 语言生成 <code>setueq</code> 和 <code>setune</code> 指令，所以实际上并不会对其做选择（不过考虑到不要过分依赖前端，还是实现了）。</p><h4 id="3-Cpu0MCInstLower-cpp"><a href="#3-Cpu0MCInstLower-cpp" class="headerlink" title="(3) Cpu0MCInstLower.cpp"></a>(3) Cpu0MCInstLower.cpp</h4><p>因为跳转的地址既可以是跳转表偏移，也可以是一个 label，所以需要在 <code>MachineOperand</code> 这里对相关的类型做 lowering。在 <code>LowerSymbolOperand()</code> 函数中增加对 <code>MO_MachineBasicBlock</code>、<code>MO_BlockAddress</code> 和 <code>MO_JumpTableIndex</code> 类型的 lowering。</p><h4 id="4-Cpu0MCCodeEmitter-h-cpp"><a href="#4-Cpu0MCCodeEmitter-h-cpp" class="headerlink" title="(4) Cpu0MCCodeEmitter.h&#x2F;cpp"></a>(4) Cpu0MCCodeEmitter.h&#x2F;cpp</h4><p>实现地址操作数的编码实现函数，包括 <code>getBranch16TargetOpValue()</code>，<code>getBranch24TargetOpValue()</code> 和 <code>getJumpTargetOpValue()</code> 函数，对 <code>JMP</code> 指令同时还是表达式类型的跳转位置的情况，选择正确的 fixups，fixups 类型在 Cpu0FixupKinds.h 文件中定义。</p><h4 id="5-Cpu0AsmPrinter-h-cpp"><a href="#5-Cpu0AsmPrinter-h-cpp" class="headerlink" title="(5) Cpu0AsmPrinter.h&#x2F;cpp"></a>(5) Cpu0AsmPrinter.h&#x2F;cpp</h4><p>定义一个名为 <code>isLongBranchPseudo()</code> 的函数，用来判断指令是否是长跳转的伪指令。</p><p>同时在 <code>EmitInstruction()</code> 函数中增加当属于长跳转伪指令时，不发射该指令。</p><h4 id="6-MCTargetDesc-Cpu0FixupKinds-h"><a href="#6-MCTargetDesc-Cpu0FixupKinds-h" class="headerlink" title="(6) MCTargetDesc&#x2F;Cpu0FixupKinds.h"></a>(6) MCTargetDesc&#x2F;Cpu0FixupKinds.h</h4><p>添加重定位类型 <code>fixup_Cpu0_PC16</code> 和 <code>fixup_Cpu0_PC24</code>。</p><h4 id="7-MCTargetDesc-Cpu0ELFObjectWriter-cpp"><a href="#7-MCTargetDesc-Cpu0ELFObjectWriter-cpp" class="headerlink" title="(7) MCTargetDesc&#x2F;Cpu0ELFObjectWriter.cpp"></a>(7) MCTargetDesc&#x2F;Cpu0ELFObjectWriter.cpp</h4><p>添加重定位类型的一些设置，在 <code>getRelocType()</code> 函数中增加内容。</p><h4 id="8-MCTargetDesc-Cpu0AsmBackend-cpp"><a href="#8-MCTargetDesc-Cpu0AsmBackend-cpp" class="headerlink" title="(8) MCTargetDesc&#x2F;Cpu0AsmBackend.cpp"></a>(8) MCTargetDesc&#x2F;Cpu0AsmBackend.cpp</h4><p>这里有个小的要点需要留意。Cpu0 的架构和其他 RISC 机器一样，采用五级流水线结构，跳转指令会在 decode 阶段实现跳转动作（也就是将 PC 修改为跳转后的位置），但跳转指令在 fetch 阶段时，PC 会自动先移动到下一条指令位置，fetch 阶段在 decode 阶段之前，所以实际上，在 decode 阶段执行前，PC 已经自动 +4 （一个指令长度），所以实际上跳转指令中的偏移，并不是从跳转指令到目标位置的差，而应该是跳转指令的下一条指令到目标位置的差。</p><p>比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jne $BB0_2</span><br><span class="line">jmp $BB0_1         # jne 指令 decode 之前，PC 指向这里</span><br><span class="line">$BB0_1:</span><br><span class="line">ld $4, 36($fp)</span><br><span class="line">addiu $4, $4, 1</span><br><span class="line">st $4, 36($fp)</span><br><span class="line">jmp $BB0_2</span><br><span class="line">$BB0_2:</span><br><span class="line">ld $4, 32($fp)     # jne 指令 decode 之后，假设 PC 指向这里</span><br></pre></td></tr></table></figure><p>jne 指令中的偏移，应该是 jmp 指令到 最后一条 ld 指令之间的距离，也就是 20 （而不是 24）。</p><p>为了实现这样的修正，我们在 <code>adjustFixupValue()</code> 函数中，针对重定位类型 <code>fixup_Cpu0_PC16</code> 和 <code>fixup_Cpu0_PC24</code>，指定其 Value 应该在自身的基础上减 4。</p><h3 id="7-1-3-检验成果"><a href="#7-1-3-检验成果" class="headerlink" title="7.1.3 检验成果"></a>7.1.3 检验成果</h3><p>编译提供的测试用例 ch7_1_controlflow.c， 使用 Cpu032I 生成的汇编如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmp $sw, $3, $2</span><br><span class="line">jne $sw, $BB0_2</span><br><span class="line">jmp $BB0_1</span><br><span class="line">$BB0_1:</span><br><span class="line">ld $4, 4($sp)</span><br><span class="line">addiu $4, $4, 1</span><br><span class="line">st $4, 4($sp)</span><br><span class="line">jmp $BB0_2</span><br><span class="line">$BB0_2:</span><br><span class="line">ld $2, 4($sp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可见 Cpu032I 处理器使用 sw 寄存器和 J 系列跳转指令完成控制流操作。</p><p>使用 Cpu032II 生成的汇编如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">bne $2, $zero, $BB0_2</span><br><span class="line">jmp $BB0_1</span><br><span class="line">$BB0_1:</span><br><span class="line">ld $4, 4($sp)</span><br><span class="line">addiu $4, $4, 1</span><br><span class="line">st $4, 4($sp)</span><br><span class="line">jmp $BB0_2</span><br><span class="line">$BB0_2:</span><br><span class="line">ld $2, 4($sp)</span><br></pre></td></tr></table></figure><p>Cpu032II 处理器使用 B 系列跳转指令完成控制流操作，指令数更少。</p><p>通过 Cpu032I 直接生成二进制代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -mcpu=cpu032I -relocation-model=pic -filetype=obj ch7_1_controlflow.ll -o ch7_1_controlflow.o</span><br><span class="line">hexdump ch7_1_controlflow.o</span><br></pre></td></tr></table></figure><p>通过 hexdump 可以将二进制代码输出到终端。从其中找到 <code>31 00 00 14 36 00 00 00</code> 这段编码，<code>31</code> 是 jne 指令，<code>36</code> 是 jmp 指令，<code>14</code> 是 偏移的编码，可见这里偏移是 20，说明我们 Cpu0AsmBackend.cpp 中的设计生效了。</p><h2 id="7-2-消除无用的-JMP-指令"><a href="#7-2-消除无用的-JMP-指令" class="headerlink" title="7.2 消除无用的 JMP 指令"></a>7.2 消除无用的 JMP 指令</h2><p>LLVM 的大多数优化操作都是在中端完成，也就是在 LLVM IR 下完成。除了中端优化以外，其实还有一些依赖于后端特性的优化在后端完成。比如说，Mips 机器中的填充延迟槽优化，就是针对 RISC 下的 pipeline 优化。如果你的后端是一个带有延迟槽的 pipeline RISC 机器，那么也可以使用 Mips 的这一套优化。</p><p>这一小节，我们实现一个简单的后端优化，叫做消除无用的 JMP 指令。这个算法简单且高效，可以作为一个优化的教程来学习，通过学习，也可以了解如何新增一个优化 pass，以及如何在真实的工程中编写复杂的优化算法。</p><h3 id="7-2-1-简要说明"><a href="#7-2-1-简要说明" class="headerlink" title="7.2.1 简要说明"></a>7.2.1 简要说明</h3><p>对于如下汇编指令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    jmp    $BB_0</span><br><span class="line">$BB_0:</span><br><span class="line">    ... other instructions</span><br></pre></td></tr></table></figure><p>在 jmp 指令的下一条指令，就是 jmp 指令需要跳转的 BasicBlock 块，因为 jmp 指令是无条件跳转，所以这里的控制流必然会做顺序执行，进而可以明确这里的 jmp 指令是多余的，即使删掉这条 jmp 指令，程序流也一样可以执行正确。</p><p>所以，我们的目的就是识别这种模式，并删除对应的 jmp 指令。</p><h3 id="7-2-2-文件修改"><a href="#7-2-2-文件修改" class="headerlink" title="7.2.2 文件修改"></a>7.2.2 文件修改</h3><h4 id="1-CMakeLists-txt"><a href="#1-CMakeLists-txt" class="headerlink" title="(1) CMakeLists.txt"></a>(1) CMakeLists.txt</h4><p>添加新文件 Cpu0DelUselessJMP.cpp。</p><h4 id="2-Cpu0-h"><a href="#2-Cpu0-h" class="headerlink" title="(2) Cpu0.h"></a>(2) Cpu0.h</h4><p>声明这个 pass 的工厂函数。</p><h4 id="3-Cpu0TargetMachine-cpp"><a href="#3-Cpu0TargetMachine-cpp" class="headerlink" title="(3) Cpu0TargetMachine.cpp"></a>(3) Cpu0TargetMachine.cpp</h4><p>覆盖 <code>addPreEmitPass()</code> 函数，在其中添加我们的 pass。调用这个函数表示我们的 pass 会在代码发射之前被执行。</p><h3 id="7-2-3-文件新增"><a href="#7-2-3-文件新增" class="headerlink" title="7.2.3 文件新增"></a>7.2.3 文件新增</h3><h4 id="1-Cpu0DelUselessJMP-cpp"><a href="#1-Cpu0DelUselessJMP-cpp" class="headerlink" title="(1) Cpu0DelUselessJMP.cpp"></a>(1) Cpu0DelUselessJMP.cpp</h4><p>这是我们实现该优化 pass 的具体代码。有几个具体要留意的点：</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_TYPE <span class="string">&quot;del-jmp&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">LLVM_DEBUG</span>(<span class="built_in">dbgs</span>() &lt;&lt; <span class="string">&quot;debug info&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里是为我们的优化 pass 添加一个调试宏，这样我们可以通过在执行编译命令时，指定该调试宏来打印出我们想要的调试信息。注意需要以 debug 模式来编译编译器，并且在执行编译命令时，指定参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -debug-only=del-jmp</span><br></pre></td></tr></table></figure><p>或直接打开所有调试信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -debug</span><br></pre></td></tr></table></figure><p>其次，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STATISTIC</span>(NumDelJmp, <span class="string">&quot;Number of useless jmp deleted&quot;</span>);</span><br></pre></td></tr></table></figure><p>表示我们定义了一个全局变量 <code>NumDelJmp</code>，可以允许我们在执行编译命令时，当执行完毕时，打印出这个变量的值。这个变量的作用是统计这个优化 pass 一共消除了多少的无用 jmp 指令，变量的累加是在实现该 pass 的逻辑中手动设计进去的。</p><p>在执行编译命令时，指定参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -stats</span><br></pre></td></tr></table></figure><p>就可以打印出所有的统计变量的值。</p><p>其次，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;<span class="type">bool</span>&gt; <span class="title">EnableDelJmp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ...</span></span></span><br><span class="line"><span class="params"><span class="function">  ...</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>这部分代码是向 LLVM 注册了一个编译参数，参数名称是这里第一个元素，还指定了参数的默认值，描述信息等。我们使用参数名为：<code>enable-cpu0-del-useless-jmp</code>，默认是打开的。这就是说，如果我们指定了这个参数，并且令其值为 false，则会关闭这个优化 pass。</p><p>具体的实现代码中，继承了 MachineFunctionPass 类，并在 <code>runOnMachineFunction</code> 中重写了逻辑，这个函数会在每次进入一个新的 Function 时被执行。在内部逻辑中调用了 <code>runOnMachineBasicBlock</code> 函数，同理，这个函数在每进入一个新的 BasicBlock 时被执行。</p><p>我们的基本思路是，在每个函数中遍历每一个基本块，直接取其最后一条指令，判断是否为 jmp 指令，如果是，再判断这条指令指向的基本块是否是下一个基本块。如果都满足，则调用 <code>MBB.erase(I)</code> 删除 <code>I</code> 指向的指令（jmp 指令）并且累加 <code>NumDelJmp</code> 变量。</p><h3 id="7-2-4-检验成果"><a href="#7-2-4-检验成果" class="headerlink" title="7.2.4 检验成果"></a>7.2.4 检验成果</h3><p>执行我提供的测试用例：ch7_2_deluselessjmp.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=static -filetype=asm -stats ch7_2_deluselessjmp.ll -o -</span><br></pre></td></tr></table></figure><p>查看输出汇编，会发现已经没有 jmp 指令，输出 statistics 信息中 <code>8 del-jmp</code> 告诉我们删除了 8 条无用的 jmp 指令。可以关闭这个优化再查看汇编（添加 <code>-enable-cpu0-del-useless-jmp=false</code>），两次结果做对比。</p><h2 id="7-3-填充跳转延迟槽"><a href="#7-3-填充跳转延迟槽" class="headerlink" title="7.3 填充跳转延迟槽"></a>7.3 填充跳转延迟槽</h2><p>这是个功能性的 pass。很多 RISC 机器采用多级流水线设计，有些 phase 会产生延迟，为了保证软件运行正确，可能会需要软件（编译器）在需要延迟的指令做处理。Cpu0 就符合这种情况，对于所有的跳转指令，需要有一个 cycle 的延迟，编译器需要负责对这些跳转指令做延迟插入指令。为了让实现简单，我们目前的实现只是将一条 nop 指令填充到跳转指令之后。有关于将其他有用的指令插入到跳转之后，可以参考 Mips 的实现（更加有意义，不单单是一条无用的等待），比如 MipsDelaySlotFiller.cpp 文件。</p><h3 id="7-3-1-简要说明"><a href="#7-3-1-简要说明" class="headerlink" title="7.3.1 简要说明"></a>7.3.1 简要说明</h3><p>对于如下汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    jne    $sw, $BB_0</span><br><span class="line">    nop    // 这里是插入的指令</span><br><span class="line">$BB_1:</span><br><span class="line">    ... other instructions</span><br></pre></td></tr></table></figure><p>对于 jne 指令，因为需要为其填充延迟指令，所以实际我们代码运行之后，会在汇编中，jne 的下一条指令，输出一条 nop 指令，这样就可以保证在 jne 执行完毕之后，再进行后续的运行。</p><p>与上一节的设计类似，我们依然是设计一个 pass，专门去识别这样一个模式，并创建一个 nop 指令并与跳转指令打到一个 bundle 中。bundle 是 LLVM 在 MI 层支持的一种指令扩展，它会在 bundle emit 之前，将 bundle 看做一条指令，而 bundle 内部却可以包含多条指令。</p><h3 id="7-3-2-文件修改"><a href="#7-3-2-文件修改" class="headerlink" title="7.3.2 文件修改"></a>7.3.2 文件修改</h3><h4 id="1-CMakeLists-txt-1"><a href="#1-CMakeLists-txt-1" class="headerlink" title="(1) CMakeLists.txt"></a>(1) CMakeLists.txt</h4><p>添加新增的文件 Cpu0DelaySlotFiller.cpp。</p><h4 id="2-Cpu0-h-1"><a href="#2-Cpu0-h-1" class="headerlink" title="(2) Cpu0.h"></a>(2) Cpu0.h</h4><p>添加创建新 pass 的工厂函数。</p><h4 id="3-Cpu0TargetMachine-cpp-1"><a href="#3-Cpu0TargetMachine-cpp-1" class="headerlink" title="(3) Cpu0TargetMachine.cpp"></a>(3) Cpu0TargetMachine.cpp</h4><p>在 addPreEmitPass() 函数中增加我们的 pass，和上一小节同理。</p><h4 id="4-Cpu0AsmPrinter-cpp"><a href="#4-Cpu0AsmPrinter-cpp" class="headerlink" title="(4) Cpu0AsmPrinter.cpp"></a>(4) Cpu0AsmPrinter.cpp</h4><p>这里是汇编代码发射的地方，需要检查要发射的指令是否是 bundle，如果是，则将 bundle 展开，依次发射其中的每一条指令。这一个 while 代码在之前的章节已经添加。如果不做这个检查，则只有 bundle 中的第一条指令会被发射，这将会导致代码错误。</p><h3 id="7-2-3-文件新增-1"><a href="#7-2-3-文件新增-1" class="headerlink" title="7.2.3 文件新增"></a>7.2.3 文件新增</h3><h4 id="1-Cpu0DelaySlotFiller-cpp"><a href="#1-Cpu0DelaySlotFiller-cpp" class="headerlink" title="(1) Cpu0DelaySlotFiller.cpp"></a>(1) Cpu0DelaySlotFiller.cpp</h4><p>新 pass 的实现代码。和上一小节类似的实现就不赘述了。</p><p>定义了一个 <code>hasUnoccupiedSlot()</code> 函数，用来判断某条指令是否满足我们上文指定的模式，首先判断这条指令是否具有延迟槽，调用 <code>hasDelaySlot()</code> 函数，然后判断这条指令是否已经属于一个 bundle 或者是最后一条指令，调用 <code>isBundledWithSucc()</code> 函数。这两个函数都是 LLVM 内置函数，在 MachineInstr.h 中实现。</p><p>当满足条件时，先使用 BuildMI 创建 nop 指令，并插入到跳转指令的后边；然后调用 <code>MIBundleBuilder</code> 函数，将跳转指令和 nop 指令打到一个 bundle。</p><h3 id="7-3-4-检验成果"><a href="#7-3-4-检验成果" class="headerlink" title="7.3.4 检验成果"></a>7.3.4 检验成果</h3><p>我没有额外提供测试用例，可以通过编译上一节的 ch7_2_deluselessjmp.cpp，查看输出的汇编内容，加 <code>-stats</code> 参数，输出共填充了 5 个这样模式的延迟槽。</p><h2 id="7-4-条件-MOV-指令"><a href="#7-4-条件-MOV-指令" class="headerlink" title="7.4 条件 MOV 指令"></a>7.4 条件 MOV 指令</h2><h3 id="7-4-1-简要说明"><a href="#7-4-1-简要说明" class="headerlink" title="7.4.1 简要说明"></a>7.4.1 简要说明</h3><p>条件 MOV 指令也叫做 Select 指令，和 C 语言中的 select 操作语义一致，由一个条件值、两个指定值和一个定义值（输出）组成。在满足一个条件时，将指定值赋给定义值，否则把另一个指定值赋给定义值。我们在 Cpu0 中将实现两条 MOV 指令，分别是 <code>movz</code> 和 <code>movn</code>，表示当条件成立时（或条件不成立时），赋值第一个值，否则，赋值另一个值。</p><p>由于编码位有限，通常的条件 MOV 指令和 Select 指令均设计为其中一个指定值与定义值是同一个操作数（或者也有设计为条件值与定义值是同一个操作数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movz $1, $2, $3;    @ $3 为条件值，当 $3 满足（为 true）时，将 $2 赋值给 $1,</span><br><span class="line">                    @ 否则，保持 $1 值不变</span><br><span class="line">movn $1, $2, $3;    @ $3 为条件值，当 $3 不满足（为 false）时，将 $2 赋值给 $1,</span><br><span class="line">                    @ 否则，保持 $1 值不变</span><br></pre></td></tr></table></figure><p>可以发现，<code>movz</code> 和 <code>movn</code> 是可以相互替代的，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movz $1, $2, $3;    @ 等价于</span><br><span class="line">movn $2, $1, $3;    @ 当然，还需要保证上下文数据正确</span><br></pre></td></tr></table></figure><p>在 LLVM IR 中，只有一个指令来处理这个情况，叫做 <code>select</code> 指令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%ret</span> <span class="operator">=</span> <span class="keyword">select</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span></span><br></pre></td></tr></table></figure><p>所以我们需要做的就是在后端代码中，将这个 IR 转换为正确的指令表示。</p><h3 id="7-4-2-文件修改"><a href="#7-4-2-文件修改" class="headerlink" title="7.4.2 文件修改"></a>7.4.2 文件修改</h3><h4 id="1-Cpu0InstrInfo-td"><a href="#1-Cpu0InstrInfo-td" class="headerlink" title="(1) Cpu0InstrInfo.td"></a>(1) Cpu0InstrInfo.td</h4><p>新增和条件 MOV 相关的指令实例和用于窥孔优化的 Pattern 描述。</p><p>前者即定义 <code>movz</code> 和 <code>movn</code> 指令。注意到在 class 中使用 <code>let Constraints = &quot;$F = $ra&quot;</code> 的属性来指定两个操作符是同一个值，这种写法通常用于当其中一个 def 操作数同时也需要作为 use 操作数的情况下，比如当前的 select 示例中。</p><p>后者是将 IR 过来的 <code>select</code> + <code>cmp</code> 节点组合优化为一条 <code>movz</code> 或 <code>movn</code> 指令。<code>select</code> 指令的 condition 需要一条比较（或其他起相同作用的）指令来得出条件结果，在 Cpu032I 机器中是 <code>cmp</code> 指令，在 Cpu032II 机器中是 <code>slt</code> 指令。因为通常比较两个值是否相等，还可以采用 <code>xor</code> 指令，所以对于低效的 Cpu032I 比较 <code>cmp</code> 指令，可以使用 <code>xor</code> 做替换，但对于大于、小于等条件代码则只能继续使用 <code>cmp</code> 指令，体现在 .td 文件中就是不特别去优化 <code>select</code> 指令组合下的条件指令。</p><p>这个优化的路径是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR:   icmp + (eq, ne, sgt, sge, slt, sle) + br</span><br><span class="line">DAG:  ((seteq, setne, setgt, setge, setlt, setle) + setcc) + select</span><br><span class="line">Cpu0: movz, movn</span><br></pre></td></tr></table></figure><h4 id="2-Cpu0ISelLowering-h-cpp"><a href="#2-Cpu0ISelLowering-h-cpp" class="headerlink" title="(2) Cpu0ISelLowering.h&#x2F;.cpp"></a>(2) Cpu0ISelLowering.h&#x2F;.cpp</h4><p>需要做一点配置。首先，LLVM 的后端会默认把 <code>SetCC</code> 和 <code>Select</code> 两个 Node 合并成一条 <code>Select_cc</code> 指令，这是为能够支持 <code>Select_cc</code> 指令的后端而准备的，这种指令是通过 condition code 来作为 <code>select</code> 指令的条件，比如在 X86 机器中。我们的 Cpu0 不支持这种指令，所以需要在 Cpu0ISelLowering.cpp 中，将 <code>Select_cc</code> 设置为 Expand 类型，表示我们希望 LLVM 帮我们替代这个类型的节点。</p><p>另一件事是将 <code>ISD::SELECT</code> 这个 Node 的默认下降关掉，也就是设置其为 Custom 类型，在我们自定义的下降中，直接将这个 Node 返回。因为我们不希望 select Node 在 lowering 阶段被选择为 select，这样它会无法选到指令。我们的条件 MOV 指令和这里的 select 指令有一些差异，所以只能通过在指令选择时的优化合并来实现从 select Node 到后端指令的 lowering。</p><h3 id="7-4-3-检验成果"><a href="#7-4-3-检验成果" class="headerlink" title="7.4.3 检验成果"></a>7.4.3 检验成果</h3><p>这一小节提供了 3 个 case，第一个 case （ch7_4_select.c）是最简单的情况，直接使用 C 语言中的三目运算符，clang 会在不开优化的情况下将其生成为 IR Select。</p><p>第二个 case (ch7_4_select2.c) 没有使用三目运算符，clang 在不开优化的编译下，会生成两个 BB 块，通过跳转实现功能，只有在启用至少 <code>-O1</code> 优化下，才会生成为 IR Select。</p><p>第三个 case (ch7_4_select_global_pic.c) 引入了全局变量，测试在全局变量与 select 混合的情况下是否能正常处理代码。</p><p>三个 case 的编译命令均与之前相同。</p><h2 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h2><p>以上就是本章的全部内容。最后再补充几个知识点。静态单赋值形式的表示形式，在对待多分支的控制流时，会遇到多赋值的问题。LLVM IR 处理这个问题的方式是引入 Phi 节点，Phi 节点是一种特殊的操作，它允许操作中通过判断控制流的流向来选择要赋值的值，从而避免了多赋值问题。</p><p>这种操作只有在 clang 启用优化的情况下才会生成，如果是 O0 不开优化时，LLVM 则会使用内存访问来解决问题，也就是将值写入同一个内存位置，再在需要赋值时从内存位置读出值，这样也能避免数据的多赋值。但也很显然，这种依赖于内存访问的方式会导致性能变差，所以只会在不开优化的情况下生成这种代码。</p><p>测试路径下也有这样的一个测试用例：ch7_5_phinode.c，可以通过 clang -O0 和 clang -O1 来编译生成 LLVM IR，查看代码并确认在 O1 优化下生成了 Phi 节点。</p><p>需要注意的是，因为我们目前还没有处理传参的问题，所以将 LLVM IR 编译成汇编代码的过程会出错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failed: (InVals.size() == Ins.size() &amp;&amp; &quot;LowerFormalArguments didn&#x27;t emit the correct number of values!&quot;), function LowerArguments, file </span><br></pre></td></tr></table></figure><p>我们会在下一章开始处理和函数调用有关的功能。</p><p>有关于 Phi 节点更多的细节，可以查看静态单赋值代码形式的 Wiki： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">https://en.wikipedia.org/wiki/Static_single_assignment_form</a>。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386457923">LLVM 后端实践笔记 7：控制流 - 知乎 (zhihu.com)</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://p2tree.top">P2Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://p2tree.top/posts/8908debe.html">https://p2tree.top/posts/8908debe.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://p2tree.top" target="_blank">P2Tree's Mill</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/LLVM/">LLVM</a></div><div class="post-share"><div class="social-share" data-image="https://img.p2tree.top/2021/07/04/index.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用"><img class="cover" src="https://img.p2tree.top/2021/07/24/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">LLVM 后端实践笔记 8：函数调用</div></div><div class="info-2"><div class="info-item-1">在这一章，我们会在 Cpu0 后端中增加对子过程&#x2F;函数调用的翻译功能，会添加大量代码。这一章首先会介绍 Mips 的栈帧结构，我们的 Cpu0 也会借用 Mips 的栈帧设计，大多数 RISC 机器的栈帧设计都是类似的，如果你对这块的背景知识有困惑，需要先查阅其他书籍，比如《深入理解计算机系统》这类计算机体系结构的书。 LLVM 后端实践笔记 0：序LLVM 后端实践笔记 1：新后端初始化和软件编译LLVM 后端实践笔记 2：后端结构LLVM 后端实践笔记 3：算术和逻辑指令LLVM 后端实践笔记 4：生成目标文件LLVM 后端实践笔记 5：全局变量LLVM 后端实践笔记 6：更多数据类型LLVM 后端实践笔记 7：控制流LLVM 后端实践笔记 8：函数调用LLVM 后端实践笔记 9：ELF文件支持LLVM 后端实践笔记 10：汇编LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器 8.1 栈帧结构Cpu0 函数调用的第一件事是设计好如何使用栈帧，比如在调用函数时，如何保存参数。 具体如下表所示，保存函数参数有两种设计，第一种是将所有参数都保存在栈...</div></div></div></a><a class="pagination-related" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型"><img class="cover" src="https://img.p2tree.top/2021/06/19/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LLVM 后端实践笔记 6：更多数据类型</div></div><div class="info-2"><div class="info-item-1">之前的章节只实现了 int 和 32 位的 long 类型数据，这一章会新增一些更复杂的数据类型，比如 char, bool, short, long long，还会增加结构体，浮点，和向量类型。这一部分内容相对比较简单，其实这些类型也都是标准语言都支持的类型，所以 LLVM 自身已经实现了很大一部分功能，只要我们的后端不那么奇怪，就很容易填补缺失的内容。 LLVM 后端实践笔记 0：序LLVM 后端实践笔记 1：新后端初始化和软件编译LLVM 后端实践笔记 2：后端结构LLVM 后端实践笔记 3：算术和逻辑指令LLVM 后端实践笔记 4：生成目标文件LLVM 后端实践笔记 5：全局变量LLVM 后端实践笔记 6：更多数据类型LLVM 后端实践笔记 7：控制流LLVM 后端实践笔记 8：函数调用LLVM 后端实践笔记 9：ELF文件支持LLVM 后端实践笔记 10：汇编LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器 6.1 实现类型6.1.1 局部指针我们需要在 td 文件中添加内存操作数的描述片段。具体参见代码描述部分。 6.1.2 char, sho...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet"><img class="cover" src="https://img.p2tree.top/2025/4/27/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">学习LLVM数据结构：SmallSet</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本系列文章以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 在现代编程语言开发中，集合（Set）是一种非常有用的数据结构，它可以高效存储唯一元素。本文介绍一种更轻量级的集合实现：SmallSet。它非常适合存储少量元素，同时保持出色的性能和内存效率。 基本介绍SmallSet 是一种小型集合类型，它实现了基本的集合操作，比如插入、删除和查找等。它的设计目标是优化在存储小规模数据时的性能和内存占用，它结合了小对象优化和动态内存调节技术，非常适合频繁访问的小集合场景。如果你已经对 SmallVector 有了解，那么 SmallSet 和它有着类似的实现思路。 llvm::SmallSet 定义在...</div></div></div></a><a class="pagination-related" href="/posts/a198516a.html" title="学习LLVM数据结构：StringRef"><img class="cover" src="https://img.p2tree.top/2025/3/25/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="info-item-2">学习LLVM数据结构：StringRef</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 基本介绍llvm::StringRef 定义在 llvm/ADT/StringRef.h 头文件中。 它的声明为： 1class StringRef; 和 ArrayRef 类似，StringRef 是一种轻量级的字符串引用类型，它用于实现高效地表示和操作字符串数据，尤其是在一些高频处理字符串，但同时不希望维护实际内存开销地场景下。 它是不可变引用，主要用于向函数内传递字符串同时避免深拷贝。它只包含了指向字符串的指针和字符串的长度信息，从而使得对它的操作直接而高效。 特点 轻量级：只存储一个指向字符串的指针和字符串的长度，不存储实际的数...</div></div></div></a><a class="pagination-related" href="/posts/e9ae65d7.html" title="学习LLVM数据结构：SmallVector"><img class="cover" src="https://img.p2tree.top/2025/3/9/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">学习LLVM数据结构：SmallVector</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 基本介绍llvm::SmallVector 定义在 llvm/ADT/SmallVector.h 头文件中。它的声明为： 12template&lt;typename T, unsigned N = CalculateSmallVectorDefaultInlinedElements&lt;T&gt;::value&gt; class SmallVector; llvm::SmallVector 是一个可变长数组，类似于 std::vector，同时它对较小长度的数组做了优化。它的内存管理方式采用局部缓存的设计思路，在对象内部预留一小块...</div></div></div></a><a class="pagination-related" href="/posts/cdf6959f.html" title="学习LLVM数据结构：ArrayRef"><img class="cover" src="https://img.p2tree.top/2025/2/25/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-25</div><div class="info-item-2">学习LLVM数据结构：ArrayRef</div></div><div class="info-2"><div class="info-item-1">在现代 C++ 程序开发中，选择合适的数据结构，对于程序性能和内存安全都至关重要。LLVM 项目中，有一大块内容便是设计用于内部开发的高效数据结构。 本文将以 cppreference 的格式，介绍这些实用的数据结构。你既可以将其作为学习参考，也可以作为学习 LLVM 的补充材料。 学习LLVM数据结构：ArrayRef学习LLVM数据结构：SmallVector学习LLVM数据结构：StringRef学习LLVM数据结构：SmallSet 基本介绍llvm::ArrayRef 定义在 llvm/ADT/ArrayRef.h 头文件中。它的声明为： 1template&lt;typename T&gt; class ArrayRef; llvm::ArrayRef 是一个轻量级的只读容器，主要用于引用一段连续的内存区域。它的设计目标是提供高效的数据访问，而不需要拥有底层数据的所有权。这使得 ArrayRef 特别适合在函数参数中实用，从而避免了不必要的内存拷贝。 特点 只读：ArrayRef 不能修改其引用的数据，也不能添加新元素（另一个容器 MutableArrayR...</div></div></div></a><a class="pagination-related" href="/posts/801cd0f2.html" title="LLVM 风格的 RTTI"><img class="cover" src="https://img.p2tree.top/2023/08/14/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="info-item-2">LLVM 风格的 RTTI</div></div><div class="info-2"><div class="info-item-1">开头叨叨众所周知，LLVM project 没有开启 C++ 的 RTTI 特性。一个主要的原因是 LLVM project 认为 C++ RTTI 特性的实现需要使用到虚函数表，对性能并不友好。LLVM 自己实现了一种类似 RTTI 的行为。我们在开发 LLVM 代码时，尤其是需要自己搭建自定义的数据结构时，可能会想用到 RTTI，此时，学习在 LLVM 风格下如何创建类似的 API，就显得尤为重要。 什么是 RTTI难度：⭐ RTTI 是运行时类型识别，全称 Runtime Type Identification，网上有很多介绍这个的资料，属于 C++ 程序员必须要熟悉的内容。 它的主要目的是为程序运行时提供一种对对象类型的获取、操作的方式。 对应到 C++ API 上，有三个 API 会用到 RTTI： dynamic_cast，用来将一个指向基类的指针转换为一个指向派生类的指针，如果转换失败，会返回 nullptr typeid，用来返回对象类型的值 type_info，也就是 typeid 的返回类型，用来存储描述类型的信息 如果不使用这三个 API，关闭 RTTI...</div></div></div></a><a class="pagination-related" href="/posts/ab589331.html" title="LLVM New Pass Manager"><img class="cover" src="https://img.p2tree.top/2022/12/03/index.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">LLVM New Pass Manager</div></div><div class="info-2"><div class="info-item-1">这是一篇译文，主要介绍了 LLVM 中的 New Pass Manager 原文链接：https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/by Arthur Eubanks（Mar 26, 2021） Pass Manager 的介绍Pass Manager 的主要用途是调度 Pass 在各 IR 层级按顺序运行。 Pass 分为 transformation pass 和 analyses pass，它们可以选择运行在 module、function 等各种 scope 下，甚至更加抽象地，比如 call graph 上的强连接组件（SCC: strongly connected component）或者 loop 上。 调度可以很简单，比如直接按顺序运行 pass list，或者按遇到的每一个 function 来调用。同时调度也可能很复杂，比如 SCC 在 call graph 中的顺序必须正确。 Pass Manager 还负责管理 analyses pass 的分析结果，比如说支配树（dominat...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://img.p2tree.top/avatar.webp" onerror='this.onerror=null,this.src="/img/404.gif"' alt="avatar"></div><div class="author-info-name">P2Tree</div><div class="author-info-description">基础软件研发工程师</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/p2tree" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:public@p2tree.top" target="_blank" title="Email"><i class="iconfont icon-mail"></i></a><a class="social-icon" href="https://zhihu.com/people/p2tree" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu"></i></a><a class="social-icon" href="/2024/08/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-P2Tree/" target="_blank" title="Weixin"><i class="iconfont icon-wechat"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="Feed"><i class="iconfont icon-feed"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问我的个人站点，这里会发布我的学习笔记和生活感悟。<br>可以通过选择分类或标签来阅读你感兴趣的文章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.</span> <span class="toc-text">7.1 控制流语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">7.1.1 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">1.2.</span> <span class="toc-text">7.1.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0ISelLowering-cpp"><span class="toc-number">1.2.1.</span> <span class="toc-text">(1) Cpu0ISelLowering.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0InstrInfo-td"><span class="toc-number">1.2.2.</span> <span class="toc-text">(2) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0MCInstLower-cpp"><span class="toc-number">1.2.3.</span> <span class="toc-text">(3) Cpu0MCInstLower.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0MCCodeEmitter-h-cpp"><span class="toc-number">1.2.4.</span> <span class="toc-text">(4) Cpu0MCCodeEmitter.h&#x2F;cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0AsmPrinter-h-cpp"><span class="toc-number">1.2.5.</span> <span class="toc-text">(5) Cpu0AsmPrinter.h&#x2F;cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-MCTargetDesc-Cpu0FixupKinds-h"><span class="toc-number">1.2.6.</span> <span class="toc-text">(6) MCTargetDesc&#x2F;Cpu0FixupKinds.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-MCTargetDesc-Cpu0ELFObjectWriter-cpp"><span class="toc-number">1.2.7.</span> <span class="toc-text">(7) MCTargetDesc&#x2F;Cpu0ELFObjectWriter.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-MCTargetDesc-Cpu0AsmBackend-cpp"><span class="toc-number">1.2.8.</span> <span class="toc-text">(8) MCTargetDesc&#x2F;Cpu0AsmBackend.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">1.3.</span> <span class="toc-text">7.1.3 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%B6%88%E9%99%A4%E6%97%A0%E7%94%A8%E7%9A%84-JMP-%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">7.2 消除无用的 JMP 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">7.2.1 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">2.2.</span> <span class="toc-text">7.2.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CMakeLists-txt"><span class="toc-number">2.2.1.</span> <span class="toc-text">(1) CMakeLists.txt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0-h"><span class="toc-number">2.2.2.</span> <span class="toc-text">(2) Cpu0.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0TargetMachine-cpp"><span class="toc-number">2.2.3.</span> <span class="toc-text">(3) Cpu0TargetMachine.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E"><span class="toc-number">2.3.</span> <span class="toc-text">7.2.3 文件新增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0DelUselessJMP-cpp"><span class="toc-number">2.3.1.</span> <span class="toc-text">(1) Cpu0DelUselessJMP.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">2.4.</span> <span class="toc-text">7.2.4 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%A1%AB%E5%85%85%E8%B7%B3%E8%BD%AC%E5%BB%B6%E8%BF%9F%E6%A7%BD"><span class="toc-number">3.</span> <span class="toc-text">7.3 填充跳转延迟槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">7.3.1 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">3.2.</span> <span class="toc-text">7.3.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CMakeLists-txt-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">(1) CMakeLists.txt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0-h-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">(2) Cpu0.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0TargetMachine-cpp-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">(3) Cpu0TargetMachine.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0AsmPrinter-cpp"><span class="toc-number">3.2.4.</span> <span class="toc-text">(4) Cpu0AsmPrinter.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E-1"><span class="toc-number">3.3.</span> <span class="toc-text">7.2.3 文件新增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0DelaySlotFiller-cpp"><span class="toc-number">3.3.1.</span> <span class="toc-text">(1) Cpu0DelaySlotFiller.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">3.4.</span> <span class="toc-text">7.3.4 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E6%9D%A1%E4%BB%B6-MOV-%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">7.4 条件 MOV 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">7.4.1 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">4.2.</span> <span class="toc-text">7.4.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0InstrInfo-td"><span class="toc-number">4.2.1.</span> <span class="toc-text">(1) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0ISelLowering-h-cpp"><span class="toc-number">4.2.2.</span> <span class="toc-text">(2) Cpu0ISelLowering.h&#x2F;.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">4.3.</span> <span class="toc-text">7.4.3 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">7.5 总结</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器"><img src="https://img.p2tree.top/2021/09/10/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器"></a><div class="content"><a class="title" href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a><time datetime="2021-09-10T17:12:50.000Z" title="发表于 2021-09-10 17:12:50">2021-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编"><img src="https://img.p2tree.top/2021/08/07/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 10：汇编"></a><div class="content"><a class="title" href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a><time datetime="2021-08-07T23:15:39.000Z" title="发表于 2021-08-07 23:15:39">2021-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持"><img src="https://img.p2tree.top/2021/07/31/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 9：ELF文件支持"></a><div class="content"><a class="title" href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a><time datetime="2021-07-31T23:04:26.000Z" title="发表于 2021-07-31 23:04:26">2021-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用"><img src="https://img.p2tree.top/2021/07/24/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 8：函数调用"></a><div class="content"><a class="title" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a><time datetime="2021-07-24T23:01:27.000Z" title="发表于 2021-07-24 23:01:27">2021-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流"><img src="https://img.p2tree.top/2021/07/04/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 7：控制流"></a><div class="content"><a class="title" href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a><time datetime="2021-07-04T22:09:23.000Z" title="发表于 2021-07-04 22:09:23">2021-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型"><img src="https://img.p2tree.top/2021/06/19/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 6：更多数据类型"></a><div class="content"><a class="title" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a><time datetime="2021-06-19T17:15:17.000Z" title="发表于 2021-06-19 17:15:17">2021-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量"><img src="https://img.p2tree.top/2021/06/06/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 5：全局变量"></a><div class="content"><a class="title" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a><time datetime="2021-06-06T21:38:10.000Z" title="发表于 2021-06-06 21:38:10">2021-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件"><img src="https://img.p2tree.top/2021/05/11/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 4：生成目标文件"></a><div class="content"><a class="title" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a><time datetime="2021-05-11T22:18:35.000Z" title="发表于 2021-05-11 22:18:35">2021-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令"><img src="https://img.p2tree.top/2021/04/05/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 3：算术和逻辑指令"></a><div class="content"><a class="title" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a><time datetime="2021-04-05T23:24:42.000Z" title="发表于 2021-04-05 23:24:42">2021-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构"><img src="https://img.p2tree.top/2021/03/13/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 2：后端结构"></a><div class="content"><a class="title" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a><time datetime="2021-03-13T07:47:31.000Z" title="发表于 2021-03-13 07:47:31">2021-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译"><img src="https://img.p2tree.top/2021/02/24/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 1：新后端初始化和软件编译"></a><div class="content"><a class="title" href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a><time datetime="2021-02-24T22:53:00.000Z" title="发表于 2021-02-24 22:53:00">2021-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序"><img src="https://img.p2tree.top/2021/02/22/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 0：序"></a><div class="content"><a class="title" href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a><time datetime="2021-02-22T23:14:05.000Z" title="发表于 2021-02-22 23:14:05">2021-02-22</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4fefbc0d.html" title="跟随一条指令来看LLVM的基本结构"><img src="https://img.p2tree.top/2020/01/04/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跟随一条指令来看LLVM的基本结构"></a><div class="content"><a class="title" href="/posts/4fefbc0d.html" title="跟随一条指令来看LLVM的基本结构">跟随一条指令来看LLVM的基本结构</a><time datetime="2025-12-17T14:29:57.080Z" title="更新于 2025-12-17 14:29:57">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a866e07b.html" title="计算机体系结构模拟器简述"><img src="https://img.p2tree.top/2025/12/5/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机体系结构模拟器简述"></a><div class="content"><a class="title" href="/posts/a866e07b.html" title="计算机体系结构模拟器简述">计算机体系结构模拟器简述</a><time datetime="2025-12-17T14:29:57.079Z" title="更新于 2025-12-17 14:29:57">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1e952ac7.html" title="读书推荐：南京大屠杀"><img src="https://img.p2tree.top/2025/4/26/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：南京大屠杀"></a><div class="content"><a class="title" href="/posts/1e952ac7.html" title="读书推荐：南京大屠杀">读书推荐：南京大屠杀</a><time datetime="2025-12-17T14:29:57.079Z" title="更新于 2025-12-17 14:29:57">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dc0bdc19.html" title="读书推荐：活着"><img src="https://img.p2tree.top/2024/12/15/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：活着"></a><div class="content"><a class="title" href="/posts/dc0bdc19.html" title="读书推荐：活着">读书推荐：活着</a><time datetime="2025-12-17T14:29:57.079Z" title="更新于 2025-12-17 14:29:57">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2626ad0e.html" title="读书推荐：宝贵的人生建议"><img src="https://img.p2tree.top/2024/10/27/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：宝贵的人生建议"></a><div class="content"><a class="title" href="/posts/2626ad0e.html" title="读书推荐：宝贵的人生建议">读书推荐：宝贵的人生建议</a><time datetime="2025-12-17T14:29:57.079Z" title="更新于 2025-12-17 14:29:57">2025-12-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://img.p2tree.top/default.webp)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2025 By P2Tree</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.0"></script><script src="/js/main.js?v=5.5.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.29/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const o="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t=(t=document,e=location.pathname)=>{twikoo.init({el:t.querySelector("#twikoo-wrap"),envId:"https://twikoo.p2tree.top/",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))},path:e}),o&&(window.shuoshuoComment.destroyTwikoo=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})},e=(o,e)=>{"object"==typeof twikoo?setTimeout(()=>t(o,e),0):btf.getScript("https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js").then(()=>t(o,e))};o?window.shuoshuoComment={loadComment:e}:e()})()</script></div><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3JR7r5l5JW5Miut3",ck:"3JR7r5l5JW5Miut3",autoTrack:!0})</script><script src="/js/mourning.js"></script><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div id="algolia-search-input"><div class="ais-SearchBox"><form class="ais-SearchBox-form" action="" role="search" novalidate><input class="ais-SearchBox-input" type="search" placeholder="搜索文章" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" maxlength="512" aria-label="Search"><button class="ais-SearchBox-submit" type="submit" title="Submit the search query" style="display:none"><svg class="ais-SearchBox-submitIcon" width="10" height="10" viewBox="0 0 40 40" aria-hidden="true"><path d="M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z"></path></svg></button></form></div><hr><div id="algolia-search-results"><div id="algolia-hits"><div id="algolia-hits-empty" style="display:none"></div><div class="ais-Hits" style="display:none"><ol class="ais-Hits-list"></ol></div></div><div class="ais-Pagination" id="algolia-pagination" style="display:none"><ul class="ais-Pagination-list"></ul></div><div id="algolia-info"><span class="ais-Stats-text"></span><a class="algolia-poweredBy" href="https://www.algolia.com/?utm_source=algoliasearch.js&amp;utm_medium=website&amp;utm_content=localhost&amp;utm_campaign=poweredby" target="_blank" aria-label="Search by Algolia" rel="noopener noreferrer"><svg class="ais-PoweredBy-logo" height="1.2em" viewBox="0 0 572 64" style="width:auto"><path fill="#36395A" d="M16 48.3c-3.4 0-6.3-.6-8.7-1.7A12.4 12.4 0 0 1 1.9 42C.6 40 0 38 0 35.4h6.5a6.7 6.7 0 0 0 3.9 6c1.4.7 3.3 1.1 5.6 1.1 2.2 0 4-.3 5.4-1a7 7 0 0 0 3-2.4 6 6 0 0 0 1-3.4c0-1.5-.6-2.8-1.9-3.7-1.3-1-3.3-1.6-5.9-1.8l-4-.4c-3.7-.3-6.6-1.4-8.8-3.4a10 10 0 0 1-3.3-7.9c0-2.4.6-4.6 1.8-6.4a12 12 0 0 1 5-4.3c2.2-1 4.7-1.6 7.5-1.6s5.5.5 7.6 1.6a12 12 0 0 1 5 4.4c1.2 1.8 1.8 4 1.8 6.7h-6.5a6.4 6.4 0 0 0-3.5-5.9c-1-.6-2.6-1-4.4-1s-3.2.3-4.4 1c-1.1.6-2 1.4-2.6 2.4-.5 1-.8 2-.8 3.1a5 5 0 0 0 1.5 3.6c1 1 2.6 1.7 4.7 1.9l4 .3c2.8.2 5.2.8 7.2 1.8 2.1 1 3.7 2.2 4.9 3.8a9.7 9.7 0 0 1 1.7 5.8c0 2.5-.7 4.7-2 6.6a13 13 0 0 1-5.6 4.4c-2.4 1-5.2 1.6-8.4 1.6Zm35.6 0c-2.6 0-4.8-.4-6.7-1.3a13 13 0 0 1-4.7-3.5 17.1 17.1 0 0 1-3.6-10.4v-1c0-2 .3-3.8 1-5.6a13 13 0 0 1 7.3-8.3 15 15 0 0 1 6.3-1.4A13.2 13.2 0 0 1 64 24.3c1 2.2 1.6 4.6 1.6 7.2V34H39.4v-4.3h21.8l-1.8 2.2c0-2-.3-3.7-.9-5.1a7.3 7.3 0 0 0-2.7-3.4c-1.2-.7-2.7-1.1-4.6-1.1s-3.4.4-4.7 1.3a8 8 0 0 0-2.9 3.6c-.6 1.5-.9 3.3-.9 5.4 0 2 .3 3.7 1 5.3a7.9 7.9 0 0 0 2.8 3.7c1.3.8 3 1.3 5 1.3s3.8-.5 5.1-1.3c1.3-1 2.1-2 2.4-3.2h6a11.8 11.8 0 0 1-7 8.7 16 16 0 0 1-6.4 1.2ZM80 48c-2.2 0-4-.3-5.7-1a8.4 8.4 0 0 1-3.7-3.3 9.7 9.7 0 0 1-1.3-5.2c0-2 .5-3.8 1.5-5.2a9 9 0 0 1 4.3-3.1c1.8-.7 4-1 6.7-1H89v4.1h-7.5c-2 0-3.4.5-4.4 1.4-1 1-1.6 2.1-1.6 3.6s.5 2.7 1.6 3.6c1 1 2.5 1.4 4.4 1.4 1.1 0 2.2-.2 3.2-.7 1-.4 1.9-1 2.6-2 .6-1 1-2.4 1-4.2l1.7 2.1c-.2 2-.7 3.8-1.5 5.2a9 9 0 0 1-3.4 3.3 12 12 0 0 1-5.3 1Zm9.5-.7v-8.8h-1v-10c0-1.8-.5-3.2-1.4-4.1-1-1-2.4-1.4-4.2-1.4a142.9 142.9 0 0 0-10.2.4v-5.6a74.8 74.8 0 0 1 8.6-.4c3 0 5.5.4 7.5 1.2s3.4 2 4.4 3.6c1 1.7 1.4 4 1.4 6.7v18.4h-5Zm12.9 0V17.8h5v12.3h-.2c0-4.2 1-7.4 2.8-9.5a11 11 0 0 1 8.3-3.1h1v5.6h-2a9 9 0 0 0-6.3 2.2c-1.5 1.5-2.2 3.6-2.2 6.4v15.6h-6.4Zm34.4 1a15 15 0 0 1-6.6-1.3c-1.9-.9-3.4-2-4.7-3.5a15.5 15.5 0 0 1-2.7-5c-.6-1.7-1-3.6-1-5.4v-1c0-2 .4-3.8 1-5.6a15 15 0 0 1 2.8-4.9c1.3-1.5 2.8-2.6 4.6-3.5a16.4 16.4 0 0 1 13.3.2c2 1 3.5 2.3 4.8 4a12 12 0 0 1 2 6H144c-.2-1.6-1-3-2.2-4.1a7.5 7.5 0 0 0-5.2-1.7 8 8 0 0 0-4.7 1.3 8 8 0 0 0-2.8 3.6 13.8 13.8 0 0 0 0 10.3c.6 1.5 1.5 2.7 2.8 3.6s2.8 1.3 4.8 1.3c1.5 0 2.7-.2 3.8-.8a7 7 0 0 0 2.6-2c.7-1 1-2 1.2-3.2h6.2a11 11 0 0 1-2 6.2 15.1 15.1 0 0 1-11.8 5.5Zm19.7-1v-40h6.4V31h-1.3c0-3 .4-5.5 1.1-7.6a9.7 9.7 0 0 1 3.5-4.8A9.9 9.9 0 0 1 172 17h.3c3.5 0 6 1.1 7.9 3.5 1.7 2.3 2.6 5.7 2.6 10v16.8h-6.4V29.6c0-2.1-.6-3.8-1.8-5a6.4 6.4 0 0 0-4.8-1.8c-2 0-3.7.7-5 2a7.8 7.8 0 0 0-1.9 5.5v17h-6.4Zm63.8 1a12.2 12.2 0 0 1-10.9-6.2 19 19 0 0 1-1.8-7.3h1.4v12.5h-5.1v-40h6.4v19.8l-2 3.5c.2-3.1.8-5.7 1.9-7.7a11 11 0 0 1 4.4-4.5c1.8-1 3.9-1.5 6.1-1.5a13.4 13.4 0 0 1 12.8 9.1c.7 1.9 1 3.8 1 6v1c0 2.2-.3 4.1-1 6a13.6 13.6 0 0 1-13.2 9.4Zm-1.2-5.5a8.4 8.4 0 0 0 7.9-5c.7-1.5 1.1-3.3 1.1-5.3s-.4-3.8-1.1-5.3a8.7 8.7 0 0 0-3.2-3.6 9.6 9.6 0 0 0-9.2-.2 8.5 8.5 0 0 0-3.3 3.2c-.8 1.4-1.3 3-1.3 5v2.3a9 9 0 0 0 1.3 4.8 9 9 0 0 0 3.4 3c1.4.7 2.8 1 4.4 1Zm27.3 3.9-10-28.9h6.5l9.5 28.9h-6Zm-7.5 12.2v-5.7h4.9c1 0 2-.1 2.9-.4a4 4 0 0 0 2-1.4c.4-.7.9-1.6 1.2-2.7l8.6-30.9h6.2l-9.3 32.4a14 14 0 0 1-2.5 5 8.9 8.9 0 0 1-4 2.8c-1.5.6-3.4.9-5.6.9h-4.4Zm9-12.2v-5.2h6.4v5.2H248Z"></path><path fill="#003DFF" d="M534.4 9.1H528a.8.8 0 0 1-.7-.7V1.8c0-.4.2-.7.6-.8l6.5-1c.4 0 .8.2.9.6v7.8c0 .4-.4.7-.8.7zM428 35.2V.8c0-.5-.3-.8-.7-.8h-.2l-6.4 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.5 0 .8-.4.8-.8V43c0-.4-.3-.7-.6-.8-4.5-.5-4.5-6-4.5-7zm106.5-21.8H528c-.4 0-.7.4-.7.8v34c0 .4.3.8.7.8h6.5c.4 0 .8-.4.8-.8v-34c0-.5-.4-.8-.8-.8zm-17.7 21.8V.8c0-.5-.3-.8-.8-.8l-6.5 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.4 0 .8-.4.8-.8V43c0-.4-.3-.7-.7-.8-4.4-.5-4.4-6-4.4-7zm-22.2-20.6a16.5 16.5 0 0 1 8.6 9.3c.8 2.2 1.3 4.8 1.3 7.5a19.4 19.4 0 0 1-4.6 12.6 14.8 14.8 0 0 1-5.2 3.6c-2 .9-5.2 1.4-6.8 1.4a21 21 0 0 1-6.7-1.4 15.4 15.4 0 0 1-8.6-9.3 21.3 21.3 0 0 1 0-14.4 15.2 15.2 0 0 1 8.6-9.3c2-.8 4.3-1.2 6.7-1.2s4.6.4 6.7 1.2zm-6.7 27.6c2.7 0 4.7-1 6.2-3s2.2-4.3 2.2-7.8-.7-6.3-2.2-8.3-3.5-3-6.2-3-4.7 1-6.1 3c-1.5 2-2.2 4.8-2.2 8.3s.7 5.8 2.2 7.8 3.5 3 6.2 3zm-88.8-28.8c-6.2 0-11.7 3.3-14.8 8.2a18.6 18.6 0 0 0 4.8 25.2c1.8 1.2 4 1.8 6.2 1.7s.1 0 .1 0h.9c4.2-.7 8-4 9.1-8.1v7.4c0 .4.3.7.8.7h6.4a.7.7 0 0 0 .7-.7V14.2c0-.5-.3-.8-.7-.8h-13.5zm6.3 26.5a9.8 9.8 0 0 1-5.7 2h-.5a10 10 0 0 1-9.2-14c1.4-3.7 5-6.3 9-6.3h6.4v18.3zm152.3-26.5h13.5c.5 0 .8.3.8.7v33.7c0 .4-.3.7-.8.7h-6.4a.7.7 0 0 1-.8-.7v-7.4c-1.2 4-4.8 7.4-9 8h-.1a4.2 4.2 0 0 1-.5.1h-.9a10.3 10.3 0 0 1-7-2.6c-4-3.3-6.5-8.4-6.5-14.2 0-3.7 1-7.2 3-10 3-5 8.5-8.3 14.7-8.3zm.6 28.4c2.2-.1 4.2-.6 5.7-2V21.7h-6.3a9.8 9.8 0 0 0-9 6.4 10.2 10.2 0 0 0 9.1 13.9h.5zM452.8 13.4c-6.2 0-11.7 3.3-14.8 8.2a18.5 18.5 0 0 0 3.6 24.3 10.4 10.4 0 0 0 13 .6c2.2-1.5 3.8-3.7 4.5-6.1v7.8c0 2.8-.8 5-2.2 6.3-1.5 1.5-4 2.2-7.5 2.2l-6-.3c-.3 0-.7.2-.8.5l-1.6 5.5c-.1.4.1.8.5 1h.1c2.8.4 5.5.6 7 .6 6.3 0 11-1.4 14-4.1 2.7-2.5 4.2-6.3 4.5-11.4V14.2c0-.5-.4-.8-.8-.8h-13.5zm6.3 8.2v18.3a9.6 9.6 0 0 1-5.6 2h-1a10.3 10.3 0 0 1-8.8-14c1.4-3.7 5-6.3 9-6.3h6.4zM291 31.5A32 32 0 0 1 322.8 0h30.8c.6 0 1.2.5 1.2 1.2v61.5c0 1.1-1.3 1.7-2.2 1l-19.2-17a18 18 0 0 1-11 3.4 18.1 18.1 0 1 1 18.2-14.8c-.1.4-.5.7-.9.6-.1 0-.3 0-.4-.2l-3.8-3.4c-.4-.3-.6-.8-.7-1.4a12 12 0 1 0-2.4 8.3c.4-.4 1-.5 1.6-.2l14.7 13.1v-46H323a26 26 0 1 0 10 49.7c.8-.4 1.6-.2 2.3.3l3 2.7c.3.2.3.7 0 1l-.2.2a32 32 0 0 1-47.2-28.6z"></path></svg></a></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@5.37.0/dist/lite/builds/browser.umd.min.js"></script><script src="/js/search/algolia.js?v=5.5.0"></script></div></div><script data-pjax>function butterfly_footer_beautify_injector_config(){var e=document.getElementById("footer");console.log("已挂载butterfly_footer_beautify"),e.innerHTML='<footer id="footer" style="background: transparent"><div id="footer-bottom"><div class="footer-bottom-content"><div class="footer-bottom-left"><span class="copyright">&copy;2024 - 2025 By <a target="_blank" rel="noopener" href="https://p2tree.top/" title="点击访问&quot;P2Tree&quot;的主页" style="margin-left:5px">P2Tree</a></span><div></div></div><div class="footer-bottom-right"><div><a class="footer-bottom-link" target="_blank" href="https://icp.hentioe.dev/sites/20255550" rel="noopener external nofollow" title="喵ICP备20255550号">喵ICP备20255550号</a><a class="footer-bottom-link" target="_blank" href="https://hexo.io/zh-cn/" rel="noopener external nofollow" title="博客框架">Hexo</a><a class="footer-bottom-link" target="_blank" href="https://butterfly.js.org/" rel="noopener external nofollow" title="主题">Butterfly</a><a class="footer-bottom-link" target="_blank" href="https://vercel.com/" rel="noopener external nofollow" title="undefined">Vercel</a><a class="footer-bottom-link" target="_blank" href="https://cloudflare.com/" rel="noopener external nofollow" title="undefined">CloudFlare</a><a class="footer-bottom-link" target="_blank" href="https://v6.51.la/land/3JR7r5l5JW5Miut3" rel="noopener external nofollow" title="undefined">51LA</a><a class="footer-bottom-link" target="_blank" href="https://stat.p2tree.top/" rel="noopener external nofollow" title="undefined">UptimeFlare</a></div></div></div></div></footer>'}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script defer src="https://cdn1.tianli0.top/npm/hexo-butterfly-footer-marcus/lib/footer.min.js"></script></body></html>