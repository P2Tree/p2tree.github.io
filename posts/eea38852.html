<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>LLVM 后端实践笔记 2：后端结构 | P2Tree Home</title><meta name="author" content="P2Tree"><meta name="copyright" content="P2Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这一章介绍LLVM后端代码的组成结构，并分别实现这些结构下的类。这一章结束时，我们的后端就能够正常生成简单代码的汇编码了。这一章会增加不少代码，Cpu0 的后端代码主要参考 Mips 后端的代码，建议直接复制拿去用，然后根据实际情况修改。 这一章需要留意一下类关系。还需要知道指令选择、寄存器分配等概念。到调整栈帧的时候，可能会有点难，但只要对计算机体系结构比较清楚，相对会好理解。 （内容有点多，建"><meta property="og:type" content="article"><meta property="og:title" content="LLVM 后端实践笔记 2：后端结构"><meta property="og:url" content="https://p2tree.top/posts/eea38852.html"><meta property="og:site_name" content="P2Tree Home"><meta property="og:description" content="这一章介绍LLVM后端代码的组成结构，并分别实现这些结构下的类。这一章结束时，我们的后端就能够正常生成简单代码的汇编码了。这一章会增加不少代码，Cpu0 的后端代码主要参考 Mips 后端的代码，建议直接复制拿去用，然后根据实际情况修改。 这一章需要留意一下类关系。还需要知道指令选择、寄存器分配等概念。到调整栈帧的时候，可能会有点难，但只要对计算机体系结构比较清楚，相对会好理解。 （内容有点多，建"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p2tree.top/img/20210313/index.webp"><meta property="article:published_time" content="2021-03-13T07:47:31.000Z"><meta property="article:modified_time" content="2024-08-19T15:26:47.818Z"><meta property="article:author" content="P2Tree"><meta property="article:tag" content="编译器"><meta property="article:tag" content="LLVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p2tree.top/img/20210313/index.webp"><link rel="shortcut icon" href="/img/avatar.webp"><link rel="canonical" href="https://p2tree.top/posts/eea38852.html"><link rel="preconnect" href="https://npm.elemecdn.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@latest/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:{limitDay:1e3,position:"top",messagePrev:"距离上次更新已过去",messageNext:"天，文章中的部分内容可能已经过时，请酌情参考～"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:500,languages:{author:"作者: P2Tree",link:"链接: ",source:"来源: P2Tree Home",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://npm.elemecdn.com/@egjs/infinitegrid@latest/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"LLVM 后端实践笔记 2：后端结构",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-08-19 15:26:47"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach(e=>{c.setAttribute(e,t[e])}),document.head.appendChild(c)}),e.getCSS=(e,t=!1)=>new Promise((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="baidu-site-verification" content="codeva-Watq1Co2vC"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4649427_nfzovmtn6c.css"><link rel="stylesheet" href="/css/footer_beautify.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="P2Tree Home" type="application/atom+xml">
</head><body><script>window.paceOptions={restartOnPushState:!1},document.addEventListener("pjax:send",()=>{Pace.restart()})</script><link rel="stylesheet" href="/css/pace-theme-minimal.css"><script src="https://npm.elemecdn.com/pace-js@latest/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.jpg" data-lazy-src="/img/avatar.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-pen-to-square"></i><span> Article</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Library</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> Games</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/20210313/index.webp)"><nav id="nav"><span id="blog-info"><a href="/" title="P2Tree Home"><span class="site-name">P2Tree Home</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-pen-to-square"></i><span> Article</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Library</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> Games</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LLVM 后端实践笔记 2：后端结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-13T07:47:31.000Z" title="发表于 2021-03-13 07:47:31">2021-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-19T15:26:47.818Z" title="更新于 2024-08-19 15:26:47">2024-08-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="LLVM 后端实践笔记 2：后端结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这一章介绍LLVM后端代码的组成结构，并分别实现这些结构下的类。这一章结束时，我们的后端就能够正常生成简单代码的汇编码了。这一章会增加不少代码，Cpu0 的后端代码主要参考 Mips 后端的代码，建议直接复制拿去用，然后根据实际情况修改。</p><p>这一章需要留意一下类关系。还需要知道指令选择、寄存器分配等概念。到调整栈帧的时候，可能会有点难，但只要对计算机体系结构比较清楚，相对会好理解。</p><p>（内容有点多，建议收藏后分多次阅读。本来打算分开的，但感觉分开之后章节关系变得太松散了，便作罢）</p><ol><li><a href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a></li><li><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a></li><li><a href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a></li><li><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a></li><li><a href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a></li><li><a href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a></li><li><a href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a></li><li><a href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a></li><li><a href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a></li><li><a href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a></li><li><a href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a></li><li><a href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a></li></ol><hr><h2 id="2-1-目标机器架构"><a href="#2-1-目标机器架构" class="headerlink" title="2.1 目标机器架构"></a>2.1 目标机器架构</h2><p>这一部分代码比较多，主要有以下一些文件，实际内容请参考我提供的代码。</p><h3 id="2-1-1-文件新增"><a href="#2-1-1-文件新增" class="headerlink" title="2.1.1 文件新增"></a>2.1.1 文件新增</h3><h4 id="1-Cpu0TargetMachine-h-cpp"><a href="#1-Cpu0TargetMachine-h-cpp" class="headerlink" title="(1) Cpu0TargetMachine.h&#x2F;.cpp"></a>(1) Cpu0TargetMachine.h&#x2F;.cpp</h4><p>这是有关于目标机器的定义，实现了 <code>Cpu0TargetMachine</code>，<code>Cpu0ebTargetMachine</code>，<code>Cpu0elTargetMachine</code> 三个类，后两个类继承第一个类，而第一个类继承自 <code>LLVMTargetMachine</code>。其中定义了有关于目标的初始化工作，比如拼装 DataLayout，重定位模式，大小端，核心目的就是生成 TargetMachine 的对象，LLVM 会用。</p><p>其中有个函数 <code>getSubtargetImpl()</code>，这个函数可以构造 Subtarget 对象，进而能引用到 Subtarget 的属性和方法。</p><h4 id="2-Cpu0FrameLowering-h-cpp"><a href="#2-Cpu0FrameLowering-h-cpp" class="headerlink" title="(2) Cpu0FrameLowering.h&#x2F;.cpp"></a>(2) Cpu0FrameLowering.h&#x2F;.cpp</h4><p>这是 Frame Lowering 的功能实现，完成栈的管理。基于 <code>TargetFrameLowering</code> 实现了 <code>Cpu0FrameLowering</code> 类，本身没有太多东西，重要内容都放到 <code>Cpu0SEFrameLowering.h/.cpp</code>文件中了。</p><p>Cpu0 的栈也是向下生长，用栈指针指向栈顶，栈内内容通过栈指针加一个正数的偏移来获取。栈中的内容按顺序从高地址到低地址是：函数参数、GP、自由空间、CPU 的 Callee 寄存器、FP、RA、FPU 的 Callee 寄存器。</p><p><code>hasFP()</code> 方法用来判断函数栈中是否包含 FP（帧指针，可以用来作为固定基址访问栈，但也可以被 SP 替代）。</p><p><code>create()</code> 方法用来创建该类的对象，实际要返回的是它的子类对象，比如 <code>Cpu0SEFrameLowering</code>。</p><h4 id="3-Cpu0SEFrameLowering-h-cpp"><a href="#3-Cpu0SEFrameLowering-h-cpp" class="headerlink" title="(3) Cpu0SEFrameLowering.h&#x2F;.cpp"></a>(3) Cpu0SEFrameLowering.h&#x2F;.cpp</h4><p>继承自 <code>Cpu0FrameLowering</code> 类实现了 <code>Cpu0SEFrameLowering</code> 类，SE 的意思是 stardand edition，在 Mips 里边表示 32 位版本，我们目前的 Cpu0 只有 32 位版本，不过后端还是做了区分，有利于将来再扩展其他版本的后端，比如 16 位 Cpu0。</p><p>项目中出现的 SE 基本都是指 startdand edition，下不赘述。</p><p>留了 <code>emitPrologue</code> 和 <code>emitEpilogue</code> 函数的坑，这两个函数在 Frame Lowering 中很重要，用来在进入函数前和从函数返回时插入内容。后边章节会补充这块内容。</p><h4 id="4-Cpu0InstrInfo-h-cpp"><a href="#4-Cpu0InstrInfo-h-cpp" class="headerlink" title="(4) Cpu0InstrInfo.h&#x2F;.cpp"></a>(4) Cpu0InstrInfo.h&#x2F;.cpp</h4><p>这是指令相关的代码，用来基于 tablegen 生成的指令描述完成和指令相关的动作，所以它包含 Cpu0GenInstrInfo.inc。定义了 <code>Cpu0InstrInfo</code> 类，继承自 <code>Cpu0GenInstrInfo</code>，基类就是由 tablegen 生成的类结构。因为 tablegen 的功能并不够那么灵活（至少不如 C++ 灵活），所以有一些情况需要在 C++ 代码中处理。类里边目前还没有实质性的内容。</p><p>其中有个成员是 Subtarget 对象，在构造函数中初始化。反复强调 Subtarget，是因为它是所有类结构中占据比较中心位置的一个类。</p><h4 id="5-Cpu0SEInstrInfo-h-cpp"><a href="#5-Cpu0SEInstrInfo-h-cpp" class="headerlink" title="(5) Cpu0SEInstrInfo.h&#x2F;.cpp"></a>(5) Cpu0SEInstrInfo.h&#x2F;.cpp</h4><p>基于 <code>Cpu0InstrInfo</code> 类定义的派生类 <code>Cpu0SEInstrInfo</code> ，目前也没有什么重要内容。只做了工厂函数。</p><h4 id="6-Cpu0ISelLowering-h-cpp"><a href="#6-Cpu0ISelLowering-h-cpp" class="headerlink" title="(6) Cpu0ISelLowering.h&#x2F;.cpp"></a>(6) Cpu0ISelLowering.h&#x2F;.cpp</h4><p>关于指令选择中将 LLVM IR 下降为 IR SelectionDAG 的功能实现，继承自 <code>TargetLowering</code> 定义了 <code>Cpu0TargetLowering</code>。</p><p>包含了 Cpu0GenCallingConv.inc 文件，该文件由 Cpu0CallingConv.td 文件生成，用到了它里边定义的一些类型。</p><p>其中挖了 <code>LowerGlobalAddress</code> 的坑，将来会补；<code>LowerRet()</code> 方法返回 <code>CPU0ISD::Ret</code> 这个 ISDNode。</p><p><code>create()</code> 方法用来生成对象，实际返回的是它的子类对象，比如 <code>Cpu0SEISelLowering</code>。</p><h4 id="7-Cpu0SEISelLowering-h-cpp"><a href="#7-Cpu0SEISelLowering-h-cpp" class="headerlink" title="(7) Cpu0SEISelLowering.h&#x2F;.cpp"></a>(7) Cpu0SEISelLowering.h&#x2F;.cpp</h4><p>定义 <code>Cpu0SEISelLowering</code> 类，继承自 <code>Cpu0ISelLowering</code> 类。暂没有实质的内容。</p><h4 id="8-Cpu0MachineFunctionInfo-h-cpp"><a href="#8-Cpu0MachineFunctionInfo-h-cpp" class="headerlink" title="(8) Cpu0MachineFunctionInfo.h&#x2F;.cpp"></a>(8) Cpu0MachineFunctionInfo.h&#x2F;.cpp</h4><p>用来处理和函数有关的动作。继承 <code>MachineFunctionInfo</code> 类定义 <code>Cpu0MachineFunctionInfo</code>类。声明了与参数有关的方法，不过目前都先挖坑，后续补。</p><h4 id="9-MCTargetDesc-Cpu0ABIInfo-h-cpp"><a href="#9-MCTargetDesc-Cpu0ABIInfo-h-cpp" class="headerlink" title="(9) MCTargetDesc&#x2F;Cpu0ABIInfo.h&#x2F;.cpp"></a>(9) MCTargetDesc&#x2F;Cpu0ABIInfo.h&#x2F;.cpp</h4><p>定义 ABI 的信息，提供了 O32、S32 和未知三种 ABI 规范。</p><p>这套文件在其他一些后端里是没有的，这里参考 Mips 后端的规范和设计，就一并给加上了。</p><h4 id="10-Cpu0RegisterInfo-h-cpp"><a href="#10-Cpu0RegisterInfo-h-cpp" class="headerlink" title="(10) Cpu0RegisterInfo.h&#x2F;.cpp"></a>(10) Cpu0RegisterInfo.h&#x2F;.cpp</h4><p>包含有 Cpu0GenRegisterInfo.inc 文件，基于 <code>Cpu0GenRegisterInfo</code> 类定义了 <code>Cpu0RegisterInfo</code> 方法。定义了几个和寄存器有关的方法，同理，这里也是因为 tablegen 文件不够灵活，无法描述复杂的寄存器信息时，在这里用钩子函数挂上。大多数方法的定义暂时先挖坑。</p><h4 id="11-Cpu0SERegisterInfo-h-cpp"><a href="#11-Cpu0SERegisterInfo-h-cpp" class="headerlink" title="(11) Cpu0SERegisterInfo.h&#x2F;.cpp"></a>(11) Cpu0SERegisterInfo.h&#x2F;.cpp</h4><p>基于 <code>Cpu0RegisterInfo</code> 定义的一个子类 <code>Cpu0SERegisterInfo</code>。暂时没有啥东西。</p><h4 id="12-Cpu0Subtarget-h-cpp"><a href="#12-Cpu0Subtarget-h-cpp" class="headerlink" title="(12) Cpu0Subtarget.h&#x2F;.cpp"></a>(12) Cpu0Subtarget.h&#x2F;.cpp</h4><p>比较重要的一个类，继承自 <code>Cpu0GenSubtargetInfo</code> 定义了 <code>Cpu0Subtarget</code>。我们的 Cpu0.td 中本身已经定义了和子目标平台相关的信息，这里做的工作并不多，就是维护了一些属性，并建立与其他类之间的调用接口，诸如 <code>getInstrInfo()</code>，<code>getRegisterInfo()</code> 等，同时在其构造函数中，也会初始化这些对象。</p><p>注：感谢 [@乱世倾颓](<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/fcc3699e080b75400c43583c72278afc">https://www.zhihu.com/people/fcc3699e080b75400c43583c72278afc</a><br>的指正，并没有 <a target="_blank" rel="noopener" href="http://cpu0subtargetinfo.td/">Cpu0SubtargetInfo.td</a> 这个文件，我们定义 Subtarget 的信息放在 <a target="_blank" rel="noopener" href="http://cpu0.td/">Cpu0.td</a>中，因为 Subtarget 的结构是通用的，所以都放在公共代码的 TargetSubtargetInfo.cpp 中。另外这里想指出，xxx.td 文件的名字并不是和生成的相同名字的 <a target="_blank" rel="noopener" href="http://genxxx.inc/">Genxxx.inc</a> 文件一一对应的，Tablegen 工具会综合各个 td 文件的信息，来组织、生成对应后端的各种 <a target="_blank" rel="noopener" href="http://genxxx.inc/">Genxxx.inc</a> 文件。</p><h4 id="13-Cpu0TargetObjectFile-h-cpp"><a href="#13-Cpu0TargetObjectFile-h-cpp" class="headerlink" title="(13) Cpu0TargetObjectFile.h&#x2F;.cpp"></a>(13) Cpu0TargetObjectFile.h&#x2F;.cpp</h4><p>这块代码实现了一个类 <code>Cpu0TargetObjectFile</code>，继承自 <code>TargetLoweringObjectFileELF</code>，里边会定义有关于 ELF 文件格式的一些属性和初始化函数。</p><p>其中有个地方要留意，这里设计了 .sdata 段和 .sbss 段，这两个段和 .data .bss 段表示一样的功能，但更节省 ELF 文件占用内存，我们会在后续章节再次提到。<code>Initialize</code> 暂时用不到。</p><h4 id="14-Cpu0CallingConv-td"><a href="#14-Cpu0CallingConv-td" class="headerlink" title="(14) Cpu0CallingConv.td"></a>(14) Cpu0CallingConv.td</h4><p>这是调用规约的一些说明，定义了 CSR_032 这个 Callee 寄存器。</p><h4 id="15-Cpu0InstrInfo-td"><a href="#15-Cpu0InstrInfo-td" class="headerlink" title="(15) Cpu0InstrInfo.td"></a>(15) Cpu0InstrInfo.td</h4><p>新增了很少量的东西，Cmp 和 Slt 的 Predicate 条目定义，将来会用。</p><h4 id="16-Cpu0-td"><a href="#16-Cpu0-td" class="headerlink" title="(16) Cpu0.td"></a>(16) Cpu0.td</h4><p>作为 tablegen 的入口，它将我们新增的那些 td 文件都 include 进来。另外，新增了几个目标机器的 Feature：FeatureCmp，FeatureSlt，FeatureCpu032I，FeatureCpu032II。另外定义了 subtarget 的条目，也就是 cpu032I 和 cpu032II，还基于 td 中的 Target 类定义了 Cpu0 条目。</p><h4 id="17-CMakeLists-txt-和-MCTargetDesc-CMakeLists-txt"><a href="#17-CMakeLists-txt-和-MCTargetDesc-CMakeLists-txt" class="headerlink" title="(17) CMakeLists.txt 和 MCTargetDesc&#x2F;CMakeLists.txt"></a>(17) CMakeLists.txt 和 MCTargetDesc&#x2F;CMakeLists.txt</h4><p>因为新增了源文件，所以这两个 cmake 配置也要做一下修改。</p><h3 id="2-1-2-简要说明"><a href="#2-1-2-简要说明" class="headerlink" title="2.1.2 简要说明"></a>2.1.2 简要说明</h3><p>整个类结构中，Cpu0Subtarget 承担着接口的作用，它提供了访问其他类的接口：Cpu0FrameLowering，Cpu0TargetMachine，Cpu0TargetObjectFile，Cpu0RegisterInfo，Cpu0InstrInfo 等。其他这几个类，都携带有 Cpu0Subtarget 的属性。即使你的一个类无法通过标准方式访问其他类，比如没有 Cpu0Subtarget 属性，也可以通过访问 Cpu0TargetMachine 来获取一个 Subtarget （利用 getSubtargetImpl() 方法）。</p><p>Tablegen 在这里的作用就很明显了，它通过我们编写的 td 文件，将其翻译为 C++ 的类结构和一些宏、枚举等材料，然后我们在 C++ 代码中就可以灵活的使用这些材料。LLVM 设计 Tablegen 的目的就是将这些目标相关的属性尽量的隔离在 td 文件中，虽然目前还没有完全做到，但已经隔离了很大的一部分（虽然 td 文件的管理也很混乱，但确实有效）。</p><h3 id="2-1-3-编译测试"><a href="#2-1-3-编译测试" class="headerlink" title="2.1.3 编译测试"></a>2.1.3 编译测试</h3><p>需要重新编译，因为我们修改了很多东西，且更新了 cmake 配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ninja clean</span><br><span class="line">cmake -G Ninja -DLLVM_TARGETS_TO_BUILD=Cpu0 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang ../llvm</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure><p>编译时，很可能会遇到问题，按 C++ 的语法规则解决就行，我们目前还不会遇到编译器的问题。</p><h3 id="2-1-4-检验成果"><a href="#2-1-4-检验成果" class="headerlink" title="2.1.4 检验成果"></a>2.1.4 检验成果</h3><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -mcpu=help</span><br></pre></td></tr></table></figure><p>目前，我们能指定的是 cpu032I 和 cpu032II，不指定这个参数默认是 cpu032II，这是在 Cpu0Subtarget.cpp 中设置的。</p><p>终端会输出 Cpu0 后端和其支持的特性。-mcpu 是用来指定 cpu 类型的（这里的 cpu 是广义的，即使你在做 gpu，也是这个参数，他表示架构之下那一层的分类），它可以控制到 Cpu0Subtarget.h 中的属性 isCpu032I 和 isCpu032II，进而会影响到特性的使能，比如 HasSlt 的返回值。</p><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/bin/clang -target mips-unknown-linux-gnu -c ch2.c -emit-llvm -o ch2.bc</span><br><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch2.bc -o ch2.s</span><br></pre></td></tr></table></figure><p>你会收到一个新的错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion `AsmInfo &amp;&amp; &quot;MCAsmInfo not initialized. &quot;</span><br></pre></td></tr></table></figure><p>这就表示这块已经完成了，我们还没有做汇编输出的动作，下一节中将会增加。</p><h2 id="2-2-增加-AsmPrinter"><a href="#2-2-增加-AsmPrinter" class="headerlink" title="2.2 增加 AsmPrinter"></a>2.2 增加 AsmPrinter</h2><p>这一部分，我们要将 AsmPrinter 支持起来，它在 LLVM 后端中的位置在 CodeGen 中比较重要。 首先我们看一下新增或修改的文件。</p><h3 id="2-2-1-文件新增"><a href="#2-2-1-文件新增" class="headerlink" title="2.2.1 文件新增"></a>2.2.1 文件新增</h3><h4 id="1-InstPrinter-Cpu0InstPrinter-h-cpp"><a href="#1-InstPrinter-Cpu0InstPrinter-h-cpp" class="headerlink" title="(1) InstPrinter&#x2F;Cpu0InstPrinter.h&#x2F;.cpp"></a>(1) InstPrinter&#x2F;Cpu0InstPrinter.h&#x2F;.cpp</h4><p>我们新增了一个 InstPrinter 文件夹，存放一些 InstPrinter 相关的文件。 Cpu0InstPrinter 这两个文件主要是完成将 MCInst 输出到汇编文件的工作。定义了 <code>Cpu0InstPrinter</code> 这个类，继承自 <code>MCInstPrinter</code>。类中一个比较重要的成员函数，<code>printInstruction()</code> 是由 tblgen 工具根据 Cpu0InstrInfo.td 生成的，另一个自动生成的成员函数是 <code>getRegisterName()</code>，是根据 Cpu0RegisterInfo.td 文件生成的，两个函数都位于 Cpu0GenAsmWriter.inc 文件中。内部的函数 <code>printRegName()</code> ，<code>printInst()</code> ，<code>printOperand()</code>，<code>printUnsignedImm()</code>，<code>printMemOperand()</code>， 均调用前两个函数完成指令的输出。</p><h4 id="2-InstPrinter-CMakeLists-txt-InstPrinter-LLVMBuild-txt"><a href="#2-InstPrinter-CMakeLists-txt-InstPrinter-LLVMBuild-txt" class="headerlink" title="(2) InstPrinter&#x2F;CMakeLists.txt, InstPrinter&#x2F;LLVMBuild.txt"></a>(2) InstPrinter&#x2F;CMakeLists.txt, InstPrinter&#x2F;LLVMBuild.txt</h4><p>因为新增了 InstPrinter 子路径，所以为这个子路径增加编译支持文件。</p><h4 id="3-Cpu0MCInstLower-h-cpp"><a href="#3-Cpu0MCInstLower-h-cpp" class="headerlink" title="(3) Cpu0MCInstLower.h&#x2F;.cpp"></a>(3) Cpu0MCInstLower.h&#x2F;.cpp</h4><p>从名字上可以看出，这两个文件是用来完成将 MI 指令 lower 到 MCInst 指令的工作。 定义了 <code>Cpu0MCInstLower</code> 类，主要的成员函数是 <code>Lower()</code>，它输入一个 MI，输出一个 MCInst，内部处理比较简单，因为我们知道，两种形式相比，MCInst 只是更为底层，所以它大致只需要忽略掉 MI 的一些信息即可。这里主要是设置 Opcode 和 Operand list。</p><h4 id="4-MCTargetDesc-Cpu0BaseInfo-h"><a href="#4-MCTargetDesc-Cpu0BaseInfo-h" class="headerlink" title="(4) MCTargetDesc&#x2F;Cpu0BaseInfo.h"></a>(4) MCTargetDesc&#x2F;Cpu0BaseInfo.h</h4><p>这个文件中定义了一些宏，将用在 MC 的其他位置。包括操作数标签的 TOF（Target Operand Flag）和指令编码类型。</p><h4 id="5-Cpu0MCAsmInfo-h-cpp"><a href="#5-Cpu0MCAsmInfo-h-cpp" class="headerlink" title="(5) Cpu0MCAsmInfo.h&#x2F;.cpp"></a>(5) Cpu0MCAsmInfo.h&#x2F;.cpp</h4><p>上一节报错中说明要依赖的文件。这两个文件定义了 <code>Cpu0MCAsmInfo</code> 类，继承自 <code>MCAsmInfoELF</code>。其中没啥内容，定义了一些汇编文件格式通用的东西。</p><h4 id="6-Cpu0AsmPrinter-h-cpp"><a href="#6-Cpu0AsmPrinter-h-cpp" class="headerlink" title="(6) Cpu0AsmPrinter.h&#x2F;.cpp"></a>(6) Cpu0AsmPrinter.h&#x2F;.cpp</h4><p>用来将 MI 结构的程序输出到汇编文件的直接入口。 定义了 <code>Cpu0AsmPrinter</code> 类，继承自<code>AsmPrinter</code>。声明了很多 Emit 函数，各自负责发射对应的内容，比如 <code>EmitInstruction()</code>。 和前边 Cpu0InstPrinter 的区别是，前者是将 MCInst 输出到文件，而 AsmPrinter 是将 MI 发射到文件，在这些 Emit 函数内部，也是先将 MI lower 到 MCInst 之后，再通过 Streamer 发射，而 Streamer 内部也会调用到 MCInst 的 printer 接口。 因为 MI 承载的信息本身就更多，所以值得处理的内容也多一些。另外，汇编文件除了指令本身以外，还会有其他的信息，比如调试信息，文件描述信息等，这些都是在 AsmPrinter 中来发射的。</p><h3 id="2-2-2-文件修改"><a href="#2-2-2-文件修改" class="headerlink" title="2.2.2 文件修改"></a>2.2.2 文件修改</h3><h4 id="1-Cpu0InstrInfo-td"><a href="#1-Cpu0InstrInfo-td" class="headerlink" title="(1) Cpu0InstrInfo.td"></a>(1) Cpu0InstrInfo.td</h4><p>新增了几个 record。对于内存操作数，若指定 <code>let PrintMethod = &quot;printMemOperand&quot;</code>，则 tablegen 会在处理这个 record 时，调用 <code>printMemOperand()</code> 函数。这是本节中比较关键的一个点。</p><h4 id="2-MCTargetDesc-Cpu0MCTargetDesc-h-cpp"><a href="#2-MCTargetDesc-Cpu0MCTargetDesc-h-cpp" class="headerlink" title="(2) MCTargetDesc&#x2F;Cpu0MCTargetDesc.h&#x2F;.cpp"></a>(2) MCTargetDesc&#x2F;Cpu0MCTargetDesc.h&#x2F;.cpp</h4><p>MC 层的目标描述类中，我们需要为新加的几个MC 处理的类结构做注册工作，添加了不少代码。创建对应的对象，通过 TargetRegistry 提供的接口返回去。 一定要分得清 MC 层的东西有啥，他们的大多数描述性的文件都位于 MCTargetDesc 路径下，比如描述指令的 MCInstrInfo，描述寄存器的 MCRegisterInfo，描述指令输出的 MCInstPrinter 等。</p><h4 id="3-MCTargetDesc-CMakeLists-txt-MCTargetDesc-LLVMBuild-txt"><a href="#3-MCTargetDesc-CMakeLists-txt-MCTargetDesc-LLVMBuild-txt" class="headerlink" title="(3) MCTargetDesc&#x2F;CMakeLists.txt, MCTargetDesc&#x2F;LLVMBuild.txt"></a>(3) MCTargetDesc&#x2F;CMakeLists.txt, MCTargetDesc&#x2F;LLVMBuild.txt</h4><p>路径下新增了文件，将它们添加到构建描述文件中。</p><h4 id="4-Cpu0ISelLowering-cpp"><a href="#4-Cpu0ISelLowering-cpp" class="headerlink" title="(4) Cpu0ISelLowering.cpp"></a>(4) Cpu0ISelLowering.cpp</h4><p>在构造函数中增加了一个操作，<code>computeRegisterProperties()</code>，这是必需的，用来分析寄存器标记的属性，它实现的位置在 TargetLoweringBase.cpp 文件中，是 <code>TargetLoweringBase</code> 类的方法，不需要我们太关心。</p><h4 id="5-Cpu0MachineFunctionInfo-h"><a href="#5-Cpu0MachineFunctionInfo-h" class="headerlink" title="(5) Cpu0MachineFunctionInfo.h"></a>(5) Cpu0MachineFunctionInfo.h</h4><p>在构造函数中增加发射 NOAT 的 flag。</p><h4 id="6-CMakeLists-txt-LLVMBuild-txt"><a href="#6-CMakeLists-txt-LLVMBuild-txt" class="headerlink" title="(6) CMakeLists.txt, LLVMBuild.txt"></a>(6) CMakeLists.txt, LLVMBuild.txt</h4><p>将新增加的文件和路径加入到构建描述文件中。</p><h3 id="2-2-3-简要说明"><a href="#2-2-3-简要说明" class="headerlink" title="2.2.3 简要说明"></a>2.2.3 简要说明</h3><p>这一小节比较重要的是 TargetDesc 中的注册部分和 AsmPrinter 的汇编文件输出部分，它们也确实占用了比较大的代码篇幅，不过逻辑上都比较清晰。AsmPrinter 最终输出内容时，是托管给了 Streamer 对象，其实 MCStreamer 结构是非常重要的部分，但因为它已经在 LLVM 公共代码中实现地比较完整，所以不需要我们太关心。最底层的输出便是 MCStreamer，所以最底层的发射其实是 <code>Streamer-&gt;Emitxx()</code>。 很多比较细节的东西，其实都是从其他后端参考过来的，尤其是 Mips 后端，前人走过的路，我们便可以放心的去走。</p><h3 id="2-2-4-编译测试"><a href="#2-2-4-编译测试" class="headerlink" title="2.2.4 编译测试"></a>2.2.4 编译测试</h3><p>需要重新编译，因为我们修改了很多东西，且更新了 cmake 配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ninja clean</span><br><span class="line">cmake -G Ninja -DLLVM_TARGETS_TO_BUILD=Cpu0 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang ../llvm</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure><p>编译时，很可能会遇到问题，按 C++ 的语法规则解决就行，我们目前还不会遇到编译器的问题。</p><h3 id="2-2-5-检验成果"><a href="#2-2-5-检验成果" class="headerlink" title="2.2.5 检验成果"></a>2.2.5 检验成果</h3><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch2.bc -o ch2.cpu0.s</span><br></pre></td></tr></table></figure><p>你会收到一个新的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc: target does not support generation of this file <span class="built_in">type</span>!</span><br></pre></td></tr></table></figure><p>这样的话，这部分就结束了。我们实现了较为靠后的一些功能，但其实在前边的功能还不完整。</p><h2 id="2-3-增加-DAGToDAGISel"><a href="#2-3-增加-DAGToDAGISel" class="headerlink" title="2.3 增加 DAGToDAGISel"></a>2.3 增加 DAGToDAGISel</h2><p>AsmPrinter 支持之后，已经可以将 Machine DAG 转成 asm 了，但我们现在还缺少将 LLVM IR DAG 转换成 Machine DAG 的功能，也就是指令选择的部分功能，在 LLVM 机器无关的目标代码生成中，指令选择占据了非常重要的地位。</p><p>指令选择的目的就是，把 DAG 中所有的 Node 都转换成目标相关的 Node，虽然在 Lowering LLVM IR 到 DAG 时，我们已经将部分 Node 转换了，但并不是所有，经过这个 pass 之后，所有的 Node 就都是目标机器支持的操作了。</p><p>但实际上需要我们做的工作并不是指令选择的功能，这些功能已经被 LLVM 实现了（感兴趣可以看看 <code>lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp</code> 中的实现），我们只需要继承已有实现，并将我们的指令系统支持进去（通过 tablegen）即可。这也便是 LLVM 模块化设计下的优势。</p><p>先来看看本节新增的文件：</p><h3 id="2-3-1-文件新增"><a href="#2-3-1-文件新增" class="headerlink" title="2.3.1 文件新增"></a>2.3.1 文件新增</h3><h4 id="1-Cpu0ISelDAGToDAG-h-cpp"><a href="#1-Cpu0ISelDAGToDAG-h-cpp" class="headerlink" title="(1) Cpu0ISelDAGToDAG.h&#x2F;.cpp"></a>(1) Cpu0ISelDAGToDAG.h&#x2F;.cpp</h4><p>这两个文件定义了 <code>Cpu0DAGToDAGISel</code> 类，继承自 <code>SelectionDAGISel</code> 类，并包含有一些全局化的接口，比如 <code>Select</code> 是指令选择的入口，其中会调用 <code>trySelect</code> 方法，后者是提供给子类的自定义部分指令选择方式的入口，可以先不管。在 Select 函数前边部分都没有选择成功的指令，会最后到 <code>SelectCode</code> 函数，这个函数是由 tablegen 依据 td 文件生成的 Cpu0GenDAGISel.inc 文件中定义的。</p><p>虽然 LLVM 的最终目标是让所有和平台相关的信息全部用 td 文件来描述，但目前还没有完全做到（毕竟不同的硬件差异还是挺大的，有些如 X86 的硬件设计还很复杂），所以这些无法用 td 描述的指令选择操作就可以放在这部分 cpp 代码中完成。</p><p>还有个 <code>SelectAddr</code> 函数，顾名思义是做关于地址模式的执行选择的，我们知道 IR DAG 中有些 Node 是地址操作数，这些 Node 可以很复杂，目前 Cpu0 把这块代码提出来特殊对待了。我们打开 Cpu0InstrInfo.td 中对 addr 记录的描述，就可以发现，之前已经在这里注册了一个处理函数名称，就叫 <code>SelectAddr</code>，实际上在 tablegen 指令选择时，也会对经由 addr 记录来描述的那些记录（显然会是一些地址 pattern），交给 <code>SelectAddr</code> 函数来处理。</p><p><code>getImm</code> 函数是将一个指定的立即数切入到一个目标支持的 Node 中。</p><h4 id="2-Cpu0SEISelDAGToDAG-h-cpp"><a href="#2-Cpu0SEISelDAGToDAG-h-cpp" class="headerlink" title="(2) Cpu0SEISelDAGToDAG.h&#x2F;.cpp"></a>(2) Cpu0SEISelDAGToDAG.h&#x2F;.cpp</h4><p>这两个文件定义了 <code>Cpu0SEDAGToDAGISel</code> 类，继承自 <code>Cpu0DAGToDAGISel</code> 类，这种双层设计，我们在前边已经描述过了。在这个底层的 SE 类中，实现了 <code>trySelect</code> 类，这个类目前还没有实现什么实质性的内容。目的就是将来留着处理 tablegen 无法自动处理的那些指令的指令选择。</p><p>另外还实现了 <code>createCpu0SEISelDAG</code> 函数，用来做 Target 注册。</p><h3 id="2-3-2-文件修改"><a href="#2-3-2-文件修改" class="headerlink" title="2.3.2 文件修改"></a>2.3.2 文件修改</h3><h4 id="1-Cpu0TargetMachine-cpp"><a href="#1-Cpu0TargetMachine-cpp" class="headerlink" title="(1) Cpu0TargetMachine.cpp"></a>(1) Cpu0TargetMachine.cpp</h4><p>注册一个指令选择器。目前是将 <code>Cpu0SEISelDAG</code> 添加进来。<code>addInstSelector</code> 方法重写了父类 <code>TargetPassConfig</code> 的方法。</p><h4 id="2-CMakeLists-txt"><a href="#2-CMakeLists-txt" class="headerlink" title="(2) CMakeLists.txt"></a>(2) CMakeLists.txt</h4><p>因为新增了文件，所以修改这个文件保证编译顺利。</p><h3 id="2-3-3-简要说明"><a href="#2-3-3-简要说明" class="headerlink" title="2.3.3 简要说明"></a>2.3.3 简要说明</h3><p>目前我们的目标是把整个后端打通，所以没有操刀 td 文件，我们的 td 文件现在还很简单，但足够去跑我们那个很简单的 test case 了，将来添加其他指令也会是很顺利的事情。</p><p>将来随着支持的指令越来越多，尤其是一些复杂指令的支持，cpp 代码中 <code>trySelect</code> 会增加一些手动处理的指令选择代码，这是目前无法避免的问题。</p><h3 id="2-3-4-编译测试"><a href="#2-3-4-编译测试" class="headerlink" title="2.3.4 编译测试"></a>2.3.4 编译测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ninja clean</span><br><span class="line">cmake -G Ninja -DLLVM_TARGETS_TO_BUILD=Cpu0 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang ../llvm</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure><p>实际上不去手动 <code>ninja clean</code>，也可以编译，ninja 会自动检查 CMakeLists 是否被修改了，如果修改则重新编译。</p><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch2.bc -o ch2.cpu0.s</span><br></pre></td></tr></table></figure><p>你会收到一个新的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LLVM ERROR: Cannot <span class="keyword">select</span>: t6: ch = Cpu0ISD::Ret t4, Register:i32 <span class="variable">$lr</span></span><br><span class="line">  t5: i32 = Register <span class="variable">$lr</span></span><br><span class="line">In <span class="keyword">function</span>: main</span><br></pre></td></tr></table></figure><p>Ret 指令选择卡住了。我们在之前的 Cpu0ISelLowering.cpp 中已经设计了 <code>Cpu0ISD::Ret</code> 节点，在 ISelLowering 中也留下了 <code>LowerReturn</code> 的实现函数，但现在还没有完整实现对它的处理。</p><h2 id="2-4-处理返回寄存器-lr"><a href="#2-4-处理返回寄存器-lr" class="headerlink" title="2.4 处理返回寄存器 $lr"></a>2.4 处理返回寄存器 $lr</h2><p>Mips 后端通过 <code>jr $ra</code> 来返回到调用者，<code>$ra</code> 是一个特殊寄存器，它用来保存调用者（caller）的调用之后的下一条指令的地址，返回值会放到 <code>$2</code> 中。如果我们不对返回值做特殊处理，LLVM 会使用任意一个寄存器来存放返回值，这便与 Mips 的调用惯例不符。而且，LLVM 会为 <code>jr</code> 指令分配任意一个寄存器来存放返回地址。Mips 允许程序员使用其他寄存器代替 <code>$ra</code>，比如 <code>jr $1</code>，这样可以实现更加灵活的编程方式，节省时间。</p><h3 id="2-4-1-文件修改"><a href="#2-4-1-文件修改" class="headerlink" title="2.4.1 文件修改"></a>2.4.1 文件修改</h3><h4 id="1-Cpu0CallingConv-td"><a href="#1-Cpu0CallingConv-td" class="headerlink" title="(1) Cpu0CallingConv.td"></a>(1) Cpu0CallingConv.td</h4><p>新增有关于返回的调用约定，增加<code>RetCC_Cpu0</code> ，指定将 32 位整形返回值放到 V0、V1、A0、A1 这几个寄存器中。</p><h4 id="2-Cpu0InstrFormats-td"><a href="#2-Cpu0InstrFormats-td" class="headerlink" title="(2) Cpu0InstrFormats.td"></a>(2) Cpu0InstrFormats.td</h4><p>新增 <code>Cpu0Pseudo</code> 的 Pattern，下边会用到。</p><h4 id="3-Cpu0InstrInfo-td"><a href="#3-Cpu0InstrInfo-td" class="headerlink" title="(3) Cpu0InstrInfo.td"></a>(3) Cpu0InstrInfo.td</h4><p>利用刚才的伪指令 Pattern，定义新的 record，<code>RetLR</code>，它指定的 SDNode 是 <code>Cpu0Ret</code>，后者是我们之前定义好的。</p><h4 id="4-Cpu0ISelLowering-h-cpp"><a href="#4-Cpu0ISelLowering-h-cpp" class="headerlink" title="(4) Cpu0ISelLowering.h&#x2F;.cpp"></a>(4) Cpu0ISelLowering.h&#x2F;.cpp</h4><p>我们新增了一些调用约定的分析函数，关键函数是 <code>analyzeReturn()</code>。该函数中利用了前边调用约定中定义的 <code>RetCC_Cpu0</code> 来分析返回值类型、值等信息，阻断不合法的情况。</p><p>其次，很重要的一个函数就是 <code>LowerReturn()</code>，该函数在早期将 ISD 的 ret 下降成 <code>Cpu0ISD::Ret</code> 节点。我们之前的实现是一句很简单的做法，也就是会忽略返回时的特殊约定，现在重新设计了这块的逻辑，也就是总生成 <code>ret $lr</code> 指令。</p><h4 id="5-Cpu0MachineFunctionInfo-h-1"><a href="#5-Cpu0MachineFunctionInfo-h-1" class="headerlink" title="(5) Cpu0MachineFunctionInfo.h"></a>(5) Cpu0MachineFunctionInfo.h</h4><p>增加了几个和返回寄存器、参数相关的辅助函数。</p><h4 id="6-Cpu0SEInstrInfo-h-cpp"><a href="#6-Cpu0SEInstrInfo-h-cpp" class="headerlink" title="(6) Cpu0SEInstrInfo.h&#x2F;.cpp"></a>(6) Cpu0SEInstrInfo.h&#x2F;.cpp</h4><p>增加伪指令展开部分的内容，也就是展开返回指令，选择 <code>$lr</code> 寄存器作为返回地址寄存器，选择 <code>Cpu0::RET</code> 作为指令。</p><h3 id="2-4-2-简要说明"><a href="#2-4-2-简要说明" class="headerlink" title="2.4.2 简要说明"></a>2.4.2 简要说明</h3><p>这一部分，我们处理了函数调用时返回的操作，主要就是对针对 Cpu0 的特殊调用约定下的返回指令做约束，比如返回地址使用 <code>$lr</code> 来存储，返回值保存在特殊的寄存器中。</p><p>函数 <code>LowerReturn</code> 正确处理了 return 的情况，上一节结尾的错误就是因此而来。函数创建了 <code>Cpu0ISD::Ret</code> 节点，并且里边包含了 <code>%V0</code> 寄存器的关联关系，这个寄存器保存了返回值，如果不这样做，在 Lower Ret 时，使用 <code>$lr</code> 寄存器，所以看起来 <code>%V0</code> 寄存器没有用了，进而后边的优化阶段会把这个 CopyToReg 的 Node 给删掉，结果就导致了错误。</p><h3 id="2-4-4-检验成果"><a href="#2-4-4-检验成果" class="headerlink" title="2.4.4 检验成果"></a>2.4.4 检验成果</h3><p>正常编译工程，不再赘述。 编译之后，进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/clang -target mips-unknown-linux-gnu -c ch2.cpp -emit-llvm -o ch2.bc</span><br></pre></td></tr></table></figure><p>我们看一下 LLVM IR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llvm-dis ch2.bc -o -</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  %1 = alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的指令中有一条 store 指令，这条指令会将局部变量 0 放到栈中，但是我们目前还没有解决栈帧的管理问题，所以如果把这个代码传给后端，会卡在这里（通过 Ctrl-C 退出）。我们可以通过 O2 来编译，O2 会把局部变量放到寄存器中，避免生成 store 指令，从而可以先验证我们 ret 的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/clang -O2 -target mips-unknown-linux-gnu -c ch2.cpp -emit-llvm -o ch2.bc</span><br></pre></td></tr></table></figure><p>看一下 LLVM IR：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，我们能够输出正确的值了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch2.bc -o -</span><br></pre></td></tr></table></figure><p>生成的内容直接输出到终端，能看到，已经正常生成了 <code>ret $lr</code> 指令。也能看到返回值 0 通过 <code>addiu $2, $zero, 0</code> 这条指令放到了寄存器 <code>$2</code> 中，<code>$2</code> 就是 <code>%V0</code>，我们在 Cpu0RegisterInfo.td 中做过定义。 通过指定 <code>-print-before-all</code> 和 <code>-print-after-all</code> 参数到 llc，可以打印出 DAG 指令选择前后的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm -print-before-all -print-after-all ch2.bc -o -</span><br></pre></td></tr></table></figure><p>其中显示，分别将 <code>Cpu0ISD::Ret t3, Register::i32 %V0, t3:1</code> 指令选择到 <code>RetLR Register:i32 %V0, t3, t3:1</code>，将 <code>t1: i32 = Constant&lt;0&gt;</code> 指令选择到 <code>t1: i32 = ADDiu Register:i32 %ZERO, TargetConstant:i32&lt;0&gt;</code>。注意到，RetLR 后续还会做伪指令展开为 <code>ret $lr</code>，并隐式使用了 <code>%V0</code>（寄存器分配之后，就不用担心 <code>%V0</code> 被删掉了，所以可以改成隐式依赖了）。</p><p>两条指令从 LLVM IR 到汇编的路径是：</p><table><thead><tr><th>LLVM IR</th><th>Lower</th><th>ISel</th><th>RVR（重写虚拟寄存器）</th><th>Post-RA （寄存器分配之后）</th><th>Asm</th></tr></thead><tbody><tr><td>constant 0</td><td>constant 0</td><td>ADDiu</td><td>ADDiu</td><td>ADDiu</td><td>addiu</td></tr><tr><td>ret</td><td>Cpu0ISD::Ret</td><td>Cpu0ISD::Ret</td><td>RetLR</td><td>RET</td><td>ret</td></tr></tbody></table><p>之所以做 CopyToReg 的原因是，ret 指令不能接受一个立即数作为操作数。它通过在 Cpu0InstrInfo.td 中的定义来完成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def : Pat&lt;i32 immSExt16:$in), (ADDiu ZERO, imm:$in)&gt;;</span><br></pre></td></tr></table></figure><p>接下来就来处理一下稍微比较复杂的栈帧的管理问题。</p><h2 id="2-5-增加-Prologue-Epilogue-部分代码"><a href="#2-5-增加-Prologue-Epilogue-部分代码" class="headerlink" title="2.5 增加 Prologue&#x2F;Epilogue 部分代码"></a>2.5 增加 Prologue&#x2F;Epilogue 部分代码</h2><h3 id="2-5-1-文件新增"><a href="#2-5-1-文件新增" class="headerlink" title="2.5.1 文件新增"></a>2.5.1 文件新增</h3><h4 id="1-Cpu0AnalyzeImmediate-h-cpp"><a href="#1-Cpu0AnalyzeImmediate-h-cpp" class="headerlink" title="(1) Cpu0AnalyzeImmediate.h&#x2F;.cpp"></a>(1) Cpu0AnalyzeImmediate.h&#x2F;.cpp</h4><p>实现了一个 <code>Cpu0AnalyzeImmediate</code> 类，这个类的主要作用是用来分析一些带立即数的指令，将一些不支持的形式转化为支持的形式，比如 ADDiu 操作立即数、ORi 操作立即数、SHL 操作立即数，甚至是他们的组合。</p><p>我们这里特殊处理立即数是因为当立即数比较大时，指令编码的空间有限，就可能无法用单条指令来实现了。而本节我们还需要支持大栈空间的调栈操作，当栈空间足够大时，立即数偏移就可能无法直接支持，就需要我们对立即数做特殊处理。</p><h3 id="2-5-2-文件修改"><a href="#2-5-2-文件修改" class="headerlink" title="2.5.2 文件修改"></a>2.5.2 文件修改</h3><h4 id="1-Cpu0SEFrameLowering-h-cpp"><a href="#1-Cpu0SEFrameLowering-h-cpp" class="headerlink" title="(1) Cpu0SEFrameLowering.h&#x2F;.cpp"></a>(1) Cpu0SEFrameLowering.h&#x2F;.cpp</h4><p>主要实现之前就留空的函数：<code>emitPrologue</code> 和 <code>emitEpilogue</code> 函数，这两个函数是基类定义好的虚函数。</p><p><code>emitPrologue</code> 函数的主要内容有：</p><ol><li>拿到栈空间大小，并调整栈指针，创建新的栈空间。</li><li>发射一些伪指令。</li><li>获取 <code>CalleeSavedInfo</code>，将 Callee Saved Register 保存到栈中。</li></ol><p><code>emitEpilogue</code> 函数的主要内容有：</p><ol><li>还原 Callee Saved Register。</li><li>拿到栈空间大小，并调整栈指针，丢弃栈空间。</li></ol><p>另外还有几个函数。<code>hasReservedCallFrame</code> 用来判断最大的调用栈空间是否能用 16 位立即数表示且栈中没有可变空间的对象。<code>determineCalleeSaves</code> 和 <code>setAliasRegs</code> 用来在插入 Prologue 和 Epilogue 代码之前判断需要 spill 的 callee saved 寄存器，当确定 spill 寄存器后， <code>eliminateFrameIndex</code> 就可以将确定的寄存器保存到栈中正确位置，或从栈中正确位置取出寄存器值。</p><h4 id="2-Cpu0MachineFunctionInfo-h"><a href="#2-Cpu0MachineFunctionInfo-h" class="headerlink" title="(2) Cpu0MachineFunctionInfo.h"></a>(2) Cpu0MachineFunctionInfo.h</h4><p>实现了几个辅助函数，用来读写一些特殊属性，比如 <code>IncomingArgSize</code>，<code>CallsEhReturn</code> 等。</p><h4 id="3-Cpu0SEInstrInfo-h-cpp"><a href="#3-Cpu0SEInstrInfo-h-cpp" class="headerlink" title="(3) Cpu0SEInstrInfo.h&#x2F;.cpp"></a>(3) Cpu0SEInstrInfo.h&#x2F;.cpp</h4><p>实现两个重要函数：<code>storeRegToStack</code> 和 <code>loadRegFromStack</code> 函数，这两个函数是基类定义好的虚函数。</p><p>前者用于生成将寄存器 store 入栈中的动作，后者用于生成将栈中值 load 到寄存器的动作。目前我们生成的都是使用 st 和 ld 指令来完成。因为每个局部变量都对应一个 frame index，所以他们在寄存器分配阶段对应的虚拟寄存器的 offset 都是 0。</p><p>还实现了 <code>adjustStackPtr</code> 函数，用来做栈指针调整的动作。需要根据调整距离是否大于 16 位能表示的范围，分为两种操作分别使用 ADDiu 和 ADDu 来处理。其中 <code>loadImmediate</code> 函数辅助完成一个寄存器和立即数的加法动作。</p><h4 id="4-Cpu0RegisterInfo-cpp"><a href="#4-Cpu0RegisterInfo-cpp" class="headerlink" title="(4) Cpu0RegisterInfo.cpp"></a>(4) Cpu0RegisterInfo.cpp</h4><p>实现 <code>eliminateFrameIndex</code> 函数。</p><p>输入这个函数之前的指令，带有一个 FrameIndex 的操作数，这个函数用来将 FrameIndex 替换为寄存器与一个偏移的组合。对于输出参数、动态分配栈空间的指针和全局保存的寄存器，不需要调整 offset，如果是其他的，则需要调整，比如输入参数、callee saved 寄存器或局部变量。</p><h4 id="5-Cpu0InstrInfo-td"><a href="#5-Cpu0InstrInfo-td" class="headerlink" title="(5) Cpu0InstrInfo.td"></a>(5) Cpu0InstrInfo.td</h4><p>新增了一些用于 load&#x2F;store 和 立即数处理的 pattern。LUi 指令用于将一个 16 位立即数放到寄存器的高 16 位，寄存器的低 16 位赋值 0。SHL 是左移指令。</p><p>其中，注意到将 16 位无符号数映射为 <code>ORi ZERO, imm</code>，将低 16 位为 0 的立即数映射为 <code>LUi HI16-imm</code>。</p><h4 id="6-Cpu0InstrInfo-h-cpp"><a href="#6-Cpu0InstrInfo-h-cpp" class="headerlink" title="(6) Cpu0InstrInfo.h&#x2F;.cpp"></a>(6) Cpu0InstrInfo.h&#x2F;.cpp</h4><p>将基类的 <code>loadRegFromStack</code> 和 <code>storeRegToStack</code> 虚函数声明出来，并定义了 <code>loadRegFromStackSlot</code> 和 <code>storeRegToStackSlot</code> 用来当做 Offset 为 0 的特殊情况使用。</p><p>实现了一个 <code>GetMemOperand</code> 函数用来构造出内存操作数。</p><h4 id="7-InstPrinter-Cpu0InstPrinter-cpp"><a href="#7-InstPrinter-Cpu0InstPrinter-cpp" class="headerlink" title="(7) InstPrinter&#x2F;Cpu0InstPrinter.cpp"></a>(7) InstPrinter&#x2F;Cpu0InstPrinter.cpp</h4><p>修改代码来支持打印 Alias 指令。</p><h4 id="8-CMakeLists-txt"><a href="#8-CMakeLists-txt" class="headerlink" title="(8) CMakeLists.txt"></a>(8) CMakeLists.txt</h4><p>添加新增加的 <code>Cpu0AnalyzeImmediate</code> 文件。</p><h3 id="2-5-3-简要说明"><a href="#2-5-3-简要说明" class="headerlink" title="2.5.3 简要说明"></a>2.5.3 简要说明</h3><p>本节主要完成和函数调用时栈管理的功能。核心的动作就是计算正确的栈空间，调整好栈内变量的正确位置，以及插入一些在进入函数和退出函数时的辅助代码。功能的基本逻辑是由 LLVM 提供的，我们只需要实现继承来的类中的一些关键函数即可。</p><p>有些寄存器依赖于运行时的可变量来决定，所以不能够使用 td 文件中的静态描述直接生成，这些寄存器包括：</p><ul><li>被调用函数需要负责保存的寄存器（Callee-saved register）：ABI 中会指定一些寄存器必须在函数进入和返回时维护寄存器值。</li><li>保留寄存器：有些在 td 中定义好的寄存器可能在 RegisterInfo 的代码中可能设计不去分配。</li></ul><p>这部分需要实现几个重要的方法：</p><ul><li><code>emitPrologure()</code> 函数：这个函数用来在函数开头插入 prologue 代码，这部分功能会比较琐碎，但还好，并不需要我们手动去操作如何保存寄存器，唯一要做的就是调整栈指针来为函数开辟出足够的空间，LLVM 会为我们处理好这部分功能。</li><li><code>emitEpilogue()</code> 函数：这个函数用来在函数结束时销毁栈，并还原调用之前的寄存器状态。不过，很多信息可以经由 ret 指令来完成，比如和上下文相关的特殊寄存器（比如栈指针和帧指针）。</li><li><code>eliminateFrameIndex()</code> 函数：这个函数会在每一个引用栈槽中数据的指令时被调用，在之前的代码生成阶段时，对栈槽的访问是依赖于一个抽象的帧索引和立即数的偏移来描述栈槽具体位置的，这个函数可以将这种引用翻译为寄存器和一个偏移的对。依赖于指令需要基于固定的还是可变的栈帧，可以使用栈指针或帧指针作为基址寄存器。比如如果栈空间的大小会动态调整，则需要使用帧指针（在函数内部是固定的）作为基址，再减偏移立即数来定位，否则，可以采用栈指针作为基址，再加偏移立即数来定位。如果偏移值过大，超出立即数能编码的范围，则会发射多条指令来计算有效地址，中间值会放到未使用的地址寄存器中，如果没有未使用的寄存器，就会使用 <code>regScavenger</code> 的类来清除掉部分占用的地址寄存器。<code>eliminateFrameIndex</code> 函数在指令选择和寄存器分配阶段之后被调用，位于 PrologEpilogeInserter 这个 pass 中。偏移计算是由 <code>spOffset = MF.getFrameInfo()-&gt;getObjectOffset(FrameIndex);</code> 完成的，FrameIndex 是需要翻译的栈下标对象。</li></ul><p>最后，我们还处理了大栈空间的情况。实际工作中很容易遇到大栈的问题，这需要正确的运算栈偏移的指令来支持。下边举例不同大小栈空间时的 Prologue 和 Epilogue 代码：</p><h4 id="1-小栈空间：0x0-0x7ff8"><a href="#1-小栈空间：0x0-0x7ff8" class="headerlink" title="(1) 小栈空间：0x0 ~ 0x7ff8"></a>(1) 小栈空间：0x0 ~ 0x7ff8</h4><p>比如栈大小：0x7ff8</p><p>替换前 Prologue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addiu $sp, $sp, -32760;</span><br></pre></td></tr></table></figure><p>替换后 Epilogue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addiu $sp, $sp, 32760;</span><br></pre></td></tr></table></figure><p>替换之后的 Prologue 代码和 Epilogue 代码保持不变。</p><h4 id="2-较小栈空间：0x8000-0xfff8"><a href="#2-较小栈空间：0x8000-0xfff8" class="headerlink" title="(2) 较小栈空间：0x8000 ~ 0xfff8"></a>(2) 较小栈空间：0x8000 ~ 0xfff8</h4><p>比如栈大小：0x8000</p><p>Prologue 代码：</p><p>替换前 Prologue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addiu $sp, $sp, -32768;</span><br></pre></td></tr></table></figure><p>替换前 Epilogue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addiu $1, $zero, 1;</span><br><span class="line">shl $1, $1, 16;</span><br><span class="line">addiu $1, $1, -32768;</span><br><span class="line">addu $sp, $sp, $1;</span><br></pre></td></tr></table></figure><p>替换后 Prologue 代码保持不变。</p><p>替换后 Epilogue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ori $1, $zero, 32768;</span><br><span class="line">addu $sp, $sp, $1;</span><br></pre></td></tr></table></figure><h4 id="3-较大栈空间：0x10000-0xfffffff8"><a href="#3-较大栈空间：0x10000-0xfffffff8" class="headerlink" title="(3) 较大栈空间：0x10000 ~ 0xfffffff8"></a>(3) 较大栈空间：0x10000 ~ 0xfffffff8</h4><p>比如栈空间：0x7ffffff8</p><p>替换前 Prologue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addiu $1, $zero, 8;</span><br><span class="line">shl $1, $1, 28;</span><br><span class="line">addiu $1, $1, 8;</span><br><span class="line">addu $sp, $sp, $1;</span><br></pre></td></tr></table></figure><p>替换前 Epilogue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addiu $1, $zero, 8;</span><br><span class="line">shl $1, $1, 28;</span><br><span class="line">addiu $1, $1, -8;</span><br><span class="line">addu $sp, $sp, $1;</span><br></pre></td></tr></table></figure><p>替换后 Prologue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lui $1, 32768;</span><br><span class="line">addiu $1, $1, 8;</span><br><span class="line">addu $sp, $sp, $1;</span><br></pre></td></tr></table></figure><p>替换后 Epilogue 代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lui $1, 32767;</span><br><span class="line">ori $1, $1, 65528;</span><br><span class="line">addu $sp, $sp, $1;</span><br></pre></td></tr></table></figure><h4 id="4-大栈空间：0x1000-0xfffffff8"><a href="#4-大栈空间：0x1000-0xfffffff8" class="headerlink" title="(4) 大栈空间：0x1000 ~ 0xfffffff8"></a>(4) 大栈空间：0x1000 ~ 0xfffffff8</h4><p>比如栈空间：0x90008000</p><p>替换前 Prologue 代码 （注释中假设 sp &#x3D; 0xa0008000）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addiu $1, $zero, -9;  // $1 = 0 + 0xfffffff7 = 0xfffffff7</span><br><span class="line">shl $1, $1, 28;       // $1 = 0x70000000</span><br><span class="line">addiu $1, $1, -32768; // $1 = 0x70000000 + 0xffff8000 = 0x6fff8000</span><br><span class="line">addu $sp, $sp, $1;    // $sp = 0xa0008000 + 0x6fff8000 = 0x10000000</span><br></pre></td></tr></table></figure><p>替换钱 Epilogue 代码（注释中假设 sp &#x3D; 0x10000000）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addiu $1, $zero, -28671;  // $1 = 0 + 0xffff9001 = 0xffff9001</span><br><span class="line">shl $1, $1, 16;           // $1 = 0x90010000</span><br><span class="line">addiu $1, $1, -32768;     // $1 = 0x90010000 + 0xffff8000 = 0x90008000</span><br><span class="line">addu $sp, $sp, $1;        // $sp = 0x10000000 + 0x90008000 = 0xa0008000</span><br></pre></td></tr></table></figure><p>注释中可检查 Prologue 和 Epilogue 的功能是正常的。</p><p>替换后 Prologue 代码（注释中假设 sp &#x3D; 0xa0008000）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lui $1, 28671;      // $1 = 0x6fff0000 // 28671 &lt;=&gt; 0x6fff</span><br><span class="line">ori $1, $1, 32768;  // $1 = 0x6fff0000 + 0x00008000 = 0x6fff8000</span><br><span class="line">addu $sp, $sp, $1;  // $sp = 0xa0008000 + 0x6fff8000 = 0x10000000</span><br></pre></td></tr></table></figure><p>替换后 Epilogue 代码（注释中假设 sp &#x3D; 0x10000000）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lui $1, 36865;         // $1 = 0x90010000 // 36865 &lt;=&gt; 0x9001</span><br><span class="line">addiu $1, $1, -32768;  // $1 = 0x90010000 + 0xffff8000 = 0x90008000</span><br><span class="line">addu $sp, $sp, $1;     // $sp = 0x10000000 + 0x90008000 = 0xa0008000</span><br></pre></td></tr></table></figure><p>注释中可检查 Prologue 和 Epilogue 的功能是正常的。</p><h3 id="2-5-4-检验成果"><a href="#2-5-4-检验成果" class="headerlink" title="2.5.4 检验成果"></a>2.5.4 检验成果</h3><p>我们编写最简单的 case，在 main 函数中 return 0，并用 O0 来编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch2.bc -o -</span><br></pre></td></tr></table></figure><p>发现输出的代码大概是很简单的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addiu $13, $13, -8  // prologue code</span><br><span class="line">st $2, 4($13)       // save callee saved register</span><br><span class="line">addiu $2, $zero, 0  // return 0;</span><br><span class="line">ld $2, 4($13)       // restore callee saved register</span><br><span class="line">addiu $13, $13, -8  // epilogue code</span><br><span class="line">ret $14             // return to $14 address</span><br></pre></td></tr></table></figure><p>我们重新编写稍微复杂的 case：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">469753856</span>];  <span class="comment">// allowed big stack</span></span><br><span class="line">                     <span class="comment">// O0 will not optimized it</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述编译命令，输出的代码大致为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lui $1, 36864         ; start prologue code</span><br><span class="line">addiu $1, $1, 32760  </span><br><span class="line">addu $13, $13, $1     ; end prologue code</span><br><span class="line">st $2, 1879015428($sp)</span><br><span class="line">lui $1, 28672</span><br><span class="line">addiu $1, $1, -32760</span><br><span class="line">addu $sp, $sp, $1</span><br><span class="line">ret $lr</span><br></pre></td></tr></table></figure><p>目前代码已经能够生成最简单代码的汇编代码了。</p><h2 id="2-6-操作数-pattern"><a href="#2-6-操作数-pattern" class="headerlink" title="2.6 操作数 pattern"></a>2.6 操作数 pattern</h2><p>在 TableGen 中，除了一些描述指令的 pattern 之外，还有些是描述操作数的。用来描述指令的 pattern 都是 DAG 中的内部节点，而操作数是 DAG 中的叶子节点。</p><p>操作数的叶子节点最主要的类是 <code>PatLeaf</code>，因为操作数不会再有其内部的分支，所以我们可以把操作数的节点看做是没有操作数的节点，从 <code>include/llvm/Target/TargetSelectionDAG.td</code> 中可以了解到，<code>PatLeaf</code> 的定义是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class PatLeaf&lt;dag frag, code pred = [&#123;&#125;], SDNodeXForm xform = NOOP_SDNodeXForm&gt;</span><br><span class="line">  : PatFrag&lt;(ops), frag, pred, xform&gt;;</span><br></pre></td></tr></table></figure><p>可以看到，<code>PatFrag</code> 传入的第一个 dag 模式中，没有操作数（<code>(ops)</code> 就表示操作数为空）。</p><p>我们现在定义的一些典型的操作数 pattern ，它们用来作为一个 Node 的类型描述：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def simm16 : Operand&lt;i32&gt; &#123;             // 因为是 32 位机器，所以继承自 Operand&lt;i32&gt;</span><br><span class="line">  let DecoderMethod = &quot;DecodeSimm16&quot;;   // 指定解码函数，将在其他代码中实现</span><br><span class="line">&#125;</span><br><span class="line">def uimm16 : Operand&lt;i32&gt; &#123;</span><br><span class="line">  let PrintMethod = &quot;printUnsignedImm&quot;; // 指定打印格式函数，将在其他代码中实现</span><br><span class="line">&#125;</span><br><span class="line">get mem : Operand&lt;iPTR&gt; &#123;</span><br><span class="line">  let PrintMethod = &quot;printMemOperand&quot;;</span><br><span class="line">  let MIOperandInfo = (ops CPURegs, simm16) // 指定操作数的信息，这里是一个寄存器类和一个立即数</span><br><span class="line">  let EncoderMethod = &quot;getMemEncoding&quot;;     // 指定获取编码的函数，将在其他代码中实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边这部分是 Node 转换动作：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def LO16 : SDNodeXForm&lt;imm, [&#123;   // 转换函数，获取 imm 低 16 位值</span><br><span class="line">  return getImm(N, N-&gt;getZExtValue() &amp; 0xffff);</span><br><span class="line">&#125;]</span><br><span class="line">def HI16 : SDNodeXForm&lt;imm, [&#123;   // 获取 imm 高 16 位值</span><br><span class="line">  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xffff);</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>代码片段会插入到做 Node TransForm 的函数中，N 是不能改为其他名称的，表示 imm 对应的 <code>ConstantSDNode</code> 对象。这个记录可以作为 <code>PatLeaf</code> 的第三个参数传入，用来在指令选择时做必要的转换。</p><p>下边是一些典型的 dag pattern：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def immSExt16 : PatLeaf&lt;(imm), [&#123;</span><br><span class="line">  return isInt&lt;16&gt;(N-&gt;getSExtValue());  // predicate 限定功能中插入的一段代码</span><br><span class="line">&#125;]</span><br><span class="line">def immZExt16 : PatLeaf&lt; ... &gt;;</span><br></pre></td></tr></table></figure><p>从 <code>PatLeaf</code> 的定义中可以看出，第二个参数的代码片段是用来做 predicate 的，实际上用在指令选择时，判断 Node 的 predicate 是否满足。后续几个 Node 也是同理。</p><p>下边是复杂 pattern：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def addr : ComplexPattern&lt;iPTR, 2, &quot;SelectAddr&quot;, [frameindex], [SDNPWantParent]&gt;;</span><br><span class="line">class AlignedLoad&lt;PatFrag Node&gt; :  // 确保 load 操作是对齐的</span><br><span class="line">  PatFrag&lt;(ops node:$ptr), (Node node:$ptr), [&#123;</span><br><span class="line">    LoadSDNode *LD = cast&lt;LoadSDNode&gt;(N);</span><br><span class="line">    return LD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= LD-&gt;getAlignment();</span><br><span class="line">  &#125;]&gt;;</span><br><span class="line">def load_a : AlignedLoad&lt;load&gt;;</span><br><span class="line">​</span><br><span class="line">def store_a : AlignedStore&lt;store&gt;;  // store 同理，不再展示</span><br></pre></td></tr></table></figure><p>这一类是比较复杂的 pattern，<code>ComplexPattern</code> 是内建的一个类，通常这一类都是内存操作数。<code>SelectAddr</code> 字符串对应 Cpu0ISelDAGToDAG.cpp 中的同名函数，而 TableGen 会自动在发现这个 Node 时调用 SelectAddr 来完成进一步的动作。</p><p>重点要区分两种不同用途的描述，一种是描述操作数的 pattern 片段，一种是描述 dag pattern。</p><h2 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h2><p>本章，我们新增了一个 pass，实现了一个叫 Cpu0DAGToDAGISel 的类，可以使用 <code>llc -debug-pass=Structure</code> 可以查看输出的 pass 结构。</p><p>一个简单的后端过程和调用的主要函数罗列在下表：</p><table><thead><tr><th>阶段</th><th>主要函数</th></tr></thead><tbody><tr><td>指令下降</td><td>Cpu0TargetLowering::LowerFormalArguments、Cpu0TargetLowerinng::LowerReturn</td></tr><tr><td>指令选择</td><td>Cpu0DAGToDAGISel::Select</td></tr><tr><td>Prologue&#x2F;Epilogue 插入和栈帧处理</td><td>Cpu0SEFrameLowering::emitPrologue、Cpu0SEFrameLowering::emitEpilogue</td></tr><tr><td>Spill callee saved register</td><td>Cpu0SEFrameLowering::determinneCalleeSaves</td></tr><tr><td>局部变量栈槽处理</td><td>Cpu0RegisterInfo::eliminateFrameIndex</td></tr><tr><td>寄存器分配之后的伪指令展开</td><td>Cpu0SEInstrInfo::expandPostRAPseudo</td></tr><tr><td>汇编输出</td><td>Cpu0AsmPrinter.cpp、Cpu0MCInstLower.cpp、Cpu0InstPrinter.cpp</td></tr></tbody></table><p>我们当前仅支持 <code>ld, st, addiu, ori, lui, addu, shl, ret</code>这几条指令。虽然看样子功能还很简单，但本章的关键是我们实现了 Cpu0 整个框架。到目前位置，包括注释，我们写了大概 3 千多行代码。但后续会很快，我们只需要不断的添加其他的指令和功能即可。下一章开始，我们将陆续添加其他的指令。</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356837953">LLVM 后端实践笔记 2：后端结构 - 知乎 (zhihu.com)</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://p2tree.top">P2Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://p2tree.top/posts/eea38852.html">https://p2tree.top/posts/eea38852.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://p2tree.top" target="_blank">P2Tree Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/LLVM/">LLVM</a></div><div class="post_share"><div class="social-share" data-image="/img/20210313/index.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@latest/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20210405/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LLVM 后端实践笔记 3：算术和逻辑指令</div></div></a></div><div class="next-post pull-right"><a href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20210224/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LLVM 后端实践笔记 1：新后端初始化和软件编译</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/ab589331.html" title="LLVM New Pass Manager"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20221203/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="title">LLVM New Pass Manager</div></div></a></div><div><a href="/posts/640e5f3e.html" title="LLVM 目标无关代码生成器 1：介绍"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20201121/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-21</div><div class="title">LLVM 目标无关代码生成器 1：介绍</div></div></a></div><div><a href="/posts/6e862920.html" title="LLVM 目标无关代码生成器 3：机器代码描述类"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20201125/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-25</div><div class="title">LLVM 目标无关代码生成器 3：机器代码描述类</div></div></a></div><div><a href="/posts/5ab3a536.html" title="LLVM 目标无关代码生成器 2：目标描述类"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20201122/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-22</div><div class="title">LLVM 目标无关代码生成器 2：目标描述类</div></div></a></div><div><a href="/posts/2aaad353.html" title="LLVM 目标无关代码生成器 5：目标无关代码生成算法"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20201206/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-06</div><div class="title">LLVM 目标无关代码生成器 5：目标无关代码生成算法</div></div></a></div><div><a href="/posts/5cc76640.html" title="LLVM 目标无关代码生成器 6：实现原生汇编器"><img class="cover" src= "/img/loading.jpg" data-lazy-src="/img/20201209/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-09</div><div class="title">LLVM 目标无关代码生成器 6：实现原生汇编器</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.jpg" data-lazy-src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">P2Tree</div><div class="author-info__description">基础软件研发工程师</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/p2tree" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:p2tree@163.com" target="_blank" title="Email"><i class="iconfont icon-mail"></i></a><a class="social-icon" href="https://zhihu.com/people/p2tree" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu"></i></a><a class="social-icon" href="/2024/08/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-P2Tree/" target="_blank" title="Weixin"><i class="iconfont icon-wechat"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="Feed"><i class="iconfont icon-feed"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站正在搭建中，About 页有我的介绍，欢迎留言</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">2.1 目标机器架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E"><span class="toc-number">1.1.</span> <span class="toc-text">2.1.1 文件新增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0TargetMachine-h-cpp"><span class="toc-number">1.1.1.</span> <span class="toc-text">(1) Cpu0TargetMachine.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0FrameLowering-h-cpp"><span class="toc-number">1.1.2.</span> <span class="toc-text">(2) Cpu0FrameLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0SEFrameLowering-h-cpp"><span class="toc-number">1.1.3.</span> <span class="toc-text">(3) Cpu0SEFrameLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0InstrInfo-h-cpp"><span class="toc-number">1.1.4.</span> <span class="toc-text">(4) Cpu0InstrInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0SEInstrInfo-h-cpp"><span class="toc-number">1.1.5.</span> <span class="toc-text">(5) Cpu0SEInstrInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Cpu0ISelLowering-h-cpp"><span class="toc-number">1.1.6.</span> <span class="toc-text">(6) Cpu0ISelLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Cpu0SEISelLowering-h-cpp"><span class="toc-number">1.1.7.</span> <span class="toc-text">(7) Cpu0SEISelLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Cpu0MachineFunctionInfo-h-cpp"><span class="toc-number">1.1.8.</span> <span class="toc-text">(8) Cpu0MachineFunctionInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-MCTargetDesc-Cpu0ABIInfo-h-cpp"><span class="toc-number">1.1.9.</span> <span class="toc-text">(9) MCTargetDesc&#x2F;Cpu0ABIInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Cpu0RegisterInfo-h-cpp"><span class="toc-number">1.1.10.</span> <span class="toc-text">(10) Cpu0RegisterInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Cpu0SERegisterInfo-h-cpp"><span class="toc-number">1.1.11.</span> <span class="toc-text">(11) Cpu0SERegisterInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Cpu0Subtarget-h-cpp"><span class="toc-number">1.1.12.</span> <span class="toc-text">(12) Cpu0Subtarget.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Cpu0TargetObjectFile-h-cpp"><span class="toc-number">1.1.13.</span> <span class="toc-text">(13) Cpu0TargetObjectFile.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-Cpu0CallingConv-td"><span class="toc-number">1.1.14.</span> <span class="toc-text">(14) Cpu0CallingConv.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-Cpu0InstrInfo-td"><span class="toc-number">1.1.15.</span> <span class="toc-text">(15) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Cpu0-td"><span class="toc-number">1.1.16.</span> <span class="toc-text">(16) Cpu0.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-CMakeLists-txt-%E5%92%8C-MCTargetDesc-CMakeLists-txt"><span class="toc-number">1.1.17.</span> <span class="toc-text">(17) CMakeLists.txt 和 MCTargetDesc&#x2F;CMakeLists.txt</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">2.1.2 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">2.1.3 编译测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">1.4.</span> <span class="toc-text">2.1.4 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A2%9E%E5%8A%A0-AsmPrinter"><span class="toc-number">2.</span> <span class="toc-text">2.2 增加 AsmPrinter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E"><span class="toc-number">2.1.</span> <span class="toc-text">2.2.1 文件新增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-InstPrinter-Cpu0InstPrinter-h-cpp"><span class="toc-number">2.1.1.</span> <span class="toc-text">(1) InstPrinter&#x2F;Cpu0InstPrinter.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-InstPrinter-CMakeLists-txt-InstPrinter-LLVMBuild-txt"><span class="toc-number">2.1.2.</span> <span class="toc-text">(2) InstPrinter&#x2F;CMakeLists.txt, InstPrinter&#x2F;LLVMBuild.txt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0MCInstLower-h-cpp"><span class="toc-number">2.1.3.</span> <span class="toc-text">(3) Cpu0MCInstLower.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-MCTargetDesc-Cpu0BaseInfo-h"><span class="toc-number">2.1.4.</span> <span class="toc-text">(4) MCTargetDesc&#x2F;Cpu0BaseInfo.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0MCAsmInfo-h-cpp"><span class="toc-number">2.1.5.</span> <span class="toc-text">(5) Cpu0MCAsmInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Cpu0AsmPrinter-h-cpp"><span class="toc-number">2.1.6.</span> <span class="toc-text">(6) Cpu0AsmPrinter.h&#x2F;.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0InstrInfo-td"><span class="toc-number">2.2.1.</span> <span class="toc-text">(1) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MCTargetDesc-Cpu0MCTargetDesc-h-cpp"><span class="toc-number">2.2.2.</span> <span class="toc-text">(2) MCTargetDesc&#x2F;Cpu0MCTargetDesc.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MCTargetDesc-CMakeLists-txt-MCTargetDesc-LLVMBuild-txt"><span class="toc-number">2.2.3.</span> <span class="toc-text">(3) MCTargetDesc&#x2F;CMakeLists.txt, MCTargetDesc&#x2F;LLVMBuild.txt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0ISelLowering-cpp"><span class="toc-number">2.2.4.</span> <span class="toc-text">(4) Cpu0ISelLowering.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0MachineFunctionInfo-h"><span class="toc-number">2.2.5.</span> <span class="toc-text">(5) Cpu0MachineFunctionInfo.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-CMakeLists-txt-LLVMBuild-txt"><span class="toc-number">2.2.6.</span> <span class="toc-text">(6) CMakeLists.txt, LLVMBuild.txt</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.</span> <span class="toc-text">2.2.3 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95"><span class="toc-number">2.4.</span> <span class="toc-text">2.2.4 编译测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">2.5.</span> <span class="toc-text">2.2.5 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A2%9E%E5%8A%A0-DAGToDAGISel"><span class="toc-number">3.</span> <span class="toc-text">2.3 增加 DAGToDAGISel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E"><span class="toc-number">3.1.</span> <span class="toc-text">2.3.1 文件新增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0ISelDAGToDAG-h-cpp"><span class="toc-number">3.1.1.</span> <span class="toc-text">(1) Cpu0ISelDAGToDAG.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0SEISelDAGToDAG-h-cpp"><span class="toc-number">3.1.2.</span> <span class="toc-text">(2) Cpu0SEISelDAGToDAG.h&#x2F;.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2.3.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0TargetMachine-cpp"><span class="toc-number">3.2.1.</span> <span class="toc-text">(1) Cpu0TargetMachine.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CMakeLists-txt"><span class="toc-number">3.2.2.</span> <span class="toc-text">(2) CMakeLists.txt</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.</span> <span class="toc-text">2.3.3 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95"><span class="toc-number">3.4.</span> <span class="toc-text">2.3.4 编译测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%AF%84%E5%AD%98%E5%99%A8-lr"><span class="toc-number">4.</span> <span class="toc-text">2.4 处理返回寄存器 $lr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">4.1.</span> <span class="toc-text">2.4.1 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0CallingConv-td"><span class="toc-number">4.1.1.</span> <span class="toc-text">(1) Cpu0CallingConv.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0InstrFormats-td"><span class="toc-number">4.1.2.</span> <span class="toc-text">(2) Cpu0InstrFormats.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0InstrInfo-td"><span class="toc-number">4.1.3.</span> <span class="toc-text">(3) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0ISelLowering-h-cpp"><span class="toc-number">4.1.4.</span> <span class="toc-text">(4) Cpu0ISelLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0MachineFunctionInfo-h-1"><span class="toc-number">4.1.5.</span> <span class="toc-text">(5) Cpu0MachineFunctionInfo.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Cpu0SEInstrInfo-h-cpp"><span class="toc-number">4.1.6.</span> <span class="toc-text">(6) Cpu0SEInstrInfo.h&#x2F;.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">2.4.2 简要说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">4.3.</span> <span class="toc-text">2.4.4 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%A2%9E%E5%8A%A0-Prologue-Epilogue-%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">2.5 增加 Prologue&#x2F;Epilogue 部分代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E"><span class="toc-number">5.1.</span> <span class="toc-text">2.5.1 文件新增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0AnalyzeImmediate-h-cpp"><span class="toc-number">5.1.1.</span> <span class="toc-text">(1) Cpu0AnalyzeImmediate.h&#x2F;.cpp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">5.2.</span> <span class="toc-text">2.5.2 文件修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cpu0SEFrameLowering-h-cpp"><span class="toc-number">5.2.1.</span> <span class="toc-text">(1) Cpu0SEFrameLowering.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cpu0MachineFunctionInfo-h"><span class="toc-number">5.2.2.</span> <span class="toc-text">(2) Cpu0MachineFunctionInfo.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cpu0SEInstrInfo-h-cpp"><span class="toc-number">5.2.3.</span> <span class="toc-text">(3) Cpu0SEInstrInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Cpu0RegisterInfo-cpp"><span class="toc-number">5.2.4.</span> <span class="toc-text">(4) Cpu0RegisterInfo.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Cpu0InstrInfo-td"><span class="toc-number">5.2.5.</span> <span class="toc-text">(5) Cpu0InstrInfo.td</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Cpu0InstrInfo-h-cpp"><span class="toc-number">5.2.6.</span> <span class="toc-text">(6) Cpu0InstrInfo.h&#x2F;.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-InstPrinter-Cpu0InstPrinter-cpp"><span class="toc-number">5.2.7.</span> <span class="toc-text">(7) InstPrinter&#x2F;Cpu0InstPrinter.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-CMakeLists-txt"><span class="toc-number">5.2.8.</span> <span class="toc-text">(8) CMakeLists.txt</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.</span> <span class="toc-text">2.5.3 简要说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%8F%E6%A0%88%E7%A9%BA%E9%97%B4%EF%BC%9A0x0-0x7ff8"><span class="toc-number">5.3.1.</span> <span class="toc-text">(1) 小栈空间：0x0 ~ 0x7ff8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BE%83%E5%B0%8F%E6%A0%88%E7%A9%BA%E9%97%B4%EF%BC%9A0x8000-0xfff8"><span class="toc-number">5.3.2.</span> <span class="toc-text">(2) 较小栈空间：0x8000 ~ 0xfff8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BE%83%E5%A4%A7%E6%A0%88%E7%A9%BA%E9%97%B4%EF%BC%9A0x10000-0xfffffff8"><span class="toc-number">5.3.3.</span> <span class="toc-text">(3) 较大栈空间：0x10000 ~ 0xfffffff8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%A7%E6%A0%88%E7%A9%BA%E9%97%B4%EF%BC%9A0x1000-0xfffffff8"><span class="toc-number">5.3.4.</span> <span class="toc-text">(4) 大栈空间：0x1000 ~ 0xfffffff8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E6%A3%80%E9%AA%8C%E6%88%90%E6%9E%9C"><span class="toc-number">5.4.</span> <span class="toc-text">2.5.4 检验成果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%93%8D%E4%BD%9C%E6%95%B0-pattern"><span class="toc-number">6.</span> <span class="toc-text">2.6 操作数 pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">2.7 总结</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器"><img src= "/img/loading.jpg" data-lazy-src="/img/20210910/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器"></a><div class="content"><a class="title" href="/posts/96dd94da.html" title="LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器">LLVM 后端实践笔记 附录A：使用 Simulator 验证编译器</a><time datetime="2021-09-10T17:12:50.000Z" title="发表于 2021-09-10 17:12:50">2021-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编"><img src= "/img/loading.jpg" data-lazy-src="/img/20210807/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 10：汇编"></a><div class="content"><a class="title" href="/posts/419cdb7c.html" title="LLVM 后端实践笔记 10：汇编">LLVM 后端实践笔记 10：汇编</a><time datetime="2021-08-07T23:15:39.000Z" title="发表于 2021-08-07 23:15:39">2021-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持"><img src= "/img/loading.jpg" data-lazy-src="/img/20210731/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 9：ELF文件支持"></a><div class="content"><a class="title" href="/posts/949c9f6a.html" title="LLVM 后端实践笔记 9：ELF文件支持">LLVM 后端实践笔记 9：ELF文件支持</a><time datetime="2021-07-31T23:04:26.000Z" title="发表于 2021-07-31 23:04:26">2021-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用"><img src= "/img/loading.jpg" data-lazy-src="/img/20210724/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 8：函数调用"></a><div class="content"><a class="title" href="/posts/17d95923.html" title="LLVM 后端实践笔记 8：函数调用">LLVM 后端实践笔记 8：函数调用</a><time datetime="2021-07-24T23:01:27.000Z" title="发表于 2021-07-24 23:01:27">2021-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流"><img src= "/img/loading.jpg" data-lazy-src="/img/20210704/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 7：控制流"></a><div class="content"><a class="title" href="/posts/8908debe.html" title="LLVM 后端实践笔记 7：控制流">LLVM 后端实践笔记 7：控制流</a><time datetime="2021-07-04T22:09:23.000Z" title="发表于 2021-07-04 22:09:23">2021-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型"><img src= "/img/loading.jpg" data-lazy-src="/img/20210619/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 6：更多数据类型"></a><div class="content"><a class="title" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a><time datetime="2021-06-19T17:15:17.000Z" title="发表于 2021-06-19 17:15:17">2021-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量"><img src= "/img/loading.jpg" data-lazy-src="/img/20210606/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 5：全局变量"></a><div class="content"><a class="title" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a><time datetime="2021-06-06T21:38:10.000Z" title="发表于 2021-06-06 21:38:10">2021-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件"><img src= "/img/loading.jpg" data-lazy-src="/img/20210511/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 4：生成目标文件"></a><div class="content"><a class="title" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a><time datetime="2021-05-11T22:18:35.000Z" title="发表于 2021-05-11 22:18:35">2021-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令"><img src= "/img/loading.jpg" data-lazy-src="/img/20210405/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 3：算术和逻辑指令"></a><div class="content"><a class="title" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a><time datetime="2021-04-05T23:24:42.000Z" title="发表于 2021-04-05 23:24:42">2021-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构"><img src= "/img/loading.jpg" data-lazy-src="/img/20210313/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 2：后端结构"></a><div class="content"><a class="title" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a><time datetime="2021-03-13T07:47:31.000Z" title="发表于 2021-03-13 07:47:31">2021-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译"><img src= "/img/loading.jpg" data-lazy-src="/img/20210224/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 1：新后端初始化和软件编译"></a><div class="content"><a class="title" href="/posts/400d7b12.html" title="LLVM 后端实践笔记 1：新后端初始化和软件编译">LLVM 后端实践笔记 1：新后端初始化和软件编译</a><time datetime="2021-02-24T22:53:00.000Z" title="发表于 2021-02-24 22:53:00">2021-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序"><img src= "/img/loading.jpg" data-lazy-src="/img/20210222/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 0：序"></a><div class="content"><a class="title" href="/posts/4b2442c5.html" title="LLVM 后端实践笔记 0：序">LLVM 后端实践笔记 0：序</a><time datetime="2021-02-22T23:14:05.000Z" title="发表于 2021-02-22 23:14:05">2021-02-22</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构"><img src= "/img/loading.jpg" data-lazy-src="/img/20210313/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 2：后端结构"></a><div class="content"><a class="title" href="/posts/eea38852.html" title="LLVM 后端实践笔记 2：后端结构">LLVM 后端实践笔记 2：后端结构</a><time datetime="2024-08-19T15:26:47.818Z" title="更新于 2024-08-19 15:26:47">2024-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令"><img src= "/img/loading.jpg" data-lazy-src="/img/20210405/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 3：算术和逻辑指令"></a><div class="content"><a class="title" href="/posts/1268381.html" title="LLVM 后端实践笔记 3：算术和逻辑指令">LLVM 后端实践笔记 3：算术和逻辑指令</a><time datetime="2024-08-19T15:26:47.818Z" title="更新于 2024-08-19 15:26:47">2024-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件"><img src= "/img/loading.jpg" data-lazy-src="/img/20210511/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 4：生成目标文件"></a><div class="content"><a class="title" href="/posts/3616dfe9.html" title="LLVM 后端实践笔记 4：生成目标文件">LLVM 后端实践笔记 4：生成目标文件</a><time datetime="2024-08-19T15:26:47.818Z" title="更新于 2024-08-19 15:26:47">2024-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量"><img src= "/img/loading.jpg" data-lazy-src="/img/20210606/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 5：全局变量"></a><div class="content"><a class="title" href="/posts/bd2628c8.html" title="LLVM 后端实践笔记 5：全局变量">LLVM 后端实践笔记 5：全局变量</a><time datetime="2024-08-19T15:26:47.818Z" title="更新于 2024-08-19 15:26:47">2024-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型"><img src= "/img/loading.jpg" data-lazy-src="/img/20210619/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LLVM 后端实践笔记 6：更多数据类型"></a><div class="content"><a class="title" href="/posts/cb3a6aa4.html" title="LLVM 后端实践笔记 6：更多数据类型">LLVM 后端实践笔记 6：更多数据类型</a><time datetime="2024-08-19T15:26:47.818Z" title="更新于 2024-08-19 15:26:47">2024-08-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/20210313/index.webp)"><div id="footer-wrap"><div class="copyright">&copy;2024 By P2Tree</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@latest/dist/fancybox/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@latest/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://npm.elemecdn.com/pangu@latest/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><script>(()=>{const t=()=>{let t=document.createElement("script");t.id="utterances_comment",t.src="https://utteranc.es/client.js",t.setAttribute("repo","p2tree/p2tree.github.io"),t.setAttribute("issue-term","pathname");const e="dark"===document.documentElement.getAttribute("data-theme")?"photon-dark":"github-light";t.setAttribute("theme",e),t.crossOrigin="anonymous",t.async=!0,document.getElementById("utterances-wrap").appendChild(t)};btf.addGlobalFn("themeChange",t=>{const e=document.querySelector(".utterances-frame");if(e){const t="dark"===t?"photon-dark":"github-light",n={type:"set-theme",theme:t};e.contentWindow.postMessage(n,"https://utteranc.es")}},"utterances"),t()})()</script></div><script defer id="ribbon" src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v7.0.0" title=""><img src= "/img/loading.jpg" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.13.0" title=""><img src= "/img/loading.jpg" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站部署托管于Vercel" title=""><img src= "/img/loading.jpg" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "/img/loading.jpg" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站源码由Github托管" title=""><img src= "/img/loading.jpg" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "/img/loading.jpg" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script async src="/js/footer_beautify.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/73fc32a.html" alt=""><img width="48" height="48" src= "/img/loading.jpg" data-lazy-src="/img/20231014/index.webp" alt="" onerror="this.src=/img/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-14</span><a class="blog-slider__title" href="posts/73fc32a.html" alt="">Vim 高效编辑技巧</a><div class="blog-slider__text">绝对是全网都没有的 Vim 使用硬干货经验</div><a class="blog-slider__button" href="posts/73fc32a.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4b2442c5.html" alt=""><img width="48" height="48" src= "/img/loading.jpg" data-lazy-src="/img/20210222/index.webp" alt="" onerror="this.src=/img/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-02-22</span><a class="blog-slider__title" href="posts/4b2442c5.html" alt="">LLVM 后端实践笔记 0：序</a><div class="blog-slider__text">LLVM 后端学习的系列教程，这是第一集，必读起跑线</div><a class="blog-slider__button" href="posts/4b2442c5.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/e8d522db.html" alt=""><img width="48" height="48" src= "/img/loading.jpg" data-lazy-src="/img/20240805/wechat_logo.webp" alt="" onerror="this.src=/img/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-05</span><a class="blog-slider__title" href="posts/e8d522db.html" alt="">微信公众号 P2Tree</a><div class="blog-slider__text">我维护的微信公众号，欢迎来交个朋友</div><a class="blog-slider__button" href="posts/e8d522db.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="/about/,/tags/,/categories/,/draft/".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>