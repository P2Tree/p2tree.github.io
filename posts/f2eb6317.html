<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>编写一个LLVM后端 | P2Tree's Mill</title><meta name="author" content="P2Tree"><meta name="copyright" content="P2Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文翻译自 LLVM 官方的一篇教程：Writing an LLVM Backend​releases.llvm.org&#x2F;10.0.0&#x2F;docs&#x2F;WritingAnLLVMBackend.html#instruction-scheduling   该文档需要有一定的 LLVM 和 编译原理的基础。LLVM目前的更新很活跃，请注意跟踪项目最新变更   1 介绍这篇文章"><meta property="og:type" content="article"><meta property="og:title" content="编写一个LLVM后端"><meta property="og:url" content="https://p2tree.top/posts/f2eb6317.html"><meta property="og:site_name" content="P2Tree&#39;s Mill"><meta property="og:description" content="本文翻译自 LLVM 官方的一篇教程：Writing an LLVM Backend​releases.llvm.org&#x2F;10.0.0&#x2F;docs&#x2F;WritingAnLLVMBackend.html#instruction-scheduling   该文档需要有一定的 LLVM 和 编译原理的基础。LLVM目前的更新很活跃，请注意跟踪项目最新变更   1 介绍这篇文章"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.p2tree.top/2020/06/20/index.webp"><meta property="article:published_time" content="2020-06-20T21:22:03.000Z"><meta property="article:modified_time" content="2020-06-20T21:22:03.000Z"><meta property="article:author" content="P2Tree"><meta property="article:tag" content="编译器"><meta property="article:tag" content="译文"><meta property="article:tag" content="LLVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.p2tree.top/2020/06/20/index.webp"><link rel="shortcut icon" href="https://img.p2tree.top/avatar.webp"><link rel="canonical" href="https://p2tree.top/posts/f2eb6317.html"><link rel="preconnect" href="https://npm.elemecdn.com"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=5.0.0-b2"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@latest/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},o&&n[e][o]||(n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n)}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",()=>{void 0===t.get("theme")&&(e.matches?o():a())})}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-2M9BYWL9WW"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2M9BYWL9WW"),btf.addGlobalFn("pjaxComplete",()=>{gtag("config","G-2M9BYWL9WW",{page_path:window.location.pathname})},"google_analytics")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"D6LVAK5RKB",apiKey:"f6946a241b05432428a3e4fc6e7ba9e7",indexName:"my-hexo-blog",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,noticeOutdate:{limitDay:1e3,position:"top",messagePrev:"距离上次更新已过去",messageNext:"天，文章中的部分内容可能已经过时，请酌情参考～"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!0,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:500,languages:{author:"作者: P2Tree",link:"链接: ",source:"来源: P2Tree's Mill",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://npm.elemecdn.com/@egjs/infinitegrid@latest/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"编写一个LLVM后端",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-06-20 21:22:03"}</script><meta name="baidu-site-verification" content="codeva-Watq1Co2vC"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4649427_nfzovmtn6c.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="P2Tree's Mill" type="application/atom+xml">
</head><body><script>window.paceOptions={restartOnPushState:!1},btf.addGlobalFn("pjaxSend",()=>{Pace.restart()},"pace_restart")</script><link rel="stylesheet" href="/css/pace-theme-minimal.css"><script src="https://npm.elemecdn.com/pace-js@latest/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.p2tree.top/avatar.webp" onerror='onerror=null,src="/img/404.gif"' alt="avatar"></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">类别</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pen-to-square"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文踪</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.p2tree.top/2020/06/20/index.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">P2Tree's Mill</span></a><a class="nav-page-title" href="/"><span class="site-name">编写一个LLVM后端</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pen-to-square"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文踪</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Games-Collection-a82b7f1e22b44e5fb7e207e521279a31"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://quirky-olivine-7e6.notion.site/My-Book-Tracker-3ee78866f1274e869d48fe75bfec23e7"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">编写一个LLVM后端</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-20T21:22:03.000Z" title="发表于 2020-06-20 21:22:03">2020-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-06-20T21:22:03.000Z" title="更新于 2020-06-20 21:22:03">2020-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>本文翻译自 LLVM 官方的一篇教程：<br><a target="_blank" rel="noopener" href="https://releases.llvm.org/10.0.0/docs/WritingAnLLVMBackend.html#instruction-scheduling">Writing an LLVM Backend​releases.llvm.org&#x2F;10.0.0&#x2F;docs&#x2F;WritingAnLLVMBackend.html#instruction-scheduling</a></p></blockquote><blockquote><p>该文档需要有一定的 LLVM 和 编译原理的基础。<br><strong>LLVM目前的更新很活跃，请注意跟踪项目最新变更</strong></p></blockquote><hr><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>这篇文章描述了如何编写一个用于将LLVM中间表示（IR）转换成特定目标机器上的代码或其他编程语言的编译器后端的技术。作用于特定目标机器的代码可以使汇编码形式，也可以是用于JIT编译器的二进制码形式。</p><p>LLVM的后端特点是目标无关代码生成器，它可以输出多种不同类型目标CPU的代码，包括X86、PowerPC、ARM以及SPARC等。后端也会被用来生成如SPU一类的元胞处理器（Cell processor）或者是一些GPU上的计算内核。</p><p>这篇文章专注在的路径是在release版本LLVM源码路径下的<code>llvm/lib/Target</code>，尤其是专注于举例如何编写一个为SPARC目标平台的静态编译器（也就是发射汇编码），因为SPARC架构有非常标准的特性，比如RISC架构指令集以及常规的调用约定。</p><h2 id="1-1-目标读者"><a href="#1-1-目标读者" class="headerlink" title="1.1 目标读者"></a>1.1 目标读者</h2><p>本文目标读者是任何需要编写LLVM后端来为特定软硬件目标生成代码的人。</p><h2 id="1-2-预先阅读"><a href="#1-2-预先阅读" class="headerlink" title="1.2 预先阅读"></a>1.2 预先阅读</h2><p>以下资料必须提前阅读了解：</p><ul><li><a target="_blank" rel="noopener" href="https://releases.llvm.org/10.0.0/docs/LangRef.html">LLVM Language Reference Manual</a>：这是一个介绍LLVM汇编语言的参考手册</li><li><a target="_blank" rel="noopener" href="https://releases.llvm.org/10.0.0/docs/CodeGenerator.html">The LLVM Target-Independent Code Generator</a>：一个描述用于翻译LLVM中间表示到特定目标机器代码需要使用的类结构和算法的指南。需要特别注意代码生成阶段（pass）的内容：指令选择，调度和队列化（Formation），SSA级优化，寄存器分配，Prolog和Epilog代码插入，后机器代码优化，以及代码发射。</li><li><a target="_blank" rel="noopener" href="https://releases.llvm.org/10.0.0/docs/TableGen/index.html">TableGen</a>：这个文档描述了TableGen（tblgen）引用如何管理领域特定信息来支持LLVM代码生成。TableGen从一个特殊的目标描述文件（.td后缀）中读入输入信息，然后生成c++代码，用于代码生成。</li></ul><blockquote><p>这篇文章我做了翻译，也融入了自己的一些认识，可做参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141265959">有关于TableGen的简单介绍</a></p></blockquote><ul><li><a target="_blank" rel="noopener" href="https://releases.llvm.org/10.0.0/docs/WritingAnLLVMPass.html">Writing an LLVM Pass</a>：汇编输出是一个FunctionPass，另外还有几个SelectionDAG的处理步骤。</li></ul><p>另外，为了支持SPARC案例相关的信息，你需要有一份 <a target="_blank" rel="noopener" href="http://www.sparc.org/standards/V8.pdf">The SPARC Architecture Manual, Version 8</a> 来作为参考。更多关于ARM架构指令集的信息，需要参考<a target="_blank" rel="noopener" href="http://infocenter.arm.com/">ARM Architecture Reference Manual</a> 。有关于GNU汇编器格式的说明，参考 <a target="_blank" rel="noopener" href="http://sourceware.org/binutils/docs/as/index.html">Using As</a> ，特别是汇编代码输出的部分， Using As 中包含了一个目标机器相关特性的清单。</p><h3 id="1-3-基本步骤"><a href="#1-3-基本步骤" class="headerlink" title="1.3 基本步骤"></a>1.3 基本步骤</h3><p>编写一个编译器后端来将LLVM的IR转换为特定目标的代码（如硬件机器或其他语言），需要以下步骤：</p><ul><li>创建一个TargetMachine的子类，用来描述你的目标机器的特性。拷贝已经存在的其他特定后端中的TargetMachine和头文件；比如拷贝SparcTargetMachine.cpp和SparcTargetMachine.h，但是要修改文件名为你自己的目标。类似的，也要把文件内容中的space都改成你的目标名称。</li><li>需要描述目标机器的寄存器集。依赖于目标相关的RegisterInfo.td文件作为输入，使用TableGen来生成有关寄存器定义、寄存器别名和寄存器类的代码。你也可能编写一些额外的代码，通过实现继承TargetRegisterInfo类的子类来表示有助于寄存器分配和寄存器间交互的信息。</li><li>需要描述目标机器的指令集。依赖于目标相关的TargetInstrFormats.td文件和TargetInstrInfo.td文件作为输入，使用TableGen来生成有关目标的指令集信息。你也可能编写一些额外的代码，通过实现TargetInstrInfo类的子类来表示目标机器的一些机器指令。</li><li>需要描述将LLVM IR从一个DAG描述的指令转换成原生特定机器指令的选择和转换。依赖于目标相关的TargetInstrInfo.td文件作为输入，使用TableGen生成有关描述模式匹配和指令选择的信息。编写XXXISelDAGToDAG.cpp文件中代码（XXX表示目标平台名称）来描述模式匹配和DAG到DAG的指令选择。另外也要完成XXXISelLowering.cpp文件中代码，来替代或移除一些SelectionDAG中不支持的操作和数据类型。</li><li>需要为汇编输出模块编写代码，从而可以将LLVM IR转换为与你目标机器平台匹配的GAS格式的输出。你应该会在目标相关的TargetInstrInfo.td中增加对指令汇编格式的约定。同事还需要完成继承AsmPrinter类的之类，它被用来实现LLVM IR到汇编格式的转换，另外还有个辅助的继承类TargetAsmInfo的之类。</li><li>可选部分，可以支持子目标平台（subtarget）你可以编写一个继承自TargetSubtarget类的之类，通过命令行参数-mcpu&#x3D;和-mattr&#x3D;可以指定针对特定子目标平台和部分特性的编译选项。</li><li>可选部分，增加一个JIT支持，创建一个机器码输出，你需要编写一个继承自TargetJITInfo类的子类，用来发射二进制机器码到内存中。</li></ul><p>在cpp和h文件中，首先需要为这些方法占位，然后再逐步实现它们。最初，你可能不知道这些类需要哪些私有成员，以及哪些子类需要被创建。</p><h2 id="1-4-预备步骤"><a href="#1-4-预备步骤" class="headerlink" title="1.4 预备步骤"></a>1.4 预备步骤</h2><p>为了创建你的编译器后端，你需要创建和修改一些文件，这里简单讨论了一下。但是真正的操作，你必须要参考 LLVM Target-Independent Code Generator 文档中的描述来逐步进行。</p><p>首先，你应该在 lib&#x2F;Target 目录下创建一个你自己目标名称的子目录，用来存放所有的和你目标相关的文件。如果你的目标叫做Dummy，需要创建的目录就是 lib&#x2F;Target&#x2F;Dummy。</p><p>在这个目录下，需要创建一个CMakeLists.txt文件，你可以简单的从其他的后端路径下复制该文件，然后直接修改，至少需要将 LLVM_TARGET_DEFINITIONS 变量修改了。对应的library可以叫做LLVMDummy（你可以参考MIPS后端）。另一种方式是，你可以区分LLVMDummyCodeGen和LLVMDummyAsmPrinter这两个为不同的库，后者需要实现在 lib&#x2F;Target&#x2F;Dummy下一级的子目录中（你可以参考PowerPC后端）。</p><p>需要注意，这两种命名方式是硬编码在llvm-config中的。使用其他的命名方式会让llvm-config无法正常工作，并在llc中产生很多的链接错误。</p><p>为了让你的目标真的做什么事情，至少你需要实现TargetMachine的子类，这个实现是在 lib&#x2F;Target&#x2F;DummyTargetMachine.cpp中完成的，但任何在该目录下的其他文件都应该能正常编译和工作。为了实现LLVM的目标无关的代码生成工作，你需要实现所有当前机器平台后端需要做的事情，实现一个继承自LLVMTargetMachine的子类（如果是从零开始创建目标平台，实现TargetMachine的子类）。</p><p>为了能让LLVM可以编译和链接你的目标，你需要指定参数-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD&#x3D;Dummy来运行cmake，这将能够在不必将目标添加在其他目标的列表前，就构建你的目标。</p><p>一旦你的目标后端稳定了，你可以将其增加在LLVM_ALL_TARGETS变量中，这个变量位于最外层的CMakeLists.txt中。</p><hr><h1 id="2-目标机器"><a href="#2-目标机器" class="headerlink" title="2 目标机器"></a>2 目标机器</h1><p>LLVMTargetMachine被设计作为一个基类来完成LLVM目标无关代码生成任务。这个类需要被继承并实现其定义的虚函数。LLVMTargetMachine是TargetMachine的一个子类，其在 include&#x2F;llvm&#x2F;Target&#x2F;TargetMachine.h 中被实现，同时TargetMachine类还处理大量和命令行参数有关的内容（TargetMachine.cpp）。</p><p>为了定义一个继承自LLVMTargetMachine类的目标平台特定的子类，首先需要复制一个已经存在的TargetMachine的源文件和头文件，然后你应该将其命名为与你特定后端相关的名字，比如对于SPARC平台来说，将其命名为 SparcTargetMachine.h和SparcTargetMachine.cpp文件。</p><p>对于一个目标机器XXX，实现的XXXTargetMachine必须通过一些方法来访问到对应后端的各种组件。这些方法被命名为 <code>get*Info</code>，比如能够获得指令集信息的getInstrInfo，获得寄存器集信息的getRegisterInfo，获得帧信息的getFrameInfo等。XXXTargetMachine还需要实现getDataLayout方法，用来访问对应这个目标特殊的数据特性，比如数据类型的空间占用和对齐要求。</p><p>举个例子，对于SPARC目标来说，头文件SparcTargetMachine.h 中声明了很多<code>get*Info</code>和getDataLayout方法的原型，这些方法返回的是对应的类成员对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> llvm &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparcTargetMachine</span> : <span class="keyword">public</span> LLVMTargetMachine &#123;</span><br><span class="line">    <span class="type">const</span> DataLayout DataLayout;</span><br><span class="line">    SparcSubtarget Subtarget;</span><br><span class="line">    SparcInstrInfo InstrInfo;</span><br><span class="line">    TargetFrameInfo FrameInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> TargetAsmInfo *<span class="title">createTargetAsmInfo</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SparcTargetMachine</span>(<span class="type">const</span> Module &amp;M, <span class="type">const</span> std::string &amp;FS);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> SparcInstrInfo *<span class="title">getInstrInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> &amp;InstrInfo; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> TargetFrameInfo *<span class="title">getFrameInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> &amp;FrameInfo; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> TargetSubtarget *<span class="title">getSubtargetImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> &amp;Subtarget; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> TargetRegisterInfo *<span class="title">getRegisterInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;InstrInfo.<span class="built_in">getRegisterInfo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> DataLayout *<span class="title">getDataLayout</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &amp;DataLayout; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">getModuleMatchQuality</span><span class="params">(<span class="type">const</span> Module &amp;M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass Pipeline Configuration</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">addInstSelector</span><span class="params">(PassManagerBase &amp;PM, <span class="type">bool</span> Fast)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">addPreEmitPass</span><span class="params">(PassManagerBase &amp;PM, <span class="type">bool</span> Fast)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end namespace llvm</span></span><br></pre></td></tr></table></figure><p>这就包括：</p><ul><li>getInstrInfo()</li><li>getRegisterInfo()</li><li>getFrameInfo()</li><li>getDataLayout()</li><li>getSubtargetImpl()</li></ul><p>对于另外一些目标，你还可以支持如下的方法：</p><ul><li>getTargetLowering()</li><li>getJITInfo()</li></ul><p>一些架构，比如GPU等，并不支持跳转到程序任意位置，执行分支任务需要屏蔽执行并使用循环体周围的特殊指令实现循环。为了避免CFG修改引入不可约束的控制流无法被硬件处理，目标必须在初始化时调用setRequiresStructuredCFG(true)。</p><p>另外，XXXTargetMachine的构造函数需要应该指定一个特殊的TargetDescription字符串，用来决定该目标平台的data layout，包括指针的占用内存大小、对齐以及大小端信息。比如，SPARCTargetMachine中的构造函数包括如下信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SparcTargetMachine::<span class="built_in">SparcTargetMachine</span>(<span class="type">const</span> Module &amp;M, <span class="type">const</span> std::string &amp;FS)</span><br><span class="line">  : <span class="built_in">DataLayout</span>(<span class="string">&quot;E-p:32:32-f128:128:128&quot;</span>),</span><br><span class="line">    <span class="built_in">Subtarget</span>(M, FS), <span class="built_in">InstrInfo</span>(Subtarget),</span><br><span class="line">    <span class="built_in">FrameInfo</span>(TargetFrameInfo::StackGrowsDown, <span class="number">8</span>, <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接符<code>-</code>区分了data layout字符串的不同部分：</p><ul><li>大写的E表示这是大端目标数据模型，而小写的e则表示是小端模型；</li><li><code>p:</code>以及后续的几个值，表示指针的信息，包括占用空间大小，ABI的对齐要求和优先对齐。如果后边只有2个数字，则第一个数字是指针的占用空间大小，第二个数字同时表示两种对齐情况。</li><li>然后后边的一个字符，可能是<code>f</code>，<code>i</code>，<code>v</code>，<code>a</code>等，分别表示浮点数、整数、向量和整体，然后后边的数据格式意义与指针类型是基本一致的。</li></ul><hr><h1 id="3-目标注册"><a href="#3-目标注册" class="headerlink" title="3 目标注册"></a>3 目标注册</h1><p>你还需要将你的目标通过TargetRegistry接口来注册，从而其他的LLVM工具可以在运行时来查找和使用你的目标。TargetRegistry接口可以直接使用，但是大多数后端都会额外有一些帮助模版来辅助注册。</p><p>所有的目标都需要声明一个全局的Target对象，这将被用来在注册时表示目标。然后，在目标的TargetInfo库中，目标需要定义对象并使用RegisterTarget模版接口来注册对象。比如对于Sparc目标的注册代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Target <span class="title">llvm::getTheSparcTarget</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">LLVMInitializeSparcTargetInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">RegisterTarget&lt;Triple::sparc, <span class="comment">/*HasJIT=*/</span><span class="literal">false</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="title">X</span><span class="params">(getTheSparcTarget(), <span class="string">&quot;sparc&quot;</span>, <span class="string">&quot;Sparc&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将允许TargetRegistry通过名字或目标标识来查找目标。另外，大多数目标还会注册一些其他会在单独的库中使用的特性。这些注册步骤是独立的，因为一些工具可能只需要目标中的部分特性，比如说JIT代码生成的库就不需要汇编输出的特性，以下是一个Sparc中注册汇编输出功能的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">LLVMInitializeSparcAsmPrinter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">RegisterAsmPrinter&lt;SparcAsmPrinter&gt; <span class="title">X</span><span class="params">(getTheSparcTarget())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的信息请参考 “llvm&#x2F;Target&#x2F;TargetRegistry.h”</p><hr><h1 id="4-寄存器集合寄存器类别"><a href="#4-寄存器集合寄存器类别" class="headerlink" title="4 寄存器集合寄存器类别"></a>4 寄存器集合寄存器类别</h1><blockquote><p>译注：本节及后文将原文中Register Set译为寄存器集合，将Register Class译为寄存器类别。</p></blockquote><p>你应该接下来描述表示目标机器的寄存器文件的简单类结构。这个类被称为 XXXRegisterInfo，这个类中的寄存器文件数据会被用来做寄存器分配等工作，它同事也描述了寄存器之间的关系。</p><p>你也需要定义一些寄存器类别来分类相关的寄存器。一个寄存器类别中的寄存器应该对于一些指令有着相同的行为。典型的例子是包括所有整形寄存器的类别、浮点型寄存器的类别和向量寄存器的类别。寄存器分配允许一个指令使用某个特定寄存器类别中的寄存器来完成相同的指令功能。寄存器类别会给这些指令分配虚拟寄存器，同时也会在寄存器分配阶段分配真实的寄存器。</p><p>大多数寄存器相关的代码，比如寄存器定义、别名以及类别，都是在TableGen的 XXXRegisterInfo.td文件中完成的，这个文件会生成 XXXGenRegisterInfo.h.inc 和 XXXGenRegisterInfo.inc。另外一些代码需要手动在 XXXRegisterInfo 结构中实现。</p><h2 id="4-1-定义一个寄存器"><a href="#4-1-定义一个寄存器" class="headerlink" title="4.1 定义一个寄存器"></a>4.1 定义一个寄存器</h2><p>在 XXXRegisterInfo.td文件中，习惯性先定义目标机器的寄存器。Register类（在Target.td中定义）用来为每个寄存器定义对象，参见下边代码。其中的参数 n 是指寄存器的名字。基本 Register 对象没有子寄存器，也没有特殊的别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Register</span>&lt;string n&gt; &#123;</span><br><span class="line">  string Namespace = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  string AsmName = n;</span><br><span class="line">  string Name = n;</span><br><span class="line">  <span class="type">int</span> SpillSize = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> SpillAlignment = <span class="number">0</span>;</span><br><span class="line">  list&lt;Register&gt; Aliases = [];</span><br><span class="line">  list&lt;Register&gt; SubRegs = [];</span><br><span class="line">  list&lt;<span class="type">int</span>&gt; DwarfNumbers = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在 X86RegisterInfo.td 文件中，使用Register类完成寄存器定义的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def AL : Register&lt;<span class="string">&quot;AL&quot;</span>&gt;, DwarfRegNum&lt;[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]&gt;;</span><br></pre></td></tr></table></figure><p>这行代码定义了寄存器 AL 并且指定了 Dwarf 中寄存器编号，这个编号会被如 gcc，gdb 或其他调试信息工具来识别寄存器。对于 AL 寄存器 来说，DwarfRegNum 使用了一个由 3 个值组成的数组，用来表示 3 种不同的模式：第一个元素是针对 X86-64，第二个元素是用于 X86-32 中的异常处理（exception handling），第三个元素是通用值。如果指定 -1 则表示 gcc 的值未定义，如果指定 -2 则表示寄存器值是非法的。</p><p>对于之前的 td 文件中的描述，TableGen 工具会在 X86RegisterInfo.inc 中生成如下的 c++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> GR8[] = &#123; X86::AL, ... &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> AL_AliasSet[] = &#123; X86::AX, X86::EAX, X86::RAX, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">const</span> TargetRegisterDesc RegisterDescriptors = &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#123; <span class="string">&quot;AL&quot;</span>, <span class="string">&quot;AL&quot;</span>, AL_AliasSet, Empty_SubRegsSet, Empty_SubRegsSet, AL_SuperRegsSet &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TableGen 会生成针对每个寄存器的 TargetRegisterDesc 对象。这个对象在 include&#x2F;llvm&#x2F;Target&#x2F;TargetRegisterInfo.h 中定义，它的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TargetRegisterDesc</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *AsmName;              <span class="comment">// Assembly language name for the register</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *Name;                 <span class="comment">// Printable name for the reg (for debugging)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> *AliasSet;         <span class="comment">// Register Alias Set</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> *SubRegs;          <span class="comment">// Sub-register set</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> *ImmSubRegs;       <span class="comment">// Immediate sub-register set</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> *SuperRegs;        <span class="comment">// Super-register set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TableGen 使用 td 文件来决定寄存器名称（AsmName 和 Name 部分）和与其他寄存器的关系。在这个例子中，还定义了寄存器 AX，EAX 和 RAX 并互相作为别名，所以 TableGen 生成了一个以 null 结尾的数组（AL_AliasSet）来保存寄存器别名集合。</p><p>Register 类也会作为更加复杂的寄存器类的基类，在 Target.td 文件中，Register 类作为 RegisterWithSubRegs 类的基类，后者被用来定义需要指定特殊子寄存器的寄存器，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RegisterWithSubRegs</span>&lt;string n, list&lt;Register&gt; subregs&gt; : Register&lt;n&gt; &#123;</span><br><span class="line">  let SubRegs = subregs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SparcRegisterInfo.td 文件中，还有SPARC 特殊使用的寄存器类，如 SparcReg，它以 Register 作为基类，并衍生出更多子类，如 Ri，Rf 和 Rd。SPARC 寄存器由 5 个 ID 数字来识别，这个在不同的子类中是相同的，他们使用 let 表达式来覆盖在父类中初始化时定义的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SparcReg</span>&lt;string n&gt; : Register&lt;n&gt; &#123;</span><br><span class="line">  field bits&lt;<span class="number">5</span>&gt; Num;</span><br><span class="line">  let Namespace = <span class="string">&quot;SP&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ri - 32-bit integer registers</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ri</span>&lt;bits&lt;<span class="number">5</span>&gt; num, string n&gt; : SparcReg&lt;n&gt; &#123;</span><br><span class="line">  let Num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Rf - 32-bit floating-point registers</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rf</span>&lt;bits&lt;<span class="number">5</span>&gt; num, string n&gt; : SparcReg&lt;n&gt; &#123;</span><br><span class="line">  let Num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Rd - Slots in the FP register file for 64-bit floating-point values</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rd</span>&lt;bits&lt;<span class="number">5</span>&gt; num, string n, list&lt;Register&gt; subregs&gt; : SparcReg&lt;n&gt; &#123;</span><br><span class="line">  let Num = num;</span><br><span class="line">  let SubRegs = subregs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SparcRegisterInfo.td 文件中，使用这些子类来完成寄存器定义，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def G0 : Ri&lt; <span class="number">0</span>, <span class="string">&quot;G0&quot;</span>&gt;, DwarfRegNum&lt;[<span class="number">0</span>]&gt;;</span><br><span class="line">def G1 : Ri&lt; <span class="number">1</span>, <span class="string">&quot;G1&quot;</span>&gt;, DwarfRegNum&lt;[<span class="number">1</span>]&gt;;</span><br><span class="line">...</span><br><span class="line">def F0 : Rf&lt; <span class="number">0</span>, <span class="string">&quot;F0&quot;</span>&gt;, DwarfRegNum&lt;[<span class="number">32</span>]&gt;;</span><br><span class="line">def F1 : Rf&lt; <span class="number">1</span>, <span class="string">&quot;F1&quot;</span>&gt;, DwarfRegNum&lt;[<span class="number">33</span>]&gt;;</span><br><span class="line">...</span><br><span class="line">def D0 : Rd&lt; <span class="number">0</span>, <span class="string">&quot;F0&quot;</span>, [F0, F1]&gt;, DwarfRegNum&lt;[<span class="number">32</span>]&gt;;</span><br><span class="line">def D1 : Rd&lt; <span class="number">2</span>, <span class="string">&quot;F2&quot;</span>, [F2, F3]&gt;, DwarfRegNum&lt;[<span class="number">34</span>]&gt;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后两个寄存器（D0 和 D1）是双精度的浮点寄存器，他们由两个单精度浮点子寄存器组成。除别名之外，子寄存器和父寄存器的关系也存在于寄存器的 TargetRegisterDesc 字段中。</p><h2 id="4-2-定义一个寄存器类别"><a href="#4-2-定义一个寄存器类别" class="headerlink" title="4.2 定义一个寄存器类别"></a>4.2 定义一个寄存器类别</h2><blockquote><p>译注，原文 Register Class 想表达的是寄存器的集合，这里译作寄存器类别，去 C++中的类做区别</p></blockquote><p>寄存器类别的类 RegisterClass（在 Target.td 中定义）被用来定义一个表示一组相关寄存器的集合的对象，同时用来定义寄存器的默认分配顺序。目标描述文件 XXXRegisterInfo.td 使用 Target.td 来构造寄存器类别，该类的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RegisterClass</span>&lt;string <span class="keyword">namespace</span>, list&lt;ValueType&gt; regTypes, <span class="type">int</span> alignment, dag regList&gt; &#123;</span><br><span class="line">  string Namespace = <span class="keyword">namespace</span>;</span><br><span class="line">  list&lt;ValueType&gt; RegTypes = regTypes;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;  <span class="comment">// 位为单位的溢出长度，设为 0，由 tblgen 工具设定</span></span><br><span class="line">  <span class="type">int</span> Alignment = alignment;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CopyCost 是在两个寄存器间复制值的成本</span></span><br><span class="line">  <span class="comment">// 默认是 1，表示用 1 条指令完成</span></span><br><span class="line">  <span class="comment">// 设定为负数表示复制值非常困难或无法实现</span></span><br><span class="line">  <span class="type">int</span> CopyCost = <span class="number">1</span>;</span><br><span class="line">  dag MemberList = regList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个类别的子类别</span></span><br><span class="line">  list&lt;RegisterClass&gt; SubRegClassList = [];</span><br><span class="line"></span><br><span class="line">  code MethodProtos = [&#123;&#125;];  <span class="comment">// 任意代码</span></span><br><span class="line">  code MethodBodies = [&#123;&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 RegisterClass 的对象，需要给定 4 个参数：</p><ul><li>第一个参数是命名空间；</li><li>第二个参数是一个寄存器类型值的列表，这些类型在 include&#x2F;llvm&#x2F;CodeGen&#x2F;ValueTypes.td 中定义。已定义的类型包括整数类型（i16, i32, 用于布尔型的i1等），浮点类型（f32, f64），向量类型（比如 v8i16 表示 8 * i16 的向量）。同一个寄存器类型中的所有的寄存器必须有相同的 ValueType，但是一些寄存器可能在不同的配置下存储不同类型的向量数据。比如，一个能够存放 128 位数据的向量寄存器，既可以保存 16 个 8 位的整形元素，也可以保存 8 个 16 位的整形或 4 个 32 位的整形元素（译注：所以这个参数用列表来指定不同的可能的类型）。</li><li>第三个参数是这个 RegisterClass 对象特定的对齐长度，当它们做 store 和 load 操作时，这个参数会被用到。</li><li>第四个参数，指定了这个类别中有哪些寄存器。如果没有指定可选的分配顺序，则这个参数中的顺序还同时表示寄存器分配时的顺序。简单的例子如<code>(add R0, R1, ...)</code>，更加复杂的一些例子可查看 include&#x2F;llvm&#x2F;Target&#x2F;Target.td。</li></ul><p>在 SparcRegisterInfo.td 文件中，定义了三个寄存器类别的类对象，分别是 FPRegs，DFPRegs，IntRegs。这三个寄存器类别对象的第一个参数（命名空间）指定为“SP”。FPRegs 定义了一组保存 32 位单精度浮点数的寄存器集合（F0 到 F31）；DFPRegs 定义了一组保存 16 位双精度浮点数寄存器集合（D0-D15）。实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F0, F1, F2, ..., F31</span></span><br><span class="line">def FPRegs : RegisterClass&lt;<span class="string">&quot;SP&quot;</span>, [f32], <span class="number">32</span>, (sequence <span class="string">&quot;F%u&quot;</span>, <span class="number">0</span>, <span class="number">31</span>)&gt;;</span><br><span class="line"></span><br><span class="line">def DFPRegs : RegisterClass&lt;<span class="string">&quot;SP&quot;</span>, [f64], <span class="number">64</span>, </span><br><span class="line">                            (add D0, D1, D2, D3, D4, D5, D6, D7, D8, </span><br><span class="line">                                 D9, D10, D11, D12, D13, D14, D15)&gt;;</span><br><span class="line"></span><br><span class="line">def IntRegs : RegisterClass&lt;<span class="string">&quot;SP&quot;</span>, [i32], <span class="number">32</span>, </span><br><span class="line">                            (add L0, L1, L2, L3, L4, L5, L6, L7, </span><br><span class="line">                                 I0, I1, I2, I3, I4, I5, </span><br><span class="line">                                 O0, O1, O2, O3, O4, O5, O7, </span><br><span class="line">                                 G1,</span><br><span class="line">                                 <span class="comment">// 不分配的寄存器：</span></span><br><span class="line">                                 G2, G3, G4,</span><br><span class="line">                                 O6, <span class="comment">// 栈指针</span></span><br><span class="line">                                 I6, <span class="comment">// 帧指针</span></span><br><span class="line">                                 I7, <span class="comment">// 返回地址</span></span><br><span class="line">                                 G0, <span class="comment">// 常数 0</span></span><br><span class="line">                                 G5, G6, G7 <span class="comment">// 内核保留</span></span><br><span class="line">                             )&gt;;</span><br></pre></td></tr></table></figure><p>将 SparcRegisterInfo.td 作为 TableGen 的输入，会生成多个输出文件，这些文件可以在你的代码中被调用。SparcRegisterInfo.td 首先生成 SparcGenRegisterInfo.h.inc，这个文件可以包含（included）到你的 SPARC 寄存器实现的头文件（SparcRegisterInfo.h）中。在SparcGenRegisterInfo.h.inc 文件中，定义了一个新的结构，SparcGenRegisterInfo，它使用 TargetRegisterInfo 作为基类，同样的，会根据 td 文件中的指定区分类型：DFPRegsClass，FPRegsClass 和 IntRegsClass。</p><p>另外，SparcRegisterInfo.td 还会输出 SparcGenRegisterInfo.inc，可以包含到（included）SparcRegisterInfo.cpp 最下边，后者是寄存器的实现代码文件。下边代码展示了生成的整数寄存器的内容和对应的类。IntRegs 的寄存器顺序和 td 文件中的定义时保持一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数寄存器类别</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> IntRegs[] = &#123;</span><br><span class="line">  SP::L0, SP::L1, SP::L2, SP::L3, SP::L4, SP::L5,</span><br><span class="line">  SP::L6, SP::L7, SP::I0, SP::I1, SP::I2, SP::I3,</span><br><span class="line">  SP::I4, SP::I5, SP::O0, SP::O1, SP::O2, SP::O3,</span><br><span class="line">  SP::O4, SP::O5, SP::O7, SP::G1, SP::G2, SP::G3,</span><br><span class="line">  SP::G4, SP::O6, SP::I6, SP::I7, SP::G0, SP::G5,</span><br><span class="line">  SP::G6, SP::G7,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntRegsVTs 寄存器类别类型</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MVT::ValueType IntRegsVTs[] = &#123;</span><br><span class="line">  MVT::i32, MVT::Other</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SP &#123;    <span class="comment">// 寄存器类别的实例</span></span><br><span class="line">  DFPRegsClass    DFPRegsRegClass;</span><br><span class="line">  FPRegsClass     FPRegsRegClass;</span><br><span class="line">  IntRegsClass    IntRegsRegClass;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> TargetRegisterClass* <span class="type">const</span> IntRegsSubRegClasses [] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> TargetRegisterClass* <span class="type">const</span> IntRegsSuperRegClasses [] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  IntRegsClass::<span class="built_in">IntRegsClass</span>() : <span class="built_in">TargetRegisterClass</span>(IntRegsRegClassID,</span><br><span class="line">                                                     IntRegsVTs, IntRegsSubclasses,</span><br><span class="line">                                                     IntRegsSuperclasses, IntRegsSubRegClasses,</span><br><span class="line">                                                     IntRegsSuperRegClasses, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>,</span><br><span class="line">                                                     IntRegs, IntRegs + <span class="number">32</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寄存器分配会避免使用保留寄存器，被调用函数保存的寄存器在所有可分配寄存器都被使用完之前不会被使用。大多数情况下这都是正常的，但在一些特殊情况下，可能需要手动指定分配顺序。</p><h2 id="4-3-实现一个-TargetRegisterInfo-的子类"><a href="#4-3-实现一个-TargetRegisterInfo-的子类" class="headerlink" title="4.3 实现一个 TargetRegisterInfo 的子类"></a>4.3 实现一个 TargetRegisterInfo 的子类</h2><p>寄存器的这一部分，最后一步是手动编写 XXXRegisterInfo 的代码，这一部分会实现 TargetRegisterInfo.h 中描述的接口。这些函数如果没有被重写（overridden），会返回 0，NULL 或 false。以下列出了一部分 SPARC 后端在 SparcRegisterInfo.cpp 中重写的函数接口：</p><ul><li>getCalleeSavedRegs：该函数返回一个被调用函数保存寄存器的列表，预期被用于调用栈帧偏移。</li><li>getReservedRegs：返回物理寄存器编号的序号列表，表示那些被保留的寄存器。</li><li>hasFP：返回一个布尔型，表示函数具有专用栈帧寄存器。</li><li>eliminateCallFramePseudoInstr：如果调用帧需要设置或销毁伪指令，这个函数会清除它们。</li><li>eliminateFrameIndex：从使用抽象帧索引的指令中清除它们。</li><li>emitPrologue：插入 prologue 代码。</li><li>emitEpilogure：插入 epilogure 代码。</li></ul><blockquote><p>译注：这些函数的具体功能可参见代码</p></blockquote><hr><h1 id="5-指令集"><a href="#5-指令集" class="headerlink" title="5 指令集"></a>5 指令集</h1><p>在代码生成的早期阶段，LLVM IR 格式代码被转换为 SelectionDAG 格式，其中的节点SDNode 包含有目标平台的指令信息。一个 SDNode 具有一个操作码，还有操作数，类型要求和属性，这些属性比如有描述这个节点是可交换的（commutative），或者描述这个节点是一个 load 操作。不同的操作节点类型在 include&#x2F;llvm&#x2F;CodeGen&#x2F;SelectionDAGNodes.h 中描述（NodeType 类型的枚举属于 ISD 命名空间）。</p><p>TableGen 使用以下列出的 td 文件来生成指令定义的代码：</p><ul><li>Target.td：这里定义了主要的基本类型，比如 Instruction, Operand, InstrInfo 等；</li><li>TargetSelectionDAG.td：被 SelectionDAG 指令选择生成器使用，包含有一些 SDTC 开头的类（这些类是 selectionDAG 类型约束），以及定义 SelectionDAG 节点（比如 imm, cond, bb, add, fadd, sub 等），还有 pattern 的基础类支持（比如 Pattern, Pat, PatFrag, PatLeaf, ComplexPattern 等）。</li><li>XXXInstrFormats.td：目标平台相关的指令 pattern 定义。</li><li>XXXInstrInfo.td：目标平台相关的指令模板、条件编码、指令实现等。根据具体的架构区别，这个文件会有不同的命名，比如对于带 SSE 指令的 Pentium 架构，这个文件被命名为 X86InstrSSE.td，对于带 MMX 指令的 Pentium 架构，这个文件为 X86InstrMMX.td。（译注：对于不那么复杂的架构，可以不修改名称）。</li></ul><p>另外还有和平台相关的 XXX.td 文件，该文件包含了其他的各种 td 文件，但其内容与子目标直接相关。</p><p>你应该完成一个精确的特定平台下的 XXXInstrInfo 的类（译注：这里存疑，这个类默认应该是 TableGen 生成的），用来表示目标机器支持的指令。XXXInstrInfo 中包含有一个 XXXInstrDescriptor 的对象数组，每个对象描述一个指令。这个对象中包含有：</p><ul><li>操作编码的标记名称</li><li>操作数的数量</li><li>隐式使用的寄存器和定义的寄存器的列表</li><li>目标无关的属性（如内存操作，是否可替换等）</li><li>目标相关的标记</li></ul><p>Instruction 类（在 Target.td 中定义）经常会被先继承为更复杂的 Instruction 子类，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instruction</span> &#123;</span><br><span class="line">  string Namespace = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dag OutOperandList;    <span class="comment">// 包含有 MI def 操作数列表的 dag 结构</span></span><br><span class="line">  dag InOperandList;     <span class="comment">// 包含有 MI use 操作数列表的 dag 结构</span></span><br><span class="line">  string AsmString = <span class="string">&quot;&quot;</span>; <span class="comment">// 汇编文件中的指令表示</span></span><br><span class="line">  list&lt;dag&gt; Pattern;     <span class="comment">// 这条指令的 dag patter</span></span><br><span class="line">  list&lt;Register&gt; Uses = [];</span><br><span class="line">  list&lt;Register&gt; Defs = [];</span><br><span class="line">  list&lt;Predicate&gt; Predicates = [];  <span class="comment">// 指令选择中的谓词部分</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDNode中包含有平台相关的指令的描述对象，这些指令的定义在 XXXInstrInfo.td 中定义。硬件架构手册中有关于指令对象描述信息的说明（比如对于 SPARC 平台的是 SPARC Architecture Manual）。</p><p>架构手册中一条简单的指令，可能会依赖于操作数的差异，被扩展为多条指令。比如，手册中描述了一条 add 指令，因为 add 指令可能的操作数是寄存器或者立即数，所以在 LLVM 后端平台中会有两个指令，分别是 ADDri 和 ADDrr。</p><p>你应该为没个指令类别定义 class，然后为每个不同的操作码定义子类，同时指定合适的参数（比如固定的编码部分和可变的部分）。另外还需要指定指令中寄存器占用的位是哪些，这些也会被编码，还有指令在输出汇编格式时如何被打印。</p><p>在 SPARC Architecture Manual, Version 8 中，描述了架构主要有三种 32 位格式的指令，第一种格式是 CALL 指令，第二种格式是分支、条件指令以及 SETHI 指令，第三种格式是其他普通指令。</p><p>每一类指令格式都有一个对应的类，在 SparcInstrFormat.td 中定义。InstSP 是其他指令类的基类。其他的基类都是某种特殊格式下的结构：比如 F2_1 被用于 SETHI 指令，F2_2 被用于分支指令。另外还有三个基类：F3_1 被用于寄存器与寄存器的操作，F3_2 被用于寄存器与立即数的操作，F3_3 被用于浮点操作。SparcInstrInfo.td 中同样为合成指令（synthetic instructions）增加了基类（Pseudo）。</p><p>SParcInstrInfo.td 中主要由这些指令和操作数的定义组成。举一个例子，下边代码中，描述了 LDrr 这个指令，它是一个从通过寄存器指定访问的内存中 load 一个 32 位数据到寄存器的指令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def LDrr : F3_1 &lt;<span class="number">3</span>, <span class="number">0b000000</span>, (outs IntRegs:$dst), (ins MEMrr:$addr),</span><br><span class="line">                 <span class="string">&quot;ld [$addr], $dst&quot;</span>,</span><br><span class="line">                 [(set i32:$dst, (load ADDRrr:$addr))]&gt;;</span><br></pre></td></tr></table></figure><p>第一个参数，<code>3（0b11）</code>，表示这个指令所在分类的操作码；第二个指令，<code>0b000000</code>，表示这个指令特殊的操作码。第三个参数，<code>(outs IntRegs:$dst)</code>，是输出位置，在这里是一个寄存器操作数，IntRegs 的定义在寄存器的 td 中；第四个参数，<code>(ins MEMrr:$addr)</code>，是一个地址操作数，MEMrr 在 SparcInstrInfo.td 中靠前的位置定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def MEMrr : Operand&lt;i32&gt; &#123;</span><br><span class="line">  let PrintMethod = <span class="string">&quot;printMemOperand&quot;</span>;</span><br><span class="line">  let MIOperandInfo = (ops IntRegs, IntRegs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五个参数是一个字符串，它表示汇编输出的样式，也可以暂时留空，让汇编输出器（addembly printer）接口来实现。第六个参数，也是最后一个参数，是一个 pattern，这个参数用来在 SelectionDAG 指令选择阶段做指令匹配。参考：<a target="_blank" rel="noopener" href="https://releases.llvm.org/8.0.0/docs/CodeGenerator.html">The LLVM Target-Independent Code Generator</a>，这个参数在下一部分指令选择时再介绍。</p><p>指令类不会根据不同类型的操作数来重载，所以需要根据操作数为不同的寄存器、内存或立即数类型来分别定义指令类。比如，再针对从立即数指定访问的内存中 load 一个 32 位数据到寄存器的指令，LDri ，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def LDri : F3_2 &lt;<span class="number">3</span>, <span class="number">0b000000</span>, (outs IntRegs:$dst), (ins MEMri:$addr),</span><br><span class="line">                 <span class="string">&quot;ld [$addr], $dst&quot;</span>,</span><br><span class="line">                 [(set i32:$dst, (load ADDRri:$addr))]&gt;;</span><br></pre></td></tr></table></figure><p>但是，如果反复的写这些相似的指令，会有大量重复的冗余代码。在 td 文件中，可以通过 multiclass 关键字来同时一次性定义多个指令类（再通过 defm 来同时定义这些指令类的指令）。比如，在 SparcInstrInfo.td 中，F3_12 是个 multiclass，它内部定义了两个指令类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">multiclass F3_12 &lt;string OpcStr, bits&lt;<span class="number">6</span>&gt; Op3Val, SDNode OpNode&gt; &#123;</span><br><span class="line">  def rr : F3_1 &lt;<span class="number">2</span>, Op3Val,</span><br><span class="line">                 (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),</span><br><span class="line">                 !<span class="built_in">strconcat</span>(OpcStr, <span class="string">&quot; $b, $c, $dst&quot;</span>),</span><br><span class="line">                 [(set i32:$dst, (OpNode i32:$b, i32:$c))]&gt;;</span><br><span class="line">  def ri : F3_2 &lt;<span class="number">2</span>, Op3Val,</span><br><span class="line">                 (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),</span><br><span class="line">                 !<span class="built_in">strconcat</span>(OpcStr, <span class="string">&quot; $b, $c, $dst&quot;</span>),</span><br><span class="line">                 [(set i32:$dst, (OpNode i32:$b, simm13:$c))]&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以使用 defm 关键字来同时定义多个指令类，比如 XOR 和 ADD 指令，比如下边代码，定义了 4 条指令，分别是 XORrr, XORri, ADDrr, ADDri：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defm XOR : F3_12&lt;<span class="string">&quot;xor&quot;</span>, <span class="number">0b000011</span>, <span class="keyword">xor</span>&gt;;</span><br><span class="line">defm ADD : F3_12&lt;<span class="string">&quot;add&quot;</span>, <span class="number">0b000000</span>, add&gt;;</span><br></pre></td></tr></table></figure><p>SparcInstrInfo.td 文件同样定义了条件码（condition codes），条件码会在分支指令中作为跳转依据。以下代码定义了 SPARC 中使用的条件码位信息，比如，第 10 位表示整形数大于比较状态，第 22 位表示浮点数大于比较状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def ICC_NE : ICC_VAL&lt; <span class="number">9</span>&gt;; <span class="comment">// 整形不等于</span></span><br><span class="line">def ICC_E  : ICC_VAL&lt; <span class="number">1</span>&gt;; <span class="comment">// 整形等于</span></span><br><span class="line">def ICC_G  : ICC_VAL&lt;<span class="number">10</span>&gt;; <span class="comment">// 整形大于</span></span><br><span class="line">...</span><br><span class="line">def FCC_U  : FCC_VAL&lt;<span class="number">23</span>&gt;; <span class="comment">// 浮点型未排序</span></span><br><span class="line">def FCC_G  : FCC_VAL&lt;<span class="number">22</span>&gt;; <span class="comment">// 浮点型大于</span></span><br><span class="line">def FCC_UG : FCC_VAL&lt;<span class="number">21</span>&gt;; <span class="comment">// 浮点型未排序或大于</span></span><br></pre></td></tr></table></figure><p>注：Sparc.h 中也定义了一些条件码相关的枚举类型，要确保其与这里的类型保持一致，比如 SPCC::ICC_NE &#x3D; 9, SPCC::FCC_U &#x3D; 23。</p><h2 id="5-1-指令操作数映射"><a href="#5-1-指令操作数映射" class="headerlink" title="5.1 指令操作数映射"></a>5.1 指令操作数映射</h2><p>代码生成器后端会映射指令操作数到指令的编码域（field）中。操作数按照定义的顺序分配到指令中未绑定的编码域，而当他们被分配值时会被绑定。比如说，在 Sparc 后端中，定义 XNORrr 指令，它具有 3 个操作数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">XNORrr</span> : F3_1&lt;<span class="number">2</span>, <span class="number">0b000111</span>,</span><br><span class="line">                  (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),</span><br><span class="line">                  <span class="string">&quot;xnor $b, $c, $dst&quot;</span>,</span><br><span class="line">                  [(<span class="built_in">set</span> i32:$dst, (<span class="keyword">not</span> (xor i32:$b, i32:$c)))]&gt;;</span><br></pre></td></tr></table></figure><p>SparcInstrFormats.td 中展示了 F3_1的基类 InstSP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InstSP</span>&lt;dag outs, dag ins, string asmstr, <span class="built_in">list</span>&lt;dag&gt; pattern&gt;</span><br><span class="line">    : Instruction &#123;</span><br><span class="line">  field bits&lt;<span class="number">32</span>&gt; Inst;</span><br><span class="line">  let Namespace = <span class="string">&quot;SP&quot;</span>;</span><br><span class="line">  bits&lt;<span class="number">2</span>&gt; op;</span><br><span class="line">  let Inst&#123;<span class="number">31</span>-<span class="number">30</span>&#125; = op;</span><br><span class="line">  dag OutOperandList = outs;</span><br><span class="line">  dag InOperandList = ins;</span><br><span class="line">  let AsmString = asmstr;</span><br><span class="line">  let Pattern = pattern;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InstSP 中的 op 字段没有绑定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F3</span>&lt;dag outs, dag ins, string asmstr, <span class="built_in">list</span>&lt;dag&gt; pattern&gt;</span><br><span class="line">    : InstSP&lt;outs, ins, asmstr, pattern&gt; &#123;</span><br><span class="line">  bits&lt;<span class="number">5</span>&gt; rd;</span><br><span class="line">  bits&lt;<span class="number">6</span>&gt; op3;</span><br><span class="line">  bits&lt;<span class="number">5</span>&gt; rs1;</span><br><span class="line">  let op&#123;<span class="number">1</span>&#125; = <span class="number">1</span>;</span><br><span class="line">  let Inst&#123;<span class="number">29</span>-<span class="number">25</span>&#125; = rd;    // 目的操作数</span><br><span class="line">  let Inst&#123;<span class="number">24</span>-<span class="number">19</span>&#125; = op3;</span><br><span class="line">  let Inst&#123;<span class="number">18</span>-<span class="number">14</span>&#125; = rs1;   // 第一个源操作数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F3 中对 op 域做了绑定，并且定义了 rd, op3 和 rs1 域。F3 类型格式的指令会绑定 rd, op3 和 rs1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F3_1</span>&lt;bits&lt;<span class="number">2</span>&gt; opVal, bits&lt;<span class="number">6</span>&gt; op3val, dag outs, dag ins,</span><br><span class="line">           string asmstr, <span class="built_in">list</span>&lt;dag&gt; pattern&gt;</span><br><span class="line">    : F3&lt;outs, ins, asmstr, pattern&gt; &#123;</span><br><span class="line">  bits&lt;<span class="number">8</span>&gt; asi = <span class="number">0</span>;</span><br><span class="line">  bits&lt;<span class="number">5</span>&gt; rs2;</span><br><span class="line">  let op = opVal;</span><br><span class="line">  let op3 = op3val;</span><br><span class="line">  let Inst&#123;<span class="number">13</span>&#125; = <span class="number">0</span>;</span><br><span class="line">  let Inst&#123;<span class="number">12</span>-<span class="number">5</span>&#125; = asi;</span><br><span class="line">  let Inst&#123;<span class="number">4</span>-<span class="number">0</span>&#125; = rs2;    // 第二个源操作数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F3_1中绑定了 op3，并定义了 rs2 域。F3_1类型格式的指令会绑定 rd, rs1, rs2。也就是前边 XNORrr 定义时绑定的<code>$dst</code>，<code>$b</code>，和<code>$c</code>操作数，分别对应 rd, rs1, rs2。</p><h3 id="5-1-1-指令操作数命名映射"><a href="#5-1-1-指令操作数命名映射" class="headerlink" title="5.1.1 指令操作数命名映射"></a>5.1.1 指令操作数命名映射</h3><p>TableGen 还会生成一个 getNamedOperandIdx() 的函数，这个函数用来在 MachineInstr 中，以操作数的 TableGen 名字作为输入，查找对应序号。在一个指令的 TableGen 定义中设置 UseNamedOperandTable 位，会将其操作数增加在一个位于 llvm::XXX:OpName 命名空间中的枚举中，另外还会在 OperandMap 表中增加一个针对操作数的入口，从而可以被 getNamedOperandIdx() 引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> DstIndex = SP::<span class="built_in">getNamedOperandIdx</span>(SP::XNORrr, SP::OpName::dst);  <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="type">int</span> BIndex = SP::<span class="built_in">getNamedOperandIdx</span>(SP::XNORrr, SP::OpName::b);      <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="type">int</span> CIndex = SP::<span class="built_in">getNamedOperandIdx</span>(SP::XNORrr, SP::OpName::c);      <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="type">int</span> DIndex = SP::<span class="built_in">getNamedOperandIdx</span>(SP::XNORrr, SP::OpName::d);      <span class="comment">// =&gt; -1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 OpName 枚举中的入口根据 TableGen 中的定义依次设定，所以小写的操作数就会有小写的入口名。</p><p>为了将这个 getNamedOperandIdx() 函数增加到你的后端中使用，你需要在 XXXInstrInfo.cpp 和 XXXInstrInfo.h 中定义一些预处理宏：</p><p>XXXInstrInfo.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_INSTRINFO_NAMED_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XXXGenInstrInfo.inc&quot;</span></span></span><br></pre></td></tr></table></figure><p>XXXInstrInfo.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_INSTRINFO_OPERAND_ENUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XXXGenInstrInfo.inc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> XXX &#123;</span><br><span class="line">  <span class="function"><span class="type">int16_t</span> <span class="title">getNamedOperandIdx</span><span class="params">(<span class="type">uint16_t</span> Opcode, <span class="type">uint16_t</span> NamedIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-指令操作数类型"><a href="#5-1-2-指令操作数类型" class="headerlink" title="5.1.2 指令操作数类型"></a>5.1.2 指令操作数类型</h3><p>TableGen 还会生成一个枚举结构，其中包括了所有后端定义的已命名操作数类型，所在的命名空间是 llvm::XXX::OpTypes。一些通用的立即数类型（比如 i8, i32, i64, f32, f64）被定义在统一的 include&#x2F;llvm&#x2F;Target&#x2F;Target.td 文件中，对每个后端的OpTypes 枚举都可用。同时，枚举中仅仅包含已命名的操作数类型，匿名类型会被忽略。比如，X86 后端中定义了 brtarget 和 brtarget8，这两个操作数类型是 Operand 类的实例化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">brtarget</span> : Operand&lt;OtherVT&gt;;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">brtarget8</span> : Operand&lt;OtherVT&gt;;</span><br></pre></td></tr></table></figure><p>那么，在枚举结构中是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X86 &#123;</span><br><span class="line"><span class="keyword">namespace</span> OpTypes &#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OperandType</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  brtarget,</span><br><span class="line">  brtarget8,</span><br><span class="line">  ...</span><br><span class="line">  i32imm,</span><br><span class="line">  i64imm,</span><br><span class="line">  ...</span><br><span class="line">  OPERAND_TYPE_LIST_END</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能使用这个枚举结构，你需要定义一个预处理宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_INSTRINFO_OPERAND_TYPES_ENUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;XXXGenInstrInfo.inc&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="5-2-指令调度"><a href="#5-2-指令调度" class="headerlink" title="5.2 指令调度"></a>5.2 指令调度</h2><p>可以通过 MCDesc::getSchedClass() 方法来查看指令行程（itinerary）。对应的值在 TableGen 生成的 XXXGenInstrInfo.inc 中定义为枚举结构，所在的命名空间是 llvm::XXX::Sched。调度类的名字等同于 XXXSchedule.td 中的定义。</p><p>调度模型由 TableGen 中的 SubtargetEmitter 使用 CodeGenSchedModels 类来生成。这与机器平台资源使用的行程方法不同。utils&#x2F;schedcover.py 这个工具可以用来决定哪些指令可以被调度模型所涉及（covered）。第一步是使用以下指令来生成输出文件，然后调用 schedcover.py 来处理输出文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ &lt;src&gt;/utils/schedcover.py &lt;build&gt;/lib/Target/AArch64/tblGenSubtarget.with</span><br><span class="line">instruction, default, CortexA53Model, CortexA57Model, CycloneModel, ExynosM3Model, FalkorModel, KryoModel, ThunderX2T99Model, ThunderXT8XModel</span><br><span class="line">ABSv16i8, WriteV, , , CyWriteV3, M3WriteNMISC1, FalkorWr_2VXVY_2cyc, KryoWrite_2cyc_XY_XY_150ln, ,</span><br><span class="line">ABSv1i64, WriteV, , , CyWriteV3, M3WriteNMISC1, FalkorWr_1VXVY_2cyc, KryoWrite_2cyc_XY_noRSV_67ln, ,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为了获取生成调度模型的调试输出信息，使用以下命令（指定 target 路径并设定 subtarget-emitter debug 选项）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ &lt;build&gt;/bin/llvm-tblgen -debug-only=subtarget-emitter -gen-subtarget \</span><br><span class="line">  -I &lt;src&gt;/lib/Target/&lt;target&gt; -I &lt;src&gt;/include \</span><br><span class="line">  -I &lt;src&gt;/lib/Target/&lt;src&gt;/lib/Target/&lt;target&gt;/&lt;target&gt;.td \</span><br><span class="line">  -o &lt;build&gt;/lib/Target/&lt;target&gt;/&lt;target&gt;GenSubtargetInfo.inc.tmp \</span><br><span class="line">  &gt; tblGenSubtarget.dbg 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>其中 build 是构建目录， src 是源码目录， target 是目标名称。可以在构建中捕获 TableGen 命令，通过在以下命令的输出中搜索 llvm-tblgen 的输出内容，从而再次检查以上命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ VERBOSE=1 make ...</span><br></pre></td></tr></table></figure><h2 id="5-3-指令相关映射"><a href="#5-3-指令相关映射" class="headerlink" title="5.3 指令相关映射"></a>5.3 指令相关映射</h2><p>这个 TableGen 特性被用于相关的指令间。当你有多个指令格式需要在指令选择之后互相转换，那么可以使用这个特性。这个特性受 XXXInstrInfo.td 文件中目标相关指令的相关模型（relation models）的驱动。相关模型使用 InstrMapping 类作为基类。TableGen 解析所有的相关模型，并使用确定的信息生成指令的相关映射。相关映射和能够调用它们的函数一起被发射到 XXXGenInstrInfo.td 文件中。更多关于这个特性的信息，请参考：<a target="_blank" rel="noopener" href="https://releases.llvm.org/8.0.0/docs/HowToUseInstrMappings.html">How To Use Instruction Mappings</a></p><h2 id="5-4-实现一个-TargetInstrInfo-的子类"><a href="#5-4-实现一个-TargetInstrInfo-的子类" class="headerlink" title="5.4 实现一个 TargetInstrInfo 的子类"></a>5.4 实现一个 TargetInstrInfo 的子类</h2><p>最后一步是在 XXXInstrInfo 中硬编码一些代码，来实现 TargetInstrInfo.h 中的接口描述。这些函数除非被重写，否则均返回 0 或布尔类型，又或者直接 assert。以下是被 SPARC 后端重写实现的函数的列表，定义在 SparcInstrInfo.cpp 中：</p><ul><li>isLoadFromStackSlot：如果某个指令是从栈槽中直接 load，则返回目的寄存器的值和栈槽的栈帧下标。</li><li>isStoreToStackSlot：如果某个指令是直接 store 入栈槽，则返回目的寄存器的值和栈槽的栈帧下标。</li><li>copyPhysReg：在一对物理寄存器之间复制值。</li><li>storeRegToStackSlot：将一个寄存器值 store 入栈槽。</li><li>loadRegFromStackSlot：从栈槽中 load 值到一个寄存器。</li><li>storeRegToAddr：将一个寄存器值 store 入内存。</li><li>loadRegFromAddr：从内存中 load 值到一个寄存器。</li><li>foldMemoryOperand：尝试合并特殊操作数的一些 load 和 store 指令。</li></ul><h2 id="5-5-分支折叠和-If-约定"><a href="#5-5-分支折叠和-If-约定" class="headerlink" title="5.5 分支折叠和 If 约定"></a>5.5 分支折叠和 If 约定</h2><p>将指令合并或者消除不可达指令可以提高程序性能。在 XXXInstrInfo 中的 AnalyzeBranch 方法可以实现测试分支条件指令，并移除无效指令。它从一个机器基本块（MBB, machine basic block）的末尾开始查找可能的性能提升方式，比如分支折叠和 If 约定。BranchFolder 和 IfConverter 方法（位于 lib&#x2F;CodeGen 路径下的 BranchFolding.cpp 和 IfConversion.cpp 文件中）调用 AnalyzeBranch 方法来优化表示这些指令的控制流图结构。</p><p>可以使用 AnalyzeBranch 的多种实现（ARM, Alpha, X86）来作为你自己的 AnalyzeBranch 实现。SPARC 没有实现一个能用的 AnalyzeBranch，所以使用 ARM 的实现，描述如下。</p><p>AnalyzeBranch 返回一个布尔类型值，并有 4 个参数：</p><ul><li><code>MachineBasicBlock &amp;MBB</code>：输入要检查的 MBB 块；</li><li><code>MachineBasicBlock *&amp;TBB</code>：将会返回的 MBB 块，对于一个条件分支，TBB 返回为真的块；</li><li><code>MachineBasicBlock *&amp;FBB</code>：和 TBB 类似，FBB 返回为假的块；</li><li><code>std::vector &amp;Cond</code>：评估条件分支中条件的操作数列表；</li></ul><p>在以下简单的例子中，如果一个块到结束时没有分支，它就会传递到下一个块，TBB 和 FBB 不会被特殊指定，均返回 NULL。AnalyzeBranch（ARM 版本）的开头如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ARMInstrInfo::AnalyzeBranch</span><span class="params">(MachineBasicBlock &amp;MBB,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 MachineBasicBlock *&amp;TBB,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 MachineBasicBlock *&amp;FBB,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 std::vector&lt;MachineOperand&gt; &amp;Cond)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MachineBasicBlock::iterator I = MBB.<span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">if</span> (I == MBB.<span class="built_in">begin</span>() || !<span class="built_in">isUnpredicatedTerminator</span>(--I))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果一个块的结尾是一个非条件分支指令，那么 AnalyzeBranch 会返回这个分支跳转的块到 TBB 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LastOpc == ARM::B || LastOpc == ARM::tB) &#123;</span><br><span class="line">  TBB = LastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>).<span class="built_in">getMBB</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个块的结尾有两个非条件分支指令，那么第二个分支就是不可达的。这种情况下，会移除第二个分支指令，并将跳转的块返回到 TBB 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((SecondLastOpc == ARM::B || SecondLastOpc == ARM::tB) &amp;&amp;</span><br><span class="line">    (LastOpc == ARM::B || LastOpc == ARM::tB)) &#123;</span><br><span class="line">  TBB = SecondLastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>).<span class="built_in">getMBB</span>();</span><br><span class="line">  I = LastInst;</span><br><span class="line">  I-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个块的结尾有一条条件分支指令且条件值为 false，则会被传递到下一个后继块。AnalyzeBranch 将分支跳转的块范湖到 TBB，并且将操作数返回到 Cond。（译注：这里有点怪怪的，没太看懂）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LastOpc == ARM::Bcc || LastOpc == ARM::tBcc) &#123;</span><br><span class="line">  TBB = LastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>).<span class="built_in">getMBB</span>();</span><br><span class="line">  Cond.<span class="built_in">push_back</span>(LastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>));</span><br><span class="line">  Cond.<span class="built_in">push_back</span>(LastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个块的结尾包含一个条件分支和一个确定的非条件分支指令，AnalyzeBranch 会将条件分支条件为 true 的跳转块放到 TBB 中返回，将非条件分支跳转的块（也就是条件分支为 false 时会跳转的块）放到 FBB 中返回。条件分支的操作数放到 Cond 参数返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> SecondLastOpc = SecondLastInst-&gt;<span class="built_in">getOpcode</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((SecondLastOpc == ARM::Bcc &amp;&amp; LastOpc == ARM::B) ||</span><br><span class="line">    (SecondLastOpc == ARM::tBcc &amp;&amp; LastOpc == ARM::tB)) &#123;</span><br><span class="line">  TBB = SecondLastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>).<span class="built_in">getMBB</span>();</span><br><span class="line">  Cond.<span class="built_in">push_back</span>(SecondLastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>));</span><br><span class="line">  Cond.<span class="built_in">push_back</span>(SecondLastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">2</span>));</span><br><span class="line">  FBB = LastInst-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>).<span class="built_in">getMBB</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最后两种情况（结束是一条条件分支或一条条件分支和一条非条件分支），Cond 返回的操作数可以传递给其他指令的方法，来创建新的分支或其他操作。AnalyzeBranch 需要辅助函数 RemoveBranch 和 InstrBranch 来处理一些操作。</p><p>AnalyzeBranch 中，当处理正确时，返回 false（译注：LLVM 中很多函数都是这样的），仅仅当遇到无法处理的情况时，比如块结束时有 3 个终止符或遇到无法处理的终止符时 ，会返回 true。</p><hr><h1 id="6-指令选择"><a href="#6-指令选择" class="headerlink" title="6 指令选择"></a>6 指令选择</h1><p>LLVM 使用 SelectionDAG 来表示 LLVM IR 指令，故而 SelectionDAG 的节点应当用来表示原生的目标指令。在代码生成时，指令选择阶段将非目标相关的 DAG 节点描述的指令转换为目标相关的原生指令。这一部分代码在 XXXISelDAGToDAG.cpp 中描述，通过模式匹配来完成从 DAG 到 DAG 的指令选择工作。另外可选的是，可以定义个阶段（pass）来实现分支指令的类似 DAG 到 DAG 的指令选择工作（在 XXXBranchSelector.cpp 中描述）。之后，由 XXXISelLowering.cpp 中的代码来替换或删除不支持的操作和数据类型（也就是合法化）。</p><p>TableGen 为指令选择生成的代码主要在以下的 td 文件中描述：</p><ul><li>XXXInstrInfo.td：包括目标相关指令的定义，会被生成 XXXGenDAGISel.inc，而这个 inc 被 XXXISELDAGToDAG.cpp 使用；</li><li>XXXCallingConv.td：包括目标架构支持的调用和返回值约定描述，会被生成 XXXGenCallingConv.inc，这个 inc 被 XXXISelLowering.cpp 使用；</li></ul><p>（译注：以上列表中的描述实际上不是必然的，你可以在任意 C++ 源代码中引用这些 inc 文件）</p><p>指令选择阶段的实现必须包括一个头文件，声明 FunctionPass 类或者其子类。在 XXXTargetMachine.cpp 中，需要使用 PassManager 将当前的指令选择加入当阶段序列（queue of passes）中。</p><p>LLVM 的静态编译器（llc）是一个可视化 DAG 内容非常棒的工具。使用 llc 加上特殊的命令行参数，就可以显示在不同阶段 SelectionDAG 的状态。具体描述参考：<a target="_blank" rel="noopener" href="https://releases.llvm.org/8.0.0/docs/CodeGenerator.html#selectiondag-process">SelectionDAG Instruction Selection Process</a>。</p><p>为了描述指令选择器的行为，你需要为 lowering LLVM 代码 到 SelectionDAG 而指定 pattern。pattern 放在 XXXInstrInfo.td 文件中指令定义的最后一个参数中（译注：不是绝对的，参见具体后端）。比如，在 SparcInstrInfo.td 中，定义寄存器 store 操作的指令，最后一个参数描述了 pattern。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">STrr</span> : F3_1&lt;<span class="number">3</span>, <span class="number">0b000100</span>, (outs), (ins MEMrr:$addr, IntRegs:$src),</span><br><span class="line">                <span class="string">&quot;st $src, [$addr]&quot;</span>, [(store i32:$src, ADDRrr:$addr)]&gt;;</span><br></pre></td></tr></table></figure><p>其中 ADDRrr 是一个 memory mode，也在这个文件中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ADDRrr</span> : ComplexPattern&lt;i32, <span class="number">2</span>, <span class="string">&quot;SelectADDRrr&quot;</span>, [], []&gt;;</span><br></pre></td></tr></table></figure><p>ADDRrr 的定义依赖自 SelectADDRrr，后者是一个定义在指令选择器中的函数（比如定义在 SparcISelDAGToDAG.cpp 中）。</p><p>在 lib&#x2F;Target&#x2F;TargetSelectionDAG.td 文件（注，最新的工程中，这个文件位于 include&#x2F;llvm&#x2F;Target&#x2F;TargetSelectionDAG.td，包括下边的定义，也已更新，这里不做修改）中，DAG 的操作符 store 定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store</span> : PatFrag&lt;(ops node:$val, node:$ptr),</span><br><span class="line">                    (st node:$val, node:$ptr), [&#123;</span><br><span class="line">                      <span class="keyword">if</span> (StoreSDNode *ST = dyn_cast&lt;StoreSDNode&gt;(N))</span><br><span class="line">                        <span class="keyword">return</span> !ST-&gt;isTruncatingStore() &amp;&amp;</span><br><span class="line">                               ST-&gt;getAddressingMode() == ISD::UNINDEXED;</span><br><span class="line">                      <span class="keyword">return</span> false;</span><br><span class="line">                    &#125;]&gt;;</span><br></pre></td></tr></table></figure><p>XXXInstrInfo.td 也生成 SelectCode 方法 （位于 XXXGenDAGISel.inc），这个方法被用来在为指令匹配合适的处理方法时被调用。在上边的例子中，SelectionCode 调用 Select_ISD_STORE 来处理 ISD::STORE 操作码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDNode *<span class="title">SelectCode</span><span class="params">(SDValue N)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  MVT::ValueType NVT = N.<span class="built_in">getNode</span>()-&gt;<span class="built_in">getValueType</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">switch</span> (N.<span class="built_in">getOpcode</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ISD::STORE: &#123;</span><br><span class="line">            <span class="keyword">switch</span> (NVT) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Select_ISD_STORE</span>(N);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STrr 的 pattern 被匹配后，会在 XXXGenDAGISel.inc 中为 Select_ISD_STORE 创建处理 STrr 的代码，该文件内也会生成 Emit_22 方法，来配合完成选择过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDNode *<span class="title">Select_ISD_STORE</span><span class="params">(<span class="type">const</span> SDValue &amp;N)</span> </span>&#123;</span><br><span class="line">  SDValue Chain = N.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Predicate_store</span>(N.<span class="built_in">getNode</span>())) &#123;</span><br><span class="line">    SDValue N1 = N.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">    SDValue N2 = N.<span class="built_in">getOperand</span>(<span class="number">2</span>);</span><br><span class="line">    SDValue CPTmp0;</span><br><span class="line">    SDValue CPTmp1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pattern: (st:void i32:i32:$src,</span></span><br><span class="line">    <span class="comment">//           ADDRrr:i32:$addr)&lt;&lt;P:Predicate_store&gt;&gt;</span></span><br><span class="line">    <span class="comment">// Emits: (STrr:void ADDRrr:i32:$addr, IntRegs:i32:$src)</span></span><br><span class="line">    <span class="comment">// Pattern complexity = 13  cost = 1  size = 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SelectADDRrr</span>(N, N2, CPTmp0, CPTmp1) &amp;&amp;</span><br><span class="line">        N<span class="number">1.</span><span class="built_in">getNode</span>()-&gt;<span class="built_in">getValueType</span>(<span class="number">0</span>) == MVT::i32 &amp;&amp;</span><br><span class="line">        N<span class="number">2.</span><span class="built_in">getNode</span>()-&gt;<span class="built_in">getValueType</span>(<span class="number">0</span>) == MVT::i32) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Emit_22</span>(N, SP::STrr, CPTmp0, CPTmp1);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="6-1-SelectionDAG合法化阶段"><a href="#6-1-SelectionDAG合法化阶段" class="headerlink" title="6.1 SelectionDAG合法化阶段"></a>6.1 SelectionDAG合法化阶段</h2><p>合法化阶段用于将DAG转换为使用目标本身支持的类型和操作。你需要在 XXXTargetLowering 中增加实现代码，从而将原生不支持的类型和操作转换为支持的对应类型和操作。</p><p>XXXTargetLowering 类的构造函数中，首先使用了 addRegisterClass 方法来指定哪些类型是支持的、哪些寄存器类与之相配合。寄存器类代码的设计是 TableGen 使用 XXXRegisterInfo.td 文件生成的，生成文件是 XXXGenRegisterInfo.h.inc。比如，SparcTargetLowering 类的构造函数开头代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addRegisterClass</span>(MVT::i32, SP::IntRegsRegisterClass);</span><br><span class="line"><span class="built_in">addRegisterClass</span>(MVT::f32, SP::FPRegsRegisterClass);</span><br><span class="line"><span class="built_in">addRegisterClass</span>(MVT::f64, SP::DFPRegsRegisterClass);</span><br></pre></td></tr></table></figure><p>你可以到 ISD 命名空间中检查节点类型（位于 include&#x2F;llvm&#x2F;CodeGen&#x2F;SelectionDAGNodes.h），并判断目标原生支持的类型有哪些。对于原生不支持的操作，需要在 XXXTargetLowering 类中的构造函数中增加回调函数，进而指令选择阶段知道根据这种情况来特殊处理。TargetLowering 类的回调函数有如下一些：（在 llvm&#x2F;Target&#x2F;TargetLowering.h 中声明，译注：这个位置也发生了变更）</p><ul><li>setOperationAction：通用操作</li><li>setLoadExtAction：Load 扩展操作</li><li>setTruncStoreAction：截断 Store 操作</li><li>setIndexedLoadAction：序列 Load （Indexed Load）</li><li>setIndexedStoreAction：序列 Store （Indexed Store）</li><li>setConvertAction：类型转换操作</li><li>setCondCodeAction：条件码相关</li></ul><p>注：旧一些的版本中，使用 setLoadXAction 代替 setLoadExtAction，并且 setCondCodeAction 可能不支持。请自己检查自己的 LLVM 版本是否支持这些操作。</p><p>这些回调函数用来决定一个操作在特定类型下如何做，所有的 case 中，第三个参数是一个 LegalAction 类型，这是一个枚举，包括枚举值：Promote, Expand, Custom, Legal（译注：还有个 LibCall）。在SparcISelLowering.cpp 中包含了全部的情况。</p><h3 id="6-1-1-Promote"><a href="#6-1-1-Promote" class="headerlink" title="6.1.1 Promote"></a>6.1.1 Promote</h3><p>可以将一个原生不支持的类型 Promote 到一个更大的但支持的类型。比如，SPARC 不支持符号扩展的布尔型（i1 type），所以在 SparcISelLowering.cpp 中，以下代码，指定在 load 之前，使用 Promote 将 i1 type 转为更大的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setLoadExtAction</span>(ISD::SEXTLOAD, MVT::i1, Promote);</span><br></pre></td></tr></table></figure><h3 id="6-1-2-Expand"><a href="#6-1-2-Expand" class="headerlink" title="6.1.2 Expand"></a>6.1.2 Expand</h3><p>可以将一个原生不支持的类型 Expand，而不是 Promote，使用其他操作的组合来实现功能。比如，SPARC 中浮点的正弦和余弦运算可以通过展开成多个指令完成，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setOperationAction</span>(ISD::FSIN, MVT::f32, Expand);</span><br><span class="line"><span class="built_in">setOperationAction</span>(ISD::FCOS, MVT::f32, Expand);</span><br></pre></td></tr></table></figure><h3 id="6-1-3-Custom"><a href="#6-1-3-Custom" class="headerlink" title="6.1.3 Custom"></a>6.1.3 Custom</h3><p>对于一些操作，简单的类型 Promote 或类型 Expand 可能不适用。这是，就需要实现一些特殊的 intrinsic 函数。</p><p>比如，如果一个常数需要做特殊处理，或者一个操作需要 spill 和 restore 寄存器到栈，需要寄存器分配器协助。</p><p>在 SparcISelLowering.cpp 中，如下代码，展示了一个从浮点到有符号整型的类型转换，首先调用setOperationAction 并指定 Custom 值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setOperationAction</span>(ISD::FP_TO_SINT, MVT::i32, Custom);</span><br></pre></td></tr></table></figure><p>然后，在LowerOperation 方法中，对于每个 Custom操作，对应一个条件 case。代码如下，会调用到 LowerFP_TO_SINT 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDValue <span class="title">SparcTargetLowering::LowerOperation</span><span class="params">(SDValue Op, SelectionDAG &amp;DAG)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(Op.<span class="built_in">getOpcode</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISD::FP_TO_SINT: <span class="keyword">return</span> <span class="built_in">LowerFP_TO_SINT</span>(Op, DAG);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，这个 LowerFP_TO_SINT 需要被实现，实现代码大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SDValue <span class="title">LowerFP_TO_SINT</span><span class="params">(SDValue Op, SelectionDAG &amp;DAG)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(Op.<span class="built_in">getValueType</span>() == MVT::i32);</span><br><span class="line">    Op = DAG.<span class="built_in">getNode</span>(SPISD::FTOI, MVT::f32, Op.<span class="built_in">getOperand</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> DAG.<span class="built_in">getNode</span>(ISD::BITCAST, MVT::i32, Op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-4-Legal"><a href="#6-1-4-Legal" class="headerlink" title="6.1.4 Legal"></a>6.1.4 Legal</h3><p>Legal 这个枚举值只是表示一种操作是原生支持的，是默认的情况，所以其很少被使用。在 SparcISelLowering.cpp 中，CTPOP 这个操作（计算一个整型值中位为1的数量）只在 SPARC V9 中原生支持。接下来的代码表示在非 V9 的其他 SPARC 平台上通过 Expand 来实现这个操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setOperationAction</span>(ISD::CTPOP, MVT::i32, Expand);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (TM.<span class="built_in">getSubtarget</span>&lt;SparcSubtarget&gt;().<span class="built_in">isV9</span>())</span><br><span class="line">    <span class="built_in">setOperationAction</span>(ISD::CTPOP, MVT::i32, Legal);   <span class="comment">// 如果是 V9 那么就原生支持</span></span><br></pre></td></tr></table></figure><h2 id="6-2-调用约定"><a href="#6-2-调用约定" class="headerlink" title="6.2 调用约定"></a>6.2 调用约定</h2><p>为了能够支持目标相关的调用约定，XXXCallingConv.td （译注，原文为XXXGenCallingConv.td应有误，已修正）文件中调用了一些在 lib&#x2F;Target&#x2F;TargetCallingConv.td （更新位于 include&#x2F;llvm&#x2F;CodeGen 中）文件内定义的接口，比如 CCIfType 和 CCAssignToReg。TableGen 使用 XXXCallingConv.td 来生成 XXXGenCallingConv.inc 文件，这个文件被 XXXISelLowering.cpp 文件所包含与使用。在 TargetCallingConv.td 中有一些接口功能有：</p><ul><li>参数分配的顺序</li><li>参数和返回值的存放位置（栈或寄存器）</li><li>哪些寄存器用来分配</li><li>调用方还是被调用方展开栈。</li></ul><p>以下的例子展示了使用 CCIfType 和 CCAssignToReg 接口。如果 CCIfType 值为 true （这表示当前的参数是 f32 或 f64），进而会触发动作。当前的处理情况是使用 CCAssignToReg 将参数的值分配给靠前的未分配的寄存器，比如 R0 或 R1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CCIfType&lt;f32, f64], CCAssignToReg&lt;[R0, R1]&gt;&gt;</span><br></pre></td></tr></table></figure><p>在 SparcCallingConv.td 文件中包含有目标相关的返回值调用约定的描述（RetCC_Sparc32）以及一个通用的C标准调用约定的描述（CC_Sparc32）。前者的定义如下，它指示了哪些寄存器被用作特殊的标量返回类型。包括单精度浮点型将返回值到寄存器 F0，双精度浮点型会返回值到寄存器 D0，而32位整型会返回到寄存器 I0 或 I1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RetCC_Sparc32</span> : CallingConv&lt;[</span><br><span class="line">    CCIfType&lt;[i32], CCAssignToReg&lt;[I0, I1]&gt;&gt;,</span><br><span class="line">    CCIfType&lt;[f32], CCAssignToReg&lt;[F0]&gt;&gt;,</span><br><span class="line">    CCIfType&lt;[f64], CCAssignToReg&lt;[D0]&gt;&gt;</span><br><span class="line">]&gt;;</span><br></pre></td></tr></table></figure><p>而 CCIfCC 这个接口尝试将给定的名称与当前调用约定做匹配，如果名称匹配当前的调用约定，这调用指定的操作。下边是 X86的例子 （位于 X86CallingConv.td ），如果使用了 Fast 调用约定，则 RetCC_X86_32_Fast 将会被调用。 如果使用 SSECall 调用约定，则 RetCC_X86_32_SSE 将会被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RetCC_X86_32</span> : CallingConv&lt;[</span><br><span class="line">    CCIfCC&lt;<span class="string">&quot;CallingConv::Fast&quot;</span>, CCDelegateTo&lt;RetCC_X86_32_Fast&gt;&gt;,</span><br><span class="line">    CCIfCC&lt;<span class="string">&quot;CallingConv::X86_SSECall&quot;</span>, CCDelegateTo&lt;RetCC_X86_32_SSE&gt;&gt;,</span><br><span class="line">    CCDelegateTo&lt;RetCC_X86_32_C&gt;</span><br><span class="line">]&gt;;</span><br></pre></td></tr></table></figure><p>其他的一些类似的接口还有：</p><ul><li>CCIf ：如果匹配 predicate，执行动作。</li><li>CCIfInReg &lt; action&gt;：如果参数被标记为 inreg 属性，执行动作。</li><li>CCIfNest &lt; action&gt;：如果参数被标记为 nest 属性，执行动作。</li><li>CCIfNotVarArg &lt; action&gt;：如果当前函数没有可变长参数表，执行动作。</li><li>CCAssignToRegWithShadow ：和 CCAssignToReg 类似，但是还包括一个寄存器的 shadow 列表。</li><li>CCPassByVal ：以指定最小的 size 和 align 向栈槽赋值。</li><li>CallingConv &lt;[action]&gt;：为每一个支持的调用约定做定义。</li></ul><p>（译注：以上这些接口我都没遇到过，所以不好做解释）</p><hr><h1 id="7-汇编输出"><a href="#7-汇编输出" class="headerlink" title="7 汇编输出"></a>7 汇编输出</h1><p>在 code emission 阶段，代码生成器可能需要使用一个 LLVM 的 pass 来处理汇编输出工作（汇编的输出是可选的）。你需要实现 assemble printer 的代码，将 LLVM IR 转换成 GAS 的汇编格式，主要步骤有：</p><ul><li>定义你的目标平台支持的所有汇编语法字符串，将他们与 XXXInstrInfo.td 中的指令定义相对应。TableGen 将会为你生成这些映射 （XXXGenAsmWriter.inc 文件），实现了一个 位于 XXXAsmPrinter 类的 printInstruction 成员函数。</li><li>编写 XXXTargetAsmInfo.h 文件，包含了 XXXTargetAsmInfo 类的最基本声明信息，这个类是 TargetAsmInfo 的子类。</li><li>编写 XXXTargetAsmInfo.cpp 文件，包含了目标相关的 TargetAsmInfo 的属性信息和一些方法的实现。</li><li>编写 XXXAsmPrinter.cpp 文件，实现 AsmPrinter 类，完成转换的主要代码。</li></ul><p>在 XXXTargetAsmInfo.h 文件对 XXXTargetAsmInfo.cpp 通常不怎么重要，并且其实 XXXTargetAsmInfo.cpp 中也只有一小部分声明来覆盖父类 TargetAsmInfo.cpp 中的一些属性，比如在 SparcTargetAsmInfo.cpp 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SparcTargetAsmInfo::<span class="built_in">SparcTargetAsmInfo</span>(<span class="type">const</span> SparcTargetMachine &amp;TM) &#123;</span><br><span class="line">  Data16bitsDirective = <span class="string">&quot;\t.half\t&quot;</span>;</span><br><span class="line">  Data32bitsDirective = <span class="string">&quot;\t.word\t&quot;</span>;</span><br><span class="line">  Data64bitsDirective = <span class="number">0</span>;     <span class="comment">// .xword is only supported by v9.</span></span><br><span class="line">  ZeroDirective = <span class="string">&quot;\t.skip\t&quot;</span>;</span><br><span class="line">  CommentString = <span class="string">&quot;!&quot;</span>;</span><br><span class="line">  ConstantPoolSection = <span class="string">&quot;\t.section \&quot;.rodata\&quot;.#alloc\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 X86 的汇编输出实现（X86TargetAsmInfo）中，覆盖了默认的 ExpandInlineAsm 方法。</p><p>目标相关的 AsmPrinter 的实现位于 XXXAsmPrinter.cpp 中，定义了 AsmPrinter 类来完成转换工作。必须包含下列头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/CodeGen/AsmPrinter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/COdeGen/MachineFunctionPass.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>MachineFunctionPass 是 FunctionPass 的子类，AsmPrinter 被注册为一个 MachineFunctionPass，它会首先调用 doInitialization 来设置 AsmPrinter。在 SparcAsmPrinter 中，一个 Mangler 对象被实例化来处理变量名。</p><p>在 XXXAsmPrinter.cpp 中，必须实现 runOnMachineFunction 方法（在 MachineFunctionPass 中声明），在MachineFunctionPass 方法中，runOnFunction 方法调用了 runOnMachineFunction。目标相关的信息主要在 runOnMachineFunction 中有差别，通常会调用这些函数：</p><ul><li>调用 SetupMachineFunction 来初始化。</li><li>调用 EmitConstantPool 来输出 spill 到内存的常量。</li><li>调用 EmitJumpTableInfo 来输出当前函数的跳转表。</li><li>输出当前函数的标签（Label）。</li><li>输出当前函数的代码内容，包括基本块的标签和里边的汇编指令（使用 printInstruction 实现）。</li></ul><p>在 XXXAsmPrinter 中还需要使用 XXXGenAsmWriter.inc 中的函数，后者中包含了 printInstruction 的实现，该函数会调用以下函数：</p><ul><li>printOperand</li><li>printMemOperand</li><li>printCCOperand</li><li>printDataDirective</li><li>printDeclare</li><li>printImplilcitDef</li><li>printInlineAsm</li></ul><p>这些函数的实现在 AsmPrinter.cpp 中，通常来说都是可以直接适用的，不需要子类 XXXAsmPrinter 覆盖。</p><p>printOperand 方法中有个非常长的 switch&#x2F;case 结构来匹配不同类型的操作数：寄存器、立即数、基本块、外部符号、全局地址、常量池索引、跳转表索引。而对于包含内存操作数的指令，会使用 printMemOperand 方法来生成合适的汇编输出形式。同理，像 printCCOperand 函数会输出合理的条件码操作数。</p><p>doFinalization 函数会在 XXXAsmPrinter 中覆盖定义，将会在 assembly printer 完成工作后被调用。在 doFinalization 内，全局符号和常量将会被输出。</p><hr><h1 id="8-子目标平台支持"><a href="#8-子目标平台支持" class="headerlink" title="8 子目标平台支持"></a>8 子目标平台支持</h1><p>Subtarget（以下翻译成 子目标平台）被用于在对某种给定的芯片型号所对应的指令集进行代码生成使用。比如，LLVM 的 SPARC 实现中包括有 3 种主要的 SPARC 微处理器架构版本：Version 8 （V8，32 位架构），Version 9 （V9，64 位架构）以及 UltraSPARC 架构。V8 有 16 位双精度浮点寄存器，也可以被用作 32 位的单精度浮点或 8 位的四精度浮点寄存器。V8 是大端架构。V9 有 32 位双精度浮点寄存器，也可以被用作 16 位的四精度浮点寄存器，但是不能被用作单精度浮点寄存器。UltraSPARC 架构在 V9 的指令集上做了扩展。</p><p>如果需要子目标平台，你应该实现一个目标相关的 XXXSubtarget 的类，通过命令行参数 -mcpu&#x3D; 和 -mattr&#x3D; 可以访问到这个类的功能。</p><p>TableGen 使用 Target.td 和 Sparc.td 中的内容来生成 SparcGenSubtarget.inc 文件。在 Target.td 中，定义了 SubtargetFeature 接口，如下边代码。前 4 个 string 参数是特征名称、属性集、属性的值和特性的描述，第五个参数是一个隐含属性的列表，默认是空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubtargetFeature</span>&lt;string n, string a, string v, string d, </span><br><span class="line">                       <span class="built_in">list</span>&lt;SubtargetFeature&gt; i = []&gt; &#123;</span><br><span class="line">  string Name = n;</span><br><span class="line">  string Attribute = a;</span><br><span class="line">  string Value = v;</span><br><span class="line">  string Desc = d;</span><br><span class="line">  <span class="built_in">list</span>&lt;SubtargetFeature&gt; Implies = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Sparc.td 文件中，使用 SubtargetFeature 定义了一些类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FeatureV9</span> : SubtargetFeature&lt;<span class="string">&quot;v9&quot;</span>, <span class="string">&quot;IsV9&quot;</span>, <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;Enable SPARC-V9 instructions&quot;</span>&gt;;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FeatureV8Deprecated</span> : SubtargetFeature&lt;<span class="string">&quot;deprecated-v8&quot;</span>,</span><br><span class="line">                                           <span class="string">&quot;V8DeprecatedInsts&quot;</span>, <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                                           <span class="string">&quot;Enable deprecated V8 instructions in V9 mode&quot;</span>&gt;;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FeatureVIS</span> : SubtargetFeature&lt;<span class="string">&quot;vis&quot;</span>, <span class="string">&quot;IsVIS&quot;</span>, <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;Enable UltraSPARC Visual Instruction Set extensions&quot;</span>&gt;;</span><br></pre></td></tr></table></figure><p>另外在 Sparc.td 中，使用 Proc 类来定义一些特殊的 SPARC 子类型的特征描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proc</span>&lt;string Name, <span class="built_in">list</span>&lt;SubtargetFeature&gt; Features&gt;</span><br><span class="line">  : Processor&lt;Name, NoItineraries, Features&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;generic&quot;</span>,         []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;v8&quot;</span>,              []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;supersparc&quot;</span>,      []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;sparclite&quot;</span>,       []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;f934&quot;</span>,            []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;hypersparc&quot;</span>,      []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;sparclite86x&quot;</span>,    []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;sparclet&quot;</span>,        []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;tsc701&quot;</span>,          []&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;v9&quot;</span>,              [FeatureV9]&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;ultrasparc&quot;</span>,      [FeatureV9, FeatureV8Deprecated]&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;ultrasparc3&quot;</span>,     [FeatureV9, FeatureV8Deprecated]&gt;;</span><br><span class="line"><span class="keyword">def</span> : Proc&lt;<span class="string">&quot;ultrasparc3-vis&quot;</span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</span><br></pre></td></tr></table></figure><p>通过这两个 td 文件生成的 SparcGenSubtarget.inc 中，通过枚举值来识别特性，用常数数组表示 CPU 特性和子平台类型。ParseSubtargetFeatures 方法用来解析指定子平台的特征字符串。</p><p>这个 inc 文件应该被 SparcSubtarget.td 中包含，目标相关的一些实现放在 XXXSubtarget 类方法中，如下代码注释描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XXXSubtarget::<span class="built_in">XXXSubtarget</span>(<span class="type">const</span> Module &amp;M, <span class="type">const</span> std::string &amp;FS) &#123;</span><br><span class="line">  <span class="comment">// Set the default features</span></span><br><span class="line">  <span class="comment">// Determine default and user specified characteristics of the CPU</span></span><br><span class="line">  <span class="comment">// Call ParseSubtargetFeatures(FS, CPU) to parse the features string</span></span><br><span class="line">  <span class="comment">// Perform any additional operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="9-JIT支持"><a href="#9-JIT支持" class="headerlink" title="9 JIT支持"></a>9 JIT支持</h1><p>JIT （Just-In-Time，翻译为即时编译）的代码生成是目标平台可选的一个功能，它可以发射二进制形式的机器码和其他辅助信息并写入内存。JIT 的实现主要有以下几个步骤：</p><ul><li>编写 XXXCodeEmitter.cpp 文件来包含一个 machine function pass 来将目标机器指令转换为可重定位机器码。</li><li>编写 XXXJITInfo.cpp 文件来实现目标相关代码生成行为的 JIT 接口，比如发射机器码和桩（stubs）。</li><li>修改 XXXTargetMachine，使之可以通过调用它的 getJITInfo 接口函数来得到 TargetJITInfo 对象。</li></ul><p>有多种不同的实现来编写 JIT 支持代码。比如，TableGen 和目标描述文件可以被用来自动化的创建 JIT 代码生成器，但这不是必须的选择。对于 Alpha 和 PowerPC 机器架构，TableGen 生成 XXXGenCodeEmitter.inc 文件，其中包含了机器指令的二进制编码，可以通过 getBinaryCodeForInstr 方法来访问这些编码。但其他的 JIT 实现不是这样的。</p><p>XXXJITInfo.cpp 和 XXXCodeEmitter.cpp 文件必须包含 llvm&#x2F;CodeGen&#x2F;MachineCodeEmitter.h 这个头文件，头文件中定义了 MachineCodeEmitter 的类，其中实现了很多用于将数据写到输出流的回调函数。</p><h2 id="9-1-机器码输出"><a href="#9-1-机器码输出" class="headerlink" title="9.1 机器码输出"></a>9.1 机器码输出</h2><p>在 XXXCodeEmitter.cpp 文件中，目标相关的部分在 Emitter 类中被实现为一个 function pass （是 MachineFunctionPass 的子类）。目标相关的 runOnMachineFunction 实现（由 MachineFunctionPass 中的 runOnFunction 调用）迭代 MachineBasicBlock 并调用 emitInstruction 来处理每一条指令，并发射二进制码。emitInstruction 的实现非常大，主要结构是一个 switch-case，用来选择指令类型，这些指令类型在 XXXInstrInfo.h 中定义。比如，在 X86CodeEmitter.cpp 中，emitInstruction 方法的实现部分如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (Desc-&gt;TSFlags &amp; X86::FormMask) &#123;</span><br><span class="line"><span class="keyword">case</span> X86II::Pseudo:  <span class="comment">// for not yet implemented instructions</span></span><br><span class="line">   ...               <span class="comment">// or pseudo-instructions</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::RawFrm:  <span class="comment">// for instructions with a fixed opcode value</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::AddRegFrm: <span class="comment">// for instructions that have one register operand</span></span><br><span class="line">   ...                 <span class="comment">// added to their opcode</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRMDestReg:<span class="comment">// for instructions that use the Mod/RM byte</span></span><br><span class="line">   ...                 <span class="comment">// to specify a destination (register)</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRMDestMem:<span class="comment">// for instructions that use the Mod/RM byte</span></span><br><span class="line">   ...                 <span class="comment">// to specify a destination (memory)</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRMSrcReg: <span class="comment">// for instructions that use the Mod/RM byte</span></span><br><span class="line">   ...                 <span class="comment">// to specify a source (register)</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRMSrcMem: <span class="comment">// for instructions that use the Mod/RM byte</span></span><br><span class="line">   ...                 <span class="comment">// to specify a source (memory)</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRM0r: <span class="keyword">case</span> X86II::MRM1r:  <span class="comment">// for instructions that operate on</span></span><br><span class="line"><span class="keyword">case</span> X86II::MRM2r: <span class="keyword">case</span> X86II::MRM3r:  <span class="comment">// a REGISTER r/m operand and</span></span><br><span class="line"><span class="keyword">case</span> X86II::MRM4r: <span class="keyword">case</span> X86II::MRM5r:  <span class="comment">// use the Mod/RM byte and a field</span></span><br><span class="line"><span class="keyword">case</span> X86II::MRM6r: <span class="keyword">case</span> X86II::MRM7r:  <span class="comment">// to hold extended opcode data</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRM0m: <span class="keyword">case</span> X86II::MRM1m:  <span class="comment">// for instructions that operate on</span></span><br><span class="line"><span class="keyword">case</span> X86II::MRM2m: <span class="keyword">case</span> X86II::MRM3m:  <span class="comment">// a MEMORY r/m operand and</span></span><br><span class="line"><span class="keyword">case</span> X86II::MRM4m: <span class="keyword">case</span> X86II::MRM5m:  <span class="comment">// use the Mod/RM byte and a field</span></span><br><span class="line"><span class="keyword">case</span> X86II::MRM6m: <span class="keyword">case</span> X86II::MRM7m:  <span class="comment">// to hold extended opcode data</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> X86II::MRMInitReg: <span class="comment">// for instructions whose source and</span></span><br><span class="line">   ...                  <span class="comment">// destination are the same register</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些 case 的具体实现经常是先发射操作码的编码，再发射操作数的编码，根据操作数类型的不同，可以调用 helper 方法来处理不同的操作数。比如，在 X86CodeEmitter.cpp 中，X86II::AddRegFrm case 中，通过 emitBytes 发出的第一个数据是添加寄存器操作数的操作码。然后发射操作数，MO1。helper 方法，比如 isImmediate， isGlobalAddress，isExternalSymbol，isConstantPoolIndex 或者 isJumpTableIndex 来决定操作数的类型。（X86CodeEmitter.cpp 文件中的类也有一些私有方法，比如 emitConstant，emitGlobalAddress，emitExternalSymbolAddress，emitConstPoolAddress 和 emitJumpTableAddress，这些方法用来实际将数据发射到输出流。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> X86II::AddRegFrm:</span><br><span class="line">  MCE.<span class="built_in">emitByte</span>(BaseOpcode + <span class="built_in">getX86RegNum</span>(MI.<span class="built_in">getOperand</span>(CurOp++).<span class="built_in">getReg</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurOp != NumOps) &#123;</span><br><span class="line">    <span class="type">const</span> MachineOperand &amp;MO1 = MI.<span class="built_in">getOperand</span>(CurOp++);</span><br><span class="line">    <span class="type">unsigned</span> Size = X86InstrInfo::<span class="built_in">sizeOfImm</span>(Desc);</span><br><span class="line">    <span class="keyword">if</span> (MO<span class="number">1.</span><span class="built_in">isImmediate</span>())</span><br><span class="line">      <span class="built_in">emitConstant</span>(MO<span class="number">1.</span><span class="built_in">getImm</span>(), Size);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">unsigned</span> rt = Is64BitMode ? X86::reloc_pcrel_word</span><br><span class="line">        : (IsPIC ? X86::reloc_picrel_word : X86::reloc_absolute_word);</span><br><span class="line">      <span class="keyword">if</span> (Opcode == X86::MOV64ri)</span><br><span class="line">        rt = X86::reloc_absolute_dword;  <span class="comment">// <span class="doctag">FIXME:</span> add X86II flag?</span></span><br><span class="line">      <span class="keyword">if</span> (MO<span class="number">1.</span><span class="built_in">isGlobalAddress</span>()) &#123;</span><br><span class="line">        <span class="type">bool</span> NeedStub = <span class="built_in">isa</span>&lt;Function&gt;(MO<span class="number">1.</span><span class="built_in">getGlobal</span>());</span><br><span class="line">        <span class="type">bool</span> isLazy = <span class="built_in">gvNeedsLazyPtr</span>(MO<span class="number">1.</span><span class="built_in">getGlobal</span>());</span><br><span class="line">        <span class="built_in">emitGlobalAddress</span>(MO<span class="number">1.</span><span class="built_in">getGlobal</span>(), rt, MO<span class="number">1.</span><span class="built_in">getOffset</span>(), <span class="number">0</span>,</span><br><span class="line">                          NeedStub, isLazy);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MO<span class="number">1.</span><span class="built_in">isExternalSymbol</span>())</span><br><span class="line">        <span class="built_in">emitExternalSymbolAddress</span>(MO<span class="number">1.</span><span class="built_in">getSymbolName</span>(), rt);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (MO<span class="number">1.</span><span class="built_in">isConstantPoolIndex</span>())</span><br><span class="line">        <span class="built_in">emitConstPoolAddress</span>(MO<span class="number">1.</span><span class="built_in">getIndex</span>(), rt);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (MO<span class="number">1.</span><span class="built_in">isJumpTableIndex</span>())</span><br><span class="line">        <span class="built_in">emitJumpTableAddress</span>(MO<span class="number">1.</span><span class="built_in">getIndex</span>(), rt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>之前的例子中，XXXCodeEmitter.cpp 使用变量 rt （RelocationType 的枚举）来处理重定位地址（比如PIC 的全局地址）。RelocationType 的枚举在 XXXRelocations.h 文件中定义，并被用于 relocate 方法（在 XXXJITInfo.cpp 中定义）中来重写全局符号的引用（也就是写入重定位信息）。</p><p>比如，X86Relocations.h 中指定了一下的重定位类型。这 4 中类型都会将重定位值添加到内存中。对于 reloc_pcrel_word 和 reloc_picrel_word 这两种，还会有一个额外的初始调整。（译注：原文这里没有展开讲）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RelocationType</span> &#123;</span><br><span class="line">  reloc_pcrel_word = <span class="number">0</span>,    <span class="comment">// add reloc value after adjusting for the PC loc</span></span><br><span class="line">  reloc_picrel_word = <span class="number">1</span>,   <span class="comment">// add reloc value after adjusting for the PIC base</span></span><br><span class="line">  reloc_absolute_word = <span class="number">2</span>, <span class="comment">// absolute relocation; no additional adjustment</span></span><br><span class="line">  reloc_absolute_dword = <span class="number">3</span> <span class="comment">// absolute relocation; no additional adjustment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-目标平台JIT信息"><a href="#9-2-目标平台JIT信息" class="headerlink" title="9.2 目标平台JIT信息"></a>9.2 目标平台JIT信息</h2><p>XXXJITInfo.cpp 文件中实现了目标平台相关的 JIT 指令生成功能，比如发射机器码和桩。一个最小的实现需要以下几部分：</p><ul><li>getLazyResolverFunction：初始化 JIT，给定目标一个用于编译的函数；</li><li>emitFunctionStub：会返回一个指定回调函数的地址；</li><li>relocate：改变全局引用的地址，需要 relocation type 的参与；</li><li>函数桩的包装（wrapper）回调函数，在最初还不知道目标时使用；</li></ul><p>getLazyResolverFunction 需要被继承实现。它将输入参数放入全局的 JITCompilerFunction 并返回一个回调函数，该回调函数会被用作一个函数包装。 对于 Alpha 目标平台（在 AlphaJITInfo.cpp 中），getLazyResolverFunction 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TargetJITInfo::LazyResolverFn <span class="title">AlphaJITInfo::getLazyResolverFunction</span><span class="params">( JITCompilerFn F)</span> </span>&#123;</span><br><span class="line">  JITCompilerFunction = F;</span><br><span class="line">  <span class="keyword">return</span> AlphaCompilationCallback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 X86 架构，getLazyResolverFunction 实现的更为复杂一些，因为它会返回一个更加复杂的回调函数，比如会包含 SSE 指令 和 XMM 寄存器。</p><p>回调函数初始化保存和之后还原被调用者寄存器值、输入参数以及栈和返回地址。回调函数需要底层的功能来访问寄存器或栈，所以它通常和汇编器一起实现。</p><hr><p>这篇文章翻译了一个多月，最初只是零零散散的翻译自己熟悉的部分，后来鼓足勇气给全部翻译下来了，过程中收获很多，但也深切的感知到，学习 LLVM，得看代码，不能光看教程。</p><p>完成，手工，吃饭！</p><hr><div class="note info flat"><p>本文同步发布在知乎账号下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149599651">编写一个LLVM后端 - 知乎 (zhihu.com)</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://p2tree.top">P2Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://p2tree.top/posts/f2eb6317.html">https://p2tree.top/posts/f2eb6317.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://p2tree.top" target="_blank">P2Tree's Mill</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/%E8%AF%91%E6%96%87/">译文</a><a class="post-meta__tags" href="/tags/LLVM/">LLVM</a></div><div class="post-share"><div class="social-share" data-image="https://img.p2tree.top/2020/06/20/index.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@latest/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/posts/6d48ee0a.html" title="高考后如何报志愿"><img class="cover" src="https://img.p2tree.top/2020/06/25/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高考后如何报志愿</div></div></a><a class="next-post pull-right" href="/posts/afa1097f.html" title="近君子而远小人"><img class="cover" src="https://img.p2tree.top/2020/06/07/index.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">近君子而远小人</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/posts/ab589331.html" title="LLVM New Pass Manager"><img class="cover" src="https://img.p2tree.top/2022/12/03/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="title">LLVM New Pass Manager</div></div></a><a href="/posts/5cc76640.html" title="LLVM 目标无关代码生成器 6：实现原生汇编器"><img class="cover" src="https://img.p2tree.top/2020/12/09/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-09</div><div class="title">LLVM 目标无关代码生成器 6：实现原生汇编器</div></div></a><a href="/posts/2aaad353.html" title="LLVM 目标无关代码生成器 5：目标无关代码生成算法"><img class="cover" src="https://img.p2tree.top/2020/12/06/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-06</div><div class="title">LLVM 目标无关代码生成器 5：目标无关代码生成算法</div></div></a><a href="/posts/fe45d531.html" title="LLVM 目标无关代码生成器 4：MC 层"><img class="cover" src="https://img.p2tree.top/2020/11/28/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-28</div><div class="title">LLVM 目标无关代码生成器 4：MC 层</div></div></a><a href="/posts/6e862920.html" title="LLVM 目标无关代码生成器 3：机器代码描述类"><img class="cover" src="https://img.p2tree.top/2020/11/25/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-25</div><div class="title">LLVM 目标无关代码生成器 3：机器代码描述类</div></div></a><a href="/posts/5ab3a536.html" title="LLVM 目标无关代码生成器 2：目标描述类"><img class="cover" src="https://img.p2tree.top/2020/11/22/index.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-22</div><div class="title">LLVM 目标无关代码生成器 2：目标描述类</div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="https://img.p2tree.top/avatar.webp" onerror='this.onerror=null,this.src="/img/404.gif"' alt="avatar"></div><div class="author-info-name">P2Tree</div><div class="author-info-description">基础软件研发工程师</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">类别</div><div class="length-num">7</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/p2tree" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:public@p2tree.top" target="_blank" title="Email"><i class="iconfont icon-mail"></i></a><a class="social-icon" href="https://zhihu.com/people/p2tree" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu"></i></a><a class="social-icon" href="/2024/08/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-P2Tree/" target="_blank" title="Weixin"><i class="iconfont icon-wechat"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="Feed"><i class="iconfont icon-feed"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问我的个人站点，这里会发布我的学习笔记和生活感悟。<br>可以通过选择分类或标签来阅读你感兴趣的文章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%9B%AE%E6%A0%87%E8%AF%BB%E8%80%85"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 目标读者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%A2%84%E5%85%88%E9%98%85%E8%AF%BB"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 预先阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.3 基本步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%A2%84%E5%A4%87%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.</span> <span class="toc-text">1.4 预备步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">2 目标机器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%9B%AE%E6%A0%87%E6%B3%A8%E5%86%8C"><span class="toc-number">3.</span> <span class="toc-text">3 目标注册</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E5%90%88%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">4 寄存器集合寄存器类别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 定义一个寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 定义一个寄存器类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-TargetRegisterInfo-%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 实现一个 TargetRegisterInfo 的子类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">5.</span> <span class="toc-text">5 指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%95%B0%E6%98%A0%E5%B0%84"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 指令操作数映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%95%B0%E5%91%BD%E5%90%8D%E6%98%A0%E5%B0%84"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 指令操作数命名映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 指令操作数类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 指令调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3%E6%98%A0%E5%B0%84"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 指令相关映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-TargetInstrInfo-%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 实现一个 TargetInstrInfo 的子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%88%86%E6%94%AF%E6%8A%98%E5%8F%A0%E5%92%8C-If-%E7%BA%A6%E5%AE%9A"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 分支折叠和 If 约定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%8C%87%E4%BB%A4%E9%80%89%E6%8B%A9"><span class="toc-number">6.</span> <span class="toc-text">6 指令选择</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-SelectionDAG%E5%90%88%E6%B3%95%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 SelectionDAG合法化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-Promote"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 Promote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-Expand"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 Expand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-Custom"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3 Custom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-Legal"><span class="toc-number">6.1.4.</span> <span class="toc-text">6.1.4 Legal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 调用约定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%B1%87%E7%BC%96%E8%BE%93%E5%87%BA"><span class="toc-number">7.</span> <span class="toc-text">7 汇编输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AD%90%E7%9B%AE%E6%A0%87%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81"><span class="toc-number">8.</span> <span class="toc-text">8 子目标平台支持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-JIT%E6%94%AF%E6%8C%81"><span class="toc-number">9.</span> <span class="toc-text">9 JIT支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%9C%BA%E5%99%A8%E7%A0%81%E8%BE%93%E5%87%BA"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 机器码输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%9B%AE%E6%A0%87%E5%B9%B3%E5%8F%B0JIT%E4%BF%A1%E6%81%AF"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 目标平台JIT信息</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1e952ac7.html" title="读书推荐：南京大屠杀"><img src="https://img.p2tree.top/2025/4/26/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：南京大屠杀"></a><div class="content"><a class="title" href="/posts/1e952ac7.html" title="读书推荐：南京大屠杀">读书推荐：南京大屠杀</a><time datetime="2025-09-10T14:43:38.046Z" title="更新于 2025-09-10 14:43:38">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dc0bdc19.html" title="读书推荐：活着"><img src="https://img.p2tree.top/2024/12/15/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：活着"></a><div class="content"><a class="title" href="/posts/dc0bdc19.html" title="读书推荐：活着">读书推荐：活着</a><time datetime="2025-09-10T14:43:38.046Z" title="更新于 2025-09-10 14:43:38">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2626ad0e.html" title="读书推荐：宝贵的人生建议"><img src="https://img.p2tree.top/2024/10/27/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="读书推荐：宝贵的人生建议"></a><div class="content"><a class="title" href="/posts/2626ad0e.html" title="读书推荐：宝贵的人生建议">读书推荐：宝贵的人生建议</a><time datetime="2025-09-10T14:43:38.046Z" title="更新于 2025-09-10 14:43:38">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4fefbc0d.html" title="跟随一条指令来看LLVM的基本结构"><img src="https://img.p2tree.top/2020/01/04/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跟随一条指令来看LLVM的基本结构"></a><div class="content"><a class="title" href="/posts/4fefbc0d.html" title="跟随一条指令来看LLVM的基本结构">跟随一条指令来看LLVM的基本结构</a><time datetime="2025-09-10T14:43:38.046Z" title="更新于 2025-09-10 14:43:38">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet"><img src="https://img.p2tree.top/2025/4/27/index.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="学习LLVM数据结构：SmallSet"></a><div class="content"><a class="title" href="/posts/8a9047b8.html" title="学习LLVM数据结构：SmallSet">学习LLVM数据结构：SmallSet</a><time datetime="2025-09-10T14:43:38.045Z" title="更新于 2025-09-10 14:43:38">2025-09-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://img.p2tree.top/default.webp)"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By P2Tree</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.0.0-b2"></script><script src="/js/main.js?v=5.0.0-b2"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@latest/dist/fancybox/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@latest/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.p2tree.top/",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"==typeof twikoo?setTimeout(t,0):btf.getScript("https://npm.elemecdn.com/twikoo@latest/dist/twikoo.all.min.js").then(t)};o()})()</script></div><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3JR7r5l5JW5Miut3",ck:"3JR7r5l5JW5Miut3",autoTrack:!0})</script><script src="/js/mourning.js"></script><script defer id="ribbon" src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script defer id="fluttering_ribbon" mobile="false" src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://npm.elemecdn.com/algoliasearch@latest/dist/algoliasearch-lite.umd.js"></script><script src="https://npm.elemecdn.com/instantsearch.js@latest/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=5.0.0-b2"></script></div></div><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v7.0.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.13.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站部署托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://cloudflare.com/" style="margin-inline:5px" data-title="本站图床使用CloudFlare提供服务" title=""><img src="https://img.shields.io/badge/Image-CloudFlare-orange?style=flat&amp;logo=Cloudflare" alt=""/></a><a class="github-badge" target="_blank" href="https://v6.51.la/land/3JR7r5l5JW5Miut3" style="margin-inline:5px" data-title="本站使用 51la 提供网站访问统计服务" title=""><img src="https://img.shields.io/badge/Tracker-51LA-blue" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站源码由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="https://stat.p2tree.top/" style="margin-inline:5px" data-title="网站状态监控使用UptimeFlare实现" title=""><img src="https://img.shields.io/badge/Monitor-UptimeFlare-green" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script data-pjax>function butterfly_swiper_injector_config(){var t=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/73fc32a.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2023/10/14/index.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-14</span><a class="blog-slider__title" href="posts/73fc32a.html" alt="">Vim 高效编辑技巧</a><div class="blog-slider__text">绝对是全网都没有的 Vim 使用硬干货经验</div><a class="blog-slider__button" href="posts/73fc32a.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4b2442c5.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2021/02/22/index.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-02-22</span><a class="blog-slider__title" href="posts/4b2442c5.html" alt="">LLVM 后端实践笔记 0：序</a><div class="blog-slider__text">LLVM 后端学习的系列教程，这是第一集，必读起跑线</div><a class="blog-slider__button" href="posts/4b2442c5.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/e8d522db.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2024/08/05/wechat_logo.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-05</span><a class="blog-slider__title" href="posts/e8d522db.html" alt="">微信公众号 P2Tree</a><div class="blog-slider__text">我维护的微信公众号，欢迎来交个朋友</div><a class="blog-slider__button" href="posts/e8d522db.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/b32e3378.html" alt=""><img width="48" height="48" src="https://img.p2tree.top/2024/08/23/index.webp" alt="" onerror="this.src=https://img.p2tree.top/default.webp; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="posts/b32e3378.html" alt="">个人说明书 v2.2.4</a><div class="blog-slider__text">这份个人说明书，记录着我的基本信息和所思所想，希望能以最快的方式介绍我自己</div><a class="blog-slider__button" href="posts/b32e3378.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="/about/,/tags/,/categories/,/draft/".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>